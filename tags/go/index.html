<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>go | 艾倫的程式之旅</title><meta name=keywords content><meta name=description content="ExampleSite description"><meta name=author content="Alan"><link rel=canonical href=https://sz9751210.github.io/tags/go/><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.css rel="preload stylesheet" as=style><link rel=icon href=https://sz9751210.github.io/assets/profile/avatar.png><link rel=icon type=image/png sizes=16x16 href=https://sz9751210.github.io/assets/profile/avatar.png><link rel=icon type=image/png sizes=32x32 href=https://sz9751210.github.io/assets/profile/avatar.png><link rel=apple-touch-icon href=https://sz9751210.github.io/assets/profile/avatar.png><link rel=mask-icon href=https://sz9751210.github.io/assets/profile/avatar.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://sz9751210.github.io/tags/go/index.xml><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://www.googletagmanager.com/gtag/js?id=G-4RLTP9J7DY"></script>
<script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-4RLTP9J7DY",{anonymize_ip:!1})}</script><meta property="og:title" content="go"><meta property="og:description" content="ExampleSite description"><meta property="og:type" content="website"><meta property="og:url" content="https://sz9751210.github.io/tags/go/"><meta property="og:image" content="https://sz9751210.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta property="og:site_name" content="ExampleSite"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://sz9751210.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="go"><meta name=twitter:description content="ExampleSite description"><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-8214206744217848" crossorigin=anonymous></script></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://sz9751210.github.io/ accesskey=h title="Alan's BLOG (Alt + H)"><img src=https://sz9751210.github.io/assets/profile/avatar.png alt aria-label=logo height=35>Alan's BLOG</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://sz9751210.github.io/archives/ title=archives><span>archives</span></a></li><li><a href=https://sz9751210.github.io/posts/ title=posts><span>posts</span></a></li><li><a href=https://sz9751210.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://sz9751210.github.io/about/ title=about><span>about</span></a></li><li><a href=https://sz9751210.github.io/quote/ title=quote><span>quote</span></a></li><li><a href=https://sz9751210.github.io/search/ title="search (Alt + /)" accesskey=/><span>search</span></a></li></ul></nav></header><main class=main><header class=page-header><div class=breadcrumbs><a href=https://sz9751210.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://sz9751210.github.io/tags/>Tags</a></div><h1>go
<a href=index.xml title=RSS aria-label=RSS><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" height="23"><path d="M4 11a9 9 0 019 9"/><path d="M4 4a16 16 0 0116 16"/><circle cx="5" cy="19" r="1"/></svg></a></h1></header><article class="post-entry tag-entry"><div class=post-info><header class=entry-header><h2>淺談Go中的Pointer和記憶體管理</h2></header><div class=entry-content><p>👨‍💻簡介 當我們在宣告變數時，電腦會為該變數在記憶體中分配一個位置，然後將這個變數值儲存在這個位置上，需要讀取或修改這個變數值時，電腦是透過記憶體位置來存取這個值。 今天來簡單介紹一下go的Pointer，他的特性以及常見用法。
什麼是Pointer？ Pointer是一種資料類型，用來儲存變數的記憶體地址。在Go中，我們可以通過使用 * 符號來宣告和操作Pointer。這允許我們直接訪問和修改變數的內容，而不僅僅是讀取或複製它們的值。
Pointer的特性、限制與常見用法 特性 Pointer的值和地址 每個變數都有一個記憶體地址，我們可以使用Pointer變數來儲存這個地址。讓我們看一個範例：
package main import "fmt" func main() { x := 42 var p *int // 宣告一個整數Pointer p = &amp;x // 將p指向x的地址 fmt.Println("x =", x) fmt.Println("p =", p) } 在這個例子中，我們創建了一個整數變數 x，並宣告了一個整數Pointer p，然後將 p 設為 x 的地址。現在，p 裡面存放的就是 x 的地址。
Pointer的初始化 Go中的Pointer可以通過 new 函數來初始化，這將為指定的類型分配記憶體並返回其地址。範例：
package main import "fmt" func main() { var p *int p = new(int) // 初始化一個整數Pointer *p = 123 // 將Pointer所指向的記憶體設置為123 fmt....</p></div><footer class=entry-footer><span title='2023-09-08 15:50:00 +0800 CST'>2023-09-08</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;403 words&nbsp;·&nbsp;Alan</footer></div><figure class=entry-cover><img loading=lazy src=https://sz9751210.github.io/assets/go-pointer/cover.png alt></figure><a class=entry-link aria-label="post link to 淺談Go中的Pointer和記憶體管理" href=https://sz9751210.github.io/posts/go-pointer/></a></article><article class="post-entry tag-entry"><div class=post-info><header class=entry-header><h2>錯誤處理的精髓：快速了解Go語言的 error、panic和recover</h2></header><div class=entry-content><p>👨‍💻簡介 在軟體開發中，錯誤無所不在。無論是網路請求失敗、檔案不存在，還是數學計算錯誤，處理錯誤是任何開發者的日常工作，系統的穩定度基本取決於對於錯誤處理是否全面，好的錯誤處理也可以產生適當的錯誤訊息，讓 Debug 更加容易。在Go語言中，有一些獨特的功能在處理錯誤和資源管理方面非常有用。，其中包括error、panic和recover。今天就來介紹這三個關鍵字與錯誤處理的簡單用法。
Error 什麼是Error? 在Go中，Error是一個擁有error interface的類型，可以看到他只有一個方法，該方法主要用來描述一個錯誤的字串。
type error interface { Error() string } 如何產生錯誤訊息 errors.New() 使用方式很簡單，在裡面放入要顯示的錯誤訊息 package main import ( "errors" "fmt" ) func main() { err := errors.New("This is a custom error message") fmt.Println(err.Error()) // output：This is a custom error message } fmt.Errorf() 主要用在格式化錯誤訊息的情況下 package main import ( "fmt" ) func main() { name := "John" err := fmt.Errorf("Hello, %s! This is a custom error message", name) fmt....</p></div><footer class=entry-footer><span title='2023-09-07 11:30:00 +0800 CST'>2023-09-07</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;559 words&nbsp;·&nbsp;Alan</footer></div><figure class=entry-cover><img loading=lazy src=https://sz9751210.github.io/assets/go-error/cover.png alt></figure><a class=entry-link aria-label="post link to 錯誤處理的精髓：快速了解Go語言的 error、panic和recover" href=https://sz9751210.github.io/posts/go-error/></a></article><article class="post-entry tag-entry"><div class=post-info><header class=entry-header><h2>Go語言的defer：確保後置操作的執行</h2></header><div class=entry-content><p>👨‍💻簡介 當我們在寫程式時，有時候會需要在程式結束時關閉某些資源，而defer這個關鍵字，可以讓你輕鬆的實現，下面來簡單介紹一下defer以及常用的範例。，它為程式設計師提供了一種簡單而強大的工具，用於管理資源和確保程式的正確執行。在本篇文章中，我們將深入探討Go語言中的defer，並提供一些實際的程式碼範例，以幫助你理解它的工作原理以及如何運用它來提高程式的可讀性和可維護性。
什麼是defer？ defer是一個關鍵字，用來延遲函數的執行，直到包含它的函數執行完畢。這代表你可以在函數中的任何位置使用defer來安排某個操作，並確保它將在函數返回之前執行。defer通常用於執行一些清理或資源回收的操作。
package main import "fmt" func main() { defer fmt.Println("World") fmt.Print("Hello, ") } 使用方式也很簡單，在要執行的函數前面加上defer就完成了，所以上面的範例會印出 Hello World
Defer的特性 延遲執行：defer 語句允許你安排一段程式碼，使它在包含它的函數返回之前執行，無論函數是否正常返回或出現錯誤。
堆疊特性：多個 defer 語句按照後進先出（LIFO）的順序執行，這意味著最後一個被延遲的語句會最先執行。
package main import "fmt" func main() { fmt.Println("Start") defer fmt.Println("Deferred 1") defer fmt.Println("Deferred 2") fmt.Println("End") } 根據defer特性的後進先出，輸出會是下面這個樣子
Start End Deferred 2 Deferred 1 Defer的限制 延遲的函數必須是無參數函數：你只能延遲無參數的函數調用，因為 defer 不允許傳遞參數。
順序性：defer 語句的效果在函數內是有限定範圍的，它只在包含它的函數範圍內有效，無法跨函數使用。
常見用法 資源清理 最常見的用途之一是在函數返回前關閉文件、釋放鎖、關閉資料庫連接等，以確保資源被正確釋放。
func readFile(filename string) (string, error) { file, err := os.Open(filename) if err != nil { return "", err } defer file....</p></div><footer class=entry-footer><span title='2023-09-06 20:30:00 +0800 CST'>2023-09-06</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;135 words&nbsp;·&nbsp;Alan</footer></div><figure class=entry-cover><img loading=lazy src=https://sz9751210.github.io/assets/go-defer/cover.png alt></figure><a class=entry-link aria-label="post link to Go語言的defer：確保後置操作的執行" href=https://sz9751210.github.io/posts/go-defer/></a></article><article class="post-entry tag-entry"><div class=post-info><header class=entry-header><h2>保證型別安全：使用Go的Type Assertions避免型別錯誤</h2></header><div class=entry-content><p>👨‍💻簡介 在Go中，假如我要判斷一個資料類型是甚麼，該怎麼做呢? Golang有一個功能叫做Type Assertions（類型斷言），它的作用就是能夠在運行時檢查我的資料類型，讓我在傳遞類型時能確保資料類型是正確的。
Type Assertions 的基本概念 在Go中，Type Assertions的主要目的是在運行時將 interface 型別的值轉換為特定的實際型別。interface 是一種特殊的類型，它可以保存任何值的實例，但在運行時，我們可能需要確定該值的實際類型以執行相應的操作，以確保我們能夠安全地操作資料，這就是Type Assertions的作用。
Type Assertions的基本語法如下：
value, ok := someInterface.(T) 這個表達式意思為將someInterface轉換為類型T。如果成功，它將value設置為轉換後的值，並將ok設置為true。如果轉換失敗，則value將是零值，而ok將是false。
Type Assertions的用途 Type Assertions 的主要用途包括：
資料型別的轉換 當我們處理interface型別的資料時，可能需要將其轉換為具體的型別，以便進行特定操作。
func process(someInterface interface{}) { if str, ok := someInterface.(string); ok { // 將interfacce轉換為string類型並進行操作 fmt.Printf("Length of string: %d\n", len(str)) } else { fmt.Println("Not a string") } } 確保型別的正確性 使用 Type Assertions，我們可以在執行特定操作之前，確保資料的型別是我們期望的。這有助於防止因型別錯誤而引發的執行時錯誤。
if val, ok := someInterface.(int); ok { // someInterface 是一個int類型 fmt.Printf("Value is an int: %d\n", val) } else { // someInterface 不是一個int類型 fmt....</p></div><footer class=entry-footer><span title='2023-09-05 15:31:00 +0800 CST'>2023-09-05</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;397 words&nbsp;·&nbsp;Alan</footer></div><figure class=entry-cover><img loading=lazy src=https://sz9751210.github.io/assets/go-type-assertion/cover.png alt></figure><a class=entry-link aria-label="post link to 保證型別安全：使用Go的Type Assertions避免型別錯誤" href=https://sz9751210.github.io/posts/go-type-assertion/></a></article><article class="post-entry tag-entry"><div class=post-info><header class=entry-header><h2>從零開始：使用make函數創建資料結構</h2></header><div class=entry-content><p>👨‍💻簡介 make函數在slice、map和之後會介紹到的channel的初始化中扮演著關鍵的角色。本文將會簡單介紹make函數的用法，以及在初始化不同資料結構時的差異，讓你更好地理解和利用make函數。
make函數基本概念 首先，讓我們來了解一下make函數的基本概念。在Go中，make函數用於動態分配記憶體並初始化slice、map和channel。
// 創建一個切片，長度為5，容量為10 mySlice := make([]int, 5, 10) 在上面的範例中，我們使用make函數創建了一個整數切片（slice），其長度為5，容量為10。這意味著切片可以容納5個元素，但它的底層陣列的容量是10，這為後續的操作提供了一定的靈活性。
make函數的語法 make函數的語法相對簡單。它的一般形式是：
make(類型, 長度, 容量) 類型：指定要創建的資料類型，可以是切片、map或通道。 長度：表示資料結構的初始長度。 容量：只適用於切片和通道，表示底層陣列的容量。 使用make初始化切片 接下來，讓我們看看如何使用make函數初始化切片。
// 創建一個整數切片，長度為3，容量為5 mySlice := make([]int, 3, 5) mySlice[0] = 1 mySlice[1] = 2 mySlice[2] = 3 在這個例子中，我們首先使用make函數創建了一個長度為3、容量為5的整數切片。然後，我們分配了三個整數值到切片中。
使用make初始化Map 現在，讓我們看看如何使用make函數初始化Map。map是一種鍵值對的資料結構，非常適合用於存儲關聯性資料。
// 創建一個字符串到整數的map myMap := make(map[string]int) myMap["apple"] = 1 myMap["banana"] = 2 myMap["cherry"] = 3 在這個範例中，我們使用make函數創建了一個空的字符串到整數的map，然後添加了三個鍵值對。
make 函數在 Go 語言中常見用法包括初始化切片、map和通道。然而，它的使用也受到一些限制和約束。以下是 make 函數的常見用法以及相關的使用限制：
使用make初始化通道 最後，我們來看看如何使用make函數初始化通道。通道是Go語言中用於並發通信的重要機制。
// 創建一個通道，用於傳輸字符串資料 myChannel := make(chan string) go func() { myChannel &lt;- "Hello" myChannel &lt;- "World" }() 在這個例子中，我們使用make函數創建了一個通道，它可以傳輸字符串資料。然後，我們使用Go協程向通道發送了兩個字符串。...</p></div><footer class=entry-footer><span title='2023-09-04 19:26:00 +0800 CST'>2023-09-04</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;153 words&nbsp;·&nbsp;Alan</footer></div><figure class=entry-cover><img loading=lazy src=https://sz9751210.github.io/assets/go-make/cover.png alt></figure><a class=entry-link aria-label="post link to 從零開始：使用make函數創建資料結構" href=https://sz9751210.github.io/posts/go-make/></a></article><article class="post-entry tag-entry"><div class=post-info><header class=entry-header><h2>Package：Golang 專案的組織策略</h2></header><div class=entry-content><p>👨‍💻簡介 套件（Package）在Golang中扮演著組織和管理程式碼的重要角色。
package就像工具箱一樣，裡面裝滿各種不同的工具，每個工具都有特定的功能。這些工具能夠幫助你完成不同的任務，從修理家具到蓋小屋，樣樣都行。
今天這篇文章將快速瞭解 Golang 的package，學習如何建立package、匯入package以及一些使用技巧。
什麼是 Package？ 在 Golang 中，Package 是一種組織程式碼的方式，它將相關的函式、變數和資源放在一個目錄中。這不僅有助於保持程式碼的整潔，還能讓我們更容易地重複使用程式碼。
Package 名稱與資料夾名稱的一致性 通常建議在建立package時，將package名稱與所在資料夾名稱保持一致，這樣有助於提高程式碼的可讀性和一致性。Golang 的匯入機制是基於package的 import 路徑來識別package，而 import 路徑通常會反映package的資料夾結構。這種一致性可以讓其他開發人員更容易理解你的程式碼，並且不需要額外的查找工作，因為package的名稱與資料夾名稱一致。
舉例來說，假設你的資料夾結構如下：
project/ |-- greetings/ | |-- greetings.go | |-- main/ | |-- main.go 如果我們建立的package名稱為 greetings，我們可以在 greetings.go 中這樣定義：
// greetings.go package greetings func Hello(name string) string { return "Hello, " + name } 然後在 main.go 中使用這個package：
// main.go package main import ( "fmt" "your/project/path/greetings" ) func main() { message := greetings.Hello("Alan") fmt....</p></div><footer class=entry-footer><span title='2023-09-01 15:39:00 +0800 CST'>2023-09-01</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;281 words&nbsp;·&nbsp;Alan</footer></div><figure class=entry-cover><img loading=lazy src=https://sz9751210.github.io/assets/go-package/cover.png alt></figure><a class=entry-link aria-label="post link to Package：Golang 專案的組織策略" href=https://sz9751210.github.io/posts/go-package/></a></article><article class="post-entry tag-entry"><div class=post-info><header class=entry-header><h2>Interface：Go 語言中的抽象關鍵</h2></header><div class=entry-content><p>👨‍💻簡介 在Go語言中，Interface 是一個重要且強大的概念。Interface提供了一種方式來定義對象之間的契約，讓你可以設計更具有靈活性和可擴展性的程式碼。 你可以把Interface想像成是一種約定，讓不同的東西彼此溝通的方式變得特別靈活和好擴充，告訴程式裡的各個元件彼此要怎麼合作。
什麼是Interface 在 Go 語言中，Interface是一種關鍵的概念，用於定義方法的契約，而不關心具體的實現。它是一種抽象的型別，描述了物件應該具備的方法。Interface在實現多態性、抽象和模組化設計等方面扮演著重要角色。
Interface是一種抽象的類型，它定義了一組方法簽名（method signatures），但不包含方法的實際實現。這些方法簽名定義了對象應該支援的操作，從而允許不同類型的對象實現同一個Interface並進行交互。
一聽可能有點高深，但其實它就像是一份約定，不管實際怎麼做，只要能遵循這份約定就行。
就好像你和朋友約好要出去玩，你們約定好一起出門、一起玩，但具體怎麼玩，是不是吃火鍋還是去唱歌，那就隨你們。這些約定就是你們的「Interface」，告訴大家「我們一起要做這些事情！」。
當然，這在程式碼裡的作用更大。透過這個「Interface」，你可以讓不同種類的東西，像是車、狗、電腦，都能夠用一樣的方式進行互動。不管是車、狗、還是電腦，只要符合了這個「Interface」約定的方法，你就可以放心地拿來用了。
Interface的基本使用 透過Interface，我們可以在不關心具體類型的情況下，對對象進行操作。這種多態性的概念讓程式碼更具彈性，能夠適應不同的實現。
// 定義一個Interface Shape，它具有一個 Area 方法 type Shape Interface { Area() float64 } // 定義一個 Circle 結構體，實現了 Shape Interface的 Area 方法 type Circle struct { Radius float64 } func (c Circle) Area() float64 { return 3.14 * c.Radius * c.Radius } // 定義一個 Rectangle 結構體，實現了 Shape Interface的 Area 方法 type Rectangle struct { Width, Height float64 } func (r Rectangle) Area() float64 { return r....</p></div><footer class=entry-footer><span title='2023-08-31 19:12:00 +0800 CST'>2023-08-31</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;673 words&nbsp;·&nbsp;Alan</footer></div><figure class=entry-cover><img loading=lazy src=https://sz9751210.github.io/assets/go-interface/cover.png alt></figure><a class=entry-link aria-label="post link to Interface：Go 語言中的抽象關鍵" href=https://sz9751210.github.io/posts/go-interface/></a></article><article class="post-entry tag-entry"><div class=post-info><header class=entry-header><h2>探索 Golang 中的結構體：如何有效地組織複雜資料</h2></header><div class=entry-content><p>👨‍💻簡介 在程式開發的世界中，我們經常需要處理各式各樣的資料，可能是一個人的個人資訊，也可能是一個商品的詳細訊息。當我們面對這麼多的資料時，如何將它們有系統地整理起來，讓我們能夠輕鬆地找到所需，便成了一個重要的課題。這時，結構體的概念就像是一道曙光，為我們提供了一個非常有力的工具。
結構體基礎 結構體，就像是一張設計圖，讓我們畫下我們腦袋裡的想法，就像是一個多功能的工具箱，結構體讓我們能夠以組織化的方式來儲存各種資料片段，就像是將資料拼湊成了一個個獨特的拼圖。今天，我們將深入探討 Golang 中結構體的神奇之處，以及如何通過結構體來更有效地組織和處理複雜資料。
首先，我們來看看如何定義和使用結構體。結構體是一個自定義的資料類型，它允許我們組織不同類型的資料在一個單一的單位中。
type Person struct { FirstName string LastName string Age int } 以一個人的資訊為例，我們可以創建一個名為 Person 的結構體，其中包含了 FirstName、LastName 和 Age 這三個基本資料。這些資料如同載體，讓我們能夠更方便地一次性儲存和訪問它們。 現在，我們可以創建一個 Person 的實例，並訪問其字段：
func main() { person := Person{ FirstName: "John", LastName: "Doe", Age: 30, } fmt.Println("First Name:", person.FirstName) fmt.Println("Last Name:", person.LastName) fmt.Println("Age:", person.Age) } 複雜資料的嵌套組織 但有時候，我們還需要更複雜的資料結構，例如住址。這時，結構體的嵌套就派上用場了，我們可以在 Person 結構體中嵌套另一個結構體，用來表示住址的相關資訊，如 Street、City 和 Country。
type Address struct { Street string City string Country string } type Person struct { FirstName string LastName string Age int Address Address } 也可以直接寫在裡面...</p></div><footer class=entry-footer><span title='2023-08-30 16:06:00 +0800 CST'>2023-08-30</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;299 words&nbsp;·&nbsp;Alan</footer></div><figure class=entry-cover><img loading=lazy src=https://sz9751210.github.io/assets/go-struct/cover.png alt></figure><a class=entry-link aria-label="post link to 探索 Golang 中的結構體：如何有效地組織複雜資料" href=https://sz9751210.github.io/posts/go-struct/></a></article><article class="post-entry tag-entry"><div class=post-info><header class=entry-header><h2>🚀 Golang 函數：從入門到精通</h2></header><div class=entry-content><p>👨‍💻簡介 在 Go 語言中，函數（Function）是一個強大且重要的概念，就像食譜一樣，告訴你應該如何處理食材，最後得到一道美味的料理。經過哪些程序讓程式更有組織性和可讀性。函數可幫助你將程式碼區塊組織成可重複使用的元件，進而執行特定的任務。本文要帶你一探究竟，深入了解 Golang 裡的函數有哪些不同的方面。從基本的概念開始，一路講到更高級的技巧，我們會告訴你怎麼樣用函數來處理各種不同的情況。
函數基本概念 函數在 Golang 中是一組程式語句的組合，用於執行特定的任務。它們接受輸入（參數）並返回輸出（返回值），從高層次來看，就像是黑盒子，你提供輸入，它交付結果。在每個 Golang 程式中，最常見的函數是 main()，它是程式的入口點。
函數名稱與命名規則 在 Golang 中，函數名稱的命名規則如下：
名稱必須以字母開始，後面可以是任意數量的字母和數字。 函數名稱不能以數字開頭。 函數名稱不能包含空格。 如果函數名稱以大寫字母開頭，則可以被其他套件引用。如果以小寫字母開頭，則不能被其他套件引用，但可以在同一套件內部使用。 如果名稱由多個單詞組成，從第二個單詞開始的每個單詞首字母應大寫，例如 empName、EmpAddress 等。 函數名稱區分大小寫，即 car、Car 和 CAR 是三個不同的變數。 創建函數 在 Golang 中，創建函數的基本語法如下：
func 函數名稱(參數1 型別1, 參數2 型別2, ...) 返回型別 { // 函數程式碼 return 返回值 } 首先，用 func 關鍵字開始函數宣告，然後是你想要給函數的名稱，一對括號 ()，然後是一個包含函數程式碼的區塊。
以下是一個簡單的範例，它不接受任何參數，也不返回任何值。
package main import "fmt" // SimpleFunction 印出一個訊息 func SimpleFunction() { fmt.Println("Hello World") } func main() { SimpleFunction() // 呼叫 SimpleFunction 函數 } 接受參數的函數 如果要將資訊傳遞給函數，可以通過參數來實現。參數就像變數一樣。...</p></div><footer class=entry-footer><span title='2023-08-29 14:54:00 +0800 CST'>2023-08-29</span>&nbsp;·&nbsp;5 min&nbsp;·&nbsp;978 words&nbsp;·&nbsp;Alan</footer></div><figure class=entry-cover><img loading=lazy src=https://sz9751210.github.io/assets/go-func/cover.png alt></figure><a class=entry-link aria-label="post link to 🚀 Golang 函數：從入門到精通" href=https://sz9751210.github.io/posts/go-func/></a></article><article class="post-entry tag-entry"><div class=post-info><header class=entry-header><h2>淺談 Go 語言中的 Map - 快速查詢與狀態儲存的利器</h2></header><div class=entry-content><p>👨‍💻簡介 在 Go 語言中，有著一個強大又便捷的工具，可以讓你以鍵-值（Key-Value）的形式儲存和查詢資料，它就是「Map」。Map 在 Go 語言中扮演了重要的角色，簡化了許多資料處理的任務，現在讓我們一起來深入了解這個有趣的資料型別。
Map的基本概念 Map 是 Go 語言中的一種內建資料型別，用來存儲鍵值對。簡單來說，你可以將 Map 想像成一個無序的集合，每個元素都有一個唯一的鍵和相應的值。這讓你可以根據鍵來快速查詢和存取對應的值，就像是字典一樣。
宣告和初始化 Map 在 Go 中，宣告 Map 可使用以下語法：
m1 := make(map[string]int) // 創建一個儲存字串為鍵，整數為值的 Map m2 := map[int]string{1: "A", 2: "B"} // 創建一個包含鍵值對的映射 var m3 map[string]int // 創建一個鍵為字串、值為整數的空映射 而宣告時順便初始化可以使用以下方式：
myMap := map[string]int{ "apple": 3, "banana": 5, } var myMap map[string]int myMap = map[string]int{ "apple": 3, "banana": 5, } Map的基本操作 Map 的操作非常簡單直觀。你可以使用鍵來存取對應的值，也可以使用鍵來新增、修改或刪除元素。
新增或修改元素 myMap["apple"] = 3 // 新增一個元素，鍵是 "apple"，值是 3 myMap["banana"] = 5 // 新增一個元素，鍵是 "banana"，值是 5 myMap["apple"] = 10 // 修改鍵為 "apple" 的元素的值為 10 查詢元素 value := myMap["banana"] // 根據鍵 "banana" 查詢對應的值 刪除元素 delete(myMap, "apple") // 刪除鍵為 "apple" 的元素 遍歷 Map 要遍歷一個 Map 中的所有元素，通常會使用 for range 迴圈：...</p></div><footer class=entry-footer><span title='2023-08-28 16:36:00 +0800 CST'>2023-08-28</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;319 words&nbsp;·&nbsp;Alan</footer></div><figure class=entry-cover><img loading=lazy src=https://sz9751210.github.io/assets/go-map/cover.png alt></figure><a class=entry-link aria-label="post link to 淺談 Go 語言中的 Map - 快速查詢與狀態儲存的利器" href=https://sz9751210.github.io/posts/go-map/></a></article><footer class=page-footer><nav class=pagination><a class=next href=https://sz9751210.github.io/tags/go/page/2/>Next&nbsp;&nbsp;»</a></nav></footer></main><footer class=footer><span>&copy; 2023 <a href=https://sz9751210.github.io/>艾倫的程式之旅</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let detail=document.getElementsByClassName("details");details=[].slice.call(detail);for(let e=0;e<details.length;e++){let t=details[e];const n=t.getElementsByClassName("details-summary")[0];n&&n.addEventListener("click",()=>{t.classList.toggle("open")},!1)}</script><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>