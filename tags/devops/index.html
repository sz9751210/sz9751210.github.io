<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>devops | 艾倫的程式之旅</title><meta name=keywords content><meta name=description content="ExampleSite description"><meta name=author content="Alan"><link rel=canonical href=https://sz9751210.github.io/tags/devops/><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.css rel="preload stylesheet" as=style><link rel=icon href=https://sz9751210.github.io/assets/profile/avatar.png><link rel=icon type=image/png sizes=16x16 href=https://sz9751210.github.io/assets/profile/avatar.png><link rel=icon type=image/png sizes=32x32 href=https://sz9751210.github.io/assets/profile/avatar.png><link rel=apple-touch-icon href=https://sz9751210.github.io/assets/profile/avatar.png><link rel=mask-icon href=https://sz9751210.github.io/assets/profile/avatar.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://sz9751210.github.io/tags/devops/index.xml><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://www.googletagmanager.com/gtag/js?id=G-4RLTP9J7DY"></script>
<script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-4RLTP9J7DY",{anonymize_ip:!1})}</script><meta property="og:title" content="devops"><meta property="og:description" content="ExampleSite description"><meta property="og:type" content="website"><meta property="og:url" content="https://sz9751210.github.io/tags/devops/"><meta property="og:image" content="https://sz9751210.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta property="og:site_name" content="ExampleSite"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://sz9751210.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="devops"><meta name=twitter:description content="ExampleSite description"><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-8214206744217848" crossorigin=anonymous></script></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://sz9751210.github.io/ accesskey=h title="Alan's BLOG (Alt + H)"><img src=https://sz9751210.github.io/assets/profile/avatar.png alt aria-label=logo height=35>Alan's BLOG</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://sz9751210.github.io/archives/ title=archives><span>archives</span></a></li><li><a href=https://sz9751210.github.io/posts/ title=posts><span>posts</span></a></li><li><a href=https://sz9751210.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://sz9751210.github.io/about/ title=about><span>about</span></a></li><li><a href=https://sz9751210.github.io/quote/ title=quote><span>quote</span></a></li><li><a href=https://sz9751210.github.io/search/ title="search (Alt + /)" accesskey=/><span>search</span></a></li></ul></nav></header><main class=main><header class=page-header><div class=breadcrumbs><a href=https://sz9751210.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://sz9751210.github.io/tags/>Tags</a></div><h1>devops
<a href=index.xml title=RSS aria-label=RSS><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" height="23"><path d="M4 11a9 9 0 019 9"/><path d="M4 4a16 16 0 0116 16"/><circle cx="5" cy="19" r="1"/></svg></a></h1></header><article class="post-entry tag-entry"><div class=post-info><header class=entry-header><h2>從零開始學習 Kubernetes：Pod Overview</h2></header><div class=entry-content><p>Kubernetes是現代應用程序開發和部署的重要技術，而Pod是Kubernetes中最小的部署單位。Pod是一個或多個container的集合，它們共享一個網路命名空間和一個網路接口。Pod不僅提供了一個簡單而強大的container環境，還可以用於實現多種container編排方案，例如負載平衡、數據管理、多container協作等。
本文將深入探討Kubernetes中的Pod，介紹Pod的基本概念、設計原則和實現方式，以及與其他資源的關係。您將學習如何創建和配置Pod，如何使用Kubernetes管理Pod，以及如何通過Pod實現高效、彈性和可靠的應用程序部署。
什麼是Kubernetes Pod Kubernetes Pod是Kubernetes集群中最小的部署單位。一個Pod可以包含一個或多個container，這些container共享相同的網路和儲存空間。Pod提供了一個環境，讓container可以協同工作，形成一個應用程序。
Pod的結構和特性 Pod包含以下元素：
共享網路空間 (Networking)：Pod 中的所有container共享相同的網路空間，可以在container之間通過 localhost 進行通信。 共享儲存空間 (Shared Storage)：Pod 中的所有container共享相同的儲存空間，可以在container之間共享文件、環境變量等。 容器 (Containers)：Pod 中可以包含一個或多個container，這些container可以共享同一個網路和儲存空間，方便container之間的互相協作。 存活和重啟策略 (Liveness and Restart Policy)：Pod 的存活策略指定了在容器出現異常情況時，Kubernetes 如何應對，如重新啟動 container 或者將其標記為失敗。Pod 的重啟策略則指定了當 Pod 中的所有 container 都停止運行時，Kubernetes 如何進行重啟。 元數據 (Metadata)：Pod 中包含一些元數據，如 Pod 名稱、命名空間、標籤等，這些元數據可以用於管理和監控 Pod。 Pod的特性包括：
生命週期短暫 可以擁有多個container 具有唯一的IP地址 具有獨立的儲存空間 具有網路隔離 如何創建和管理Pod 要創建 Kubernetes Pod，可以使用以下兩種方式： 宣告式（Declarative）：使用 YAML 或 JSON 格式的文件來定義 Pod 的結構、元資料和規格，包括 Pod 名稱、container image、資源限制、網路設定等。 apiVersion: v1 kind: Pod metadata: name: my-pod spec: containers: - name: nginx-container image: nginx:latest ports: - containerPort: 80 接著使用kubectl創建pod...</p></div><footer class=entry-footer><span title='2023-03-01 20:43:00 +0800 CST'>2023-03-01</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;363 words&nbsp;·&nbsp;Alan</footer></div><figure class=entry-cover><img loading=lazy src=https://sz9751210.github.io/assets/k8s-pod/cover.png alt></figure><a class=entry-link aria-label="post link to 從零開始學習 Kubernetes：Pod Overview" href=https://sz9751210.github.io/posts/k8s-pod/></a></article><article class="post-entry tag-entry"><div class=post-info><header class=entry-header><h2>閱讀筆記：15 Best Practices when working with Docker</h2></header><div class=entry-content><p>標題：15 Best Practices when working with Docker
連結：15 Best Practices when working with Docker | by Ali Zeynalli | Dec, 2022 | Medium
本篇文章作者根據經驗以及自身研究整理出了15個使用Docker的技巧與提示
1. 進行中的工作不應保存在未命名、已停止的容器中 如果進行中的工作保存在不好的容器中，可能會導致資料丟失、風險以及安全問題、不利於協作
2. 定期清理Image 幫助釋放存儲空間，優化Docker引擎性能，減少安全風險，以及維持主機整潔，易於管理。
3. 使用授權的相依套件 可以帶來更好的合法性、安全性、可靠性、支持性和法律責任。
4. 將變化很大的部分放在 DockerFile 的末尾 因為Docker會將每個步驟緩存為一個單獨的容器，重複的操作將不會重新執行，將變化較大的部分放在最後可提高性能
5. 不要在容器啟動時就獲取相依套件 避免在容器啟動時獲取依賴包帶來的問題，並提高容器的啟動速度和可管理性。最佳實踐是在構建Image時就獲取依賴包，並將它們打包到Image中。另外，還可以使用多階段構建和緩存等技術來優化構建過程，提高構建速度和效率。
6. 不要掛載共享資料夾 有助於提高容器的可移植性、安全性、可重現性和可管理性。
7. 保持Image simple and small 可以提高應用程序的可移植性、降低安全風險、減少Image大小、提高Image構建和管理效率。
8. 從頭開始構建 最大限度地減少相依
9. Tag Image 使用合理的Tag，有助於對Image進行排序
10. 使用小型基礎Image 例如-slim或-alpine，可以帶來更明確的依賴項、更少的儲存、更少的安全漏洞和攻擊面以及更快的構建時間。
11. 使用官方Image 帶來可靠性、安全性、活躍的社群支持以及易用性等好處。
12. 創建臨時容器 Dockerfile定義的Image應該盡可能是臨時的，提供隔離環境、避免依賴衝突、快速清理、易於重複，提高工作效率與可靠性，方便快速測試，不必擔心對主機有影響。
13. 使用multi-stage構建 幫助減小Docker Image的大小，優化構建速度，簡化構建過程，以及提高Docker Image的安全性。...</p></div><footer class=entry-footer><span title='2023-02-14 13:56:00 +0800 CST'>2023-02-14</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;77 words&nbsp;·&nbsp;Alan</footer></div><a class=entry-link aria-label="post link to 閱讀筆記：15 Best Practices when working with Docker" href=https://sz9751210.github.io/posts/15-best-practices-when-working-with-docker/></a></article><article class="post-entry tag-entry"><div class=post-info><header class=entry-header><h2>k8s-reloader</h2></header><div class=entry-content><p>👨‍💻簡介 有時候修改掛載的config檔，無法即時更新，需要重啟pod才會生效，為了解決這個問題，k8s-reloader因此而誕生，透過觀察掛載的configmap或是secret的變化自動對掛載的物件做滾動更新。
以下為在minikube環境下，透過掛載nginx-config檔並搭配reloader這個插件進行熱部署。
🔗github-repo : stakater/Reloader: A Kubernetes controller to watch changes in ConfigMap and Secrets and do rolling upgrades on Pods with their associated Deployment, StatefulSet, DaemonSet and DeploymentConfig – [✩Star] if you’re using it! (github.com) 🔰基礎介紹 運作原理 Reloader偵測所有資源變化，對有變化的資源使用SHA1計算資源的哈西值 Reloader查看是否有設定相關的annotation，並查看有設定annotation資源的特殊環境變量 對有設定annotation的資源比對其哈希值，如果環境變量中哈希值不同，則更新環境變量，如果環境變量不存在，則創建一個 環境變量名稱 ConfigMap：STAKATER_{configmap_name}_CONFIGMAP ，比如 ConfigMap 的名稱為 foo，則生成的環境變量的名稱為：STAKATER_FOO_CONFIGMAP。 Secret：STAKATER_{secret_name}_SECRET ，比如 Secret 的名稱為 foo，則生成的環境變量的名稱為：STAKATER_FOO_SECRET。 環境變量的值 使用 SHA1 計算的 ConfigMap 或者 Secret 的哈希值。
版本需求 k8s版本需 >= 1.9
安裝方式 使用Manifests安裝 kubectl apply -f https://raw....</p></div><footer class=entry-footer><span title='2022-11-11 15:05:00 +0800 CST'>2022-11-11</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;373 words&nbsp;·&nbsp;Alan</footer></div><figure class=entry-cover><img loading=lazy src=https://sz9751210.github.io/assets/k8s-reloader/cover.png alt></figure><a class=entry-link aria-label="post link to k8s-reloader" href=https://sz9751210.github.io/posts/k8s-reloader/></a></article><article class="post-entry tag-entry"><div class=post-info><header class=entry-header><h2>系統異常指標除錯</h2></header><div class=entry-content><p>👨‍💻簡介 幫自己紀錄一下如何處理linux機器的指標
...</p></div><footer class=entry-footer><span title='2022-10-17 16:25:00 +0000 UTC'>2022-10-17</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;164 words&nbsp;·&nbsp;Alan</footer></div><a class=entry-link aria-label="post link to 系統異常指標除錯" href=https://sz9751210.github.io/posts/%E7%B3%BB%E7%B5%B1%E7%95%B0%E5%B8%B8%E6%8C%87%E6%A8%99%E9%99%A4%E9%8C%AF/></a></article><article class="post-entry tag-entry"><div class=post-info><header class=entry-header><h2>K8S-monitor</h2></header><div class=entry-content><p>📔心得 之前都介紹docker監控container，這次來點不一樣的，直接裝在k8s裡面去監控pod的一些指標。
基本的指標像是cpu, mem, pod數量, node數量等等，都能透過kube-state-metrics完成，而如果想要監控一些流量的指標，像是tcp連線數，tw數等，則是需要另外在服務的pod裡另外寫node-exporter的container，組成side-car的形式，讓exporter將指標送往prometheus。
在撰寫的過程，遇到比較大的難題是prometheus的config檔撰寫，一開始打算使用docker-compose的方式起monitor服務，然後去call k8s cluster取得相關指標，但常常call不到服務，可能是因為minikube的關係，在本地也跑docker，最後改成直接安裝在k8s裡面，另外建立一個namespace放監控相關的服務，有機會在測試kind以及k3s。
demo用的deploy使用skaffold這本地開發k8s的神器，搭配kustomize可讓我依據所需測試的環境下去做自動佈署，有機會再另外介紹這工具。
之後預計會再新增prometheus adapter，讓我的prometheus metrics可以成為我hpa的擴縮判斷，因為基本的hpa指標只有cpu以及mem，如果可以依照網路流量變大，幫我擴展pod，當流量變小時幫我縮pod，讓我能自定義指標，相信使用k8s的效益會更大。
🔗詳細專案位置 –> https://github.com/sz9751210/k8s-monitor
...</p></div><footer class=entry-footer><span title='2022-10-17 10:41:00 +0000 UTC'>2022-10-17</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;72 words&nbsp;·&nbsp;Alan</footer></div><figure class=entry-cover><img loading=lazy src=https://sz9751210.github.io/assets/k8s-monitor/cover.png alt></figure><a class=entry-link aria-label="post link to K8S-monitor" href=https://sz9751210.github.io/posts/k8s-monitor/></a></article><article class="post-entry tag-entry"><div class=post-info><header class=entry-header><h2>喬叔帶你上手Elastic Stack：Elasticsearch的最佳實踐與最佳化技巧</h2></header><div class=entry-content><p>📚讀後心得 當初在研究Elastic Stack，ILM這部份還不熟時，剛好搜尋到喬叔的鐵人賽文章，閱讀時彷彿挖到了寶，對於Index的管理講解得非常透徹，從Index如何被建立，使用Template以及Alias，再到導入ILM以及搭配Rollover以及Shrink等方式達到索引、搜尋、儲存等最佳化，一步一步穩定順利的完成，真的很感動。
之前使用Elastic Stack並沒有使用到ILM的配置，所以單個Index可能會超過官方建議的大小，並且使用的是以一天為單位，但實務上並非每個服務都是固定的大小，因此導入ILM對於整體的效能會有更好的幫助，並且使用三溫暖架構，讓最新的log都放在效能較好的機器上，較舊的log則隨著自定義的時間轉移到效能較差的機器上，讓搜尋能有更好的體驗。
...</p></div><footer class=entry-footer><span title='2022-10-17 10:20:00 +0000 UTC'>2022-10-17</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;24 words&nbsp;·&nbsp;Alan</footer></div><figure class=entry-cover><img loading=lazy src="https://im1.book.com.tw/image/getImage?i=https://www.books.com.tw/img/E05/011/42/E050114292.jpg&v=6195d615k&w=450&h=450" alt></figure><a class=entry-link aria-label="post link to 喬叔帶你上手Elastic Stack：Elasticsearch的最佳實踐與最佳化技巧" href=https://sz9751210.github.io/posts/%E5%96%AC%E5%8F%94%E5%B8%B6%E4%BD%A0%E4%B8%8A%E6%89%8Belastic-stackelasticsearch%E7%9A%84%E6%9C%80%E4%BD%B3%E5%AF%A6%E8%B8%90%E8%88%87%E6%9C%80%E4%BD%B3%E5%8C%96%E6%8A%80%E5%B7%A7/></a></article><article class="post-entry tag-entry"><div class=post-info><header class=entry-header><h2>ANSIBLE-ELK</h2></header><div class=entry-content><p>📔心得 上次使用docker建立起ELK-stack，最近剛好在研究ansible，所以也寫了一下使用playbook的方式建立起ELK-stack。
撰寫的過程中，先從官方文件查看安裝流程，接著再去找ansible相對應的module，在目錄結構的劃分也學習到了不少，從一開始只有一個main.yml慢慢獨立出來有一個根目錄的yml再去include task，並學會如何使用template以及vars。
在撰寫template時，使用到了jinja2語法，直接可以套用vars，讓我的template複製進去就都載入好我要的參數，並且可以依照我的inventory動態設定我的參數，真的有夠強大。
最後要感謝凍仁大的ansible教程，許多學習資訊都是從凍仁大的ansible git book學到的，會把網址放在下面，有興趣的可以去參考一下，寫得很簡潔明瞭，讓新手也能很快上手，尤其是使用docker-compose就能練習ansible的部份，使用jupyter notebook下去跑ansible module有夠方便。
🔗凍仁大ansible指南 –> 現代 IT 人一定要知道的 Ansible 自動化組態技巧
🔗Ansible-ELK repo –> Ansible-ELK
👨‍💻簡介 在gcp環境下使用ansible playbook 建立elk stack
elasticsearch：主要會先需要先跑init master，接著再去跑seed host去加入master組成cluster架構，邏輯上還有可修改的地方，目前先以兩份yaml分開跑下去做建立，在跑完init master後會先建立iim以及index template logstash：直接將pipeline等設定都複製進去 ...</p></div><footer class=entry-footer><span title='2022-10-17 09:57:00 +0000 UTC'>2022-10-17</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;269 words&nbsp;·&nbsp;Alan</footer></div><figure class=entry-cover><img loading=lazy src=https://sz9751210.github.io/assets/ansible-elk/cover.png alt></figure><a class=entry-link aria-label="post link to ANSIBLE-ELK" href=https://sz9751210.github.io/posts/ansible-elk/></a></article><article class="post-entry tag-entry"><div class=post-info><header class=entry-header><h2>Portainer：一款圖形化容器管理工具</h2></header><div class=entry-content><p>📔心得 一直以來都在使用container下去跑測試環境，所以都是使用docker指令下去做除錯，最近因緣際會下找到這一款可以透過UI看全部的container狀態，真的覺得好用到爆炸，所以來介紹一下這款容器化管理神器。
基本上能用docker指令做到的事情，portainer都能做到，像是docker ps，查看所有container，接著點擊某個container，就會顯示基本的container訊息。裡面能針對這個container查看logs，inspect，stat等等，功能非常齊全。 我自己最常使用的就是docker logs，透過UI可以直接點擊Logs查看，方便很多。
依照類型也會分出stack，container，image，network，volume等等，都可各別下去做新增，查看與管理，有時候東西建了忘記刪，這邊會顯示unused，打勾後就能一鍵移除。
portainer從拉image到deploy container都能透過ui完成，對於更新版本也是很有一套，可以透過設定pull latest並點擊recreate進行container的更新，對於常常使用container測試者真的是一大福音。
👨‍💻簡介 portainer主要讓我們能有個UI介面管理我們的docker，對於初學docker指令不太熟的使用者能快速進入docker的世界，並且可從docker hub一鍵拉取image，設定network、volume等進行快速部署，都可藉由portainer完成。 ...</p></div><footer class=entry-footer><span title='2022-07-10 15:45:00 +0000 UTC'>2022-07-10</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;88 words&nbsp;·&nbsp;Alan</footer></div><figure class=entry-cover><img loading=lazy src=https://sz9751210.github.io/assets/portainer-intro/cover.png alt></figure><a class=entry-link aria-label="post link to Portainer：一款圖形化容器管理工具" href=https://sz9751210.github.io/posts/portainer-intro/></a></article><article class="post-entry tag-entry"><div class=post-info><header class=entry-header><h2>CentOS 安裝docker 和 docker-compose</h2></header><div class=entry-content><p>簡介 因常會在新機器跑container，藉此紀錄安裝過程，順便寫下腳本安裝懶人包 ...</p></div><footer class=entry-footer><span title='2022-07-03 20:16:00 +0000 UTC'>2022-07-03</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;184 words&nbsp;·&nbsp;Alan</footer></div><a class=entry-link aria-label="post link to CentOS 安裝docker 和 docker-compose" href=https://sz9751210.github.io/posts/centos-%E5%AE%89%E8%A3%9Ddocker-%E5%92%8C-docker-compose/></a></article><article class="post-entry tag-entry"><div class=post-info><header class=entry-header><h2>ELFK-stack-monitor</h2></header><div class=entry-content><p>📔心得 因最近在研究elk-stack，藉此紀錄一下使用docker-compose建立起elk-stack的架構，在建立的過程中，比較多遇到的是記憶體使用率的配置不足，導致容器無法成功啟動，或是config檔權限的問題，因此在filebeat的部分會直接把config檔放進去並改成root權限。
之後希望能再增加logstash的pipeline功能，在實務上可多個服務做篩選，以及elasticsearch的資料安全性配置SSL和叢集架構，並導入ILM做log的空間管理。
監控的部分則是拿之前做的小專案直接套用並呈現，所以整體流程大致上差不多，多了個elasticsearch_exporter，可查看更多elasticsearch的整體狀況，例如index、shard的數量，資料大小，寫入速率等等。
🔗詳細專案位置 –> ELFK-stack-monitor
👨‍💻簡介 🔰ELFK-stack：使用docker-compose建立起elk-stack的架構，主要先從alpine產生假資料並存到filebeat讀取的資料夾，接著filebeat將資料送往logstash，在實務上，會在logstash做filter的功能(未來會新增)，接著送到elasticsearch存起來，並透過kibana的ui下去做搜尋所需的log資料。
🔰Monitor：使用cadvisor監控所有容器以及elasticsearch_exporter監控elasticsearch的狀態，並把資料送到prometheus儲存起來，最後透過grafana的ui呈現。
...</p></div><footer class=entry-footer><span title='2022-07-03 19:41:00 +0000 UTC'>2022-07-03</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;45 words&nbsp;·&nbsp;Alan</footer></div><figure class=entry-cover><img loading=lazy src=https://sz9751210.github.io/assets/elfk-stack-monitor/cover.png alt></figure><a class=entry-link aria-label="post link to ELFK-stack-monitor" href=https://sz9751210.github.io/posts/elfk-stack-monitor/></a></article><footer class=page-footer><nav class=pagination><a class=next href=https://sz9751210.github.io/tags/devops/page/2/>Next&nbsp;&nbsp;»</a></nav></footer></main><footer class=footer><span>&copy; 2023 <a href=https://sz9751210.github.io/>艾倫的程式之旅</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let detail=document.getElementsByClassName("details");details=[].slice.call(detail);for(let e=0;e<details.length;e++){let t=details[e];const n=t.getElementsByClassName("details-summary")[0];n&&n.addEventListener("click",()=>{t.classList.toggle("open")},!1)}</script><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>