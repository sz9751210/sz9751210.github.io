<!doctype html><html lang=en dir=auto><head><meta name=generator content="Hugo 0.111.3"><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>艾倫的程式之旅</title><meta name=keywords content="Blog,Devops,PaperMod"><meta name=description content="ExampleSite description"><meta name=author content="Alan"><link rel=canonical href=https://sz9751210.github.io/><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.css rel="preload stylesheet" as=style><link rel=icon href=https://sz9751210.github.io/assets/profile/avatar.png><link rel=icon type=image/png sizes=16x16 href=https://sz9751210.github.io/assets/profile/avatar.png><link rel=icon type=image/png sizes=32x32 href=https://sz9751210.github.io/assets/profile/avatar.png><link rel=apple-touch-icon href=https://sz9751210.github.io/assets/profile/avatar.png><link rel=mask-icon href=https://sz9751210.github.io/assets/profile/avatar.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://sz9751210.github.io/index.xml><link rel=alternate type=application/json href=https://sz9751210.github.io/index.json><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://www.googletagmanager.com/gtag/js?id=G-4RLTP9J7DY"></script>
<script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-4RLTP9J7DY",{anonymize_ip:!1})}</script><meta property="og:title" content="艾倫的程式之旅"><meta property="og:description" content="ExampleSite description"><meta property="og:type" content="website"><meta property="og:url" content="https://sz9751210.github.io/"><meta property="og:image" content="https://sz9751210.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta property="og:site_name" content="ExampleSite"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://sz9751210.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="艾倫的程式之旅"><meta name=twitter:description content="ExampleSite description"><script type=application/ld+json>{"@context":"https://schema.org","@type":"Organization","name":"艾倫的程式之旅","url":"https://sz9751210.github.io/","description":"ExampleSite description","thumbnailUrl":"https://sz9751210.github.io/assets/profile/avatar.png","sameAs":["mailto:alandev9751210@gmail.com","https://www.instagram.com/alan_wang.dev.life","https://github.com/sz9751210"]}</script><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-8214206744217848" crossorigin=anonymous></script></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://sz9751210.github.io/ accesskey=h title="Alan's BLOG (Alt + H)"><img src=https://sz9751210.github.io/assets/profile/avatar.png alt aria-label=logo height=35>Alan's BLOG</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://sz9751210.github.io/archives/ title=archives><span>archives</span></a></li><li><a href=https://sz9751210.github.io/posts/ title=posts><span>posts</span></a></li><li><a href=https://sz9751210.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://sz9751210.github.io/about/ title=about><span>about</span></a></li><li><a href=https://sz9751210.github.io/quote/ title=quote><span>quote</span></a></li><li><a href=https://sz9751210.github.io/search/ title="search (Alt + /)" accesskey=/><span>search</span></a></li></ul></nav></header><main class=main><article class=post-entry><div class=post-info><header class=entry-header><h2>從零開始：使用make函數創建資料結構</h2></header><div class=entry-content><p>👨‍💻簡介 make函數在slice、map和之後會介紹到的channel的初始化中扮演著關鍵的角色。本文將會簡單介紹make函數的用法，以及在初始化不同資料結構時的差異，讓你更好地理解和利用make函數。
make函數基本概念 首先，讓我們來了解一下make函數的基本概念。在Go中，make函數用於動態分配記憶體並初始化slice、map和channel。
// 創建一個切片，長度為5，容量為10 mySlice := make([]int, 5, 10) 在上面的範例中，我們使用make函數創建了一個整數切片（slice），其長度為5，容量為10。這意味著切片可以容納5個元素，但它的底層陣列的容量是10，這為後續的操作提供了一定的靈活性。
make函數的語法 make函數的語法相對簡單。它的一般形式是：
make(類型, 長度, 容量) 類型：指定要創建的資料類型，可以是切片、map或通道。 長度：表示資料結構的初始長度。 容量：只適用於切片和通道，表示底層陣列的容量。 使用make初始化切片 接下來，讓我們看看如何使用make函數初始化切片。
// 創建一個整數切片，長度為3，容量為5 mySlice := make([]int, 3, 5) mySlice[0] = 1 mySlice[1] = 2 mySlice[2] = 3 在這個例子中，我們首先使用make函數創建了一個長度為3、容量為5的整數切片。然後，我們分配了三個整數值到切片中。
使用make初始化Map 現在，讓我們看看如何使用make函數初始化Map。map是一種鍵值對的資料結構，非常適合用於存儲關聯性資料。
// 創建一個字符串到整數的map myMap := make(map[string]int) myMap["apple"] = 1 myMap["banana"] = 2 myMap["cherry"] = 3 在這個範例中，我們使用make函數創建了一個空的字符串到整數的map，然後添加了三個鍵值對。
make 函數在 Go 語言中常見用法包括初始化切片、map和通道。然而，它的使用也受到一些限制和約束。以下是 make 函數的常見用法以及相關的使用限制：
使用make初始化通道 最後，我們來看看如何使用make函數初始化通道。通道是Go語言中用於並發通信的重要機制。
// 創建一個通道，用於傳輸字符串資料 myChannel := make(chan string) go func() { myChannel &lt;- "Hello" myChannel &lt;- "World" }() 在這個例子中，我們使用make函數創建了一個通道，它可以傳輸字符串資料。然後，我們使用Go協程向通道發送了兩個字符串。...</p></div><footer class=entry-footer><span title='2023-09-04 19:26:00 +0800 CST'>2023-09-04</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;153 words&nbsp;·&nbsp;Alan</footer></div><figure class=entry-cover><img loading=lazy src=https://sz9751210.github.io/assets/go-make/cover.png alt></figure><a class=entry-link aria-label="post link to 從零開始：使用make函數創建資料結構" href=https://sz9751210.github.io/posts/go-make/></a></article><article class=post-entry><div class=post-info><header class=entry-header><h2>Package：Golang 專案的組織策略</h2></header><div class=entry-content><p>👨‍💻簡介 套件（Package）在Golang中扮演著組織和管理程式碼的重要角色。
package就像工具箱一樣，裡面裝滿各種不同的工具，每個工具都有特定的功能。這些工具能夠幫助你完成不同的任務，從修理家具到蓋小屋，樣樣都行。
今天這篇文章將快速瞭解 Golang 的package，學習如何建立package、匯入package以及一些使用技巧。
什麼是 Package？ 在 Golang 中，Package 是一種組織程式碼的方式，它將相關的函式、變數和資源放在一個目錄中。這不僅有助於保持程式碼的整潔，還能讓我們更容易地重複使用程式碼。
Package 名稱與資料夾名稱的一致性 通常建議在建立package時，將package名稱與所在資料夾名稱保持一致，這樣有助於提高程式碼的可讀性和一致性。Golang 的匯入機制是基於package的 import 路徑來識別package，而 import 路徑通常會反映package的資料夾結構。這種一致性可以讓其他開發人員更容易理解你的程式碼，並且不需要額外的查找工作，因為package的名稱與資料夾名稱一致。
舉例來說，假設你的資料夾結構如下：
project/ |-- greetings/ | |-- greetings.go | |-- main/ | |-- main.go 如果我們建立的package名稱為 greetings，我們可以在 greetings.go 中這樣定義：
// greetings.go package greetings func Hello(name string) string { return "Hello, " + name } 然後在 main.go 中使用這個package：
// main.go package main import ( "fmt" "your/project/path/greetings" ) func main() { message := greetings.Hello("Alan") fmt....</p></div><footer class=entry-footer><span title='2023-09-01 15:39:00 +0800 CST'>2023-09-01</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;281 words&nbsp;·&nbsp;Alan</footer></div><figure class=entry-cover><img loading=lazy src=https://sz9751210.github.io/assets/go-package/cover.png alt></figure><a class=entry-link aria-label="post link to Package：Golang 專案的組織策略" href=https://sz9751210.github.io/posts/go-package/></a></article><article class=post-entry><div class=post-info><header class=entry-header><h2>Interface：Go 語言中的抽象關鍵</h2></header><div class=entry-content><p>👨‍💻簡介 在Go語言中，Interface 是一個重要且強大的概念。Interface提供了一種方式來定義對象之間的契約，讓你可以設計更具有靈活性和可擴展性的程式碼。 你可以把Interface想像成是一種約定，讓不同的東西彼此溝通的方式變得特別靈活和好擴充，告訴程式裡的各個元件彼此要怎麼合作。
什麼是Interface 在 Go 語言中，Interface是一種關鍵的概念，用於定義方法的契約，而不關心具體的實現。它是一種抽象的型別，描述了物件應該具備的方法。Interface在實現多態性、抽象和模組化設計等方面扮演著重要角色。
Interface是一種抽象的類型，它定義了一組方法簽名（method signatures），但不包含方法的實際實現。這些方法簽名定義了對象應該支援的操作，從而允許不同類型的對象實現同一個Interface並進行交互。
一聽可能有點高深，但其實它就像是一份約定，不管實際怎麼做，只要能遵循這份約定就行。
就好像你和朋友約好要出去玩，你們約定好一起出門、一起玩，但具體怎麼玩，是不是吃火鍋還是去唱歌，那就隨你們。這些約定就是你們的「Interface」，告訴大家「我們一起要做這些事情！」。
當然，這在程式碼裡的作用更大。透過這個「Interface」，你可以讓不同種類的東西，像是車、狗、電腦，都能夠用一樣的方式進行互動。不管是車、狗、還是電腦，只要符合了這個「Interface」約定的方法，你就可以放心地拿來用了。
Interface的基本使用 透過Interface，我們可以在不關心具體類型的情況下，對對象進行操作。這種多態性的概念讓程式碼更具彈性，能夠適應不同的實現。
// 定義一個Interface Shape，它具有一個 Area 方法 type Shape Interface { Area() float64 } // 定義一個 Circle 結構體，實現了 Shape Interface的 Area 方法 type Circle struct { Radius float64 } func (c Circle) Area() float64 { return 3.14 * c.Radius * c.Radius } // 定義一個 Rectangle 結構體，實現了 Shape Interface的 Area 方法 type Rectangle struct { Width, Height float64 } func (r Rectangle) Area() float64 { return r....</p></div><footer class=entry-footer><span title='2023-08-31 19:12:00 +0800 CST'>2023-08-31</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;673 words&nbsp;·&nbsp;Alan</footer></div><figure class=entry-cover><img loading=lazy src=https://sz9751210.github.io/assets/go-interface/cover.png alt></figure><a class=entry-link aria-label="post link to Interface：Go 語言中的抽象關鍵" href=https://sz9751210.github.io/posts/go-interface/></a></article><article class=post-entry><div class=post-info><header class=entry-header><h2>探索 Golang 中的結構體：如何有效地組織複雜資料</h2></header><div class=entry-content><p>👨‍💻簡介 在程式開發的世界中，我們經常需要處理各式各樣的資料，可能是一個人的個人資訊，也可能是一個商品的詳細訊息。當我們面對這麼多的資料時，如何將它們有系統地整理起來，讓我們能夠輕鬆地找到所需，便成了一個重要的課題。這時，結構體的概念就像是一道曙光，為我們提供了一個非常有力的工具。
結構體基礎 結構體，就像是一張設計圖，讓我們畫下我們腦袋裡的想法，就像是一個多功能的工具箱，結構體讓我們能夠以組織化的方式來儲存各種資料片段，就像是將資料拼湊成了一個個獨特的拼圖。今天，我們將深入探討 Golang 中結構體的神奇之處，以及如何通過結構體來更有效地組織和處理複雜資料。
首先，我們來看看如何定義和使用結構體。結構體是一個自定義的資料類型，它允許我們組織不同類型的資料在一個單一的單位中。
type Person struct { FirstName string LastName string Age int } 以一個人的資訊為例，我們可以創建一個名為 Person 的結構體，其中包含了 FirstName、LastName 和 Age 這三個基本資料。這些資料如同載體，讓我們能夠更方便地一次性儲存和訪問它們。 現在，我們可以創建一個 Person 的實例，並訪問其字段：
func main() { person := Person{ FirstName: "John", LastName: "Doe", Age: 30, } fmt.Println("First Name:", person.FirstName) fmt.Println("Last Name:", person.LastName) fmt.Println("Age:", person.Age) } 複雜資料的嵌套組織 但有時候，我們還需要更複雜的資料結構，例如住址。這時，結構體的嵌套就派上用場了，我們可以在 Person 結構體中嵌套另一個結構體，用來表示住址的相關資訊，如 Street、City 和 Country。
type Address struct { Street string City string Country string } type Person struct { FirstName string LastName string Age int Address Address } 也可以直接寫在裡面...</p></div><footer class=entry-footer><span title='2023-08-30 16:06:00 +0800 CST'>2023-08-30</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;299 words&nbsp;·&nbsp;Alan</footer></div><figure class=entry-cover><img loading=lazy src=https://sz9751210.github.io/assets/go-struct/cover.png alt></figure><a class=entry-link aria-label="post link to 探索 Golang 中的結構體：如何有效地組織複雜資料" href=https://sz9751210.github.io/posts/go-struct/></a></article><article class=post-entry><div class=post-info><header class=entry-header><h2>🚀 Golang 函數：從入門到精通</h2></header><div class=entry-content><p>👨‍💻簡介 在 Go 語言中，函數（Function）是一個強大且重要的概念，就像食譜一樣，告訴你應該如何處理食材，最後得到一道美味的料理。經過哪些程序讓程式更有組織性和可讀性。函數可幫助你將程式碼區塊組織成可重複使用的元件，進而執行特定的任務。本文要帶你一探究竟，深入了解 Golang 裡的函數有哪些不同的方面。從基本的概念開始，一路講到更高級的技巧，我們會告訴你怎麼樣用函數來處理各種不同的情況。
函數基本概念 函數在 Golang 中是一組程式語句的組合，用於執行特定的任務。它們接受輸入（參數）並返回輸出（返回值），從高層次來看，就像是黑盒子，你提供輸入，它交付結果。在每個 Golang 程式中，最常見的函數是 main()，它是程式的入口點。
函數名稱與命名規則 在 Golang 中，函數名稱的命名規則如下：
名稱必須以字母開始，後面可以是任意數量的字母和數字。 函數名稱不能以數字開頭。 函數名稱不能包含空格。 如果函數名稱以大寫字母開頭，則可以被其他套件引用。如果以小寫字母開頭，則不能被其他套件引用，但可以在同一套件內部使用。 如果名稱由多個單詞組成，從第二個單詞開始的每個單詞首字母應大寫，例如 empName、EmpAddress 等。 函數名稱區分大小寫，即 car、Car 和 CAR 是三個不同的變數。 創建函數 在 Golang 中，創建函數的基本語法如下：
func 函數名稱(參數1 型別1, 參數2 型別2, ...) 返回型別 { // 函數程式碼 return 返回值 } 首先，用 func 關鍵字開始函數宣告，然後是你想要給函數的名稱，一對括號 ()，然後是一個包含函數程式碼的區塊。
以下是一個簡單的範例，它不接受任何參數，也不返回任何值。
package main import "fmt" // SimpleFunction 印出一個訊息 func SimpleFunction() { fmt.Println("Hello World") } func main() { SimpleFunction() // 呼叫 SimpleFunction 函數 } 接受參數的函數 如果要將資訊傳遞給函數，可以通過參數來實現。參數就像變數一樣。...</p></div><footer class=entry-footer><span title='2023-08-29 14:54:00 +0800 CST'>2023-08-29</span>&nbsp;·&nbsp;5 min&nbsp;·&nbsp;978 words&nbsp;·&nbsp;Alan</footer></div><figure class=entry-cover><img loading=lazy src=https://sz9751210.github.io/assets/go-func/cover.png alt></figure><a class=entry-link aria-label="post link to 🚀 Golang 函數：從入門到精通" href=https://sz9751210.github.io/posts/go-func/></a></article><article class=post-entry><div class=post-info><header class=entry-header><h2>淺談 Go 語言中的 Map - 快速查詢與狀態儲存的利器</h2></header><div class=entry-content><p>👨‍💻簡介 在 Go 語言中，有著一個強大又便捷的工具，可以讓你以鍵-值（Key-Value）的形式儲存和查詢資料，它就是「Map」。Map 在 Go 語言中扮演了重要的角色，簡化了許多資料處理的任務，現在讓我們一起來深入了解這個有趣的資料型別。
Map的基本概念 Map 是 Go 語言中的一種內建資料型別，用來存儲鍵值對。簡單來說，你可以將 Map 想像成一個無序的集合，每個元素都有一個唯一的鍵和相應的值。這讓你可以根據鍵來快速查詢和存取對應的值，就像是字典一樣。
宣告和初始化 Map 在 Go 中，宣告 Map 可使用以下語法：
m1 := make(map[string]int) // 創建一個儲存字串為鍵，整數為值的 Map m2 := map[int]string{1: "A", 2: "B"} // 創建一個包含鍵值對的映射 var m3 map[string]int // 創建一個鍵為字串、值為整數的空映射 而宣告時順便初始化可以使用以下方式：
myMap := map[string]int{ "apple": 3, "banana": 5, } var myMap map[string]int myMap = map[string]int{ "apple": 3, "banana": 5, } Map的基本操作 Map 的操作非常簡單直觀。你可以使用鍵來存取對應的值，也可以使用鍵來新增、修改或刪除元素。
新增或修改元素 myMap["apple"] = 3 // 新增一個元素，鍵是 "apple"，值是 3 myMap["banana"] = 5 // 新增一個元素，鍵是 "banana"，值是 5 myMap["apple"] = 10 // 修改鍵為 "apple" 的元素的值為 10 查詢元素 value := myMap["banana"] // 根據鍵 "banana" 查詢對應的值 刪除元素 delete(myMap, "apple") // 刪除鍵為 "apple" 的元素 遍歷 Map 要遍歷一個 Map 中的所有元素，通常會使用 for range 迴圈：...</p></div><footer class=entry-footer><span title='2023-08-28 16:36:00 +0800 CST'>2023-08-28</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;319 words&nbsp;·&nbsp;Alan</footer></div><figure class=entry-cover><img loading=lazy src=https://sz9751210.github.io/assets/go-map/cover.png alt></figure><a class=entry-link aria-label="post link to 淺談 Go 語言中的 Map - 快速查詢與狀態儲存的利器" href=https://sz9751210.github.io/posts/go-map/></a></article><article class=post-entry><div class=post-info><header class=entry-header><h2>Go 語言中的動態陣列：深入解析切片</h2></header><div class=entry-content><p>👨‍💻簡介 在 Go 語言中，切片（Slice）是一種動態序列的資料結構，能夠方便地存儲和操作多個相同類型的元素。切片相比於陣列，更具有彈性，因為它的大小是可變的，可以根據需要動態增長或縮小。切片在處理集合型資料時非常實用，讓你能夠輕鬆地新增、刪除、修改和操作元素，同時避免了固定大小的限制。
切片的基本概念 切片是由一個指向陣列的指針、切片長度和切片容量組成的。切片的長度指的是切片中實際包含的元素個數，而切片的容量則是從切片開始的底層陣列中能夠訪問的元素個數。切片的容量可以大於或等於切片的長度。
宣告和初始化切片 在 Go 中，宣告和初始化切片可以使用以下的語法：
var slice1 []int // 創建一個整數切片，大小和容量都是 0 slice2 := []string{"A", "B", "C"} // 創建一個包含三個字串元素的切片 slice3 := make([]int, 5) // 創建一個整數切片，大小為 5，容量也為 5 slice4 := make([]int, 3, 5) // 創建一個整數切片，大小為 3，容量為 5 切片的基本操作 新增元素到切片 Go語言中有個內件函式append()，可以用來新增元素到切片中，這使得切片能夠根據需求動態增長。
numbers := []int{10, 20, 30} numbers = append(numbers, 40, 50) // 新增兩個元素到切片 需要注意的是，如果切片的容量不足以容納新增的元素，append() 函式會創建一個新的切片，並將舊的元素和新的元素一同複製到新的切片中。
查詢和修改切片元素 切片的元素可以通過索引來存取，索引從 0 開始計數。
numbers := []int{10, 20, 30, 40, 50} firstNumber := numbers[0] // 存取第一個元素，值為 10 secondNumber := numbers[1] // 存取第二個元素，值為 20 numbers[2] = 35 // 修改切片中的元素，將第三個元素改為 35 切割和遍歷切片 可以使用切片的切割操作來獲取部分切片，這可以通過指定切片的起始索引和結束索引來實現：...</p></div><footer class=entry-footer><span title='2023-08-24 14:24:00 +0800 CST'>2023-08-24</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;392 words&nbsp;·&nbsp;Alan</footer></div><figure class=entry-cover><img loading=lazy src=https://sz9751210.github.io/assets/go-slice/cover.png alt></figure><a class=entry-link aria-label="post link to Go 語言中的動態陣列：深入解析切片" href=https://sz9751210.github.io/posts/go-slice/></a></article><article class=post-entry><div class=post-info><header class=entry-header><h2>陣列：Go語言中的數據小倉庫</h2></header><div class=entry-content><p>👨‍💻簡介 陣列就像是一個儲存相同類型資料的容器，你可以想像成裝滿了一樣東西的盒子，每個東西都叫做陣列元素。這種類型可以是基本的，像是整數或字串，也可以是你自己定義的型別。不過陣列有個限制，就是大小一旦確定就無法改變。在Go語言裡，陣列的長度也是型別的一部分。舉例來說，[5]int和[10]int就是不同的型別。雖然它們都是整數陣列，但因為長度不同，所以視為不同的資料型別，不能直接互相給值或操作。這麼做是為了在長度上更加嚴謹，不會混淆不同大小的陣列，增加了資料的安全性。
另一個類似的東西是切片（Slice），這東西可以想像成動態的序列，可以根據需要自由地增加或減少。不過，為了更好地理解切片，我們先學學陣列的使用。
陣列的基本概念 陣列是由一組元素所組成的固定大小的資料結構，每個元素都有一個相應的索引。陣列的大小在宣告時就需要確定，並且在後續操作中無法改變。
宣告和初始化陣列 在 Go 中，宣告和初始化陣列可以使用以下的語法：
var arr1 [3]int // 創建一個整數陣列，大小為 3 arr2 := [4]string{"A", "B"} // 創建一個包含 4 個字串元素的陣列 arr3 := [...]int{1, 2, 3} // 自動推斷陣列大小為 3 你也可以在宣告陣列的同時，使用指定索引的方式來初始化陣列：
arr := [...]int{1: 10, 3: 30} // 陣列的值為 [0 10 0 30] 陣列的基本操作 取得陣列元素 陣列的元素可以通過索引來存取，索引從 0 開始計數。
numbers := [5]int{10, 20, 30, 40, 50} firstNumber := numbers[0] // 存取第一個元素，值為 10 secondNumber := numbers[1] // 存取第二個元素，值為 20 假設我們有一個陣列 arr := [5]int{1, 2, 3, 4, 5}。...</p></div><footer class=entry-footer><span title='2023-08-24 11:06:00 +0800 CST'>2023-08-24</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;427 words&nbsp;·&nbsp;Alan</footer></div><figure class=entry-cover><img loading=lazy src=https://sz9751210.github.io/assets/go-array/cover.png alt></figure><a class=entry-link aria-label="post link to 陣列：Go語言中的數據小倉庫" href=https://sz9751210.github.io/posts/go-array/></a></article><article class=post-entry><div class=post-info><header class=entry-header><h2>探索 Go 語言的流程控制</h2></header><div class=entry-content><p>👨‍💻簡介 本文簡單介紹了 Go 語言的流程控制概念，涵蓋了從條件語句到迴圈，再到 range 遍歷數據結構，以及 goto 與標籤 label 的應用。主要知識點為如何使用 if 語句進行條件判斷，以及在不同情況下運用 switch 語句。此外，還探討了 for 迴圈和 range 的運用，以及在特定情境下使用 goto 與 label。
條件語句 在 Go 語言中，我們可以使用條件語句來根據不同的條件執行不同的程式碼塊。常見的條件語句包括：
if 語句 if 語句用來檢查一個條件是否成立，如果條件為真，就執行相關的程式碼塊。例如：
age := 18 if age >= 18 { fmt.Println("你已成年") } else { fmt.Println("你還未成年") } 我們也可以使用 else if 分支處理多種情況：
age := 25 if age &lt; 18 { fmt.Println("你還未成年") } else if age >= 18 && age &lt; 60 { fmt.Println("你已成年，但尚未退休") } else { fmt....</p></div><footer class=entry-footer><span title='2023-08-21 16:01:00 +0800 CST'>2023-08-21</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;372 words&nbsp;·&nbsp;Alan</footer></div><figure class=entry-cover><img loading=lazy src=https://sz9751210.github.io/assets/go-control-flow/cover.png alt></figure><a class=entry-link aria-label="post link to 探索 Go 語言的流程控制" href=https://sz9751210.github.io/posts/go-control-flow/></a></article><article class=post-entry><div class=post-info><header class=entry-header><h2>Go 語言的各種運算符</h2></header><div class=entry-content><p>👨‍💻簡介 本文快速介紹了 Go 語言中的各種運算符，從數學計算到邏輯判斷，包括自增自減、賦值、比較和位運算。透過實例和清晰的解釋，快速掌握如何在程式中運用這些運算符。
算術運算符 在 Go 語言中，我們可以使用各種算術運算符來執行基本的數學運算。以下是一些常用的算術運算符：
+：加法運算，用來將兩個數相加。 -：減法運算，用來從一個數中減去另一個數。 *：乘法運算，用來將兩個數相乘。 /：除法運算，用來將一個數除以另一個數。 %：求餘運算，用來得到兩個數相除的餘數。 例如：
a := 5 b := 3 c := a + b // c 的值是 8 d := a * b // d 的值是 15 此外，我們還有自增和自減運算符，它們用來讓變數的值增加或減少 1：
++：自增運算符，將變數的值增加 1。 --：自減運算符，將變數的值減少 1。 舉個例子：
x := 10 x++ // x 的值變成了 11 y := 5 y-- // y 的值變成了 4 賦值運算符 賦值運算符用來將一個值賦給一個變數。我們常見的賦值運算符有：
=：將右邊的值賦給左邊的變數。 +=：先將右邊的值加到左邊的變數上，然後再將結果賦給左邊的變數。 -=：先從左邊的變數中減去右邊的值，然後再將結果賦給左邊的變數。 *=：先將左邊的變數乘以右邊的值，然後再將結果賦給左邊的變數。 /=：先將左邊的變數除以右邊的值，然後再將結果賦給左邊的變數。 %=：先將左邊的變數除以右邊的值取餘數，然後再將結果賦給左邊的變數。 簡單範例如下：...</p></div><footer class=entry-footer><span title='2023-08-21 15:15:00 +0800 CST'>2023-08-21</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;401 words&nbsp;·&nbsp;Alan</footer></div><figure class=entry-cover><img loading=lazy src=https://sz9751210.github.io/assets/go-operator/cover.png alt></figure><a class=entry-link aria-label="post link to Go 語言的各種運算符" href=https://sz9751210.github.io/posts/go-operator/></a></article><footer class=page-footer><nav class=pagination><a class=prev href=https://sz9751210.github.io/page/2/>«&nbsp;Prev&nbsp;</a>
<a class=next href=https://sz9751210.github.io/page/4/>Next&nbsp;&nbsp;»</a></nav></footer></main><footer class=footer><span>&copy; 2023 <a href=https://sz9751210.github.io/>艾倫的程式之旅</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let detail=document.getElementsByClassName("details");details=[].slice.call(detail);for(let e=0;e<details.length;e++){let t=details[e];const n=t.getElementsByClassName("details-summary")[0];n&&n.addEventListener("click",()=>{t.classList.toggle("open")},!1)}</script><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>