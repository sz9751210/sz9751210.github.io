<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Posts | 艾倫的程式之旅</title>
<meta name=keywords content><meta name=description content="Posts - 艾倫的程式之旅"><meta name=author content="Alan"><link rel=canonical href=https://sz9751210.github.io/posts/><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.css rel="preload stylesheet" as=style><link rel=icon href=https://sz9751210.github.io/assets/profile/avatar.png><link rel=icon type=image/png sizes=16x16 href=https://sz9751210.github.io/assets/profile/avatar.png><link rel=icon type=image/png sizes=32x32 href=https://sz9751210.github.io/assets/profile/avatar.png><link rel=apple-touch-icon href=https://sz9751210.github.io/assets/profile/avatar.png><link rel=mask-icon href=https://sz9751210.github.io/assets/profile/avatar.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://sz9751210.github.io/posts/index.xml><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://www.googletagmanager.com/gtag/js?id=G-4RLTP9J7DY"></script><script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-4RLTP9J7DY",{anonymize_ip:!1})}</script><meta property="og:title" content="Posts"><meta property="og:description" content="ExampleSite description"><meta property="og:type" content="website"><meta property="og:url" content="https://sz9751210.github.io/posts/"><meta property="og:image" content="https://sz9751210.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta property="og:site_name" content="ExampleSite"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://sz9751210.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="Posts"><meta name=twitter:description content="ExampleSite description"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://sz9751210.github.io/posts/"}]}</script><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-8214206744217848" crossorigin=anonymous></script></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://sz9751210.github.io/ accesskey=h title="Alan's BLOG (Alt + H)"><img src=https://sz9751210.github.io/assets/profile/avatar.png alt aria-label=logo height=35>Alan's BLOG</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://sz9751210.github.io/archives/ title=archives><span>archives</span></a></li><li><a href=https://sz9751210.github.io/posts/ title=posts><span class=active>posts</span></a></li><li><a href=https://sz9751210.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://sz9751210.github.io/about/ title=about><span>about</span></a></li><li><a href=https://sz9751210.github.io/quote/ title=quote><span>quote</span></a></li><li><a href=https://sz9751210.github.io/search/ title="search (Alt + /)" accesskey=/><span>search</span></a></li></ul></nav></header><main class=main><header class=page-header><div class=breadcrumbs><a href=https://sz9751210.github.io/>Home</a></div><h1>Posts
<a href=index.xml title=RSS aria-label=RSS><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" height="23"><path d="M4 11a9 9 0 019 9"/><path d="M4 4a16 16 0 0116 16"/><circle cx="5" cy="19" r="1"/></svg></a></h1></header><article class=post-entry><div class=post-info><header class=entry-header><h2>Telegram 憑證監控機器人實作 EP1 - 讀取 MongoDB Domain Info</h2></header><div class=entry-content><p>👨‍💻 簡介 上次做的憑證監控已經可以正常運作了，但這次希望能夠不從 yaml 讀取 domain info，而是從 MongoDB 進行讀取，方便未來的擴充性。
這次的重點是要透過 Python 連接 MongoDB，並且透過 Python 讀取 MongoDB，最後透過 Python 寫入 MongoDB。
🛠️ 使用工具 Python 3.9.6 MongoDB Mongoshell Docker Docker-Compose 📝 功能需求 建立 MongoDB docker-compose 透過 Python 連接 MongoDB 透過 Python 讀取 yaml 並寫入 MongoDB 透過 Python 傳入 env 以及 domain 寫入 MongoDB 透過 Python 讀取 MongoDB 透過 Python 修改 MongoDB 透過 Python 刪除 MongoDB 🎯Setup 建立 MongoDB docker-compose 要簡單使用 MongoDB 可以用 docker-compose 快速拉起： version: "3....</p></div><footer class=entry-footer><span title="2024-05-06 15:45:00 +0800 CST">2024-05-06</span>&nbsp;·&nbsp;5 min&nbsp;·&nbsp;953 words&nbsp;·&nbsp;Alan</footer></div><figure class=entry-cover><img loading=lazy src=https://sz9751210.github.io/assets/tg-bot-ep1/cover.png alt></figure><a class=entry-link aria-label="post link to Telegram 憑證監控機器人實作 EP1 - 讀取 MongoDB Domain Info" href=https://sz9751210.github.io/posts/tg-bot-ep1/></a></article><article class=post-entry><div class=post-info><header class=entry-header><h2>實現 CloudFlare DNS 解析：使用 Terraform 和 GCS 進行高效配置</h2></header><div class=entry-content><p>👨‍💻 簡介 之前透過 Terraform 建立 GCP Global IP，延續上一篇的文，我們要把 Global IP 在 CloudFlare 上做 DNS 解析綁定，使我們一般在瀏覽網頁時能夠輸入網址進行訪問。
🛠️ 使用工具 Terraform CloudFlare GCS 📝 功能需求 研究 Terraform 建立 CloudFlare DNS 解析 取得 GCS 上的 Terraform state file 並透過 terraform 建立 CloudFlare DNS 解析 模組化 🎯Setup 1. 研究 Terraform 建立 CloudFlare DNS 解析 查看 terraform cloudflare_record 官方文件 可以看到與 dns 的相關設定會使用這個 resource。 而要操作 CloudFlare 必須取得要調整的 Website zone id 與操作者的 api token 接下來開始撰寫 terraform 代碼
resource "cloudflare_record" "example" { zone_id = "your_zone_id" name = "terraform" type = "A" comment = "Managed by Terraform" value = "192....</p></div><footer class=entry-footer><span title="2024-04-23 13:19:00 +0800 CST">2024-04-23</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;517 words&nbsp;·&nbsp;Alan</footer></div><figure class=entry-cover><img loading=lazy src=https://sz9751210.github.io/assets/terraform-cloudflare/cover.png alt></figure><a class=entry-link aria-label="post link to 實現 CloudFlare DNS 解析：使用 Terraform 和 GCS 進行高效配置" href=https://sz9751210.github.io/posts/terraform-cloudflare/></a></article><article class=post-entry><div class=post-info><header class=entry-header><h2>自動化SSL憑證監控與到期通知系統</h2></header><div class=entry-content><p>👨‍💻簡介 最近因為憑證越來越多，需要監控什麼時候到期，當到期時發送到期通知，因此撰寫一個簡單的小程式來完成。
這次使用Python和Telegram Bot來監控SSL證書的到期時間並發送通知。並使用GCP工具，如CloudFunction和CloudScheduler做部署平台。
🛠️使用工具 Python 3.9 Telegram Bot(Webhook) CloudFunction CloudScheduler 📝功能需求 取得憑證到期時間 到期後發送通知 透過 Telegram Bot 發送訊息 讀取 yaml domain list 設定環境變數 CloudFunction 設定 CloudScheduler 排程設定 🎯Setup 1. 取得憑證到期時間 def get_ssl_cert_expiry_date(domain): """ 取得 SSL 證書的過期日期。 參數: domain (str): 需要檢查SSL證書過期時間的域名。 返回: datetime: SSL證書的過期日期，如果獲取失敗則返回None。 """ # 建立SSL上下文，建立一個安全的“環境”來管理SSL設定和操作 ssl_context = ssl.create_default_context() # 包裝socket對象，將基礎的socket通訊轉變為加密通訊 conn = ssl_context.wrap_socket(socket.socket(socket.AF_INET), server_hostname=domain) # 設定連接的超時時間為 3 秒，防止長時間等待 conn.settimeout(3.0) try: # 通過加密的連線嘗試連接到服務器的443端口（HTTPS） conn.connect((domain, 443)) # 取得服務器的SSL證書訊息 ssl_info = conn.getpeercert() # 解析證書中的過期時間 expire_date = datetime....</p></div><footer class=entry-footer><span title="2024-04-07 19:40:00 +0800 CST">2024-04-07</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;669 words&nbsp;·&nbsp;Alan</footer></div><figure class=entry-cover><img loading=lazy src=https://sz9751210.github.io/assets/monitor-ssl/cover.png alt></figure><a class=entry-link aria-label="post link to 自動化SSL憑證監控與到期通知系統" href=https://sz9751210.github.io/posts/monitor-ssl/></a></article><article class=post-entry><div class=post-info><header class=entry-header><h2>Kubernetes HPA：自動化應用擴展的藝術</h2></header><div class=entry-content><p>引言 在當今的技術世界中，Kubernetes 已成為容器化應用的領導平台。作為一個高效的容器編排系統，它不僅管理著容器的部署和擴展，還提供了必要的自動化支持，以保證應用的高可用性和性能。在這個框架中，自動擴展功能起著至關重要的作用，特別是在面對不斷變化的負載和需求時。
隨著企業和開發者尋求更靈活、更高效的資源管理方式，Kubernetes Horizontal Pod Autoscaler (HPA) 應運而生。HPA 是 Kubernetes 內建的一項機能，旨在自動調整 Pod 的數量以滿足當前的性能需求。這不僅提高了資源的使用效率，也確保了應用的穩定運行，特別是在高流量或不可預測的使用模式下。
HPA 的核心價值在於其能夠基於實際的性能指標（如 CPU 利用率或自定義指標）動態調整 Pod 的數量。這種彈性的擴展機制意味著系統能夠自動應對突發流量，同時在需求降低時縮減資源，從而達到成本效益的最佳平衡。
Horizontal Pod Autoscaler (HPA) 簡介 定義 Kubernetes Horizontal Pod Autoscaler，簡稱 HPA，是一種在 Kubernetes 環境中自動調整 Pod 數量的機制。它根據指定的指標（如 CPU 利用率、記憶體使用量或自定義指標）動態增減 Pod 的數量，以應對應用的負載變化。
工作原理 當 HPA 被部署到 Kubernetes 集群時，它會定期（預設 15 秒）檢查所指定指標的當前值，來判斷是否需要擴展或縮減 Pod 的數量。當這些指標超過或低於預設的閾值時，HPA 會自動增加或減少 Pod 的數量，從而確保應用平穩運行。
主要特點 動態擴展：根據實時的系統負載進行擴展或縮減。 靈活配置：支持多種指標，包括標準指標和自定義指標。 成本效益：通過優化資源使用，減少不必要的開支。 HPA的運作機制 指標類型 CPU 利用率：最常用的自動擴展指標。 自定義指標：根據特定的業務需求或性能指標進行擴展。 決策過程 HPA 決策過程基於預定的指標和閾值。當指標超過或低於設定的閾值時，HPA 會觸發擴展或縮減的操作。
擴展策略 線性擴展：根據指標的增減比例進行擴展或縮減。 自定義策略：可以根據特定需求定制擴展策略。 HPA的設置與配置 基本設置步驟 確定指標：選擇用於自動擴展的指標，如 CPU 利用率或自定義指標。 部署 Metrics Server：安裝 Metrics Server 以提供必要的性能指標數據。 創建 HPA 資源：通過 Kubernetes 的 YAML 文件定義 HPA 資源，指定目標 Pod 和相應的擴展指標。 以下是一個使用 YAML 定義的 HPA 實例： apiVersion: autoscaling/v2beta2 kind: HorizontalPodAutoscaler metadata: name: myapp-hpa spec: scaleTargetRef: apiVersion: apps/v1 kind: Deployment name: myapp minReplicas: 1 maxReplicas: 10 metrics: - type: Resource resource: name: cpu target: type: Utilization averageUtilization: 50 在這個例子中，如果 myapp 的平均 CPU 使用率超過 50%，HPA 會自動增加 Pod 的數量，最多到 10 個副本。當 CPU 使用率下降時，HPA 則會減少 Pod 的數量，但不會少於 1 個副本。...</p></div><footer class=entry-footer><span title="2024-01-03 16:09:00 +0800 CST">2024-01-03</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;236 words&nbsp;·&nbsp;Alan</footer></div><figure class=entry-cover><img loading=lazy src=https://sz9751210.github.io/assets/k8s-hpa/cover.png alt></figure><a class=entry-link aria-label="post link to Kubernetes HPA：自動化應用擴展的藝術" href=https://sz9751210.github.io/posts/k8s-hpa/></a></article><article class=post-entry><div class=post-info><header class=entry-header><h2>使用 Terraform 在 GCP 上建立 Cloud Armor</h2></header><div class=entry-content><p>👨‍💻 簡介 本文說明如何在 Google Cloud Platform (GCP) 上使用 Terraform 配置 Google Cloud Armor 安全策略。
前提條件 Google Cloud Platform (GCP) 帳號：確保有一個有效的 GCP 帳號。 安裝 Terraform：還沒安裝可以參考 Terraform 安裝指南。 基礎 Terraform 知識：熟悉基本的 Terraform 命令和概念，如果需要，可參考Terraform 入門指南 。 🎯 設定 步驟 1：建立 provider.tf 定義 GCP 提供者和所需的 Terraform 版本。
terraform { required_providers { google = { source = "hashicorp/google" version = "5.7.0" } } } provider "google" { project = "your-project-id" region = "asia-east1" } 步驟 2：建立 main....</p></div><footer class=entry-footer><span title="2023-12-09 19:11:00 +0800 CST">2023-12-09</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;516 words&nbsp;·&nbsp;Alan</footer></div><figure class=entry-cover><img loading=lazy src=https://sz9751210.github.io/assets/tf-cloud-armor/cover.png alt></figure><a class=entry-link aria-label="post link to 使用 Terraform 在 GCP 上建立 Cloud Armor" href=https://sz9751210.github.io/posts/tf-cloud-armor/></a></article><article class=post-entry><div class=post-info><header class=entry-header><h2>使用 Terraform 在 GCP 上建立外部和內部的全球 IP 地址</h2></header><div class=entry-content><p>👨‍💻簡介 這篇文章將會說明如何快速在 Google Cloud Platform 上使用 Terraform 建立外部與內部的全球 IP 。
前提條件 Google Cloud Platform (GCP) 帳號: 確保有一個有效的 GCP 帳號。 安裝Terraform: 還沒安裝可以參考 Terraform 安裝指南 。 基礎 Terraform 知識: 瞭解基本的 Terraform 命令和概念，如果需要，可參考 Terraform 入門指南。 🎯setup 步驟 1：建立 provider.tf 定義GCP Provider 和所需的 Terraform 版本。
terraform { required_providers { google = { source = "hashicorp/google" version = "5.7.0" } } } provider "google" { project = "project-id" region = "asia-east1" } 步驟 2：建立 main.tf 在此檔案中定義全球 IP 地址資源。...</p></div><footer class=entry-footer><span title="2023-11-28 19:42:00 +0800 CST">2023-11-28</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;456 words&nbsp;·&nbsp;Alan</footer></div><figure class=entry-cover><img loading=lazy src=https://sz9751210.github.io/assets/tf-global-ip/cover.png alt></figure><a class=entry-link aria-label="post link to 使用 Terraform 在 GCP 上建立外部和內部的全球 IP 地址" href=https://sz9751210.github.io/posts/tf-global-ip/></a></article><article class=post-entry><div class=post-info><header class=entry-header><h2>使用 Terraform 在 GCP 上建立外部和內部的區域 IP 地址</h2></header><div class=entry-content><p>👨‍💻 簡介 這篇文章將會說明如何快速在 Google Cloud Platform 上使用 Terraform 建立外部和內部的區域 IP 。
前提條件 Google Cloud Platform (GCP) 帳號: 確保有一個有效的 GCP 帳號。 安裝 Terraform: 還沒安裝可以參考 Terraform 安裝指南 。 基礎 Terraform 知識: 瞭解基本的 Terraform 命令和概念，如果需要，可參考 Terraform 入門指南。 🎯setup 1：建立 provider.tf 定義 GCP Provider 和所需的 Terraform 版本。
terraform { required_providers { google = { source = "hashicorp/google" version = "5.7.0" } } } provider "google" { project = "project-id" region = "asia-east1" } 2：建立 main....</p></div><footer class=entry-footer><span title="2023-11-25 19:42:00 +0800 CST">2023-11-25</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;182 words&nbsp;·&nbsp;Alan</footer></div><figure class=entry-cover><img loading=lazy src=https://sz9751210.github.io/assets/tf-region-ip/cover.png alt></figure><a class=entry-link aria-label="post link to 使用 Terraform 在 GCP 上建立外部和內部的區域 IP 地址" href=https://sz9751210.github.io/posts/tf-region-ip/></a></article><article class=post-entry><div class=post-info><header class=entry-header><h2>Kubernetes RBAC Overview：賦予安全與彈性的管理</h2></header><div class=entry-content><p>👨‍💻簡介 在當今的雲計算時代，容器化和微服務架構成為了重要趨勢。Kubernetes，作為領先的容器編排平台，提供了強大的功能來管理和部署應用程式。然而，隨著應用程式和用戶的增加，有效管理誰可以對 Kubernetes 集群執行何種操作變得至關重要。這裡，RBAC (Role-Based Access Control) 機制起到了關鍵作用。
🔰基礎介紹 什麼是 RBAC： RBAC 可以根據角色對用戶進行細粒度的權限管理。它基於三個主要概念：角色（Role）、角色綁定（RoleBinding）和主體（Subjects）。
角色 (Role) 和 ClusterRole：
角色 (Role)：定義了一組權限，這些權限表示對特定 Kubernetes 資源的操作，如建立、讀取、更新和刪除。 ClusterRole：與 Role 類似，但它適用於整個集群範圍，而不是單個命名空間。ClusterRole 可以用來賦予對集群級資源的訪問權限，或者跨所有命名空間的特定資源。 角色綁定 (RoleBinding) 和 ClusterRoleBinding：
角色綁定 (RoleBinding)：將角色的權限賦予給特定的主體。 ClusterRoleBinding：類似於 RoleBinding，但它將 ClusterRole 的權限賦予給整個集群的主體，而不是特定命名空間的主體。 主體 (Subjects)： 可以是用戶、群組或服務帳號。
為什麼要在 Kubernetes 中使用 RBAC？ 在 Kubernetes 中，RBAC 使得管理大型、多用戶的集群變得更為安全和方便。它確保了只有合適的用戶和服務能夠訪問關鍵的 Kubernetes 資源，從而降低了安全風險。
如何使用 RBAC 要開始使用 RBAC，首先要在 Kubernetes 集群中建立角色。例如，你可能有一個角色，只允許對 Pod 資源進行讀取操作。
kind: Role apiVersion: rbac.authorization.k8s.io/v1 metadata: namespace: default name: pod-reader rules: - apiGroups: [""] resources: ["pods"] verbs: ["get", "list", "watch"] --- kind: RoleBinding apiVersion: rbac....</p></div><footer class=entry-footer><span title="2023-11-25 14:14:00 +0800 CST">2023-11-25</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;206 words&nbsp;·&nbsp;Alan</footer></div><figure class=entry-cover><img loading=lazy src=https://sz9751210.github.io/assets/k8s-rbac/cover.png alt></figure><a class=entry-link aria-label="post link to Kubernetes RBAC Overview：賦予安全與彈性的管理" href=https://sz9751210.github.io/posts/k8s-rbac/></a></article><article class=post-entry><div class=post-info><header class=entry-header><h2>如何在GCP以及AWS設定 remote backend 管理 terraform 狀態檔</h2></header><div class=entry-content><p>👨‍💻簡介 terraform在每次執行terraform plan或terraform apply時，是如何知道應該要管理哪些資源？
其實就是透過在每次執行terraform時，將建立或要變更的資源都記錄在terraform.state這份狀態檔，預設檔案使用JSON格式。
假設建立一個google cloud storage的resource，tf設定檔如下：
resource "google_storage_bucket" "bucket" { name = "terraform-alan-test-bucket" location = "ASIA-EAST1" storage_class = "STANDARD" public_access_prevention = "enforced" force_destroy = true uniform_bucket_level_access = true } 建立後的terraform.tfstate的一小部分如下：
{ "version": 4, "terraform_version": "1.5.7", "serial": 3, "lineage": "abda0fda-b807-b8b3-0a36-8b0c2f92e3f5", "outputs": {}, "resources": [ { "module": "module.base-bucket", "mode": "managed", "type": "google_storage_bucket", "name": "bucket", "provider": "module.base-bucket.provider[\"registry.terraform.io/hashicorp/google\"]", "instances": [ { "schema_version": 1, "attributes": { "autoclass": [], "cors": [], "custom_placement_config": [], "default_event_based_hold": false, "effective_labels": {}, "encryption": [], "force_destroy": true, "id": "terraform-alan-test-bucket", "labels": null, "lifecycle_rule": [], "location": "ASIA-EAST1", "logging": [], "name": "terraform-alan-test-bucket", } } ] } ] } 可以看到id的屬性，當每次執行plan或是apply時，terraform就是拿這個屬性從本地terraform設定檔與雲上資源做比對。...</p></div><footer class=entry-footer><span title="2023-10-28 17:10:00 +0800 CST">2023-10-28</span>&nbsp;·&nbsp;6 min&nbsp;·&nbsp;1143 words&nbsp;·&nbsp;Alan</footer></div><figure class=entry-cover><img loading=lazy src=https://sz9751210.github.io/assets/terraform-backend/cover.png alt></figure><a class=entry-link aria-label="post link to 如何在GCP以及AWS設定 remote backend 管理 terraform 狀態檔" href=https://sz9751210.github.io/posts/terraform-backend/></a></article><article class=post-entry><div class=post-info><header class=entry-header><h2>如何用 Go 實作一個簡單的 PTT 爬蟲</h2></header><div class=entry-content><p>👨‍💻 簡介 最近想要透過小實作來撰寫筆記，達到做中學的效果，因此就來實作個小爬蟲順便結合前面學到的package做一個小複習。
建立HTTP Client Go的net/http package 提供了一個HTTP Client，用來發送各種HTTP請求。
http.Get：發送GET請求。 http.Post：發送POST請求。 http.NewRequest：建立一個新的HTTP請求。 語法如下：
// 發送GET請求 func http.Get(url string) (resp *http.Response, err error) // 發送POST請求 func http.Post(url, contentType string, body io.Reader) (resp *http.Response, err error) // 建立一個新的HTTP請求 func http.NewRequest(method, url string, body io.Reader) (*http.Request, error) 常見的Response可以使用以下欄位
type Response struct { Status string // e.g. "200 OK" StatusCode int // e.g. 200 Proto string // e.g. "HTTP/1.0" Header Header Body io.ReadCloser ... } 接著看一下io....</p></div><footer class=entry-footer><span title="2023-10-04 10:30:00 +0800 CST">2023-10-04</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;351 words&nbsp;·&nbsp;Alan</footer></div><figure class=entry-cover><img loading=lazy src=https://sz9751210.github.io/assets/go-ptt-crawler/cover.png alt></figure><a class=entry-link aria-label="post link to 如何用 Go 實作一個簡單的 PTT 爬蟲" href=https://sz9751210.github.io/posts/go-ptt-crawler/></a></article><footer class=page-footer><nav class=pagination><a class=next href=https://sz9751210.github.io/posts/page/2/>Next&nbsp;&nbsp;»</a></nav></footer></main><footer class=footer><span>&copy; 2024 <a href=https://sz9751210.github.io/>艾倫的程式之旅</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let detail=document.getElementsByClassName("details");details=[].slice.call(detail);for(let e=0;e<details.length;e++){let t=details[e];const n=t.getElementsByClassName("details-summary")[0];n&&n.addEventListener("click",()=>{t.classList.toggle("open")},!1)}</script><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>