<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Posts | 艾倫的程式之旅</title>
<meta name=keywords content><meta name=description content="Posts - 艾倫的程式之旅"><meta name=author content="Alan"><link rel=canonical href=https://sz9751210.github.io/posts/><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.css rel="preload stylesheet" as=style><link rel=icon href=https://sz9751210.github.io/assets/profile/avatar.png><link rel=icon type=image/png sizes=16x16 href=https://sz9751210.github.io/assets/profile/avatar.png><link rel=icon type=image/png sizes=32x32 href=https://sz9751210.github.io/assets/profile/avatar.png><link rel=apple-touch-icon href=https://sz9751210.github.io/assets/profile/avatar.png><link rel=mask-icon href=https://sz9751210.github.io/assets/profile/avatar.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://sz9751210.github.io/posts/index.xml><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://www.googletagmanager.com/gtag/js?id=G-4RLTP9J7DY"></script><script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-4RLTP9J7DY",{anonymize_ip:!1})}</script><meta property="og:title" content="Posts"><meta property="og:description" content="ExampleSite description"><meta property="og:type" content="website"><meta property="og:url" content="https://sz9751210.github.io/posts/"><meta property="og:image" content="https://sz9751210.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta property="og:site_name" content="ExampleSite"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://sz9751210.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="Posts"><meta name=twitter:description content="ExampleSite description"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://sz9751210.github.io/posts/"}]}</script><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-8214206744217848" crossorigin=anonymous></script></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://sz9751210.github.io/ accesskey=h title="Alan's BLOG (Alt + H)"><img src=https://sz9751210.github.io/assets/profile/avatar.png alt aria-label=logo height=35>Alan's BLOG</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://sz9751210.github.io/archives/ title=archives><span>archives</span></a></li><li><a href=https://sz9751210.github.io/posts/ title=posts><span class=active>posts</span></a></li><li><a href=https://sz9751210.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://sz9751210.github.io/about/ title=about><span>about</span></a></li><li><a href=https://sz9751210.github.io/quote/ title=quote><span>quote</span></a></li><li><a href=https://sz9751210.github.io/search/ title="search (Alt + /)" accesskey=/><span>search</span></a></li></ul></nav></header><main class=main><header class=page-header><div class=breadcrumbs><a href=https://sz9751210.github.io/>Home</a></div><h1>Posts
<a href=index.xml title=RSS aria-label=RSS><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" height="23"><path d="M4 11a9 9 0 019 9"/><path d="M4 4a16 16 0 0116 16"/><circle cx="5" cy="19" r="1"/></svg></a></h1></header><article class=post-entry><div class=post-info><header class=entry-header><h2>如何在 AWS 使用 SASL/SCRAM 建立 MSK</h2></header><div class=entry-content><p>👨‍💻簡介 Amazon Managed Streaming for Apache Kafka（Amazon MSK）是 Amazon 推出的完全代管、具有高可用以及安全的 Apache Kafka 服務。在這篇文章中，會使用 AWS 建立 MSK，並使用 SASL/SCRAM 的驗證方式來完成整個設定。
🎯setup 建立叢集 進入到 MSK 頁面，然後創建叢集 叢集設定 創建時選自訂建立，叢集類型我這邊使用的是已佈建，規格可以選最小的，版本使用 AWS 建議的，區域數量為3，達到高可用，最後叢集組態先使用預設即可 聯網 聯網的部分可以使用 AWS 幫你建立好的預設 VPC，我在前一步選擇三個可用區，因此會需要有三條不同區域的子網，安全群組也選擇預設的即可
安全 安全這邊選擇 SASL/SCRAM 身分驗證，加密靜態資料選擇使用 AWS 受管金鑰，待會會提到
SASL/SCRAM(Simple Authentication andSecurity Layer/ Salted Challenge Response Mechanism)，是一種使用帳號和密碼來完成驗證的方式，但它的前提是 Client 端與 Proxy 之間必須使用 TLS 加密。 監控和標籤 這裡監控只要選基本的即可 接著等到叢集建立完成後開始設定密鑰，建立叢集大概需要15分鐘
建立KMS Key AmazonMSK 使用 Amazon Secret Manager 來儲存 MSK 使用的帳號與密碼。在設定 Secret Manager 之前，必須先在 Amazon KMS(Key Management Service) 創建一個使用者託管的 Key。...</p></div><footer class=entry-footer><span title="2024-09-21 09:31:00 +0800 CST">2024-09-21</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;716 words&nbsp;·&nbsp;Alan</footer></div><figure class=entry-cover><img loading=lazy src=https://sz9751210.github.io/assets/aws-msk/cover.png alt></figure><a class=entry-link aria-label="post link to 如何在 AWS 使用 SASL/SCRAM 建立 MSK" href=https://sz9751210.github.io/posts/aws-msk/></a></article><article class=post-entry><div class=post-info><header class=entry-header><h2>MongoRestore 快速介紹</h2></header><div class=entry-content><p>👨‍💻簡介 上一篇介紹了 mongodump，拿來將我們資料庫的檔案備份到本地，這次則是要來介紹 mongorestore，將本地的資料還原到指定的資料庫。
🔰基礎介紹 什麼是 MongoRestore? mongorestore 是 MongoDB 提供的一個命令行工具，用於將先前使用 mongodump 產生的備份檔案恢復到資料庫中，支援 BSON 格式的資料恢復。
MongoRestore 主要功能 恢復資料庫： 可以將備份的整個資料庫恢復。
恢復集合(collection)： 可以指定恢復特定的集合。
從遠端伺服器恢復： 可以從遠端的 MongoDB 伺服器恢復資料。
Mongorestore 優缺點 優點
簡單易用：簡單的命令行操作即可完成資料還原。 支援大規模資料恢復：可以高效處理大型資料集。 支援各種平台：跨平台使用，不限作業系統。 缺點
相對耗時：對於大型資料庫，還原時間可能較長。 空間需求：恢復操作需要足夠的磁碟空間。 🎯setup 基本指令 恢復整個資料庫 語法：
mongorestore --db &lt;database_name> &lt;path_to_backup_directory> 範例：
mongorestore --db mydatabase /path/to/backup 恢復特定集合(collection) 語法：
mongorestore \ --db &lt;database_name> \ --collection &lt;collection_name> &lt;path_to_collection_backup> 範例：
mongorestore \ --db mydatabase \ --collection mycollection /path/to/backup/mycollection.bson 恢復到特定目錄 語法：
mongorestore --db &lt;database_name> --dir &lt;path_to_backup_directory> 範例：...</p></div><footer class=entry-footer><span title="2024-09-15 16:09:00 +0800 CST">2024-09-15</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;164 words&nbsp;·&nbsp;Alan</footer></div><figure class=entry-cover><img loading=lazy src=https://sz9751210.github.io/assets/mongorestore/cover.png alt></figure><a class=entry-link aria-label="post link to MongoRestore 快速介紹" href=https://sz9751210.github.io/posts/mongorestore/></a></article><article class=post-entry><div class=post-info><header class=entry-header><h2>快速了解 mongodump：MongoDB 資料庫備份必知工具</h2></header><div class=entry-content><p>👨‍💻簡介 在資料庫管理和系統維護中，備份是非常重要的一環。對於使用 MongoDB 的開發者和資料庫管理員來說，mongodump 是一個非常實用的命令行工具，能夠快速且輕鬆地完成資料庫的備份和恢復。無論是進行資料遷移、系統升級，還是面對突發的故障，mongodump 都能提供穩定的資料保護。這篇文章會簡單介紹一下 mongodump 的基本概念、怎麼使用，以及它的優缺點，讓你能夠更全面地了解這個工具，為你的資料庫管理增添一份安全保障。
🔰基礎介紹 什麼是 mongodump ? mongodump 是 MongoDB 提供的一個命令行工具，用於備份資料庫資料。 它會將 MongoDB 資料庫中的資料導出成 BSON 格式的檔案，這些檔案可以用於後續的資料恢復或移轉。
mongodump 主要功能 mongodump 的主要用途是資料備份與恢復。開發者或資料庫管理員可以使用 mongodump 來建立資料庫的快照，確保在系統升級、遷移或故障時，能夠有完整的資料還原方案。
MongoDump 優缺點 優點 簡單易用：使用命令行即可輕鬆進行資料備份。 支援大規模資料：能夠高效處理大型資料庫。 可用於各種場景：無論是本地還是遠端資料庫都能支援。 支援跨平台：可在各種操作系統上使用。 缺點 無法熱備份：備份過程中會影響資料庫性能，特別是在大型資料庫或高負載環境下。 備份格式相對龐大：BSON 格式備份檔案較大，可能占用較多的磁碟空間。 安全性問題：備份時需要妥善處理資料和憑證，避免資料洩露。 🎯setup 基本指令 導出整個資料庫 語法： mongodump --db &lt;database_name> 範例：
mongodump --db mydatabase 導出特定集合(collection) 語法： mongodump --db &lt;database_name> --collection 範例：
mongodump --db mydatabase --collection mycolletion 導出到特定目錄 語法： mongodump --out &lt;output_directory> 範例：
mongodump --db mydatabase --out /path/to/backup 導出遠端 MongoDB 伺服器 語法： 使用參數組合指令 mongodump --host &lt;mongo_host_or_ip> --port &lt;port> --db &lt;database_name> --username &lt;username> --password &lt;password> --authenticationDatabase &lt;auth_database> 使用 URI：...</p></div><footer class=entry-footer><span title="2024-09-08 19:47:00 +0800 CST">2024-09-08</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;192 words&nbsp;·&nbsp;Alan</footer></div><figure class=entry-cover><img loading=lazy src=https://sz9751210.github.io/assets/mongodump/cover.png alt></figure><a class=entry-link aria-label="post link to 快速了解 mongodump：MongoDB 資料庫備份必知工具" href=https://sz9751210.github.io/posts/mongodump/></a></article><article class=post-entry><div class=post-info><header class=entry-header><h2>Telegram 憑證監控機器人實作 EP5 - 代碼優化</h2></header><div class=entry-content><p>👨‍💻 簡介 在這篇文章中，我們將對 Telegram 憑證監控機器人的代碼進行優化。我們會新增一些簡單的指令，並且將部分變數改為從 yaml 檔案中讀取，而不是直接寫死在程式碼中。這些改進目的是提高可讀性和可維護性。
🛠️ 使用工具 Python 3.9.6 MongoDB TG Bot 📝 功能需求 新增 TG 指令 show_cert_info 新增 TG 指令 help 調整參數讀取 🎯Setup 新增 TG 指令 show_cert_info 這裡會用到之前寫的 get_ssl_cert 函數，可以印出證書來看一下有什麼資訊：
{'subject': ((('countryName', 'US'),), (('stateOrProvinceName', 'California'),), (('localityName', 'San Francisco'),), (('organizationName', 'Wikimedia Foundation, Inc.'),), (('commonName', '*.wikipedia.org'),)), 'issuer': ((('countryName', 'US'),), (('organizationName', 'DigiCert Inc'),), (('commonName', 'DigiCert TLS Hybrid ECC SHA384 2020 CA1'),)), 'version': 3, 'serialNumber': '07419E39583A4C76CF1EA14347FA5F3A', 'notBefore': 'Oct 18 00:00:00 2023 GMT', 'notAfter': 'Oct 16 23:59:59 2024 GMT', 'subjectAltName': (('DNS', '*....</p></div><footer class=entry-footer><span title="2024-06-19 17:30:00 +0800 CST">2024-06-19</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;531 words&nbsp;·&nbsp;Alan</footer></div><figure class=entry-cover><img loading=lazy src=https://sz9751210.github.io/assets/tg-bot-ep5/cover.png alt></figure><a class=entry-link aria-label="post link to Telegram 憑證監控機器人實作 EP5 - 代碼優化" href=https://sz9751210.github.io/posts/tg-bot-ep5/></a></article><article class=post-entry><div class=post-info><header class=entry-header><h2>Telegram 憑證監控機器人實作 EP4 - 憑證資訊處理</h2></header><div class=entry-content><p>👨‍💻 簡介 前篇已經將 TG Bot 整合 MongoDB，現在要將一些函數修改，在對 DB 進行操作前，先對 domain 進行驗證操作。
🛠️ 使用工具 Python 3.9.6 MongoDB TG Bot 📝 功能需求 新增 domain 前檢查 domain 憑證 透過 TG Bot 檢查所有 domain 是否有過期 🎯Setup 新增 domain 前檢查 domain 憑證 之前在撰寫 CloudFunction 時有使用到 get_ssl_cert_expiry_date 函數，在這裡先對這個函數做一個簡單的修改，將驗證憑證是否有效以及取得過期時間拆成兩個函數：
def get_ssl_cert_info(domain, check_only=False): ssl_context = ssl.create_default_context() with ssl_context.wrap_socket(socket.socket(socket.AF_INET), server_hostname=domain) as conn: conn.settimeout(3.0) try: conn.connect((domain, 443)) if check_only: return True else: return conn.getpeercert() except Exception as e: print(f"無法獲取 {domain} 的 SSL，錯誤：{e}") return False if check_only else None def get_ssl_cert_expiry_date(cert): if cert is None: return None try: expire_date = datetime....</p></div><footer class=entry-footer><span title="2024-06-02 16:42:00 +0800 CST">2024-06-02</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;419 words&nbsp;·&nbsp;Alan</footer></div><figure class=entry-cover><img loading=lazy src=https://sz9751210.github.io/assets/tg-bot-ep4/cover.png alt></figure><a class=entry-link aria-label="post link to Telegram 憑證監控機器人實作 EP4 - 憑證資訊處理" href=https://sz9751210.github.io/posts/tg-bot-ep4/></a></article><article class=post-entry><div class=post-info><header class=entry-header><h2>Telegram 憑證監控機器人實作 EP3 - 整合 MongoDB</h2></header><div class=entry-content><p>👨‍💻 簡介 這一部分主要讓 TG Bot 可以接收指令，對 MongoDB 進行增刪改查，讓我能夠透過 TG Bot 來新增、修改、刪除 domain，這樣就能夠做到自動化管理，而且可以做到多環境的管理。
🛠️ 使用工具 Python 3.9.6 MongoDB TG Bot 📝 功能需求 透過 TG Bot 讀取 MongoDB 所有 domain 透過 TG Bot 讀取 MongoDB 特定 domain 透過 TG Bot 新增 Domain 到 MongoDB 透過 TG Bot 新增同一 env 底下多組 domain 到 MongoDB 透過 TG Bot 修改 MongoDB Domain 透過 TG Bot 刪除 MongoDB Domain 🎯Setup 透過 TG Bot 讀取 MongoDB 所有 domain 先將原本的 MongoDB 啟動起來，並放入值，接著來去呼叫 load_domain_envs_from_mongodb 這個 function...</p></div><footer class=entry-footer><span title="2024-05-24 10:08:00 +0800 CST">2024-05-24</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;533 words&nbsp;·&nbsp;Alan</footer></div><figure class=entry-cover><img loading=lazy src=https://sz9751210.github.io/assets/tg-bot-ep3/cover.png alt></figure><a class=entry-link aria-label="post link to Telegram 憑證監控機器人實作 EP3 - 整合 MongoDB" href=https://sz9751210.github.io/posts/tg-bot-ep3/></a></article><article class=post-entry><div class=post-info><header class=entry-header><h2>Telegram 憑證監控機器人實作 EP2 - 打造自己的 TG Bot</h2></header><div class=entry-content><p>👨‍💻 簡介 今天這篇主要是帶大家快速建立屬於自己的 Telegram bot，申請 bot 的部分我會附上網址，主要完成一些跟 Bot 的簡單回覆以及設定指令等等功能。
🛠️ 使用工具 Python 3.9.6 TG Bot 申請教學 📝 功能需求 輸入指令讓 TG Bot 回傳訊息 接受傳入參數並進行簡單回傳 設定 cronjob，固定時間回傳訊息 🎯Setup 要使用 TG Bot，可以使用 pyTelegramBotAPI 這個 Library，官網有簡單的範例可以讓我們快速上手。
輸入指令讓 TG Bot 回傳訊息 這個簡單的範例可以在你輸入 hello 時，做簡單的回傳：
import telebot TOKEN = "your-token" # 建立機器人 bot = telebot.TeleBot(TOKEN) # 設定一個指令處理器，當收到指令 /hello 時觸發。 @bot.message_handler(commands=['hello']) def hello_command(message): # 發送一條消息到發送 /hello 指令的聊天中 bot.send_message(message, "Someone has started me!") # 讓機器人不斷運行，等待並處理任何消息或指令。 bot.infinity_polling() 要建立指令都會需要設定 message_handler，並且需要傳入 message 參數。 這個參數代表了觸發該指令的 Telegram 消息對象，透過這個 message 對象，你可以訪問到發送指令的用戶資訊、消息內容、聊天資訊等重要資料。...</p></div><footer class=entry-footer><span title="2024-05-14 11:20:00 +0800 CST">2024-05-14</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;358 words&nbsp;·&nbsp;Alan</footer></div><figure class=entry-cover><img loading=lazy src=https://sz9751210.github.io/assets/tg-bot-ep2/cover.png alt></figure><a class=entry-link aria-label="post link to Telegram 憑證監控機器人實作 EP2 - 打造自己的 TG Bot" href=https://sz9751210.github.io/posts/tg-bot-ep2/></a></article><article class=post-entry><div class=post-info><header class=entry-header><h2>Telegram 憑證監控機器人實作 EP1 - 讀取 MongoDB Domain Info</h2></header><div class=entry-content><p>👨‍💻 簡介 上次做的憑證監控已經可以正常運作了，但這次希望能夠不從 yaml 讀取 domain info，而是從 MongoDB 進行讀取，方便未來的擴充性。
這次的重點是要透過 Python 連接 MongoDB，並且透過 Python 讀取 MongoDB，最後透過 Python 寫入 MongoDB。
🛠️ 使用工具 Python 3.9.6 MongoDB Mongoshell Docker Docker-Compose 📝 功能需求 建立 MongoDB docker-compose 透過 Python 連接 MongoDB 透過 Python 讀取 yaml 並寫入 MongoDB 透過 Python 傳入 env 以及 domain 寫入 MongoDB 透過 Python 讀取 MongoDB 透過 Python 修改 MongoDB 透過 Python 刪除 MongoDB 🎯Setup 建立 MongoDB docker-compose 要簡單使用 MongoDB 可以用 docker-compose 快速拉起： version: "3....</p></div><footer class=entry-footer><span title="2024-05-06 15:45:00 +0800 CST">2024-05-06</span>&nbsp;·&nbsp;5 min&nbsp;·&nbsp;953 words&nbsp;·&nbsp;Alan</footer></div><figure class=entry-cover><img loading=lazy src=https://sz9751210.github.io/assets/tg-bot-ep1/cover.png alt></figure><a class=entry-link aria-label="post link to Telegram 憑證監控機器人實作 EP1 - 讀取 MongoDB Domain Info" href=https://sz9751210.github.io/posts/tg-bot-ep1/></a></article><article class=post-entry><div class=post-info><header class=entry-header><h2>實現 CloudFlare DNS 解析：使用 Terraform 和 GCS 進行高效配置</h2></header><div class=entry-content><p>👨‍💻 簡介 之前透過 Terraform 建立 GCP Global IP，延續上一篇的文，我們要把 Global IP 在 CloudFlare 上做 DNS 解析綁定，使我們一般在瀏覽網頁時能夠輸入網址進行訪問。
🛠️ 使用工具 Terraform CloudFlare GCS 📝 功能需求 研究 Terraform 建立 CloudFlare DNS 解析 取得 GCS 上的 Terraform state file 並透過 terraform 建立 CloudFlare DNS 解析 模組化 🎯Setup 1. 研究 Terraform 建立 CloudFlare DNS 解析 查看 terraform cloudflare_record 官方文件 可以看到與 dns 的相關設定會使用這個 resource。 而要操作 CloudFlare 必須取得要調整的 Website zone id 與操作者的 api token 接下來開始撰寫 terraform 代碼
resource "cloudflare_record" "example" { zone_id = "your_zone_id" name = "terraform" type = "A" comment = "Managed by Terraform" value = "192....</p></div><footer class=entry-footer><span title="2024-04-23 13:19:00 +0800 CST">2024-04-23</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;517 words&nbsp;·&nbsp;Alan</footer></div><figure class=entry-cover><img loading=lazy src=https://sz9751210.github.io/assets/terraform-cloudflare/cover.png alt></figure><a class=entry-link aria-label="post link to 實現 CloudFlare DNS 解析：使用 Terraform 和 GCS 進行高效配置" href=https://sz9751210.github.io/posts/terraform-cloudflare/></a></article><article class=post-entry><div class=post-info><header class=entry-header><h2>自動化SSL憑證監控與到期通知系統</h2></header><div class=entry-content><p>👨‍💻簡介 最近因為憑證越來越多，需要監控什麼時候到期，當到期時發送到期通知，因此撰寫一個簡單的小程式來完成。
這次使用Python和Telegram Bot來監控SSL證書的到期時間並發送通知。並使用GCP工具，如CloudFunction和CloudScheduler做部署平台。
🛠️使用工具 Python 3.9 Telegram Bot(Webhook) CloudFunction CloudScheduler 📝功能需求 取得憑證到期時間 到期後發送通知 透過 Telegram Bot 發送訊息 讀取 yaml domain list 設定環境變數 CloudFunction 設定 CloudScheduler 排程設定 🎯Setup 1. 取得憑證到期時間 def get_ssl_cert_expiry_date(domain): """ 取得 SSL 證書的過期日期。 參數: domain (str): 需要檢查SSL證書過期時間的域名。 返回: datetime: SSL證書的過期日期，如果獲取失敗則返回None。 """ # 建立SSL上下文，建立一個安全的“環境”來管理SSL設定和操作 ssl_context = ssl.create_default_context() # 包裝socket對象，將基礎的socket通訊轉變為加密通訊 conn = ssl_context.wrap_socket(socket.socket(socket.AF_INET), server_hostname=domain) # 設定連接的超時時間為 3 秒，防止長時間等待 conn.settimeout(3.0) try: # 通過加密的連線嘗試連接到服務器的443端口（HTTPS） conn.connect((domain, 443)) # 取得服務器的SSL證書訊息 ssl_info = conn.getpeercert() # 解析證書中的過期時間 expire_date = datetime....</p></div><footer class=entry-footer><span title="2024-04-07 19:40:00 +0800 CST">2024-04-07</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;669 words&nbsp;·&nbsp;Alan</footer></div><figure class=entry-cover><img loading=lazy src=https://sz9751210.github.io/assets/monitor-ssl/cover.png alt></figure><a class=entry-link aria-label="post link to 自動化SSL憑證監控與到期通知系統" href=https://sz9751210.github.io/posts/monitor-ssl/></a></article><footer class=page-footer><nav class=pagination><a class=next href=https://sz9751210.github.io/posts/page/2/>Next&nbsp;&nbsp;»</a></nav></footer></main><footer class=footer><span>&copy; 2024 <a href=https://sz9751210.github.io/>艾倫的程式之旅</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let detail=document.getElementsByClassName("details");details=[].slice.call(detail);for(let e=0;e<details.length;e++){let t=details[e];const n=t.getElementsByClassName("details-summary")[0];n&&n.addEventListener("click",()=>{t.classList.toggle("open")},!1)}</script><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>