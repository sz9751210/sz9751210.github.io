<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Posts | 艾倫的程式之旅</title>
<meta name=keywords content><meta name=description content="Posts - 艾倫的程式之旅"><meta name=author content="Alan"><link rel=canonical href=https://sz9751210.github.io/posts/><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.css rel="preload stylesheet" as=style><link rel=icon href=https://sz9751210.github.io/assets/profile/avatar.png><link rel=icon type=image/png sizes=16x16 href=https://sz9751210.github.io/assets/profile/avatar.png><link rel=icon type=image/png sizes=32x32 href=https://sz9751210.github.io/assets/profile/avatar.png><link rel=apple-touch-icon href=https://sz9751210.github.io/assets/profile/avatar.png><link rel=mask-icon href=https://sz9751210.github.io/assets/profile/avatar.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://sz9751210.github.io/posts/index.xml><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://www.googletagmanager.com/gtag/js?id=G-4RLTP9J7DY"></script><script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-4RLTP9J7DY",{anonymize_ip:!1})}</script><meta property="og:title" content="Posts"><meta property="og:description" content="ExampleSite description"><meta property="og:type" content="website"><meta property="og:url" content="https://sz9751210.github.io/posts/"><meta property="og:image" content="https://sz9751210.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta property="og:site_name" content="ExampleSite"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://sz9751210.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="Posts"><meta name=twitter:description content="ExampleSite description"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://sz9751210.github.io/posts/"}]}</script><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-8214206744217848" crossorigin=anonymous></script></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://sz9751210.github.io/ accesskey=h title="Alan's BLOG (Alt + H)"><img src=https://sz9751210.github.io/assets/profile/avatar.png alt aria-label=logo height=35>Alan's BLOG</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://sz9751210.github.io/archives/ title=archives><span>archives</span></a></li><li><a href=https://sz9751210.github.io/posts/ title=posts><span class=active>posts</span></a></li><li><a href=https://sz9751210.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://sz9751210.github.io/about/ title=about><span>about</span></a></li><li><a href=https://sz9751210.github.io/quote/ title=quote><span>quote</span></a></li><li><a href=https://sz9751210.github.io/search/ title="search (Alt + /)" accesskey=/><span>search</span></a></li></ul></nav></header><main class=main><header class=page-header><div class=breadcrumbs><a href=https://sz9751210.github.io/>Home</a></div><h1>Posts
<a href=index.xml title=RSS aria-label=RSS><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" height="23"><path d="M4 11a9 9 0 019 9"/><path d="M4 4a16 16 0 0116 16"/><circle cx="5" cy="19" r="1"/></svg></a></h1></header><article class=post-entry><div class=post-info><header class=entry-header><h2>快速了解 mongodump：MongoDB 資料庫備份必知工具</h2></header><div class=entry-content><p>👨‍💻簡介 在資料庫管理和系統維護中，備份是非常重要的一環。對於使用 MongoDB 的開發者和資料庫管理員來說，mongodump 是一個非常實用的命令行工具，能夠快速且輕鬆地完成資料庫的備份和恢復。無論是進行資料遷移、系統升級，還是面對突發的故障，mongodump 都能提供穩定的資料保護。這篇文章會簡單介紹一下 mongodump 的基本概念、怎麼使用，以及它的優缺點，讓你能夠更全面地了解這個工具，為你的資料庫管理增添一份安全保障。
🔰基礎介紹 什麼是 mongodump ? mongodump 是 MongoDB 提供的一個命令行工具，用於備份資料庫資料。 它會將 MongoDB 資料庫中的資料導出成 BSON 格式的檔案，這些檔案可以用於後續的資料恢復或移轉。
mongodump 主要功能 mongodump 的主要用途是資料備份與恢復。開發者或資料庫管理員可以使用 mongodump 來建立資料庫的快照，確保在系統升級、遷移或故障時，能夠有完整的資料還原方案。
MongoDump 優缺點 優點 簡單易用：使用命令行即可輕鬆進行資料備份。 支援大規模資料：能夠高效處理大型資料庫。 可用於各種場景：無論是本地還是遠端資料庫都能支援。 支援跨平台：可在各種操作系統上使用。 缺點 無法熱備份：備份過程中會影響資料庫性能，特別是在大型資料庫或高負載環境下。 備份格式相對龐大：BSON 格式備份檔案較大，可能占用較多的磁碟空間。 安全性問題：備份時需要妥善處理資料和憑證，避免資料洩露。 🎯setup 基本指令 導出整個資料庫 語法： mongodump --db &lt;database_name> 範例：
mongodump --db mydatabase 導出特定集合(collection) 語法： mongodump --db &lt;database_name> --collection 範例：
mongodump --db mydatabase --collection mycolletion 導出到特定目錄 語法： mongodump --out &lt;output_directory> 範例：
mongodump --db mydatabase --out /path/to/backup 導出遠端 MongoDB 伺服器 語法： 使用參數組合指令 mongodump --host &lt;mongo_host_or_ip> --port &lt;port> --db &lt;database_name> --username &lt;username> --password &lt;password> --authenticationDatabase &lt;auth_database> 使用 URI：...</p></div><footer class=entry-footer><span title="2024-09-08 19:47:00 +0800 CST">2024-09-08</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;192 words&nbsp;·&nbsp;Alan</footer></div><figure class=entry-cover><img loading=lazy src=https://sz9751210.github.io/assets/mongodump/cover.png alt></figure><a class=entry-link aria-label="post link to 快速了解 mongodump：MongoDB 資料庫備份必知工具" href=https://sz9751210.github.io/posts/mongodump/></a></article><article class=post-entry><div class=post-info><header class=entry-header><h2>Telegram 憑證監控機器人實作 EP5 - 代碼優化</h2></header><div class=entry-content><p>👨‍💻 簡介 在這篇文章中，我們將對 Telegram 憑證監控機器人的代碼進行優化。我們會新增一些簡單的指令，並且將部分變數改為從 yaml 檔案中讀取，而不是直接寫死在程式碼中。這些改進目的是提高可讀性和可維護性。
🛠️ 使用工具 Python 3.9.6 MongoDB TG Bot 📝 功能需求 新增 TG 指令 show_cert_info 新增 TG 指令 help 調整參數讀取 🎯Setup 新增 TG 指令 show_cert_info 這裡會用到之前寫的 get_ssl_cert 函數，可以印出證書來看一下有什麼資訊：
{'subject': ((('countryName', 'US'),), (('stateOrProvinceName', 'California'),), (('localityName', 'San Francisco'),), (('organizationName', 'Wikimedia Foundation, Inc.'),), (('commonName', '*.wikipedia.org'),)), 'issuer': ((('countryName', 'US'),), (('organizationName', 'DigiCert Inc'),), (('commonName', 'DigiCert TLS Hybrid ECC SHA384 2020 CA1'),)), 'version': 3, 'serialNumber': '07419E39583A4C76CF1EA14347FA5F3A', 'notBefore': 'Oct 18 00:00:00 2023 GMT', 'notAfter': 'Oct 16 23:59:59 2024 GMT', 'subjectAltName': (('DNS', '*....</p></div><footer class=entry-footer><span title="2024-06-19 17:30:00 +0800 CST">2024-06-19</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;531 words&nbsp;·&nbsp;Alan</footer></div><figure class=entry-cover><img loading=lazy src=https://sz9751210.github.io/assets/tg-bot-ep5/cover.png alt></figure><a class=entry-link aria-label="post link to Telegram 憑證監控機器人實作 EP5 - 代碼優化" href=https://sz9751210.github.io/posts/tg-bot-ep5/></a></article><article class=post-entry><div class=post-info><header class=entry-header><h2>Telegram 憑證監控機器人實作 EP4 - 憑證資訊處理</h2></header><div class=entry-content><p>👨‍💻 簡介 前篇已經將 TG Bot 整合 MongoDB，現在要將一些函數修改，在對 DB 進行操作前，先對 domain 進行驗證操作。
🛠️ 使用工具 Python 3.9.6 MongoDB TG Bot 📝 功能需求 新增 domain 前檢查 domain 憑證 透過 TG Bot 檢查所有 domain 是否有過期 🎯Setup 新增 domain 前檢查 domain 憑證 之前在撰寫 CloudFunction 時有使用到 get_ssl_cert_expiry_date 函數，在這裡先對這個函數做一個簡單的修改，將驗證憑證是否有效以及取得過期時間拆成兩個函數：
def get_ssl_cert_info(domain, check_only=False): ssl_context = ssl.create_default_context() with ssl_context.wrap_socket(socket.socket(socket.AF_INET), server_hostname=domain) as conn: conn.settimeout(3.0) try: conn.connect((domain, 443)) if check_only: return True else: return conn.getpeercert() except Exception as e: print(f"無法獲取 {domain} 的 SSL，錯誤：{e}") return False if check_only else None def get_ssl_cert_expiry_date(cert): if cert is None: return None try: expire_date = datetime....</p></div><footer class=entry-footer><span title="2024-06-02 16:42:00 +0800 CST">2024-06-02</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;419 words&nbsp;·&nbsp;Alan</footer></div><figure class=entry-cover><img loading=lazy src=https://sz9751210.github.io/assets/tg-bot-ep4/cover.png alt></figure><a class=entry-link aria-label="post link to Telegram 憑證監控機器人實作 EP4 - 憑證資訊處理" href=https://sz9751210.github.io/posts/tg-bot-ep4/></a></article><article class=post-entry><div class=post-info><header class=entry-header><h2>Telegram 憑證監控機器人實作 EP3 - 整合 MongoDB</h2></header><div class=entry-content><p>👨‍💻 簡介 這一部分主要讓 TG Bot 可以接收指令，對 MongoDB 進行增刪改查，讓我能夠透過 TG Bot 來新增、修改、刪除 domain，這樣就能夠做到自動化管理，而且可以做到多環境的管理。
🛠️ 使用工具 Python 3.9.6 MongoDB TG Bot 📝 功能需求 透過 TG Bot 讀取 MongoDB 所有 domain 透過 TG Bot 讀取 MongoDB 特定 domain 透過 TG Bot 新增 Domain 到 MongoDB 透過 TG Bot 新增同一 env 底下多組 domain 到 MongoDB 透過 TG Bot 修改 MongoDB Domain 透過 TG Bot 刪除 MongoDB Domain 🎯Setup 透過 TG Bot 讀取 MongoDB 所有 domain 先將原本的 MongoDB 啟動起來，並放入值，接著來去呼叫 load_domain_envs_from_mongodb 這個 function...</p></div><footer class=entry-footer><span title="2024-05-24 10:08:00 +0800 CST">2024-05-24</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;533 words&nbsp;·&nbsp;Alan</footer></div><figure class=entry-cover><img loading=lazy src=https://sz9751210.github.io/assets/tg-bot-ep3/cover.png alt></figure><a class=entry-link aria-label="post link to Telegram 憑證監控機器人實作 EP3 - 整合 MongoDB" href=https://sz9751210.github.io/posts/tg-bot-ep3/></a></article><article class=post-entry><div class=post-info><header class=entry-header><h2>Telegram 憑證監控機器人實作 EP2 - 打造自己的 TG Bot</h2></header><div class=entry-content><p>👨‍💻 簡介 今天這篇主要是帶大家快速建立屬於自己的 Telegram bot，申請 bot 的部分我會附上網址，主要完成一些跟 Bot 的簡單回覆以及設定指令等等功能。
🛠️ 使用工具 Python 3.9.6 TG Bot 申請教學 📝 功能需求 輸入指令讓 TG Bot 回傳訊息 接受傳入參數並進行簡單回傳 設定 cronjob，固定時間回傳訊息 🎯Setup 要使用 TG Bot，可以使用 pyTelegramBotAPI 這個 Library，官網有簡單的範例可以讓我們快速上手。
輸入指令讓 TG Bot 回傳訊息 這個簡單的範例可以在你輸入 hello 時，做簡單的回傳：
import telebot TOKEN = "your-token" # 建立機器人 bot = telebot.TeleBot(TOKEN) # 設定一個指令處理器，當收到指令 /hello 時觸發。 @bot.message_handler(commands=['hello']) def hello_command(message): # 發送一條消息到發送 /hello 指令的聊天中 bot.send_message(message, "Someone has started me!") # 讓機器人不斷運行，等待並處理任何消息或指令。 bot.infinity_polling() 要建立指令都會需要設定 message_handler，並且需要傳入 message 參數。 這個參數代表了觸發該指令的 Telegram 消息對象，透過這個 message 對象，你可以訪問到發送指令的用戶資訊、消息內容、聊天資訊等重要資料。...</p></div><footer class=entry-footer><span title="2024-05-14 11:20:00 +0800 CST">2024-05-14</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;358 words&nbsp;·&nbsp;Alan</footer></div><figure class=entry-cover><img loading=lazy src=https://sz9751210.github.io/assets/tg-bot-ep2/cover.png alt></figure><a class=entry-link aria-label="post link to Telegram 憑證監控機器人實作 EP2 - 打造自己的 TG Bot" href=https://sz9751210.github.io/posts/tg-bot-ep2/></a></article><article class=post-entry><div class=post-info><header class=entry-header><h2>Telegram 憑證監控機器人實作 EP1 - 讀取 MongoDB Domain Info</h2></header><div class=entry-content><p>👨‍💻 簡介 上次做的憑證監控已經可以正常運作了，但這次希望能夠不從 yaml 讀取 domain info，而是從 MongoDB 進行讀取，方便未來的擴充性。
這次的重點是要透過 Python 連接 MongoDB，並且透過 Python 讀取 MongoDB，最後透過 Python 寫入 MongoDB。
🛠️ 使用工具 Python 3.9.6 MongoDB Mongoshell Docker Docker-Compose 📝 功能需求 建立 MongoDB docker-compose 透過 Python 連接 MongoDB 透過 Python 讀取 yaml 並寫入 MongoDB 透過 Python 傳入 env 以及 domain 寫入 MongoDB 透過 Python 讀取 MongoDB 透過 Python 修改 MongoDB 透過 Python 刪除 MongoDB 🎯Setup 建立 MongoDB docker-compose 要簡單使用 MongoDB 可以用 docker-compose 快速拉起： version: "3....</p></div><footer class=entry-footer><span title="2024-05-06 15:45:00 +0800 CST">2024-05-06</span>&nbsp;·&nbsp;5 min&nbsp;·&nbsp;953 words&nbsp;·&nbsp;Alan</footer></div><figure class=entry-cover><img loading=lazy src=https://sz9751210.github.io/assets/tg-bot-ep1/cover.png alt></figure><a class=entry-link aria-label="post link to Telegram 憑證監控機器人實作 EP1 - 讀取 MongoDB Domain Info" href=https://sz9751210.github.io/posts/tg-bot-ep1/></a></article><article class=post-entry><div class=post-info><header class=entry-header><h2>實現 CloudFlare DNS 解析：使用 Terraform 和 GCS 進行高效配置</h2></header><div class=entry-content><p>👨‍💻 簡介 之前透過 Terraform 建立 GCP Global IP，延續上一篇的文，我們要把 Global IP 在 CloudFlare 上做 DNS 解析綁定，使我們一般在瀏覽網頁時能夠輸入網址進行訪問。
🛠️ 使用工具 Terraform CloudFlare GCS 📝 功能需求 研究 Terraform 建立 CloudFlare DNS 解析 取得 GCS 上的 Terraform state file 並透過 terraform 建立 CloudFlare DNS 解析 模組化 🎯Setup 1. 研究 Terraform 建立 CloudFlare DNS 解析 查看 terraform cloudflare_record 官方文件 可以看到與 dns 的相關設定會使用這個 resource。 而要操作 CloudFlare 必須取得要調整的 Website zone id 與操作者的 api token 接下來開始撰寫 terraform 代碼
resource "cloudflare_record" "example" { zone_id = "your_zone_id" name = "terraform" type = "A" comment = "Managed by Terraform" value = "192....</p></div><footer class=entry-footer><span title="2024-04-23 13:19:00 +0800 CST">2024-04-23</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;517 words&nbsp;·&nbsp;Alan</footer></div><figure class=entry-cover><img loading=lazy src=https://sz9751210.github.io/assets/terraform-cloudflare/cover.png alt></figure><a class=entry-link aria-label="post link to 實現 CloudFlare DNS 解析：使用 Terraform 和 GCS 進行高效配置" href=https://sz9751210.github.io/posts/terraform-cloudflare/></a></article><article class=post-entry><div class=post-info><header class=entry-header><h2>自動化SSL憑證監控與到期通知系統</h2></header><div class=entry-content><p>👨‍💻簡介 最近因為憑證越來越多，需要監控什麼時候到期，當到期時發送到期通知，因此撰寫一個簡單的小程式來完成。
這次使用Python和Telegram Bot來監控SSL證書的到期時間並發送通知。並使用GCP工具，如CloudFunction和CloudScheduler做部署平台。
🛠️使用工具 Python 3.9 Telegram Bot(Webhook) CloudFunction CloudScheduler 📝功能需求 取得憑證到期時間 到期後發送通知 透過 Telegram Bot 發送訊息 讀取 yaml domain list 設定環境變數 CloudFunction 設定 CloudScheduler 排程設定 🎯Setup 1. 取得憑證到期時間 def get_ssl_cert_expiry_date(domain): """ 取得 SSL 證書的過期日期。 參數: domain (str): 需要檢查SSL證書過期時間的域名。 返回: datetime: SSL證書的過期日期，如果獲取失敗則返回None。 """ # 建立SSL上下文，建立一個安全的“環境”來管理SSL設定和操作 ssl_context = ssl.create_default_context() # 包裝socket對象，將基礎的socket通訊轉變為加密通訊 conn = ssl_context.wrap_socket(socket.socket(socket.AF_INET), server_hostname=domain) # 設定連接的超時時間為 3 秒，防止長時間等待 conn.settimeout(3.0) try: # 通過加密的連線嘗試連接到服務器的443端口（HTTPS） conn.connect((domain, 443)) # 取得服務器的SSL證書訊息 ssl_info = conn.getpeercert() # 解析證書中的過期時間 expire_date = datetime....</p></div><footer class=entry-footer><span title="2024-04-07 19:40:00 +0800 CST">2024-04-07</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;669 words&nbsp;·&nbsp;Alan</footer></div><figure class=entry-cover><img loading=lazy src=https://sz9751210.github.io/assets/monitor-ssl/cover.png alt></figure><a class=entry-link aria-label="post link to 自動化SSL憑證監控與到期通知系統" href=https://sz9751210.github.io/posts/monitor-ssl/></a></article><article class=post-entry><div class=post-info><header class=entry-header><h2>Kubernetes HPA：自動化應用擴展的藝術</h2></header><div class=entry-content><p>引言 在當今的技術世界中，Kubernetes 已成為容器化應用的領導平台。作為一個高效的容器編排系統，它不僅管理著容器的部署和擴展，還提供了必要的自動化支持，以保證應用的高可用性和性能。在這個框架中，自動擴展功能起著至關重要的作用，特別是在面對不斷變化的負載和需求時。
隨著企業和開發者尋求更靈活、更高效的資源管理方式，Kubernetes Horizontal Pod Autoscaler (HPA) 應運而生。HPA 是 Kubernetes 內建的一項機能，旨在自動調整 Pod 的數量以滿足當前的性能需求。這不僅提高了資源的使用效率，也確保了應用的穩定運行，特別是在高流量或不可預測的使用模式下。
HPA 的核心價值在於其能夠基於實際的性能指標（如 CPU 利用率或自定義指標）動態調整 Pod 的數量。這種彈性的擴展機制意味著系統能夠自動應對突發流量，同時在需求降低時縮減資源，從而達到成本效益的最佳平衡。
Horizontal Pod Autoscaler (HPA) 簡介 定義 Kubernetes Horizontal Pod Autoscaler，簡稱 HPA，是一種在 Kubernetes 環境中自動調整 Pod 數量的機制。它根據指定的指標（如 CPU 利用率、記憶體使用量或自定義指標）動態增減 Pod 的數量，以應對應用的負載變化。
工作原理 當 HPA 被部署到 Kubernetes 集群時，它會定期（預設 15 秒）檢查所指定指標的當前值，來判斷是否需要擴展或縮減 Pod 的數量。當這些指標超過或低於預設的閾值時，HPA 會自動增加或減少 Pod 的數量，從而確保應用平穩運行。
主要特點 動態擴展：根據實時的系統負載進行擴展或縮減。 靈活配置：支持多種指標，包括標準指標和自定義指標。 成本效益：通過優化資源使用，減少不必要的開支。 HPA的運作機制 指標類型 CPU 利用率：最常用的自動擴展指標。 自定義指標：根據特定的業務需求或性能指標進行擴展。 決策過程 HPA 決策過程基於預定的指標和閾值。當指標超過或低於設定的閾值時，HPA 會觸發擴展或縮減的操作。
擴展策略 線性擴展：根據指標的增減比例進行擴展或縮減。 自定義策略：可以根據特定需求定制擴展策略。 HPA的設置與配置 基本設置步驟 確定指標：選擇用於自動擴展的指標，如 CPU 利用率或自定義指標。 部署 Metrics Server：安裝 Metrics Server 以提供必要的性能指標數據。 創建 HPA 資源：通過 Kubernetes 的 YAML 文件定義 HPA 資源，指定目標 Pod 和相應的擴展指標。 以下是一個使用 YAML 定義的 HPA 實例： apiVersion: autoscaling/v2beta2 kind: HorizontalPodAutoscaler metadata: name: myapp-hpa spec: scaleTargetRef: apiVersion: apps/v1 kind: Deployment name: myapp minReplicas: 1 maxReplicas: 10 metrics: - type: Resource resource: name: cpu target: type: Utilization averageUtilization: 50 在這個例子中，如果 myapp 的平均 CPU 使用率超過 50%，HPA 會自動增加 Pod 的數量，最多到 10 個副本。當 CPU 使用率下降時，HPA 則會減少 Pod 的數量，但不會少於 1 個副本。...</p></div><footer class=entry-footer><span title="2024-01-03 16:09:00 +0800 CST">2024-01-03</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;236 words&nbsp;·&nbsp;Alan</footer></div><figure class=entry-cover><img loading=lazy src=https://sz9751210.github.io/assets/k8s-hpa/cover.png alt></figure><a class=entry-link aria-label="post link to Kubernetes HPA：自動化應用擴展的藝術" href=https://sz9751210.github.io/posts/k8s-hpa/></a></article><article class=post-entry><div class=post-info><header class=entry-header><h2>使用 Terraform 在 GCP 上建立 Cloud Armor</h2></header><div class=entry-content><p>👨‍💻 簡介 本文說明如何在 Google Cloud Platform (GCP) 上使用 Terraform 配置 Google Cloud Armor 安全策略。
前提條件 Google Cloud Platform (GCP) 帳號：確保有一個有效的 GCP 帳號。 安裝 Terraform：還沒安裝可以參考 Terraform 安裝指南。 基礎 Terraform 知識：熟悉基本的 Terraform 命令和概念，如果需要，可參考Terraform 入門指南 。 🎯 設定 步驟 1：建立 provider.tf 定義 GCP 提供者和所需的 Terraform 版本。
terraform { required_providers { google = { source = "hashicorp/google" version = "5.7.0" } } } provider "google" { project = "your-project-id" region = "asia-east1" } 步驟 2：建立 main....</p></div><footer class=entry-footer><span title="2023-12-09 19:11:00 +0800 CST">2023-12-09</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;516 words&nbsp;·&nbsp;Alan</footer></div><figure class=entry-cover><img loading=lazy src=https://sz9751210.github.io/assets/tf-cloud-armor/cover.png alt></figure><a class=entry-link aria-label="post link to 使用 Terraform 在 GCP 上建立 Cloud Armor" href=https://sz9751210.github.io/posts/tf-cloud-armor/></a></article><footer class=page-footer><nav class=pagination><a class=next href=https://sz9751210.github.io/posts/page/2/>Next&nbsp;&nbsp;»</a></nav></footer></main><footer class=footer><span>&copy; 2024 <a href=https://sz9751210.github.io/>艾倫的程式之旅</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let detail=document.getElementsByClassName("details");details=[].slice.call(detail);for(let e=0;e<details.length;e++){let t=details[e];const n=t.getElementsByClassName("details-summary")[0];n&&n.addEventListener("click",()=>{t.classList.toggle("open")},!1)}</script><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>