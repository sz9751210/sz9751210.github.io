<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Posts | 艾倫的程式之旅</title>
<meta name=keywords content><meta name=description content="Posts - 艾倫的程式之旅"><meta name=author content="Alan"><link rel=canonical href=https://sz9751210.github.io/posts/><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.css rel="preload stylesheet" as=style><link rel=icon href=https://sz9751210.github.io/assets/profile/avatar.png><link rel=icon type=image/png sizes=16x16 href=https://sz9751210.github.io/assets/profile/avatar.png><link rel=icon type=image/png sizes=32x32 href=https://sz9751210.github.io/assets/profile/avatar.png><link rel=apple-touch-icon href=https://sz9751210.github.io/assets/profile/avatar.png><link rel=mask-icon href=https://sz9751210.github.io/assets/profile/avatar.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://sz9751210.github.io/posts/index.xml><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://www.googletagmanager.com/gtag/js?id=G-4RLTP9J7DY"></script><script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-4RLTP9J7DY",{anonymize_ip:!1})}</script><meta property="og:title" content="Posts"><meta property="og:description" content="ExampleSite description"><meta property="og:type" content="website"><meta property="og:url" content="https://sz9751210.github.io/posts/"><meta property="og:image" content="https://sz9751210.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta property="og:site_name" content="ExampleSite"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://sz9751210.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="Posts"><meta name=twitter:description content="ExampleSite description"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://sz9751210.github.io/posts/"}]}</script><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-8214206744217848" crossorigin=anonymous></script></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://sz9751210.github.io/ accesskey=h title="Alan's BLOG (Alt + H)"><img src=https://sz9751210.github.io/assets/profile/avatar.png alt aria-label=logo height=35>Alan's BLOG</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://sz9751210.github.io/archives/ title=archives><span>archives</span></a></li><li><a href=https://sz9751210.github.io/posts/ title=posts><span class=active>posts</span></a></li><li><a href=https://sz9751210.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://sz9751210.github.io/about/ title=about><span>about</span></a></li><li><a href=https://sz9751210.github.io/quote/ title=quote><span>quote</span></a></li><li><a href=https://sz9751210.github.io/search/ title="search (Alt + /)" accesskey=/><span>search</span></a></li></ul></nav></header><main class=main><header class=page-header><div class=breadcrumbs><a href=https://sz9751210.github.io/>Home</a></div><h1>Posts
<a href=index.xml title=RSS aria-label=RSS><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" height="23"><path d="M4 11a9 9 0 019 9"/><path d="M4 4a16 16 0 0116 16"/><circle cx="5" cy="19" r="1"/></svg></a></h1></header><article class=post-entry><div class=post-info><header class=entry-header><h2>如何在 AWS 建立 IAM 驗證方式的 MSK</h2></header><div class=entry-content><p>👨‍💻簡介 上次介紹了使用 SASL/SCRAM 的驗證方式來完成整個設定，這次改成使用 IAM 的驗證方式，因為後續使用其他服務，像是連接器，並不能接受使用 SASL/SCRAM 驗證方式的 MSK，因此會需要改成 IAM 的驗證方式下去建立 MSK
🎯setup 建立叢集 進入到 [MSK 頁面](叢集 | MSK | ap-northeast-1 (amazon.com))，然後創建叢集 叢集設定 創建時選自訂建立，叢集類型我這邊使用的是已佈建，規格可以選最小的，版本使用 AWS 建議的，區域數量為3，達到高可用，最後叢集組態先使用預設即可
聯網 聯網的部分可以使用 AWS 幫你建立好的預設 VPC，我在前一步選擇三個可用區，因此會需要有三條不同區域的子網，安全群組也選擇預設的即可
安全 安全這邊選擇 IAM 角色型身份驗證，加密靜態資料選擇使用 AWS 受管金鑰
監控和標籤 這裡監控只要選基本的即可
接著等到叢集建立完成後開始設定密鑰，建立叢集大概需要15分鐘
建立 IAM Policy 叢集建立好後可以到屬性查看範例 Policy
這邊快速介紹一下權限用意，由上至下的區塊分別對應的是叢集、Topic、Group
叢集：
kafka-cluster:Connect：允許連接到 Kafka 叢集，確保 Client 端或服務可以與 Kafka 叢集進行通信。 kafka-cluster:AlterCluster：允許對叢集進行修改操作，比如設定更改、叢集拓撲結構修改等。 kafka-cluster:DescribeCluster：允許檢視 Kafka 叢集的設定和狀態，這可能包括叢集節點、分區等信息。 Topic：
kafka-cluster:*Topic*：允許與主題相關的所有操作，這裡使用通配符表示操作（例如，創建、刪除、列出、修改 Kafka Topic 等）。 kafka-cluster:WriteData：允許將資料寫入 Kafka Topic，這涉及生產者（Producer）將訊息發送到 Kafka。 kafka-cluster:ReadData：允許從 Kafka Topic 讀取資料，這涉及消費者（Consumer）從 Kafka 主題中接收訊息。 Group：...</p></div><footer class=entry-footer><span title="2024-10-03 17:43:00 +0800 CST">2024-10-03</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;282 words&nbsp;·&nbsp;Alan</footer></div><figure class=entry-cover><img loading=lazy src=https://sz9751210.github.io/assets/aws-msk-iam/cover.png alt></figure><a class=entry-link aria-label="post link to 如何在 AWS 建立 IAM 驗證方式的 MSK" href=https://sz9751210.github.io/posts/aws-msk-iam/></a></article><article class=post-entry><div class=post-info><header class=entry-header><h2>如何在 aws-cli 快速切換帳號</h2></header><div class=entry-content><p>👨‍💻簡介 在工作上如果有多組 AWS 環境，會需要快速切換進行操作，這篇簡單記錄一下如何快速方便的透過 aws-cli 切換帳號
💡解決辦法 使用 --profile 參數 在每次執行指令後面添加 --profile，指定要使用的 profile
aws s3 ls --profile lab 使用環境變數 AWS_PROFILE export AWS_PROFILE=lab 建立 shell function 直接在 .bashrc 或 .zshrc建立一個 shell function 來進行快速切換。 以 .bashrc 為例，將底下代碼添加到 .bashrc
change_aws_profile() { export AWS_PROFILE=$1 export AWS_DEFAULT_PROFILE=$1 echo "AWS profile switched to: $1" } 接著 reload
source ~/.bashrc 當要切換時只需要輸入對應的 profile 即可
change_aws_profile lab 📚Reference How to: Use multiple AWS accounts with the AWS-CLI - DEV Community</p></div><footer class=entry-footer><span title="2024-09-22 18:15:00 +0800 CST">2024-09-22</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;71 words&nbsp;·&nbsp;Alan</footer></div><figure class=entry-cover><img loading=lazy src=https://sz9751210.github.io/assets/aws-cli-change-account/cover.png alt></figure><a class=entry-link aria-label="post link to 如何在 aws-cli 快速切換帳號" href=https://sz9751210.github.io/posts/aws-cli-change-account/></a></article><article class=post-entry><div class=post-info><header class=entry-header><h2>如何在 AWS 使用 SASL/SCRAM 建立 MSK</h2></header><div class=entry-content><p>👨‍💻簡介 Amazon Managed Streaming for Apache Kafka（Amazon MSK）是 Amazon 推出的完全代管、具有高可用以及安全的 Apache Kafka 服務。在這篇文章中，會使用 AWS 建立 MSK，並使用 SASL/SCRAM 的驗證方式來完成整個設定。
🎯setup 建立叢集 進入到 MSK 頁面，然後創建叢集 叢集設定 創建時選自訂建立，叢集類型我這邊使用的是已佈建，規格可以選最小的，版本使用 AWS 建議的，區域數量為3，達到高可用，最後叢集組態先使用預設即可 聯網 聯網的部分可以使用 AWS 幫你建立好的預設 VPC，我在前一步選擇三個可用區，因此會需要有三條不同區域的子網，安全群組也選擇預設的即可
安全 安全這邊選擇 SASL/SCRAM 身分驗證，加密靜態資料選擇使用 AWS 受管金鑰，待會會提到
SASL/SCRAM(Simple Authentication andSecurity Layer/ Salted Challenge Response Mechanism)，是一種使用帳號和密碼來完成驗證的方式，但它的前提是 Client 端與 Proxy 之間必須使用 TLS 加密。
監控和標籤 這裡監控只要選基本的即可
接著等到叢集建立完成後開始設定密鑰，建立叢集大概需要15分鐘
建立KMS Key AmazonMSK 使用 Amazon Secret Manager 來儲存 MSK 使用的帳號與密碼。在設定 Secret Manager 之前，必須先在 Amazon KMS(Key Management Service) 創建一個使用者託管的 Key。...</p></div><footer class=entry-footer><span title="2024-09-21 09:31:00 +0800 CST">2024-09-21</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;716 words&nbsp;·&nbsp;Alan</footer></div><figure class=entry-cover><img loading=lazy src=https://sz9751210.github.io/assets/aws-msk/cover.png alt></figure><a class=entry-link aria-label="post link to 如何在 AWS 使用 SASL/SCRAM 建立 MSK" href=https://sz9751210.github.io/posts/aws-msk/></a></article><article class=post-entry><div class=post-info><header class=entry-header><h2>MongoRestore 快速介紹</h2></header><div class=entry-content><p>👨‍💻簡介 上一篇介紹了 mongodump，拿來將我們資料庫的檔案備份到本地，這次則是要來介紹 mongorestore，將本地的資料還原到指定的資料庫。
🔰基礎介紹 什麼是 MongoRestore? mongorestore 是 MongoDB 提供的一個命令行工具，用於將先前使用 mongodump 產生的備份檔案恢復到資料庫中，支援 BSON 格式的資料恢復。
MongoRestore 主要功能 恢復資料庫： 可以將備份的整個資料庫恢復。
恢復集合(collection)： 可以指定恢復特定的集合。
從遠端伺服器恢復： 可以從遠端的 MongoDB 伺服器恢復資料。
Mongorestore 優缺點 優點
簡單易用：簡單的命令行操作即可完成資料還原。 支援大規模資料恢復：可以高效處理大型資料集。 支援各種平台：跨平台使用，不限作業系統。 缺點
相對耗時：對於大型資料庫，還原時間可能較長。 空間需求：恢復操作需要足夠的磁碟空間。 🎯setup 基本指令 恢復整個資料庫 語法：
mongorestore --db &lt;database_name> &lt;path_to_backup_directory> 範例：
mongorestore --db mydatabase /path/to/backup 恢復特定集合(collection) 語法：
mongorestore \ --db &lt;database_name> \ --collection &lt;collection_name> &lt;path_to_collection_backup> 範例：
mongorestore \ --db mydatabase \ --collection mycollection /path/to/backup/mycollection.bson 恢復到特定目錄 語法：
mongorestore --db &lt;database_name> --dir &lt;path_to_backup_directory> 範例：...</p></div><footer class=entry-footer><span title="2024-09-15 16:09:00 +0800 CST">2024-09-15</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;164 words&nbsp;·&nbsp;Alan</footer></div><figure class=entry-cover><img loading=lazy src=https://sz9751210.github.io/assets/mongorestore/cover.png alt></figure><a class=entry-link aria-label="post link to MongoRestore 快速介紹" href=https://sz9751210.github.io/posts/mongorestore/></a></article><article class=post-entry><div class=post-info><header class=entry-header><h2>快速了解 mongodump：MongoDB 資料庫備份必知工具</h2></header><div class=entry-content><p>👨‍💻簡介 在資料庫管理和系統維護中，備份是非常重要的一環。對於使用 MongoDB 的開發者和資料庫管理員來說，mongodump 是一個非常實用的命令行工具，能夠快速且輕鬆地完成資料庫的備份和恢復。無論是進行資料遷移、系統升級，還是面對突發的故障，mongodump 都能提供穩定的資料保護。這篇文章會簡單介紹一下 mongodump 的基本概念、怎麼使用，以及它的優缺點，讓你能夠更全面地了解這個工具，為你的資料庫管理增添一份安全保障。
🔰基礎介紹 什麼是 mongodump ? mongodump 是 MongoDB 提供的一個命令行工具，用於備份資料庫資料。 它會將 MongoDB 資料庫中的資料導出成 BSON 格式的檔案，這些檔案可以用於後續的資料恢復或移轉。
mongodump 主要功能 mongodump 的主要用途是資料備份與恢復。開發者或資料庫管理員可以使用 mongodump 來建立資料庫的快照，確保在系統升級、遷移或故障時，能夠有完整的資料還原方案。
MongoDump 優缺點 優點 簡單易用：使用命令行即可輕鬆進行資料備份。 支援大規模資料：能夠高效處理大型資料庫。 可用於各種場景：無論是本地還是遠端資料庫都能支援。 支援跨平台：可在各種操作系統上使用。 缺點 無法熱備份：備份過程中會影響資料庫性能，特別是在大型資料庫或高負載環境下。 備份格式相對龐大：BSON 格式備份檔案較大，可能占用較多的磁碟空間。 安全性問題：備份時需要妥善處理資料和憑證，避免資料洩露。 🎯setup 基本指令 導出整個資料庫 語法： mongodump --db &lt;database_name> 範例：
mongodump --db mydatabase 導出特定集合(collection) 語法： mongodump --db &lt;database_name> --collection 範例：
mongodump --db mydatabase --collection mycolletion 導出到特定目錄 語法： mongodump --out &lt;output_directory> 範例：
mongodump --db mydatabase --out /path/to/backup 導出遠端 MongoDB 伺服器 語法： 使用參數組合指令 mongodump --host &lt;mongo_host_or_ip> --port &lt;port> --db &lt;database_name> --username &lt;username> --password &lt;password> --authenticationDatabase &lt;auth_database> 使用 URI：...</p></div><footer class=entry-footer><span title="2024-09-08 19:47:00 +0800 CST">2024-09-08</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;192 words&nbsp;·&nbsp;Alan</footer></div><figure class=entry-cover><img loading=lazy src=https://sz9751210.github.io/assets/mongodump/cover.png alt></figure><a class=entry-link aria-label="post link to 快速了解 mongodump：MongoDB 資料庫備份必知工具" href=https://sz9751210.github.io/posts/mongodump/></a></article><article class=post-entry><div class=post-info><header class=entry-header><h2>Telegram 憑證監控機器人實作 EP5 - 代碼優化</h2></header><div class=entry-content><p>👨‍💻 簡介 在這篇文章中，我們將對 Telegram 憑證監控機器人的代碼進行優化。我們會新增一些簡單的指令，並且將部分變數改為從 yaml 檔案中讀取，而不是直接寫死在程式碼中。這些改進目的是提高可讀性和可維護性。
🛠️ 使用工具 Python 3.9.6 MongoDB TG Bot 📝 功能需求 新增 TG 指令 show_cert_info 新增 TG 指令 help 調整參數讀取 🎯Setup 新增 TG 指令 show_cert_info 這裡會用到之前寫的 get_ssl_cert 函數，可以印出證書來看一下有什麼資訊：
{'subject': ((('countryName', 'US'),), (('stateOrProvinceName', 'California'),), (('localityName', 'San Francisco'),), (('organizationName', 'Wikimedia Foundation, Inc.'),), (('commonName', '*.wikipedia.org'),)), 'issuer': ((('countryName', 'US'),), (('organizationName', 'DigiCert Inc'),), (('commonName', 'DigiCert TLS Hybrid ECC SHA384 2020 CA1'),)), 'version': 3, 'serialNumber': '07419E39583A4C76CF1EA14347FA5F3A', 'notBefore': 'Oct 18 00:00:00 2023 GMT', 'notAfter': 'Oct 16 23:59:59 2024 GMT', 'subjectAltName': (('DNS', '*....</p></div><footer class=entry-footer><span title="2024-06-19 17:30:00 +0800 CST">2024-06-19</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;531 words&nbsp;·&nbsp;Alan</footer></div><figure class=entry-cover><img loading=lazy src=https://sz9751210.github.io/assets/tg-bot-ep5/cover.png alt></figure><a class=entry-link aria-label="post link to Telegram 憑證監控機器人實作 EP5 - 代碼優化" href=https://sz9751210.github.io/posts/tg-bot-ep5/></a></article><article class=post-entry><div class=post-info><header class=entry-header><h2>Telegram 憑證監控機器人實作 EP4 - 憑證資訊處理</h2></header><div class=entry-content><p>👨‍💻 簡介 前篇已經將 TG Bot 整合 MongoDB，現在要將一些函數修改，在對 DB 進行操作前，先對 domain 進行驗證操作。
🛠️ 使用工具 Python 3.9.6 MongoDB TG Bot 📝 功能需求 新增 domain 前檢查 domain 憑證 透過 TG Bot 檢查所有 domain 是否有過期 🎯Setup 新增 domain 前檢查 domain 憑證 之前在撰寫 CloudFunction 時有使用到 get_ssl_cert_expiry_date 函數，在這裡先對這個函數做一個簡單的修改，將驗證憑證是否有效以及取得過期時間拆成兩個函數：
def get_ssl_cert_info(domain, check_only=False): ssl_context = ssl.create_default_context() with ssl_context.wrap_socket(socket.socket(socket.AF_INET), server_hostname=domain) as conn: conn.settimeout(3.0) try: conn.connect((domain, 443)) if check_only: return True else: return conn.getpeercert() except Exception as e: print(f"無法獲取 {domain} 的 SSL，錯誤：{e}") return False if check_only else None def get_ssl_cert_expiry_date(cert): if cert is None: return None try: expire_date = datetime....</p></div><footer class=entry-footer><span title="2024-06-02 16:42:00 +0800 CST">2024-06-02</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;419 words&nbsp;·&nbsp;Alan</footer></div><figure class=entry-cover><img loading=lazy src=https://sz9751210.github.io/assets/tg-bot-ep4/cover.png alt></figure><a class=entry-link aria-label="post link to Telegram 憑證監控機器人實作 EP4 - 憑證資訊處理" href=https://sz9751210.github.io/posts/tg-bot-ep4/></a></article><article class=post-entry><div class=post-info><header class=entry-header><h2>Telegram 憑證監控機器人實作 EP3 - 整合 MongoDB</h2></header><div class=entry-content><p>👨‍💻 簡介 這一部分主要讓 TG Bot 可以接收指令，對 MongoDB 進行增刪改查，讓我能夠透過 TG Bot 來新增、修改、刪除 domain，這樣就能夠做到自動化管理，而且可以做到多環境的管理。
🛠️ 使用工具 Python 3.9.6 MongoDB TG Bot 📝 功能需求 透過 TG Bot 讀取 MongoDB 所有 domain 透過 TG Bot 讀取 MongoDB 特定 domain 透過 TG Bot 新增 Domain 到 MongoDB 透過 TG Bot 新增同一 env 底下多組 domain 到 MongoDB 透過 TG Bot 修改 MongoDB Domain 透過 TG Bot 刪除 MongoDB Domain 🎯Setup 透過 TG Bot 讀取 MongoDB 所有 domain 先將原本的 MongoDB 啟動起來，並放入值，接著來去呼叫 load_domain_envs_from_mongodb 這個 function...</p></div><footer class=entry-footer><span title="2024-05-24 10:08:00 +0800 CST">2024-05-24</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;533 words&nbsp;·&nbsp;Alan</footer></div><figure class=entry-cover><img loading=lazy src=https://sz9751210.github.io/assets/tg-bot-ep3/cover.png alt></figure><a class=entry-link aria-label="post link to Telegram 憑證監控機器人實作 EP3 - 整合 MongoDB" href=https://sz9751210.github.io/posts/tg-bot-ep3/></a></article><article class=post-entry><div class=post-info><header class=entry-header><h2>Telegram 憑證監控機器人實作 EP2 - 打造自己的 TG Bot</h2></header><div class=entry-content><p>👨‍💻 簡介 今天這篇主要是帶大家快速建立屬於自己的 Telegram bot，申請 bot 的部分我會附上網址，主要完成一些跟 Bot 的簡單回覆以及設定指令等等功能。
🛠️ 使用工具 Python 3.9.6 TG Bot 申請教學 📝 功能需求 輸入指令讓 TG Bot 回傳訊息 接受傳入參數並進行簡單回傳 設定 cronjob，固定時間回傳訊息 🎯Setup 要使用 TG Bot，可以使用 pyTelegramBotAPI 這個 Library，官網有簡單的範例可以讓我們快速上手。
輸入指令讓 TG Bot 回傳訊息 這個簡單的範例可以在你輸入 hello 時，做簡單的回傳：
import telebot TOKEN = "your-token" # 建立機器人 bot = telebot.TeleBot(TOKEN) # 設定一個指令處理器，當收到指令 /hello 時觸發。 @bot.message_handler(commands=['hello']) def hello_command(message): # 發送一條消息到發送 /hello 指令的聊天中 bot.send_message(message, "Someone has started me!") # 讓機器人不斷運行，等待並處理任何消息或指令。 bot.infinity_polling() 要建立指令都會需要設定 message_handler，並且需要傳入 message 參數。 這個參數代表了觸發該指令的 Telegram 消息對象，透過這個 message 對象，你可以訪問到發送指令的用戶資訊、消息內容、聊天資訊等重要資料。...</p></div><footer class=entry-footer><span title="2024-05-14 11:20:00 +0800 CST">2024-05-14</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;358 words&nbsp;·&nbsp;Alan</footer></div><figure class=entry-cover><img loading=lazy src=https://sz9751210.github.io/assets/tg-bot-ep2/cover.png alt></figure><a class=entry-link aria-label="post link to Telegram 憑證監控機器人實作 EP2 - 打造自己的 TG Bot" href=https://sz9751210.github.io/posts/tg-bot-ep2/></a></article><article class=post-entry><div class=post-info><header class=entry-header><h2>Telegram 憑證監控機器人實作 EP1 - 讀取 MongoDB Domain Info</h2></header><div class=entry-content><p>👨‍💻 簡介 上次做的憑證監控已經可以正常運作了，但這次希望能夠不從 yaml 讀取 domain info，而是從 MongoDB 進行讀取，方便未來的擴充性。
這次的重點是要透過 Python 連接 MongoDB，並且透過 Python 讀取 MongoDB，最後透過 Python 寫入 MongoDB。
🛠️ 使用工具 Python 3.9.6 MongoDB Mongoshell Docker Docker-Compose 📝 功能需求 建立 MongoDB docker-compose 透過 Python 連接 MongoDB 透過 Python 讀取 yaml 並寫入 MongoDB 透過 Python 傳入 env 以及 domain 寫入 MongoDB 透過 Python 讀取 MongoDB 透過 Python 修改 MongoDB 透過 Python 刪除 MongoDB 🎯Setup 建立 MongoDB docker-compose 要簡單使用 MongoDB 可以用 docker-compose 快速拉起： version: "3....</p></div><footer class=entry-footer><span title="2024-05-06 15:45:00 +0800 CST">2024-05-06</span>&nbsp;·&nbsp;5 min&nbsp;·&nbsp;953 words&nbsp;·&nbsp;Alan</footer></div><figure class=entry-cover><img loading=lazy src=https://sz9751210.github.io/assets/tg-bot-ep1/cover.png alt></figure><a class=entry-link aria-label="post link to Telegram 憑證監控機器人實作 EP1 - 讀取 MongoDB Domain Info" href=https://sz9751210.github.io/posts/tg-bot-ep1/></a></article><footer class=page-footer><nav class=pagination><a class=next href=https://sz9751210.github.io/posts/page/2/>Next&nbsp;&nbsp;»</a></nav></footer></main><footer class=footer><span>&copy; 2024 <a href=https://sz9751210.github.io/>艾倫的程式之旅</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let detail=document.getElementsByClassName("details");details=[].slice.call(detail);for(let e=0;e<details.length;e++){let t=details[e];const n=t.getElementsByClassName("details-summary")[0];n&&n.addEventListener("click",()=>{t.classList.toggle("open")},!1)}</script><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>