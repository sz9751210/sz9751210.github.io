<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Posts | 艾倫的程式之旅</title>
<meta name=keywords content><meta name=description content="Posts - 艾倫的程式之旅"><meta name=author content="Alan"><link rel=canonical href=https://sz9751210.github.io/posts/><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.css rel="preload stylesheet" as=style><link rel=icon href=https://sz9751210.github.io/assets/profile/avatar.png><link rel=icon type=image/png sizes=16x16 href=https://sz9751210.github.io/assets/profile/avatar.png><link rel=icon type=image/png sizes=32x32 href=https://sz9751210.github.io/assets/profile/avatar.png><link rel=apple-touch-icon href=https://sz9751210.github.io/assets/profile/avatar.png><link rel=mask-icon href=https://sz9751210.github.io/assets/profile/avatar.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://sz9751210.github.io/posts/index.xml><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://www.googletagmanager.com/gtag/js?id=G-4RLTP9J7DY"></script><script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-4RLTP9J7DY",{anonymize_ip:!1})}</script><meta property="og:title" content="Posts"><meta property="og:description" content="ExampleSite description"><meta property="og:type" content="website"><meta property="og:url" content="https://sz9751210.github.io/posts/"><meta property="og:image" content="https://sz9751210.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta property="og:site_name" content="ExampleSite"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://sz9751210.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="Posts"><meta name=twitter:description content="ExampleSite description"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://sz9751210.github.io/posts/"}]}</script><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-8214206744217848" crossorigin=anonymous></script></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://sz9751210.github.io/ accesskey=h title="Alan's BLOG (Alt + H)"><img src=https://sz9751210.github.io/assets/profile/avatar.png alt aria-label=logo height=35>Alan's BLOG</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://sz9751210.github.io/archives/ title=archives><span>archives</span></a></li><li><a href=https://sz9751210.github.io/posts/ title=posts><span class=active>posts</span></a></li><li><a href=https://sz9751210.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://sz9751210.github.io/about/ title=about><span>about</span></a></li><li><a href=https://sz9751210.github.io/quote/ title=quote><span>quote</span></a></li><li><a href=https://sz9751210.github.io/search/ title="search (Alt + /)" accesskey=/><span>search</span></a></li></ul></nav></header><main class=main><header class=page-header><div class=breadcrumbs><a href=https://sz9751210.github.io/>Home</a></div><h1>Posts
<a href=index.xml title=RSS aria-label=RSS><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" height="23"><path d="M4 11a9 9 0 019 9"/><path d="M4 4a16 16 0 0116 16"/><circle cx="5" cy="19" r="1"/></svg></a></h1></header><article class=post-entry><div class=post-info><header class=entry-header><h2>Reflect：Go 語言的鏡子</h2></header><div class=entry-content><p>👨‍💻簡介 在 Go 語言中，reflect package是用來檢查和操作變數的type、value和struct。常見用法有檢察 type、調用方法，以及修改變數的value。今天簡單介紹 reflect package的主要功能、使用方法和常見用法。
主要功能 reflect package 主要用來在運行時檢查和操作變數的type訊息。這對於需要在不確定type的情況下處理資料的情況非常有用。要使用reflect package，首先需要import它：
import "reflect" reflect package的主要功能包括：
Type reflect reflect 可以讓你取得變數的type訊息，方便我們在運行時進行type比較，檢查變數的type。下面是一些基本的type reflect操作：
reflect.TypeOf：取得變數的type。 reflect.ValueOf：取得變數的value。 reflect.Zero：建立一個zero value。 package main import ( "fmt" "reflect" ) func main() { var num int typ := reflect.TypeOf(num) val := reflect.ValueOf(num) zeroVal := reflect.Zero(typ) fmt.Printf("Type: %v\n", typ) // Type: int fmt.Printf("Value: %v\n", val) // Value: 0 fmt.Printf("Zero Value: %v\n", zeroVal) // Zero Value: 0 } Struct reflect reflect 可以讓你取得struct欄位的訊息，訪問struct欄位的value，以及修改struct欄位的value。...</p></div><footer class=entry-footer><span title="2023-09-15 10:00:00 +0800 CST">2023-09-15</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;602 words&nbsp;·&nbsp;Alan</footer></div><figure class=entry-cover><img loading=lazy src=https://sz9751210.github.io/assets/go-reflect/cover.png alt></figure><a class=entry-link aria-label="post link to Reflect：Go 語言的鏡子" href=https://sz9751210.github.io/posts/go-reflect/></a></article><article class=post-entry><div class=post-info><header class=entry-header><h2>Time：Go語言的時間處理利器</h2></header><div class=entry-content><p>👨‍💻簡介 要處理日期和時間，就必須知道這個Package -> time，Go提供了內建的timePackage。 今天主要介紹time的功能，包括時間操作、格式化等等，以及常見用法。
主要功能 timePackage的主要功能是處理時間和日期的操作，包括時間的表示、創建、格式化和計算。在Go中，時間通常以time.Time type表示，這個type包含了日期和時間的資訊。
導入Package import "time" 創建時間 使用time.Now()函數來獲取當前的時間。
package main import ( "fmt" "time" ) func main() { currentTime := time.Now() fmt.Println("Current Time:", currentTime) } 你還可以使用time.Date()函數來創建一個特定日期和時間的time.Time 物件。
package main import ( "fmt" "time" ) func main() { specificTime := time.Date(2023, time.September, 15, 12, 0, 0, 0, time.UTC) fmt.Println("Specific Time:", specificTime) } 時間格式化 timePackage有提供許多方法來格式化時間為字串。可以使用Format方法和指定的時間格式來實現。
package main import ( "fmt" "time" ) func main() { currentTime := time....</p></div><footer class=entry-footer><span title="2023-09-15 10:00:00 +0800 CST">2023-09-15</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;379 words&nbsp;·&nbsp;Alan</footer></div><figure class=entry-cover><img loading=lazy src=https://sz9751210.github.io/assets/go-time/cover.png alt></figure><a class=entry-link aria-label="post link to Time：Go語言的時間處理利器" href=https://sz9751210.github.io/posts/go-time/></a></article><article class=post-entry><div class=post-info><header class=entry-header><h2>Fmt：資料處理的好幫手</h2></header><div class=entry-content><p>👨‍💻簡介 要印出Hello World，就會碰到這個Package -> fmt，今天來簡單整理一下fmt的作用、格式化的控制與常見用法。
主要功能 fmt 套件的主要功能是處理格式化的輸出和輸入，包括資料格式處理、字串解析和數值轉換等功能。通常用來記錄訊息、檔案處理等等。fmt 套件中的函數可以主要分為兩大類：Print 和 Scan。
導入Package import "fmt" Print 函數系列 fmt.Print：將資料印到終端機。 fmt.Println：將資料印到終端機，並換行。 fmt.Printf：根據格式化參數將資料印到終端機。 fmt.Sprintf：格式化成字串，通常用在需要以字串形式處理格式化時會用到 fmt.Fprintf：格式化到文件，通常用來寫檔會用到 Print與Printf相比，差在不能印格式化輸出
Print與Println相比，差在ln多了一個換行
package main import ( "fmt" "os" ) func main() { name := "Alan" age := 30 fmt.Print("Name: ", name, " Age: ", age) // 沒有換行 fmt.Println("Name:", name, "Age:", age) // 有換行 fmt.Printf("Name: %s Age: %d\n", name, age) // 格式化印出 formatted := fmt.Sprintf("Name: %s, Age: %d", name, age) fmt....</p></div><footer class=entry-footer><span title="2023-09-14 15:44:00 +0800 CST">2023-09-14</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;498 words&nbsp;·&nbsp;Alan</footer></div><figure class=entry-cover><img loading=lazy src=https://sz9751210.github.io/assets/go-fmt/cover.png alt></figure><a class=entry-link aria-label="post link to Fmt：資料處理的好幫手" href=https://sz9751210.github.io/posts/go-fmt/></a></article><article class=post-entry><div class=post-info><header class=entry-header><h2>Go語言中Goroutine的等待方式</h2></header><div class=entry-content><p>👨‍💻簡介 昨天講到Goroutine的橋梁aka傳話筒 - Channel，那要怎麼知道對方有收到訊息，我的紙條有送到對方手上呢? 今天就是要來介紹幾種Goroutine的確定完成工作的幾種方式。
Goroutine 的等待方式 在Go語言中，等待Goroutine完成的方式有多種。
sync.WaitGroup sync.WaitGroup是Go語言中常見的一種等待方式，它允許我們等待一組Goroutine完成。
package main import ( "fmt" "sync" ) func worker(id int, wg *sync.WaitGroup) { defer wg.Done() // 表示Goroutine完成工作，減少WaitGroup計數 fmt.Printf("Worker %d 正在工作\n", id) } func main() { var wg sync.WaitGroup for i := 1; i &lt;= 3; i++ { wg.Add(1) // 增加WaitGroup數量 go worker(i, &amp;wg) // 啟動Goroutine，並將WaitGroup的指針傳遞給它 } wg.Wait() // 將主程式阻塞，直到所有Goroutines完成工作。 fmt.Println("所有工作完成") } 在上面的範例中，我們先創建了一個sync.WaitGroup的變數wg，並使用for循環去執行我們的goroutine，每次執行前都先將等待goroutine的數量+1，總共等待三個Goroutine完成工作。 接著使用 wg.Wait()將main函數先暫停一下，等所有goroutine都完成工作，wg的計數器為0，在繼續執行程式。 在 worker函數裡，會接收 wg的pointer，並在開頭使用defer wg.Done()在程式執行結束就將等待的goroutine數量-1，來確保goroutine會完成
Channel Channel是Go語言中用於通信的機制，也可以用於等待Goroutine完成。...</p></div><footer class=entry-footer><span title="2023-09-13 16:23:00 +0800 CST">2023-09-13</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;293 words&nbsp;·&nbsp;Alan</footer></div><figure class=entry-cover><img loading=lazy src=https://sz9751210.github.io/assets/go-waitgroup/cover.png alt></figure><a class=entry-link aria-label="post link to Go語言中Goroutine的等待方式" href=https://sz9751210.github.io/posts/go-waitgroup/></a></article><article class=post-entry><div class=post-info><header class=entry-header><h2>Channel：Go語言建立併發通訊的橋樑</h2></header><div class=entry-content><p>👨‍💻簡介 昨天講到Goroutine有稍微簡單介紹Channel，Channel是Go語言中極為重要的併發通訊機制，它就像是不同goroutines之間的話筒，允許它們安全地傳遞資料和信息。這個強大的工具使得Go語言在處理併發任務時非常優雅和高效。通過Channel，可以協調goroutines的操作，防止競爭條件，並實現高效的併發程式設計。
什麼是Channel？ Channel是Go語言中一個強大的併發原語言功能，用於在不同的goroutine之間傳遞資料。它們提供了一種通訊的機制，可以讓goroutines之間安全地交換信息，而不需要額外的互斥鎖或信號量。
可以把channel比喻成傳紙條，傳紙條可以是單向，也可以是雙向，單向可以想像類似以前傳紙條的中間人，他只接收和傳遞，紙條也有大小的限制，寫滿了就不能再繼續寫，並且需要等待對方將紙條進行回覆後你才能繼續。
建立和使用Channel 在Go中，可以使用內建的make函數來建立一個新的Channel。以下是使用 make函數建立整數類型的Channel
ch := make(chan int) 建立完後，就可以將資料發送到Channel中，然後在其他goroutine中接收它們。以下是一個簡單的發送和接收資料的例子：
func main() { ch := make(chan int) go func() { ch &lt;- 42 // 發送資料到Channel }() value := &lt;-ch // 從Channel接收資料 fmt.Println(value) // 輸出：42 } 這個例子中，我們建立了一個goroutine，它將數字42發送到Channel，然後主goroutine，也就是main函數，接收到這個數字。
關閉Channel 紙條用完會丟掉，Channel用完也是要關掉，您可能需要關閉Channel，以通知接收方不再有新的資料可用。要關閉Channel，可以使用close函數，如下所示：
close(ch) 接收方可以使用特殊的語法來檢查Channel是否已關閉：
value, ok := &lt;-ch if !ok { // Channel已經關閉 } 這可以防止接收方在Channel已關閉的情況下繼續等待。 並且已經關閉的Channel依然可以進行接收的操作，但不能再進行發送。
package main import ( "fmt" "time" ) func main() { ch := make(chan int) go func() { for i := 0; i &lt; 5; i++ { time....</p></div><footer class=entry-footer><span title="2023-09-12 16:09:00 +0800 CST">2023-09-12</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;460 words&nbsp;·&nbsp;Alan</footer></div><figure class=entry-cover><img loading=lazy src=https://sz9751210.github.io/assets/go-channel/cover.png alt></figure><a class=entry-link aria-label="post link to Channel：Go語言建立併發通訊的橋樑" href=https://sz9751210.github.io/posts/go-channel/></a></article><article class=post-entry><div class=post-info><header class=entry-header><h2>探索Goroutine：Go語言的併發魔法</h2></header><div class=entry-content><p>👨‍💻簡介 在日常生活中，如果能同時做很多事情，效率肯定大大提升，那麼在Go語言中，該如何做到呢，答案就是今天的主角Goroutine了，在Go語言中，讓併發變得簡單的強大工具，今天就是來給他一個快速介紹。
什麼是Goroutine？ 首先，讓我們以一個簡單的方式來解釋什麼是Goroutine。Goroutine是Go語言的一個特別的功能，它就像是小型的工作任務，可以讓我們同時處理很多事情，而不需要浪費太多電腦資源。可以把它想像成比傳統方式更聰明的方式來處理多項工作，而不會讓電腦變得超級忙碌。這種功能讓Go語言在處理大量同時執行的工作時變得非常強大。
如何創建和啟動Goroutine 要使用Goroutine很簡單，只需要創建一個函數，然後使用go關鍵字在要使用goroutine的函數前面就完成了。可以看以下範例：
package main import ( "fmt" ) func main() { go sayHello() // 主程式不會等待Goroutine完成 } func sayHello() { fmt.Println("Hello, Goroutine!") } 在這個例子中，我們使用go關鍵字啟動一個新的Goroutine，Goroutine執行了sayHello函數。但須注意，主程式main不會等待Goroutine完成，所以可能不會看到有印出任何東西來。
可以稍微讓main主程式睡一下，就可以看到輸出了
package main import ( "fmt" "time" ) func main() { go sayHello() time.Sleep(1) } func sayHello() { fmt.Println("Hello, Goroutine!") } Goroutine的執行過程 下面提供了一個簡單的小程式，在主程式裡有兩個goroutine，試著執行一下程式可以發現輸出是一段一段的，會是0跟1交錯印出，代表兩邊的goroutine會搶著印出，呈現競爭狀態
package main import ( "fmt" "time" ) func main() { go print1() go print2() time.Sleep(time.Second) } func print1() { for i := 0; i &lt; 100; i++ { fmt....</p></div><footer class=entry-footer><span title="2023-09-11 16:18:00 +0800 CST">2023-09-11</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;279 words&nbsp;·&nbsp;Alan</footer></div><figure class=entry-cover><img loading=lazy src=https://sz9751210.github.io/assets/go-goroutine/cover.png alt></figure><a class=entry-link aria-label="post link to 探索Goroutine：Go語言的併發魔法" href=https://sz9751210.github.io/posts/go-goroutine/></a></article><article class=post-entry><div class=post-info><header class=entry-header><h2>淺談Go中的Pointer和記憶體管理</h2></header><div class=entry-content><p>👨‍💻簡介 當我們在宣告變數時，電腦會為該變數在記憶體中分配一個位置，然後將這個變數值儲存在這個位置上，需要讀取或修改這個變數值時，電腦是透過記憶體位置來存取這個值。 今天來簡單介紹一下go的Pointer，他的特性以及常見用法。
什麼是Pointer？ Pointer是一種資料類型，用來儲存變數的記憶體地址。在Go中，我們可以通過使用 * 符號來宣告和操作Pointer。這允許我們直接訪問和修改變數的內容，而不僅僅是讀取或複製它們的值。
Pointer的特性、限制與常見用法 特性 Pointer的值和地址 每個變數都有一個記憶體地址，我們可以使用Pointer變數來儲存這個地址。讓我們看一個範例：
package main import "fmt" func main() { x := 42 var p *int // 宣告一個整數Pointer p = &amp;x // 將p指向x的地址 fmt.Println("x =", x) fmt.Println("p =", p) } 在這個例子中，我們創建了一個整數變數 x，並宣告了一個整數Pointer p，然後將 p 設為 x 的地址。現在，p 裡面存放的就是 x 的地址。
Pointer的初始化 Go中的Pointer可以通過 new 函數來初始化，這將為指定的類型分配記憶體並返回其地址。範例：
package main import "fmt" func main() { var p *int p = new(int) // 初始化一個整數Pointer *p = 123 // 將Pointer所指向的記憶體設置為123 fmt....</p></div><footer class=entry-footer><span title="2023-09-08 15:50:00 +0800 CST">2023-09-08</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;403 words&nbsp;·&nbsp;Alan</footer></div><figure class=entry-cover><img loading=lazy src=https://sz9751210.github.io/assets/go-pointer/cover.png alt></figure><a class=entry-link aria-label="post link to 淺談Go中的Pointer和記憶體管理" href=https://sz9751210.github.io/posts/go-pointer/></a></article><article class=post-entry><div class=post-info><header class=entry-header><h2>錯誤處理的精髓：快速了解Go語言的 error、panic和recover</h2></header><div class=entry-content><p>👨‍💻簡介 在軟體開發中，錯誤無所不在。無論是網路請求失敗、檔案不存在，還是數學計算錯誤，處理錯誤是任何開發者的日常工作，系統的穩定度基本取決於對於錯誤處理是否全面，好的錯誤處理也可以產生適當的錯誤訊息，讓 Debug 更加容易。在Go語言中，有一些獨特的功能在處理錯誤和資源管理方面非常有用。，其中包括error、panic和recover。今天就來介紹這三個關鍵字與錯誤處理的簡單用法。
Error 什麼是Error? 在Go中，Error是一個擁有error interface的類型，可以看到他只有一個方法，該方法主要用來描述一個錯誤的字串。
type error interface { Error() string } 如何產生錯誤訊息 errors.New() 使用方式很簡單，在裡面放入要顯示的錯誤訊息 package main import ( "errors" "fmt" ) func main() { err := errors.New("This is a custom error message") fmt.Println(err.Error()) // output：This is a custom error message } fmt.Errorf() 主要用在格式化錯誤訊息的情況下 package main import ( "fmt" ) func main() { name := "John" err := fmt.Errorf("Hello, %s! This is a custom error message", name) fmt....</p></div><footer class=entry-footer><span title="2023-09-07 11:30:00 +0800 CST">2023-09-07</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;559 words&nbsp;·&nbsp;Alan</footer></div><figure class=entry-cover><img loading=lazy src=https://sz9751210.github.io/assets/go-error/cover.png alt></figure><a class=entry-link aria-label="post link to 錯誤處理的精髓：快速了解Go語言的 error、panic和recover" href=https://sz9751210.github.io/posts/go-error/></a></article><article class=post-entry><div class=post-info><header class=entry-header><h2>Go語言的defer：確保後置操作的執行</h2></header><div class=entry-content><p>👨‍💻簡介 當我們在寫程式時，有時候會需要在程式結束時關閉某些資源，而defer這個關鍵字，可以讓你輕鬆的實現，下面來簡單介紹一下defer以及常用的範例。，它為程式設計師提供了一種簡單而強大的工具，用於管理資源和確保程式的正確執行。在本篇文章中，我們將深入探討Go語言中的defer，並提供一些實際的程式碼範例，以幫助你理解它的工作原理以及如何運用它來提高程式的可讀性和可維護性。
什麼是defer？ defer是一個關鍵字，用來延遲函數的執行，直到包含它的函數執行完畢。這代表你可以在函數中的任何位置使用defer來安排某個操作，並確保它將在函數返回之前執行。defer通常用於執行一些清理或資源回收的操作。
package main import "fmt" func main() { defer fmt.Println("World") fmt.Print("Hello, ") } 使用方式也很簡單，在要執行的函數前面加上defer就完成了，所以上面的範例會印出 Hello World
Defer的特性 延遲執行：defer 語句允許你安排一段程式碼，使它在包含它的函數返回之前執行，無論函數是否正常返回或出現錯誤。
堆疊特性：多個 defer 語句按照後進先出（LIFO）的順序執行，這意味著最後一個被延遲的語句會最先執行。
package main import "fmt" func main() { fmt.Println("Start") defer fmt.Println("Deferred 1") defer fmt.Println("Deferred 2") fmt.Println("End") } 根據defer特性的後進先出，輸出會是下面這個樣子
Start End Deferred 2 Deferred 1 Defer的限制 延遲的函數必須是無參數函數：你只能延遲無參數的函數調用，因為 defer 不允許傳遞參數。
順序性：defer 語句的效果在函數內是有限定範圍的，它只在包含它的函數範圍內有效，無法跨函數使用。
常見用法 資源清理 最常見的用途之一是在函數返回前關閉文件、釋放鎖、關閉資料庫連接等，以確保資源被正確釋放。
func readFile(filename string) (string, error) { file, err := os.Open(filename) if err != nil { return "", err } defer file....</p></div><footer class=entry-footer><span title="2023-09-06 20:30:00 +0800 CST">2023-09-06</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;135 words&nbsp;·&nbsp;Alan</footer></div><figure class=entry-cover><img loading=lazy src=https://sz9751210.github.io/assets/go-defer/cover.png alt></figure><a class=entry-link aria-label="post link to Go語言的defer：確保後置操作的執行" href=https://sz9751210.github.io/posts/go-defer/></a></article><article class=post-entry><div class=post-info><header class=entry-header><h2>保證型別安全：使用Go的Type Assertions避免型別錯誤</h2></header><div class=entry-content><p>👨‍💻簡介 在Go中，假如我要判斷一個資料類型是甚麼，該怎麼做呢? Golang有一個功能叫做Type Assertions（類型斷言），它的作用就是能夠在運行時檢查我的資料類型，讓我在傳遞類型時能確保資料類型是正確的。
Type Assertions 的基本概念 在Go中，Type Assertions的主要目的是在運行時將 interface 型別的值轉換為特定的實際型別。interface 是一種特殊的類型，它可以保存任何值的實例，但在運行時，我們可能需要確定該值的實際類型以執行相應的操作，以確保我們能夠安全地操作資料，這就是Type Assertions的作用。
Type Assertions的基本語法如下：
value, ok := someInterface.(T) 這個表達式意思為將someInterface轉換為類型T。如果成功，它將value設置為轉換後的值，並將ok設置為true。如果轉換失敗，則value將是零值，而ok將是false。
Type Assertions的用途 Type Assertions 的主要用途包括：
資料型別的轉換 當我們處理interface型別的資料時，可能需要將其轉換為具體的型別，以便進行特定操作。
func process(someInterface interface{}) { if str, ok := someInterface.(string); ok { // 將interfacce轉換為string類型並進行操作 fmt.Printf("Length of string: %d\n", len(str)) } else { fmt.Println("Not a string") } } 確保型別的正確性 使用 Type Assertions，我們可以在執行特定操作之前，確保資料的型別是我們期望的。這有助於防止因型別錯誤而引發的執行時錯誤。
if val, ok := someInterface.(int); ok { // someInterface 是一個int類型 fmt.Printf("Value is an int: %d\n", val) } else { // someInterface 不是一個int類型 fmt....</p></div><footer class=entry-footer><span title="2023-09-05 15:31:00 +0800 CST">2023-09-05</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;397 words&nbsp;·&nbsp;Alan</footer></div><figure class=entry-cover><img loading=lazy src=https://sz9751210.github.io/assets/go-type-assertion/cover.png alt></figure><a class=entry-link aria-label="post link to 保證型別安全：使用Go的Type Assertions避免型別錯誤" href=https://sz9751210.github.io/posts/go-type-assertion/></a></article><footer class=page-footer><nav class=pagination><a class=prev href=https://sz9751210.github.io/posts/page/2/>«&nbsp;Prev&nbsp;
</a><a class=next href=https://sz9751210.github.io/posts/page/4/>Next&nbsp;&nbsp;»</a></nav></footer></main><footer class=footer><span>&copy; 2024 <a href=https://sz9751210.github.io/>艾倫的程式之旅</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let detail=document.getElementsByClassName("details");details=[].slice.call(detail);for(let e=0;e<details.length;e++){let t=details[e];const n=t.getElementsByClassName("details-summary")[0];n&&n.addEventListener("click",()=>{t.classList.toggle("open")},!1)}</script><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>