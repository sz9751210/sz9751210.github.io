<!doctype html><html lang=en dir=auto><head><meta name=generator content="Hugo 0.111.3"><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>艾倫的程式之旅</title><meta name=keywords content="Blog,Devops,PaperMod"><meta name=description content="ExampleSite description"><meta name=author content="Alan"><link rel=canonical href=https://sz9751210.github.io/><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.css rel="preload stylesheet" as=style><link rel=icon href=https://sz9751210.github.io/assets/profile/avatar.png><link rel=icon type=image/png sizes=16x16 href=https://sz9751210.github.io/assets/profile/avatar.png><link rel=icon type=image/png sizes=32x32 href=https://sz9751210.github.io/assets/profile/avatar.png><link rel=apple-touch-icon href=https://sz9751210.github.io/assets/profile/avatar.png><link rel=mask-icon href=https://sz9751210.github.io/assets/profile/avatar.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://sz9751210.github.io/index.xml><link rel=alternate type=application/json href=https://sz9751210.github.io/index.json><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://www.googletagmanager.com/gtag/js?id=G-4RLTP9J7DY"></script>
<script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-4RLTP9J7DY",{anonymize_ip:!1})}</script><meta property="og:title" content="艾倫的程式之旅"><meta property="og:description" content="ExampleSite description"><meta property="og:type" content="website"><meta property="og:url" content="https://sz9751210.github.io/"><meta property="og:image" content="https://sz9751210.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta property="og:site_name" content="ExampleSite"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://sz9751210.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="艾倫的程式之旅"><meta name=twitter:description content="ExampleSite description"><script type=application/ld+json>{"@context":"https://schema.org","@type":"Organization","name":"艾倫的程式之旅","url":"https://sz9751210.github.io/","description":"ExampleSite description","thumbnailUrl":"https://sz9751210.github.io/assets/profile/avatar.png","sameAs":["mailto:alandev9751210@gmail.com","https://www.instagram.com/alan_wang.dev.life","https://github.com/sz9751210"]}</script><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-8214206744217848" crossorigin=anonymous></script></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://sz9751210.github.io/ accesskey=h title="Alan's BLOG (Alt + H)"><img src=https://sz9751210.github.io/assets/profile/avatar.png alt aria-label=logo height=35>Alan's BLOG</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://sz9751210.github.io/archives/ title=archives><span>archives</span></a></li><li><a href=https://sz9751210.github.io/posts/ title=posts><span>posts</span></a></li><li><a href=https://sz9751210.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://sz9751210.github.io/about/ title=about><span>about</span></a></li><li><a href=https://sz9751210.github.io/quote/ title=quote><span>quote</span></a></li><li><a href=https://sz9751210.github.io/search/ title="search (Alt + /)" accesskey=/><span>search</span></a></li></ul></nav></header><main class=main><article class="first-entry home-info"><header class=entry-header><h1>Hi👋 這裡是Alan的開發者天地📚</h1></header><div class=entry-content>記錄自己的學習歷程。避免以後的自己踩坑時有跡可循，偶爾也會放一些跟自己興趣有關的文章。</div><footer class=entry-footer><div class=social-icons><a href=mailto:alandev9751210@gmail.com target=_blank rel="noopener noreferrer me" title=Email><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 21" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M4 4h16c1.1.0 2 .9 2 2v12c0 1.1-.9 2-2 2H4c-1.1.0-2-.9-2-2V6c0-1.1.9-2 2-2z"/><polyline points="22,6 12,13 2,6"/></svg></a><a href=https://www.instagram.com/alan_wang.dev.life target=_blank rel="noopener noreferrer me" title=Instagram><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="2" y="2" width="20" height="20" rx="5" ry="5"/><path d="M16 11.37A4 4 0 1112.63 8 4 4 0 0116 11.37z"/><line x1="17.5" y1="6.5" x2="17.5" y2="6.5"/></svg></a><a href=https://github.com/sz9751210 target=_blank rel="noopener noreferrer me" title=Github><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37.0 00-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44.0 0020 4.77 5.07 5.07.0 0019.91 1S18.73.65 16 2.48a13.38 13.38.0 00-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07.0 005 4.77 5.44 5.44.0 003.5 8.55c0 5.42 3.3 6.61 6.44 7A3.37 3.37.0 009 18.13V22"/></svg></a></div></footer></article><article class=post-entry><div class=post-info><header class=entry-header><h2>如何在Go中使用正則表達式</h2></header><div class=entry-content><p>👨‍💻 簡介 在處理string時，正則表達式是一個非常有用的工具。Go語言的regexp package 可以使用正則表達式，用來執行如檢查string是否匹配某個模式、提取匹配的subString等操作。
匹配功能 regexp.MatchString：檢查一個string是否匹配某個模式。 regexp.Compile：編譯一個正則表達式。 語法如下：
// 檢查一個string是否匹配某個模式。 func regexp.MatchString(pattern string, s string) (matched bool, err error) // 編譯一個正則表達式。 func regexp.Compile(expr string) (*Regexp, error) package main import ( "fmt" "regexp" ) func main() { // 檢查string是否匹配模式 matched, err := regexp.MatchString("Go", "Hello, Go!") if err != nil { fmt.Println(err) } fmt.Println("Matched:", matched) // true } 提取功能 regexp.FindString：找到第一個匹配的subString。 regexp.FindAllString：找到所有匹配的subString。 語法如下：
// 找到第一個匹配的subString。 func (re *Regexp) FindString(s string) string // 找到所有匹配的subString。 func (re *Regexp) FindAllString(s string, n int) []string package main import ( "fmt" "regexp" ) func main() { re, err := regexp....</p></div><footer class=entry-footer><span title='2023-09-26 17:00:00 +0800 CST'>2023-09-26</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;251 words&nbsp;·&nbsp;Alan</footer></div><figure class=entry-cover><img loading=lazy src=https://sz9751210.github.io/assets/go-regexp/cover.png alt></figure><a class=entry-link aria-label="post link to 如何在Go中使用正則表達式" href=https://sz9751210.github.io/posts/go-regexp/></a></article><article class=post-entry><div class=post-info><header class=entry-header><h2>如何在 Go 中處理 String</h2></header><div class=entry-content><p>👨‍💻 簡介 一開始介紹基本資料型別時有稍微提到一點string的處理，今天介紹string的一些操作，像是檢查的功能、修改的功能、比較的功能等等。
檢查功能 strings.Contains：檢查一個string是否包含另一個string。 strings.ContainsAny：檢查一個string是否包含任何指定的Unicode字元。 strings.Count：計算subString在目標string中出現的次數。 strings.ContainsRune：檢查一個string是否包含指定的Unicode字元。 語法如下：
// 檢查一個string是否包含另一個string。 func strings.Contains(s, substr string) bool // 檢查一個string是否包含任何指定的Unicode字元。 func strings.ContainsAny(s, chars string) bool // 計算subString在目標string中出現的次數。 func strings.Count(s, substr string) int // 檢查一個string是否包含指定的Unicode字元。 func strings.ContainsRune(s string, r rune) bool package main import ( "fmt" "strings" ) func main() { text := "Hello, world! Hello, universe!" // 檢查string是否包含另一個string containsHello := strings.Contains(text, "Hello") fmt.Println("Contains 'Hello':", containsHello) // true // 檢查string是否包含指定的Unicode字元 containsAny := strings.ContainsAny(text, "aeiou") fmt....</p></div><footer class=entry-footer><span title='2023-09-22 16:45:00 +0800 CST'>2023-09-22</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;675 words&nbsp;·&nbsp;Alan</footer></div><figure class=entry-cover><img loading=lazy src=https://sz9751210.github.io/assets/go-strings/cover.png alt></figure><a class=entry-link aria-label="post link to 如何在 Go 中處理 String" href=https://sz9751210.github.io/posts/go-strings/></a></article><article class=post-entry><div class=post-info><header class=entry-header><h2>如何在 Go 中操作系統</h2></header><div class=entry-content><p>👨‍💻 簡介 昨天講到 os package，今天繼續補充 os package底下的 exec package，這個package主要用來執行外部指令和處理指令的輸入和輸出，包括如何設定指令、執行指令以及處理輸出等等。
設定指令 要執行外部指令，首先需要設定要執行的主要指令：
exec.Command：接受一個指令名稱和多個參數，並返回一個 Cmd 對象。 語法如下：
func exec.Command(name string, arg ...string) *exec.Cmd 第一個參數是放要執行的命令名稱，第二個則是放參數。 接著來看看exec.Cmd是甚麼東西：
type Cmd struct { Path string // the path of the command to run Args []string // holds command line arguments Env []string // the environment of the process Dir string // the working directory of the command. Stdin io.Reader // the process's standard input. Stdout io.Writer // the process's standard output and error....</p></div><footer class=entry-footer><span title='2023-09-21 10:00:00 +0800 CST'>2023-09-21</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;758 words&nbsp;·&nbsp;Alan</footer></div><figure class=entry-cover><img loading=lazy src=https://sz9751210.github.io/assets/go-os-exec/cover.png alt></figure><a class=entry-link aria-label="post link to 如何在 Go 中操作系統" href=https://sz9751210.github.io/posts/go-os-exec/></a></article><article class=post-entry><div class=post-info><header class=entry-header><h2>如何在 Go 中操作檔案</h2></header><div class=entry-content><p>👨‍💻 簡介 今天快速介紹一下對檔案的操作所使用的package os，包括檔案和資料夾操作等。
檔案和資料夾操作 os package 可以執行各種檔案和資料夾操作，如建立、讀取、寫入、刪除檔案，以及取得資料夾內容等。
建立相關操作 os.Create：建立一個新檔案。 os.Mkdir：建立一個新資料夾。 os.MkdirAll：建立資料夾，包括必要的父層資料夾。 語法如下：
func os.Create(name string) (*os.File, error) func os.Mkdir(name string, perm fs.FileMode) error func os.MkdirAll(path string, perm fs.FileMode) error package main import ( "fmt" "os" "io" ) func main() { // 建立資料夾，指定權限為755 err := os.Mkdir("mydir", 0755) if err != nil { fmt.Println("Error creating directory:", err) } else { fmt.Println("Directory created successfully.") } // 建立一個新檔案並寫入內容 file, err := os.Create("example.txt") if err !...</p></div><footer class=entry-footer><span title='2023-09-20 10:00:00 +0800 CST'>2023-09-20</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;542 words&nbsp;·&nbsp;Alan</footer></div><figure class=entry-cover><img loading=lazy src=https://sz9751210.github.io/assets/go-os-file/cover.png alt></figure><a class=entry-link aria-label="post link to 如何在 Go 中操作檔案" href=https://sz9751210.github.io/posts/go-os-file/></a></article><article class=post-entry><div class=post-info><header class=entry-header><h2>如何在 Go 中處理 JSON</h2></header><div class=entry-content><p>👨‍💻 簡介 今天的encoding/json package是我日常在開發web時很常用到的package之一，主要是用來將Go struct和 JSON 之間進行轉換。主要功能為資料序列化（marshalling）和反序列化（unmarshalling）。
主要功能 encoding/json package 主要用來將 Go struct轉換為 JSON 格式（marshalling）以及將 JSON 資料轉換為 Go struct（unmarshalling）。以下是一些主要功能：
將 Go struct轉換為 JSON 使用 json.Marshal 函數可以將 Go struct轉換為 JSON 格式的資料。
package main import ( "encoding/json" "fmt" ) type Person struct { Name string `json:"name"` Age int `json:"age"` } func main() { person := Person{Name: "Alan", Age: 25} jsonData, err := json.Marshal(person) if err != nil { fmt.Println("JSON 編碼失敗:", err) return } fmt....</p></div><footer class=entry-footer><span title='2023-09-19 10:00:00 +0800 CST'>2023-09-19</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;462 words&nbsp;·&nbsp;Alan</footer></div><figure class=entry-cover><img loading=lazy src=https://sz9751210.github.io/assets/go-json/cover.png alt></figure><a class=entry-link aria-label="post link to 如何在 Go 中處理 JSON" href=https://sz9751210.github.io/posts/go-json/></a></article><article class=post-entry><div class=post-info><header class=entry-header><h2>Reflect：Go 語言的鏡子</h2></header><div class=entry-content><p>👨‍💻簡介 在 Go 語言中，reflect package是用來檢查和操作變數的type、value和struct。常見用法有檢察 type、調用方法，以及修改變數的value。今天簡單介紹 reflect package的主要功能、使用方法和常見用法。
主要功能 reflect package 主要用來在運行時檢查和操作變數的type訊息。這對於需要在不確定type的情況下處理資料的情況非常有用。要使用reflect package，首先需要import它：
import "reflect" reflect package的主要功能包括：
Type reflect reflect 可以讓你取得變數的type訊息，方便我們在運行時進行type比較，檢查變數的type。下面是一些基本的type reflect操作：
reflect.TypeOf：取得變數的type。 reflect.ValueOf：取得變數的value。 reflect.Zero：建立一個zero value。 package main import ( "fmt" "reflect" ) func main() { var num int typ := reflect.TypeOf(num) val := reflect.ValueOf(num) zeroVal := reflect.Zero(typ) fmt.Printf("Type: %v\n", typ) // Type: int fmt.Printf("Value: %v\n", val) // Value: 0 fmt.Printf("Zero Value: %v\n", zeroVal) // Zero Value: 0 } Struct reflect reflect 可以讓你取得struct欄位的訊息，訪問struct欄位的value，以及修改struct欄位的value。...</p></div><footer class=entry-footer><span title='2023-09-15 10:00:00 +0800 CST'>2023-09-15</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;602 words&nbsp;·&nbsp;Alan</footer></div><figure class=entry-cover><img loading=lazy src=https://sz9751210.github.io/assets/go-reflect/cover.png alt></figure><a class=entry-link aria-label="post link to Reflect：Go 語言的鏡子" href=https://sz9751210.github.io/posts/go-reflect/></a></article><article class=post-entry><div class=post-info><header class=entry-header><h2>Time：Go語言的時間處理利器</h2></header><div class=entry-content><p>👨‍💻簡介 要處理日期和時間，就必須知道這個Package -> time，Go提供了內建的timePackage。 今天主要介紹time的功能，包括時間操作、格式化等等，以及常見用法。
主要功能 timePackage的主要功能是處理時間和日期的操作，包括時間的表示、創建、格式化和計算。在Go中，時間通常以time.Time type表示，這個type包含了日期和時間的資訊。
導入Package import "time" 創建時間 使用time.Now()函數來獲取當前的時間。
package main import ( "fmt" "time" ) func main() { currentTime := time.Now() fmt.Println("Current Time:", currentTime) } 你還可以使用time.Date()函數來創建一個特定日期和時間的time.Time 物件。
package main import ( "fmt" "time" ) func main() { specificTime := time.Date(2023, time.September, 15, 12, 0, 0, 0, time.UTC) fmt.Println("Specific Time:", specificTime) } 時間格式化 timePackage有提供許多方法來格式化時間為字串。可以使用Format方法和指定的時間格式來實現。
package main import ( "fmt" "time" ) func main() { currentTime := time....</p></div><footer class=entry-footer><span title='2023-09-15 10:00:00 +0800 CST'>2023-09-15</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;379 words&nbsp;·&nbsp;Alan</footer></div><figure class=entry-cover><img loading=lazy src=https://sz9751210.github.io/assets/go-time/cover.png alt></figure><a class=entry-link aria-label="post link to Time：Go語言的時間處理利器" href=https://sz9751210.github.io/posts/go-time/></a></article><article class=post-entry><div class=post-info><header class=entry-header><h2>Fmt：資料處理的好幫手</h2></header><div class=entry-content><p>👨‍💻簡介 要印出Hello World，就會碰到這個Package -> fmt，今天來簡單整理一下fmt的作用、格式化的控制與常見用法。
主要功能 fmt 套件的主要功能是處理格式化的輸出和輸入，包括資料格式處理、字串解析和數值轉換等功能。通常用來記錄訊息、檔案處理等等。fmt 套件中的函數可以主要分為兩大類：Print 和 Scan。
導入Package import "fmt" Print 函數系列 fmt.Print：將資料印到終端機。 fmt.Println：將資料印到終端機，並換行。 fmt.Printf：根據格式化參數將資料印到終端機。 fmt.Sprintf：格式化成字串，通常用在需要以字串形式處理格式化時會用到 fmt.Fprintf：格式化到文件，通常用來寫檔會用到 Print與Printf相比，差在不能印格式化輸出
Print與Println相比，差在ln多了一個換行
package main import ( "fmt" "os" ) func main() { name := "Alan" age := 30 fmt.Print("Name: ", name, " Age: ", age) // 沒有換行 fmt.Println("Name:", name, "Age:", age) // 有換行 fmt.Printf("Name: %s Age: %d\n", name, age) // 格式化印出 formatted := fmt.Sprintf("Name: %s, Age: %d", name, age) fmt....</p></div><footer class=entry-footer><span title='2023-09-14 15:44:00 +0800 CST'>2023-09-14</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;498 words&nbsp;·&nbsp;Alan</footer></div><figure class=entry-cover><img loading=lazy src=https://sz9751210.github.io/assets/go-fmt/cover.png alt></figure><a class=entry-link aria-label="post link to Fmt：資料處理的好幫手" href=https://sz9751210.github.io/posts/go-fmt/></a></article><article class=post-entry><div class=post-info><header class=entry-header><h2>Go語言中Goroutine的等待方式</h2></header><div class=entry-content><p>👨‍💻簡介 昨天講到Goroutine的橋梁aka傳話筒 - Channel，那要怎麼知道對方有收到訊息，我的紙條有送到對方手上呢? 今天就是要來介紹幾種Goroutine的確定完成工作的幾種方式。
Goroutine 的等待方式 在Go語言中，等待Goroutine完成的方式有多種。
sync.WaitGroup sync.WaitGroup是Go語言中常見的一種等待方式，它允許我們等待一組Goroutine完成。
package main import ( "fmt" "sync" ) func worker(id int, wg *sync.WaitGroup) { defer wg.Done() // 表示Goroutine完成工作，減少WaitGroup計數 fmt.Printf("Worker %d 正在工作\n", id) } func main() { var wg sync.WaitGroup for i := 1; i &lt;= 3; i++ { wg.Add(1) // 增加WaitGroup數量 go worker(i, &amp;wg) // 啟動Goroutine，並將WaitGroup的指針傳遞給它 } wg.Wait() // 將主程式阻塞，直到所有Goroutines完成工作。 fmt.Println("所有工作完成") } 在上面的範例中，我們先創建了一個sync.WaitGroup的變數wg，並使用for循環去執行我們的goroutine，每次執行前都先將等待goroutine的數量+1，總共等待三個Goroutine完成工作。 接著使用 wg.Wait()將main函數先暫停一下，等所有goroutine都完成工作，wg的計數器為0，在繼續執行程式。 在 worker函數裡，會接收 wg的pointer，並在開頭使用defer wg.Done()在程式執行結束就將等待的goroutine數量-1，來確保goroutine會完成
Channel Channel是Go語言中用於通信的機制，也可以用於等待Goroutine完成。...</p></div><footer class=entry-footer><span title='2023-09-13 16:23:00 +0800 CST'>2023-09-13</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;293 words&nbsp;·&nbsp;Alan</footer></div><figure class=entry-cover><img loading=lazy src=https://sz9751210.github.io/assets/go-waitgroup/cover.png alt></figure><a class=entry-link aria-label="post link to Go語言中Goroutine的等待方式" href=https://sz9751210.github.io/posts/go-waitgroup/></a></article><article class=post-entry><div class=post-info><header class=entry-header><h2>Channel：Go語言建立併發通訊的橋樑</h2></header><div class=entry-content><p>👨‍💻簡介 昨天講到Goroutine有稍微簡單介紹Channel，Channel是Go語言中極為重要的併發通訊機制，它就像是不同goroutines之間的話筒，允許它們安全地傳遞資料和信息。這個強大的工具使得Go語言在處理併發任務時非常優雅和高效。通過Channel，可以協調goroutines的操作，防止競爭條件，並實現高效的併發程式設計。
什麼是Channel？ Channel是Go語言中一個強大的併發原語言功能，用於在不同的goroutine之間傳遞資料。它們提供了一種通訊的機制，可以讓goroutines之間安全地交換信息，而不需要額外的互斥鎖或信號量。
可以把channel比喻成傳紙條，傳紙條可以是單向，也可以是雙向，單向可以想像類似以前傳紙條的中間人，他只接收和傳遞，紙條也有大小的限制，寫滿了就不能再繼續寫，並且需要等待對方將紙條進行回覆後你才能繼續。
建立和使用Channel 在Go中，可以使用內建的make函數來建立一個新的Channel。以下是使用 make函數建立整數類型的Channel
ch := make(chan int) 建立完後，就可以將資料發送到Channel中，然後在其他goroutine中接收它們。以下是一個簡單的發送和接收資料的例子：
func main() { ch := make(chan int) go func() { ch &lt;- 42 // 發送資料到Channel }() value := &lt;-ch // 從Channel接收資料 fmt.Println(value) // 輸出：42 } 這個例子中，我們建立了一個goroutine，它將數字42發送到Channel，然後主goroutine，也就是main函數，接收到這個數字。
關閉Channel 紙條用完會丟掉，Channel用完也是要關掉，您可能需要關閉Channel，以通知接收方不再有新的資料可用。要關閉Channel，可以使用close函數，如下所示：
close(ch) 接收方可以使用特殊的語法來檢查Channel是否已關閉：
value, ok := &lt;-ch if !ok { // Channel已經關閉 } 這可以防止接收方在Channel已關閉的情況下繼續等待。 並且已經關閉的Channel依然可以進行接收的操作，但不能再進行發送。
package main import ( "fmt" "time" ) func main() { ch := make(chan int) go func() { for i := 0; i &lt; 5; i++ { time....</p></div><footer class=entry-footer><span title='2023-09-12 16:09:00 +0800 CST'>2023-09-12</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;460 words&nbsp;·&nbsp;Alan</footer></div><figure class=entry-cover><img loading=lazy src=https://sz9751210.github.io/assets/go-channel/cover.png alt></figure><a class=entry-link aria-label="post link to Channel：Go語言建立併發通訊的橋樑" href=https://sz9751210.github.io/posts/go-channel/></a></article><footer class=page-footer><nav class=pagination><a class=next href=https://sz9751210.github.io/page/2/>Next&nbsp;&nbsp;»</a></nav></footer></main><footer class=footer><span>&copy; 2023 <a href=https://sz9751210.github.io/>艾倫的程式之旅</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let detail=document.getElementsByClassName("details");details=[].slice.call(detail);for(let e=0;e<details.length;e++){let t=details[e];const n=t.getElementsByClassName("details-summary")[0];n&&n.addEventListener("click",()=>{t.classList.toggle("open")},!1)}</script><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>