<!doctype html><html lang=en dir=auto><head><meta name=generator content="Hugo 0.111.3"><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>艾倫的程式之旅</title><meta name=keywords content="Blog,Devops,PaperMod"><meta name=description content="ExampleSite description"><meta name=author content="Alan"><link rel=canonical href=https://sz9751210.github.io/><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.css rel="preload stylesheet" as=style><link rel=icon href=https://sz9751210.github.io/assets/profile/avatar.png><link rel=icon type=image/png sizes=16x16 href=https://sz9751210.github.io/assets/profile/avatar.png><link rel=icon type=image/png sizes=32x32 href=https://sz9751210.github.io/assets/profile/avatar.png><link rel=apple-touch-icon href=https://sz9751210.github.io/assets/profile/avatar.png><link rel=mask-icon href=https://sz9751210.github.io/assets/profile/avatar.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://sz9751210.github.io/index.xml><link rel=alternate type=application/json href=https://sz9751210.github.io/index.json><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://www.googletagmanager.com/gtag/js?id=G-4RLTP9J7DY"></script>
<script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-4RLTP9J7DY",{anonymize_ip:!1})}</script><meta property="og:title" content="艾倫的程式之旅"><meta property="og:description" content="ExampleSite description"><meta property="og:type" content="website"><meta property="og:url" content="https://sz9751210.github.io/"><meta property="og:image" content="https://sz9751210.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta property="og:site_name" content="ExampleSite"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://sz9751210.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="艾倫的程式之旅"><meta name=twitter:description content="ExampleSite description"><script type=application/ld+json>{"@context":"https://schema.org","@type":"Organization","name":"艾倫的程式之旅","url":"https://sz9751210.github.io/","description":"ExampleSite description","thumbnailUrl":"https://sz9751210.github.io/assets/profile/avatar.png","sameAs":["mailto:alandev9751210@gmail.com","https://www.instagram.com/alan_wang.dev.life","https://github.com/sz9751210"]}</script><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-8214206744217848" crossorigin=anonymous></script></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://sz9751210.github.io/ accesskey=h title="Alan's BLOG (Alt + H)"><img src=https://sz9751210.github.io/assets/profile/avatar.png alt aria-label=logo height=35>Alan's BLOG</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://sz9751210.github.io/archives/ title=archives><span>archives</span></a></li><li><a href=https://sz9751210.github.io/posts/ title=posts><span>posts</span></a></li><li><a href=https://sz9751210.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://sz9751210.github.io/about/ title=about><span>about</span></a></li><li><a href=https://sz9751210.github.io/quote/ title=quote><span>quote</span></a></li><li><a href=https://sz9751210.github.io/search/ title="search (Alt + /)" accesskey=/><span>search</span></a></li></ul></nav></header><main class=main><article class="first-entry home-info"><header class=entry-header><h1>Hi👋 這裡是Alan的開發者天地📚</h1></header><div class=entry-content>記錄自己的學習歷程。避免以後的自己踩坑時有跡可循，偶爾也會放一些跟自己興趣有關的文章。</div><footer class=entry-footer><div class=social-icons><a href=mailto:alandev9751210@gmail.com target=_blank rel="noopener noreferrer me" title=Email><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 21" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M4 4h16c1.1.0 2 .9 2 2v12c0 1.1-.9 2-2 2H4c-1.1.0-2-.9-2-2V6c0-1.1.9-2 2-2z"/><polyline points="22,6 12,13 2,6"/></svg></a><a href=https://www.instagram.com/alan_wang.dev.life target=_blank rel="noopener noreferrer me" title=Instagram><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="2" y="2" width="20" height="20" rx="5" ry="5"/><path d="M16 11.37A4 4 0 1112.63 8 4 4 0 0116 11.37z"/><line x1="17.5" y1="6.5" x2="17.5" y2="6.5"/></svg></a><a href=https://github.com/sz9751210 target=_blank rel="noopener noreferrer me" title=Github><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37.0 00-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44.0 0020 4.77 5.07 5.07.0 0019.91 1S18.73.65 16 2.48a13.38 13.38.0 00-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07.0 005 4.77 5.44 5.44.0 003.5 8.55c0 5.42 3.3 6.61 6.44 7A3.37 3.37.0 009 18.13V22"/></svg></a></div></footer></article><article class=post-entry><div class=post-info><header class=entry-header><h2>Channel：Go語言建立併發通訊的橋樑</h2></header><div class=entry-content><p>👨‍💻簡介 昨天講到Goroutine有稍微簡單介紹Channel，Channel是Go語言中極為重要的併發通訊機制，它就像是不同goroutines之間的話筒，允許它們安全地傳遞資料和信息。這個強大的工具使得Go語言在處理併發任務時非常優雅和高效。通過Channel，可以協調goroutines的操作，防止競爭條件，並實現高效的併發程式設計。
什麼是Channel？ Channel是Go語言中一個強大的併發原語言功能，用於在不同的goroutine之間傳遞資料。它們提供了一種通訊的機制，可以讓goroutines之間安全地交換信息，而不需要額外的互斥鎖或信號量。
可以把channel比喻成傳紙條，傳紙條可以是單向，也可以是雙向，單向可以想像類似以前傳紙條的中間人，他只接收和傳遞，紙條也有大小的限制，寫滿了就不能再繼續寫，並且需要等待對方將紙條進行回覆後你才能繼續。
建立和使用Channel 在Go中，可以使用內建的make函數來建立一個新的Channel。以下是使用 make函數建立整數類型的Channel
ch := make(chan int) 建立完後，就可以將資料發送到Channel中，然後在其他goroutine中接收它們。以下是一個簡單的發送和接收資料的例子：
func main() { ch := make(chan int) go func() { ch &lt;- 42 // 發送資料到Channel }() value := &lt;-ch // 從Channel接收資料 fmt.Println(value) // 輸出：42 } 這個例子中，我們建立了一個goroutine，它將數字42發送到Channel，然後主goroutine，也就是main函數，接收到這個數字。
關閉Channel 紙條用完會丟掉，Channel用完也是要關掉，您可能需要關閉Channel，以通知接收方不再有新的資料可用。要關閉Channel，可以使用close函數，如下所示：
close(ch) 接收方可以使用特殊的語法來檢查Channel是否已關閉：
value, ok := &lt;-ch if !ok { // Channel已經關閉 } 這可以防止接收方在Channel已關閉的情況下繼續等待。 並且已經關閉的Channel依然可以進行接收的操作，但不能再進行發送。
package main import ( "fmt" "time" ) func main() { ch := make(chan int) go func() { for i := 0; i &lt; 5; i++ { time....</p></div><footer class=entry-footer><span title='2023-09-12 16:09:00 +0800 CST'>2023-09-12</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;460 words&nbsp;·&nbsp;Alan</footer></div><figure class=entry-cover><img loading=lazy src=https://sz9751210.github.io/assets/go-channel/cover.png alt></figure><a class=entry-link aria-label="post link to Channel：Go語言建立併發通訊的橋樑" href=https://sz9751210.github.io/posts/go-channel/></a></article><article class=post-entry><div class=post-info><header class=entry-header><h2>探索Goroutine：Go語言的併發魔法</h2></header><div class=entry-content><p>👨‍💻簡介 在日常生活中，如果能同時做很多事情，效率肯定大大提升，那麼在Go語言中，該如何做到呢，答案就是今天的主角Goroutine了，在Go語言中，讓併發變得簡單的強大工具，今天就是來給他一個快速介紹。
什麼是Goroutine？ 首先，讓我們以一個簡單的方式來解釋什麼是Goroutine。Goroutine是Go語言的一個特別的功能，它就像是小型的工作任務，可以讓我們同時處理很多事情，而不需要浪費太多電腦資源。可以把它想像成比傳統方式更聰明的方式來處理多項工作，而不會讓電腦變得超級忙碌。這種功能讓Go語言在處理大量同時執行的工作時變得非常強大。
如何創建和啟動Goroutine 要使用Goroutine很簡單，只需要創建一個函數，然後使用go關鍵字在要使用goroutine的函數前面就完成了。可以看以下範例：
package main import ( "fmt" ) func main() { go sayHello() // 主程式不會等待Goroutine完成 } func sayHello() { fmt.Println("Hello, Goroutine!") } 在這個例子中，我們使用go關鍵字啟動一個新的Goroutine，Goroutine執行了sayHello函數。但須注意，主程式main不會等待Goroutine完成，所以可能不會看到有印出任何東西來。
可以稍微讓main主程式睡一下，就可以看到輸出了
package main import ( "fmt" "time" ) func main() { go sayHello() time.Sleep(1) } func sayHello() { fmt.Println("Hello, Goroutine!") } Goroutine的執行過程 下面提供了一個簡單的小程式，在主程式裡有兩個goroutine，試著執行一下程式可以發現輸出是一段一段的，會是0跟1交錯印出，代表兩邊的goroutine會搶著印出，呈現競爭狀態
package main import ( "fmt" "time" ) func main() { go print1() go print2() time.Sleep(time.Second) } func print1() { for i := 0; i &lt; 100; i++ { fmt....</p></div><footer class=entry-footer><span title='2023-09-11 16:18:00 +0800 CST'>2023-09-11</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;279 words&nbsp;·&nbsp;Alan</footer></div><figure class=entry-cover><img loading=lazy src=https://sz9751210.github.io/assets/go-goroutine/cover.png alt></figure><a class=entry-link aria-label="post link to 探索Goroutine：Go語言的併發魔法" href=https://sz9751210.github.io/posts/go-goroutine/></a></article><article class=post-entry><div class=post-info><header class=entry-header><h2>淺談Go中的Pointer和記憶體管理</h2></header><div class=entry-content><p>👨‍💻簡介 當我們在宣告變數時，電腦會為該變數在記憶體中分配一個位置，然後將這個變數值儲存在這個位置上，需要讀取或修改這個變數值時，電腦是透過記憶體位置來存取這個值。 今天來簡單介紹一下go的Pointer，他的特性以及常見用法。
什麼是Pointer？ Pointer是一種資料類型，用來儲存變數的記憶體地址。在Go中，我們可以通過使用 * 符號來宣告和操作Pointer。這允許我們直接訪問和修改變數的內容，而不僅僅是讀取或複製它們的值。
Pointer的特性、限制與常見用法 特性 Pointer的值和地址 每個變數都有一個記憶體地址，我們可以使用Pointer變數來儲存這個地址。讓我們看一個範例：
package main import "fmt" func main() { x := 42 var p *int // 宣告一個整數Pointer p = &amp;x // 將p指向x的地址 fmt.Println("x =", x) fmt.Println("p =", p) } 在這個例子中，我們創建了一個整數變數 x，並宣告了一個整數Pointer p，然後將 p 設為 x 的地址。現在，p 裡面存放的就是 x 的地址。
Pointer的初始化 Go中的Pointer可以通過 new 函數來初始化，這將為指定的類型分配記憶體並返回其地址。範例：
package main import "fmt" func main() { var p *int p = new(int) // 初始化一個整數Pointer *p = 123 // 將Pointer所指向的記憶體設置為123 fmt....</p></div><footer class=entry-footer><span title='2023-09-08 15:50:00 +0800 CST'>2023-09-08</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;403 words&nbsp;·&nbsp;Alan</footer></div><figure class=entry-cover><img loading=lazy src=https://sz9751210.github.io/assets/go-pointer/cover.png alt></figure><a class=entry-link aria-label="post link to 淺談Go中的Pointer和記憶體管理" href=https://sz9751210.github.io/posts/go-pointer/></a></article><article class=post-entry><div class=post-info><header class=entry-header><h2>錯誤處理的精髓：快速了解Go語言的 error、panic和recover</h2></header><div class=entry-content><p>👨‍💻簡介 在軟體開發中，錯誤無所不在。無論是網路請求失敗、檔案不存在，還是數學計算錯誤，處理錯誤是任何開發者的日常工作，系統的穩定度基本取決於對於錯誤處理是否全面，好的錯誤處理也可以產生適當的錯誤訊息，讓 Debug 更加容易。在Go語言中，有一些獨特的功能在處理錯誤和資源管理方面非常有用。，其中包括error、panic和recover。今天就來介紹這三個關鍵字與錯誤處理的簡單用法。
Error 什麼是Error? 在Go中，Error是一個擁有error interface的類型，可以看到他只有一個方法，該方法主要用來描述一個錯誤的字串。
type error interface { Error() string } 如何產生錯誤訊息 errors.New() 使用方式很簡單，在裡面放入要顯示的錯誤訊息 package main import ( "errors" "fmt" ) func main() { err := errors.New("This is a custom error message") fmt.Println(err.Error()) // output：This is a custom error message } fmt.Errorf() 主要用在格式化錯誤訊息的情況下 package main import ( "fmt" ) func main() { name := "John" err := fmt.Errorf("Hello, %s! This is a custom error message", name) fmt....</p></div><footer class=entry-footer><span title='2023-09-07 11:30:00 +0800 CST'>2023-09-07</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;559 words&nbsp;·&nbsp;Alan</footer></div><figure class=entry-cover><img loading=lazy src=https://sz9751210.github.io/assets/go-error/cover.png alt></figure><a class=entry-link aria-label="post link to 錯誤處理的精髓：快速了解Go語言的 error、panic和recover" href=https://sz9751210.github.io/posts/go-error/></a></article><article class=post-entry><div class=post-info><header class=entry-header><h2>Go語言的defer：確保後置操作的執行</h2></header><div class=entry-content><p>👨‍💻簡介 當我們在寫程式時，有時候會需要在程式結束時關閉某些資源，而defer這個關鍵字，可以讓你輕鬆的實現，下面來簡單介紹一下defer以及常用的範例。，它為程式設計師提供了一種簡單而強大的工具，用於管理資源和確保程式的正確執行。在本篇文章中，我們將深入探討Go語言中的defer，並提供一些實際的程式碼範例，以幫助你理解它的工作原理以及如何運用它來提高程式的可讀性和可維護性。
什麼是defer？ defer是一個關鍵字，用來延遲函數的執行，直到包含它的函數執行完畢。這代表你可以在函數中的任何位置使用defer來安排某個操作，並確保它將在函數返回之前執行。defer通常用於執行一些清理或資源回收的操作。
package main import "fmt" func main() { defer fmt.Println("World") fmt.Print("Hello, ") } 使用方式也很簡單，在要執行的函數前面加上defer就完成了，所以上面的範例會印出 Hello World
Defer的特性 延遲執行：defer 語句允許你安排一段程式碼，使它在包含它的函數返回之前執行，無論函數是否正常返回或出現錯誤。
堆疊特性：多個 defer 語句按照後進先出（LIFO）的順序執行，這意味著最後一個被延遲的語句會最先執行。
package main import "fmt" func main() { fmt.Println("Start") defer fmt.Println("Deferred 1") defer fmt.Println("Deferred 2") fmt.Println("End") } 根據defer特性的後進先出，輸出會是下面這個樣子
Start End Deferred 2 Deferred 1 Defer的限制 延遲的函數必須是無參數函數：你只能延遲無參數的函數調用，因為 defer 不允許傳遞參數。
順序性：defer 語句的效果在函數內是有限定範圍的，它只在包含它的函數範圍內有效，無法跨函數使用。
常見用法 資源清理 最常見的用途之一是在函數返回前關閉文件、釋放鎖、關閉資料庫連接等，以確保資源被正確釋放。
func readFile(filename string) (string, error) { file, err := os.Open(filename) if err != nil { return "", err } defer file....</p></div><footer class=entry-footer><span title='2023-09-06 20:30:00 +0800 CST'>2023-09-06</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;135 words&nbsp;·&nbsp;Alan</footer></div><figure class=entry-cover><img loading=lazy src=https://sz9751210.github.io/assets/go-defer/cover.png alt></figure><a class=entry-link aria-label="post link to Go語言的defer：確保後置操作的執行" href=https://sz9751210.github.io/posts/go-defer/></a></article><article class=post-entry><div class=post-info><header class=entry-header><h2>保證型別安全：使用Go的Type Assertions避免型別錯誤</h2></header><div class=entry-content><p>👨‍💻簡介 在Go中，假如我要判斷一個資料類型是甚麼，該怎麼做呢? Golang有一個功能叫做Type Assertions（類型斷言），它的作用就是能夠在運行時檢查我的資料類型，讓我在傳遞類型時能確保資料類型是正確的。
Type Assertions 的基本概念 在Go中，Type Assertions的主要目的是在運行時將 interface 型別的值轉換為特定的實際型別。interface 是一種特殊的類型，它可以保存任何值的實例，但在運行時，我們可能需要確定該值的實際類型以執行相應的操作，以確保我們能夠安全地操作資料，這就是Type Assertions的作用。
Type Assertions的基本語法如下：
value, ok := someInterface.(T) 這個表達式意思為將someInterface轉換為類型T。如果成功，它將value設置為轉換後的值，並將ok設置為true。如果轉換失敗，則value將是零值，而ok將是false。
Type Assertions的用途 Type Assertions 的主要用途包括：
資料型別的轉換 當我們處理interface型別的資料時，可能需要將其轉換為具體的型別，以便進行特定操作。
func process(someInterface interface{}) { if str, ok := someInterface.(string); ok { // 將interfacce轉換為string類型並進行操作 fmt.Printf("Length of string: %d\n", len(str)) } else { fmt.Println("Not a string") } } 確保型別的正確性 使用 Type Assertions，我們可以在執行特定操作之前，確保資料的型別是我們期望的。這有助於防止因型別錯誤而引發的執行時錯誤。
if val, ok := someInterface.(int); ok { // someInterface 是一個int類型 fmt.Printf("Value is an int: %d\n", val) } else { // someInterface 不是一個int類型 fmt....</p></div><footer class=entry-footer><span title='2023-09-05 15:31:00 +0800 CST'>2023-09-05</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;397 words&nbsp;·&nbsp;Alan</footer></div><figure class=entry-cover><img loading=lazy src=https://sz9751210.github.io/assets/go-type-assertion/cover.png alt></figure><a class=entry-link aria-label="post link to 保證型別安全：使用Go的Type Assertions避免型別錯誤" href=https://sz9751210.github.io/posts/go-type-assertion/></a></article><article class=post-entry><div class=post-info><header class=entry-header><h2>從零開始：使用make函數創建資料結構</h2></header><div class=entry-content><p>👨‍💻簡介 make函數在slice、map和之後會介紹到的channel的初始化中扮演著關鍵的角色。本文將會簡單介紹make函數的用法，以及在初始化不同資料結構時的差異，讓你更好地理解和利用make函數。
make函數基本概念 首先，讓我們來了解一下make函數的基本概念。在Go中，make函數用於動態分配記憶體並初始化slice、map和channel。
// 創建一個切片，長度為5，容量為10 mySlice := make([]int, 5, 10) 在上面的範例中，我們使用make函數創建了一個整數切片（slice），其長度為5，容量為10。這意味著切片可以容納5個元素，但它的底層陣列的容量是10，這為後續的操作提供了一定的靈活性。
make函數的語法 make函數的語法相對簡單。它的一般形式是：
make(類型, 長度, 容量) 類型：指定要創建的資料類型，可以是切片、map或通道。 長度：表示資料結構的初始長度。 容量：只適用於切片和通道，表示底層陣列的容量。 使用make初始化切片 接下來，讓我們看看如何使用make函數初始化切片。
// 創建一個整數切片，長度為3，容量為5 mySlice := make([]int, 3, 5) mySlice[0] = 1 mySlice[1] = 2 mySlice[2] = 3 在這個例子中，我們首先使用make函數創建了一個長度為3、容量為5的整數切片。然後，我們分配了三個整數值到切片中。
使用make初始化Map 現在，讓我們看看如何使用make函數初始化Map。map是一種鍵值對的資料結構，非常適合用於存儲關聯性資料。
// 創建一個字符串到整數的map myMap := make(map[string]int) myMap["apple"] = 1 myMap["banana"] = 2 myMap["cherry"] = 3 在這個範例中，我們使用make函數創建了一個空的字符串到整數的map，然後添加了三個鍵值對。
make 函數在 Go 語言中常見用法包括初始化切片、map和通道。然而，它的使用也受到一些限制和約束。以下是 make 函數的常見用法以及相關的使用限制：
使用make初始化通道 最後，我們來看看如何使用make函數初始化通道。通道是Go語言中用於並發通信的重要機制。
// 創建一個通道，用於傳輸字符串資料 myChannel := make(chan string) go func() { myChannel &lt;- "Hello" myChannel &lt;- "World" }() 在這個例子中，我們使用make函數創建了一個通道，它可以傳輸字符串資料。然後，我們使用Go協程向通道發送了兩個字符串。...</p></div><footer class=entry-footer><span title='2023-09-04 19:26:00 +0800 CST'>2023-09-04</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;153 words&nbsp;·&nbsp;Alan</footer></div><figure class=entry-cover><img loading=lazy src=https://sz9751210.github.io/assets/go-make/cover.png alt></figure><a class=entry-link aria-label="post link to 從零開始：使用make函數創建資料結構" href=https://sz9751210.github.io/posts/go-make/></a></article><article class=post-entry><div class=post-info><header class=entry-header><h2>Package：Golang 專案的組織策略</h2></header><div class=entry-content><p>👨‍💻簡介 套件（Package）在Golang中扮演著組織和管理程式碼的重要角色。
package就像工具箱一樣，裡面裝滿各種不同的工具，每個工具都有特定的功能。這些工具能夠幫助你完成不同的任務，從修理家具到蓋小屋，樣樣都行。
今天這篇文章將快速瞭解 Golang 的package，學習如何建立package、匯入package以及一些使用技巧。
什麼是 Package？ 在 Golang 中，Package 是一種組織程式碼的方式，它將相關的函式、變數和資源放在一個目錄中。這不僅有助於保持程式碼的整潔，還能讓我們更容易地重複使用程式碼。
Package 名稱與資料夾名稱的一致性 通常建議在建立package時，將package名稱與所在資料夾名稱保持一致，這樣有助於提高程式碼的可讀性和一致性。Golang 的匯入機制是基於package的 import 路徑來識別package，而 import 路徑通常會反映package的資料夾結構。這種一致性可以讓其他開發人員更容易理解你的程式碼，並且不需要額外的查找工作，因為package的名稱與資料夾名稱一致。
舉例來說，假設你的資料夾結構如下：
project/ |-- greetings/ | |-- greetings.go | |-- main/ | |-- main.go 如果我們建立的package名稱為 greetings，我們可以在 greetings.go 中這樣定義：
// greetings.go package greetings func Hello(name string) string { return "Hello, " + name } 然後在 main.go 中使用這個package：
// main.go package main import ( "fmt" "your/project/path/greetings" ) func main() { message := greetings.Hello("Alan") fmt....</p></div><footer class=entry-footer><span title='2023-09-01 15:39:00 +0800 CST'>2023-09-01</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;281 words&nbsp;·&nbsp;Alan</footer></div><figure class=entry-cover><img loading=lazy src=https://sz9751210.github.io/assets/go-package/cover.png alt></figure><a class=entry-link aria-label="post link to Package：Golang 專案的組織策略" href=https://sz9751210.github.io/posts/go-package/></a></article><article class=post-entry><div class=post-info><header class=entry-header><h2>Interface：Go 語言中的抽象關鍵</h2></header><div class=entry-content><p>👨‍💻簡介 在Go語言中，Interface 是一個重要且強大的概念。Interface提供了一種方式來定義對象之間的契約，讓你可以設計更具有靈活性和可擴展性的程式碼。 你可以把Interface想像成是一種約定，讓不同的東西彼此溝通的方式變得特別靈活和好擴充，告訴程式裡的各個元件彼此要怎麼合作。
什麼是Interface 在 Go 語言中，Interface是一種關鍵的概念，用於定義方法的契約，而不關心具體的實現。它是一種抽象的型別，描述了物件應該具備的方法。Interface在實現多態性、抽象和模組化設計等方面扮演著重要角色。
Interface是一種抽象的類型，它定義了一組方法簽名（method signatures），但不包含方法的實際實現。這些方法簽名定義了對象應該支援的操作，從而允許不同類型的對象實現同一個Interface並進行交互。
一聽可能有點高深，但其實它就像是一份約定，不管實際怎麼做，只要能遵循這份約定就行。
就好像你和朋友約好要出去玩，你們約定好一起出門、一起玩，但具體怎麼玩，是不是吃火鍋還是去唱歌，那就隨你們。這些約定就是你們的「Interface」，告訴大家「我們一起要做這些事情！」。
當然，這在程式碼裡的作用更大。透過這個「Interface」，你可以讓不同種類的東西，像是車、狗、電腦，都能夠用一樣的方式進行互動。不管是車、狗、還是電腦，只要符合了這個「Interface」約定的方法，你就可以放心地拿來用了。
Interface的基本使用 透過Interface，我們可以在不關心具體類型的情況下，對對象進行操作。這種多態性的概念讓程式碼更具彈性，能夠適應不同的實現。
// 定義一個Interface Shape，它具有一個 Area 方法 type Shape Interface { Area() float64 } // 定義一個 Circle 結構體，實現了 Shape Interface的 Area 方法 type Circle struct { Radius float64 } func (c Circle) Area() float64 { return 3.14 * c.Radius * c.Radius } // 定義一個 Rectangle 結構體，實現了 Shape Interface的 Area 方法 type Rectangle struct { Width, Height float64 } func (r Rectangle) Area() float64 { return r....</p></div><footer class=entry-footer><span title='2023-08-31 19:12:00 +0800 CST'>2023-08-31</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;673 words&nbsp;·&nbsp;Alan</footer></div><figure class=entry-cover><img loading=lazy src=https://sz9751210.github.io/assets/go-interface/cover.png alt></figure><a class=entry-link aria-label="post link to Interface：Go 語言中的抽象關鍵" href=https://sz9751210.github.io/posts/go-interface/></a></article><article class=post-entry><div class=post-info><header class=entry-header><h2>探索 Golang 中的結構體：如何有效地組織複雜資料</h2></header><div class=entry-content><p>👨‍💻簡介 在程式開發的世界中，我們經常需要處理各式各樣的資料，可能是一個人的個人資訊，也可能是一個商品的詳細訊息。當我們面對這麼多的資料時，如何將它們有系統地整理起來，讓我們能夠輕鬆地找到所需，便成了一個重要的課題。這時，結構體的概念就像是一道曙光，為我們提供了一個非常有力的工具。
結構體基礎 結構體，就像是一張設計圖，讓我們畫下我們腦袋裡的想法，就像是一個多功能的工具箱，結構體讓我們能夠以組織化的方式來儲存各種資料片段，就像是將資料拼湊成了一個個獨特的拼圖。今天，我們將深入探討 Golang 中結構體的神奇之處，以及如何通過結構體來更有效地組織和處理複雜資料。
首先，我們來看看如何定義和使用結構體。結構體是一個自定義的資料類型，它允許我們組織不同類型的資料在一個單一的單位中。
type Person struct { FirstName string LastName string Age int } 以一個人的資訊為例，我們可以創建一個名為 Person 的結構體，其中包含了 FirstName、LastName 和 Age 這三個基本資料。這些資料如同載體，讓我們能夠更方便地一次性儲存和訪問它們。 現在，我們可以創建一個 Person 的實例，並訪問其字段：
func main() { person := Person{ FirstName: "John", LastName: "Doe", Age: 30, } fmt.Println("First Name:", person.FirstName) fmt.Println("Last Name:", person.LastName) fmt.Println("Age:", person.Age) } 複雜資料的嵌套組織 但有時候，我們還需要更複雜的資料結構，例如住址。這時，結構體的嵌套就派上用場了，我們可以在 Person 結構體中嵌套另一個結構體，用來表示住址的相關資訊，如 Street、City 和 Country。
type Address struct { Street string City string Country string } type Person struct { FirstName string LastName string Age int Address Address } 也可以直接寫在裡面...</p></div><footer class=entry-footer><span title='2023-08-30 16:06:00 +0800 CST'>2023-08-30</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;299 words&nbsp;·&nbsp;Alan</footer></div><figure class=entry-cover><img loading=lazy src=https://sz9751210.github.io/assets/go-struct/cover.png alt></figure><a class=entry-link aria-label="post link to 探索 Golang 中的結構體：如何有效地組織複雜資料" href=https://sz9751210.github.io/posts/go-struct/></a></article><footer class=page-footer><nav class=pagination><a class=next href=https://sz9751210.github.io/page/2/>Next&nbsp;&nbsp;»</a></nav></footer></main><footer class=footer><span>&copy; 2023 <a href=https://sz9751210.github.io/>艾倫的程式之旅</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let detail=document.getElementsByClassName("details");details=[].slice.call(detail);for(let e=0;e<details.length;e++){let t=details[e];const n=t.getElementsByClassName("details-summary")[0];n&&n.addEventListener("click",()=>{t.classList.toggle("open")},!1)}</script><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>