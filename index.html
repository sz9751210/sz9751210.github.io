<!doctype html><html lang=en dir=auto><head><meta name=generator content="Hugo 0.110.0"><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>艾倫的程式之旅</title><meta name=keywords content="Blog,Devops,PaperMod"><meta name=description content="ExampleSite description"><meta name=author content="Alan"><link rel=canonical href=https://sz9751210.github.io/><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.css rel="preload stylesheet" as=style><link rel=icon href=https://sz9751210.github.io/assets/profile/avatar.png><link rel=icon type=image/png sizes=16x16 href=https://sz9751210.github.io/assets/profile/avatar.png><link rel=icon type=image/png sizes=32x32 href=https://sz9751210.github.io/assets/profile/avatar.png><link rel=apple-touch-icon href=https://sz9751210.github.io/assets/profile/avatar.png><link rel=mask-icon href=https://sz9751210.github.io/assets/profile/avatar.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://sz9751210.github.io/index.xml><link rel=alternate type=application/json href=https://sz9751210.github.io/index.json><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://www.googletagmanager.com/gtag/js?id=G-4RLTP9J7DY"></script>
<script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-4RLTP9J7DY",{anonymize_ip:!1})}</script><meta property="og:title" content="艾倫的程式之旅"><meta property="og:description" content="ExampleSite description"><meta property="og:type" content="website"><meta property="og:url" content="https://sz9751210.github.io/"><meta property="og:image" content="https://sz9751210.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta property="og:site_name" content="ExampleSite"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://sz9751210.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="艾倫的程式之旅"><meta name=twitter:description content="ExampleSite description"><script type=application/ld+json>{"@context":"https://schema.org","@type":"Organization","name":"艾倫的程式之旅","url":"https://sz9751210.github.io/","description":"ExampleSite description","thumbnailUrl":"https://sz9751210.github.io/assets/profile/avatar.png","sameAs":["mailto:alandev9751210@gmail.com","https://www.instagram.com/alan_wang.dev.life","https://github.com/sz9751210"]}</script><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-8214206744217848" crossorigin=anonymous></script></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://sz9751210.github.io/ accesskey=h title="Alan's BLOG (Alt + H)"><img src=https://sz9751210.github.io/assets/profile/avatar.png alt aria-label=logo height=35>Alan's BLOG</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://sz9751210.github.io/archives/ title=archives><span>archives</span></a></li><li><a href=https://sz9751210.github.io/posts/ title=posts><span>posts</span></a></li><li><a href=https://sz9751210.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://sz9751210.github.io/about/ title=about><span>about</span></a></li><li><a href=https://sz9751210.github.io/quote/ title=quote><span>quote</span></a></li><li><a href=https://sz9751210.github.io/search/ title="search (Alt + /)" accesskey=/><span>search</span></a></li></ul></nav></header><main class=main><article class="first-entry home-info"><header class=entry-header><h1>Hi👋 這裡是Alan的開發者天地📚</h1></header><div class=entry-content>記錄自己的學習歷程。避免以後的自己踩坑時有跡可循，偶爾也會放一些跟自己興趣有關的文章。</div><footer class=entry-footer><div class=social-icons><a href=mailto:alandev9751210@gmail.com target=_blank rel="noopener noreferrer me" title=Email><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 21" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M4 4h16c1.1.0 2 .9 2 2v12c0 1.1-.9 2-2 2H4c-1.1.0-2-.9-2-2V6c0-1.1.9-2 2-2z"/><polyline points="22,6 12,13 2,6"/></svg></a><a href=https://www.instagram.com/alan_wang.dev.life target=_blank rel="noopener noreferrer me" title=Instagram><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="2" y="2" width="20" height="20" rx="5" ry="5"/><path d="M16 11.37A4 4 0 1112.63 8 4 4 0 0116 11.37z"/><line x1="17.5" y1="6.5" x2="17.5" y2="6.5"/></svg></a><a href=https://github.com/sz9751210 target=_blank rel="noopener noreferrer me" title=Github><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37.0 00-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44.0 0020 4.77 5.07 5.07.0 0019.91 1S18.73.65 16 2.48a13.38 13.38.0 00-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07.0 005 4.77 5.44 5.44.0 003.5 8.55c0 5.42 3.3 6.61 6.44 7A3.37 3.37.0 009 18.13V22"/></svg></a></div></footer></article><article class=post-entry><div class=post-info><header class=entry-header><h2>GCP Cloud NAT：Overview</h2></header><div class=entry-content><p>服務上雲後有時會需要固定一組IP主動對外發出連線，這時要考慮安全性與獨立性的問題，在爬文後發現了GCP推出的Cloud NAT，本篇文章簡單介紹一下這個工具的使用。
什麼是Cloud NAT GCP Cloud NAT是GCP上的一種服務，它提供了一個管理和部署Google Cloud上的NAT（Network Address Translation）的解決方案。 GCP Cloud NAT能夠讓使用者在不公開VM或GKE的外網IP情況下，透過共用一組IP對外溝通，外部服務無法直接存取Cloud NAT 閘道後的任何資源，確保了服務的安全性。
什麼時候使用Cloud NAT 在需要使用私有IP地址與外網連接時，可以使用Cloud NAT。 例如：在Pod訪問外網時需要固定Public IP的情境下會使用到。
如何使用Cloud NAT 準備環境 設定gcloud至正確專案 gcloud config set project &lt;PROJECT_ID> 建立VPC網路與子網路 建立一台無外網的vm，region選asia-east1 ，zone選asia-east1-b，網路選剛剛建立的nat-network，子網選nat-subnet-192 建立防火牆並允許35.235.240.0/20網段，允許tcp 22 port，目標為無外網的vm 到IAP頁面並選擇SSH和TCP資源設定權限 到剛剛建立的vm curl httpbin.org/ip，此時應該是無法連線到外部
設定NAT 到Cloud NAT建立NAT gateway，並選擇稍早創建的VPC以及創建Router 這時候在curl一次就會有一組對外ip了，此ip即為nat自動幫我們創建的外部ip 有了 Cloud NAT ，可以在不使用外部ip的情況下，與外網連線且同時阻擋了由外部的存取，增加了不少安全性，降低主機被攻擊的風險。
Reference Cloud NAT overview | Google Cloud Set up Cloud NAT with Compute Engine | Google Cloud 利用 Cloud NAT 維持雲端的獨立性與安全性 - PeerOne Technology 皮偶玩互動科技 - Medium</p></div><footer class=entry-footer><span title='2023-04-12 20:58:00 +0800 CST'>2023-04-12</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;76 words&nbsp;·&nbsp;Alan</footer></div><a class=entry-link aria-label="post link to GCP Cloud NAT：Overview" href=https://sz9751210.github.io/posts/gcp-cloud-nat/></a></article><article class=post-entry><div class=post-info><header class=entry-header><h2>Kubernetes ReplicaSet：Overview</h2></header><div class=entry-content><p>1. 什麼是 Kubernetes ReplicaSet? 先來個官網解說
A ReplicaSet’s purpose is to maintain a stable set of replica Pods running at any given time. As such, it is often used to guarantee the availability of a specified number of identical Pods.
根據上述描述，Replica Set主要的作用是確保始終都有一定數量的相同Pod可用，保證服務的高可用性。
Kubernetes RS是Kubernetes中的一種控制器，主要用於管理Pod的複製和伸縮，確保Pod的數量。RS具有以下幾種特性 自動管理pod的副本數量：確保指定數量的Pod跟使用者所期望的一致(desired status)，如果發生故障或需要擴展，它會自動創建或刪除Pod。 確保Pod的健康狀態：如果發生故障會對失敗的Pod進行重新調度 創建Pod的Template：當需要新的Pod時會根據定義的Pod Template創建 2. 為什麼需要Replicaset? 在Kubernetes集群中，Pod的管理對於系統的可靠性和彈性至關重要。如果一個Pod發生故障，RS會自動創建一個新的Pod來代替它，確保服務繼續運行。同時，當服務需要擴展以滿足流量增加時，Kubernetes RS也可以自動創建額外的Pod。因此RS解決了以下問題：
確保服務的高可用性和可靠性：RS可以自動維護一定數量的Pod，確保服務在Pod失敗時仍然可以正常運行。 方便服務的擴展：使用RS可以根據需求調整Pod的副本數量，實現服務的快速擴展。 簡化服務管理：RS可以自動調整Pod的數量，減少手動管理的工作量。 3. Kubernetes Replicaset是如何運作的？ 定義RS，指定所需的Pod副本數量和Pod Template，創建後，ReplicaSet使用定義好的Pod Template創建Pod，並開始監控每個Pod的狀態以及數量是否與定義的一致(desired status)，如果低於指定副本數則會創建Pod，高於指定副本數則會刪除Pod，當Pod被意外刪除時會創建新的Pod來做替代。
4. 什麼時候使用Replicaset？ 使用RS通常適用於以下情況：
需要確保一定數量的Pod正在運行，以保持服務的可用性和可靠性。 需要能夠自動擴展和縮小Pod數量，以應對流量變化和其他需求。 希望能夠自動替換發生故障的Pod，以確保服務的連續運行。 需要管理一個服務的多個Pod，並且希望使用Kubernetes提供的自動化功能，例如調度、網路配置和負載平衡。 5. Kubernetes Replicaset有哪些特性？ 高可用性：RS的目的是維護一個穩定的Pod副本集，確保始終有一定數量的相同Pod可用，從而保證服務的高可用性。...</p></div><footer class=entry-footer><span title='2023-03-06 11:52:00 +0800 CST'>2023-03-06</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;200 words&nbsp;·&nbsp;Alan</footer></div><figure class=entry-cover><img loading=lazy src=https://sz9751210.github.io/assets/k8s-rs/cover.png alt></figure><a class=entry-link aria-label="post link to Kubernetes ReplicaSet：Overview" href=https://sz9751210.github.io/posts/k8s-rs/></a></article><article class=post-entry><div class=post-info><header class=entry-header><h2>Kubernetes Service：Overview</h2></header><div class=entry-content><p>什麼是Kubernetes Service？ 先來個官網的解說
A Kubernetes Service is an abstraction which defines a logical set of Pods and a policy by which to access them.
白話文就是，訪問Pod用的一個Component。ＸＤ
Kubernetes Service是個抽象概念，通過Service，當我們的Pod創建好後，定義訪問它們的策略，該如何去訪問一群相同邏輯的Pod，給Pod提供一組穩定的IP或是Port。
因此也可以把Service當作是一種掛在一群運行相同應用程式前面的LoadBalancer，詳見下圖。
圖片來源
為什麼需要Kubernetes Service？ 因為在Kubernetes集群中，Pod的IP地址是不穩定的，可能因為重新調度或重啟Container而改變了IP。為了使其他應用程式能夠穩定地訪問Pod，需要使用Kubernetes Service。
Kubernetes Service是如何工作的？ 當Pod啟動時，它們會自動註冊到Kubernetes集群中的一個服務發現機制中，例如Kubernetes DNS或etcd。Service會監聽這個服務發現機制，並根據Label Selector選擇要提供服務的Pod。
當其他應用程式需要訪問Pod時，它們可以通過Service的IP和Port進行訪問，Service會將請求根據Label Selector轉發到選定的Pod。由於Service的IP和端口是穩定的，即使Pod的IP地址發生變化，其他應用程式依然可以一直使用相同的IP和Port訪問該Pod。
圖片來源
Kubernetes Service的類型有哪些？ Kubernetes Service有以下四種類型：
ClusterIP: 在Kubernetes集群內部使用，通常用於應用程式的內部通訊。 NodePort: 將Pod暴露到Kubernetes集群的外部，並使用Node的IP和一個Static Port進行訪問。 LoadBalancer: LoadBalancer是ClusterIP和NodePort的一種擴展。在公有雲上使用，使用雲供應商提供的LoadBalancer將流量轉發到Service中的Pod。 ExternalName: 允許服務將外部DNS名稱映射到Kubernetes集群內部的svc名稱上。這樣可以在不修改應用程式代碼的情況下實現外部服務的訪問。 圖片來源 Kubernetes Service有哪些功能？ Kubernetes Service具有以下功能：
透明地將請求轉發到Pod中，無需修改應用程式代碼。 提供負載均衡，分散流量到多個Pod中。 支持多種協議，例如TCP、UDP和HTTP。 可以設置Session Affinity，將請求路由到相同的Pod。 可以進行Port轉發，將請求轉發到Pod中的不同Port。 支持跨命名空間訪問。 如何創建和管理Kubernetes Service： 要創建 Kubernetes Service，可以使用以下兩種方式： 宣告式(Declarative) kind: Service apiVersion: v1 metadata: name: my-service spec: # type 一共有四種(ClusterIP, NodePort, LoadBalancer, ExternalName)，預設是 ClusterIP type: ClusterIP # 選擇帶有 "app=MyApp" 的 pod selector: app: MyApp # Service 實際對外服務的設定 ports: # 使用的協定與port，預設為TCP - protocol: TCP port: 80 # Pod對外開放的port，如無設定，預設與spec....</p></div><footer class=entry-footer><span title='2023-03-03 10:28:00 +0800 CST'>2023-03-03</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;188 words&nbsp;·&nbsp;Alan</footer></div><figure class=entry-cover><img loading=lazy src=https://sz9751210.github.io/assets/k8s-svc/cover.png alt></figure><a class=entry-link aria-label="post link to Kubernetes Service：Overview" href=https://sz9751210.github.io/posts/k8s-svc/></a></article><article class=post-entry><div class=post-info><header class=entry-header><h2>Kubernetes Pod：Overview</h2></header><div class=entry-content><p>Kubernetes是現代應用程序開發和部署的重要技術，而Pod是Kubernetes中最小的部署單位。Pod是一個或多個container的集合，它們共享一個網路命名空間和一個網路接口。Pod不僅提供了一個簡單而強大的container環境，還可以用於實現多種container編排方案，例如負載平衡、數據管理、多container協作等。
本文將深入探討Kubernetes中的Pod，介紹Pod的基本概念、設計原則和實現方式，以及與其他資源的關係。您將學習如何創建和配置Pod，如何使用Kubernetes管理Pod，以及如何通過Pod實現高效、彈性和可靠的應用程序部署。
什麼是Kubernetes Pod Kubernetes Pod是Kubernetes集群中最小的部署單位。一個Pod可以包含一個或多個container，這些container共享相同的網路和儲存空間。Pod提供了一個環境，讓container可以協同工作，形成一個應用程序。
Pod的結構和特性 Pod包含以下元素：
共享網路空間 (Networking)：Pod 中的所有container共享相同的網路空間，可以在container之間通過 localhost 進行通信。 共享儲存空間 (Shared Storage)：Pod 中的所有container共享相同的儲存空間，可以在container之間共享文件、環境變量等。 容器 (Containers)：Pod 中可以包含一個或多個container，這些container可以共享同一個網路和儲存空間，方便container之間的互相協作。 存活和重啟策略 (Liveness and Restart Policy)：Pod 的存活策略指定了在容器出現異常情況時，Kubernetes 如何應對，如重新啟動 container 或者將其標記為失敗。Pod 的重啟策略則指定了當 Pod 中的所有 container 都停止運行時，Kubernetes 如何進行重啟。 元數據 (Metadata)：Pod 中包含一些元數據，如 Pod 名稱、命名空間、標籤等，這些元數據可以用於管理和監控 Pod。 Pod的特性包括：
生命週期短暫 可以擁有多個container 具有唯一的IP地址 具有獨立的儲存空間 具有網路隔離 如何創建和管理Pod 要創建 Kubernetes Pod，可以使用以下兩種方式： 宣告式（Declarative）：使用 YAML 或 JSON 格式的文件來定義 Pod 的結構、元資料和規格，包括 Pod 名稱、container image、資源限制、網路設定等。 apiVersion: v1 kind: Pod metadata: name: my-pod spec: containers: - name: nginx-container image: nginx:latest ports: - containerPort: 80 接著使用kubectl創建pod...</p></div><footer class=entry-footer><span title='2023-03-01 20:43:00 +0800 CST'>2023-03-01</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;365 words&nbsp;·&nbsp;Alan</footer></div><figure class=entry-cover><img loading=lazy src=https://sz9751210.github.io/assets/k8s-pod/cover.png alt></figure><a class=entry-link aria-label="post link to Kubernetes Pod：Overview" href=https://sz9751210.github.io/posts/k8s-pod/></a></article><article class=post-entry><div class=post-info><header class=entry-header><h2>閱讀筆記：5 ChatGPT features to boost your daily work</h2></header><div class=entry-content><p>標題：5 ChatGPT features to boost your daily work
連結：5 ChatGPT features to boost your daily work | by Josep Ferrer | Geek Culture | Jan, 2023 | Medium
機器學習技術正逐漸地應用到日常工作之中，ChatGPT 便是其中之一。ChatGPT 是由 OpenAI 訓練的一個大型語言模型，它能夠根據輸入的文字，生成各種形式的回應，包括文字、代碼和語言翻譯等。
在這篇文章中，作者將介紹 ChatGPT 的五個強大功能，這些功能可以幫助開發者提高工作效率和生產力。
產生語言框架：ChatGPT 可以生成編碼框架，幫助開發人員更快速地開始編碼。
研究和比較：ChatGPT 可以幫助使用者對不同主題進行研究和比較，包括比較產品、服務、技術、公司等等。
理解代碼：ChatGPT 可以分析並幫助使用者理解代碼，包括程式語言、代碼段和概念等。
為代碼添加註釋：ChatGPT 可以根據輸入的代碼，產生相應的註釋，幫助使用者更輕鬆地理解代碼和更有效地與團隊成員協作。
使用特定風格重寫代碼：ChatGPT 可以根據輸入的代碼，重寫代碼並生成相應的代碼風格，以滿足不同的編碼標準和最佳實踐。</p></div><footer class=entry-footer><span title='2023-02-20 11:19:00 +0800 CST'>2023-02-20</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;46 words&nbsp;·&nbsp;Alan</footer></div><a class=entry-link aria-label="post link to 閱讀筆記：5 ChatGPT features to boost your daily work" href=https://sz9751210.github.io/posts/5-chatgpt-features-to-boost-your-daily-work/></a></article><article class=post-entry><div class=post-info><header class=entry-header><h2>ansible k8s</h2></header><div class=entry-content><p>Intro👨‍💻 在gcp環境下使用ansible playbook 建立k8s cluster，目前base image為centos 7，安裝方式類似elk stack，一樣先等master安裝完後產生token，接著安裝slave。
使用的CRI為containerd，CNI為calico
資料夾結構 . ├── README.md ├── create_k8s_master_instance.yaml ├── create_k8s_slave_instance.yaml ├── files │ ├── instance │ └── k8s ├── group_vars │ └── all ├── inventory │ └── k8s.cluster.host ├── inventory.instance.create.yml.example ├── k8s-setup.sh ├── roles │ ├── instance │ ├── k8s │ ├── monitor │ └── ops_agent └── vars ├── instance ├── k8s └── monitor 使用指南 設定機器資訊：複製好inventory.instance.create.yml.example後，可參考inventory裡的設定，主要設定gcp的資訊， 設定group_vars的env.yml，改成自己的gcp的專案以及要設定的region 可使用k8s-setup.sh進行一鍵安裝 sh ./k8s-setup.sh 建置流程 k8s_master -> k8s_slave...</p></div><footer class=entry-footer><span title='2023-02-14 15:23:00 +0800 CST'>2023-02-14</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;110 words&nbsp;·&nbsp;Alan</footer></div><figure class=entry-cover><img loading=lazy src=https://sz9751210.github.io/assets/ansible-k8s/cover.png alt></figure><a class=entry-link aria-label="post link to ansible k8s" href=https://sz9751210.github.io/posts/ansible-k8s/></a></article><article class=post-entry><div class=post-info><header class=entry-header><h2>閱讀筆記：15 Best Practices when working with Docker</h2></header><div class=entry-content><p>標題：15 Best Practices when working with Docker
連結：15 Best Practices when working with Docker | by Ali Zeynalli | Dec, 2022 | Medium
本篇文章作者根據經驗以及自身研究整理出了15個使用Docker的技巧與提示
1. 進行中的工作不應保存在未命名、已停止的容器中 如果進行中的工作保存在不好的容器中，可能會導致資料丟失、風險以及安全問題、不利於協作
2. 定期清理Image 幫助釋放存儲空間，優化Docker引擎性能，減少安全風險，以及維持主機整潔，易於管理。
3. 使用授權的相依套件 可以帶來更好的合法性、安全性、可靠性、支持性和法律責任。
4. 將變化很大的部分放在 DockerFile 的末尾 因為Docker會將每個步驟緩存為一個單獨的容器，重複的操作將不會重新執行，將變化較大的部分放在最後可提高性能
5. 不要在容器啟動時就獲取相依套件 避免在容器啟動時獲取依賴包帶來的問題，並提高容器的啟動速度和可管理性。最佳實踐是在構建Image時就獲取依賴包，並將它們打包到Image中。另外，還可以使用多階段構建和緩存等技術來優化構建過程，提高構建速度和效率。
6. 不要掛載共享資料夾 有助於提高容器的可移植性、安全性、可重現性和可管理性。
7. 保持Image simple and small 可以提高應用程序的可移植性、降低安全風險、減少Image大小、提高Image構建和管理效率。
8. 從頭開始構建 最大限度地減少相依
9. Tag Image 使用合理的Tag，有助於對Image進行排序
10. 使用小型基礎Image 例如-slim或-alpine，可以帶來更明確的依賴項、更少的儲存、更少的安全漏洞和攻擊面以及更快的構建時間。
11. 使用官方Image 帶來可靠性、安全性、活躍的社群支持以及易用性等好處。
12. 創建臨時容器 Dockerfile定義的Image應該盡可能是臨時的，提供隔離環境、避免依賴衝突、快速清理、易於重複，提高工作效率與可靠性，方便快速測試，不必擔心對主機有影響。
13. 使用multi-stage構建 幫助減小Docker Image的大小，優化構建速度，簡化構建過程，以及提高Docker Image的安全性。...</p></div><footer class=entry-footer><span title='2023-02-14 13:56:00 +0800 CST'>2023-02-14</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;77 words&nbsp;·&nbsp;Alan</footer></div><a class=entry-link aria-label="post link to 閱讀筆記：15 Best Practices when working with Docker" href=https://sz9751210.github.io/posts/15-best-practices-when-working-with-docker/></a></article><article class=post-entry><div class=post-info><header class=entry-header><h2>Linux 定時任務[crontab]</h2></header><div class=entry-content><p>👨‍💻簡介 什麼是crontab Crontab 是一個 Unix 系統下的定時任務管理工具。它允許用戶自動在特定時間執行指令或程式，而無需人工干預。Crontab 文件中的每一行都代表一個定時任務，其中指定了任務執行的時間，以及要執行的指令或程式。
crontab用在哪 適用於週期性的任務，例如每天定時備份檔案，或者每周定時發送報表等等。使用 Crontab 可以大大簡化這些任務的管理，避免因人為錯誤而導致的問題。
語法 crontab [ -e [UserName] | -l [UserName] | -r [UserName] | -v [UserName] | File ] 選項 參數 說明 -e UserName 編輯crontab -l UserName 顯示當前用戶的crontab -r UserName 移除當前用戶的crontab -v UserName 顯示當前用戶的cron jobs狀態 格式 # ┌───────────── 分鐘 (0 - 59) # │ ┌─────────── 小時 (0 - 23) # │ │ ┌───────── 日 (1 - 31) # │ │ │ ┌─────── 月 (1 - 12) # │ │ │ │ ┌───── 星期幾 (0 - 7，0 是週日，6 是週六，7 也是週日) # │ │ │ │ │ # * * * * * /path/to/command 範例 查看自己的crontab crontab -l 查看指定用戶的crontab sudo crontab -u alan -l 編輯crontab crontab -e 編輯指定用戶的crontab sudo crontab -u alan -e 刪除crontab crontab -r 擴展 參數 說明 crontab格式 @reboot 每次重開機執行一次 @yearly 每年執行一次 0 0 1 1 * @annualy 每年執行一次 0 0 1 1 * @monthly 每月執行一次 0 0 1 * * @weekly 每週執行一次 0 0 * * 0 @daily 每天執行一次 0 0 * * * @hourly 每小時執行一次 0 * * * * 限制特定用戶執行crontab 使用場景：系統安全性考量 使用到的檔案 /etc/cron....</p></div><footer class=entry-footer><span title='2023-02-09 11:40:00 +0800 CST'>2023-02-09</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;217 words&nbsp;·&nbsp;Alan</footer></div><a class=entry-link aria-label="post link to Linux 定時任務[crontab]" href=https://sz9751210.github.io/posts/linux-crontab/></a></article><article class=post-entry><div class=post-info><header class=entry-header><h2>gcp遠端連線的幾種方式</h2></header><div class=entry-content><p>Intro🧑‍💻 紀錄有哪些方式可以ssh到gce機器
放key到中繼資料 Compute Enging -> 中繼資料 -> 安全殼層金鑰 使用TCP Tunneling
gcloud compute start-iap-tunnel --project project-id --zone vm-zone --local-host-port 127.0.0.1:10001 vm-host 22 使用gcloud ssh gcloud compute ssh --zone vm-zone vm-host --tunnel-through-iap --project project-id 可編寫tunnel的script
## dev gcloud compute start-iap-tunnel dev-border 22 --local-host-port 127.0.0.1:10120 --zone asia-east1-b --project gcp-project & ## test gcloud compute start-iap-tunnel test-border 22 --local-host-port localhost:10121 --zone asia-east1-b --project gcp-project & ## prod gcloud compute start-iap-tunnel prod-border 22 --zone asia-east1-b --local-host-port 127....</p></div><footer class=entry-footer><span title='2023-02-09 10:49:00 +0800 CST'>2023-02-09</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;100 words&nbsp;·&nbsp;Alan</footer></div><a class=entry-link aria-label="post link to gcp遠端連線的幾種方式" href=https://sz9751210.github.io/posts/gcp%E8%B7%B3%E6%9D%BF%E6%A9%9Fssh%E7%9B%B8%E9%97%9C%E8%A8%AD%E5%AE%9A/></a></article><article class=post-entry><div class=post-info><header class=entry-header><h2>terraform-ansible</h2></header><div class=entry-content><p>簡介👩‍💻 最近在研究terraform與ansible的整合，不過還在摸索中，機器的版控對於維運來講相對重要，這時候有terraform的出現，在建立機器後會隨之產生機器的狀態檔，而ansible則是在建立好機器後幫助我完成我所需的機器相關設定
這是一款terraform結合ansible的小玩具，在gcp環境下使用terraform幫我建置好機器，接著使用local exec執行ansible的playbook完成機器的設定
資料夾結構 ├───ansible-playbook │ ├───group_vars │ │ └───all │ ├───roles │ │ ├───instance │ │ │ └───tasks │ │ └───ops_agent │ │ └───tasks │ └───vars │ └───instance ├───modules │ └───main.tf │ └───variables.tf └───roles └───general └───general.tf ansible-playbook：放置ansible相關工具 modules：放置主要使用的resource以及定義好的變數 roles：放置自定義參數 使用指南 先建立gcp sa給terraform可以有建立vm的權限，接著可以下
terraform init -> 先讓terraform下載相關的repo terraform plan -> 查看terraform會做哪些事情，一開始都會先去檢查狀態檔，最上面代表動作，此範例為create，最下面的plan代表總共有4個resource會add terraform apply -> 建立機器指令，apply一樣會把plan的部分也顯示出來，並詢問是否要繼續，打上yes後便會開始建置機器 terraform destroy -> 機器建立完要刪除時下這指令，destroy一樣會去檢查狀態檔，這次的動作為destroy，最下面的plan顯示4個資源會被destroy terraform show -> 可以顯示當前terraform的狀態 🔗專案repo –> https://github.com/sz9751210/terraform-demo</p></div><footer class=entry-footer><span title='2023-01-23 19:52:00 +0800 CST'>2023-01-23</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;67 words&nbsp;·&nbsp;Alan</footer></div><figure class=entry-cover><img loading=lazy src=https://sz9751210.github.io/assets/terraform-ansible/cover.png alt></figure><a class=entry-link aria-label="post link to terraform-ansible" href=https://sz9751210.github.io/posts/terraform-ansible/></a></article><footer class=page-footer><nav class=pagination><a class=next href=https://sz9751210.github.io/page/2/>Next&nbsp;&nbsp;»</a></nav></footer></main><footer class=footer><span>&copy; 2023 <a href=https://sz9751210.github.io/>艾倫的程式之旅</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let detail=document.getElementsByClassName("details");details=[].slice.call(detail);for(let e=0;e<details.length;e++){let t=details[e];const n=t.getElementsByClassName("details-summary")[0];n&&n.addEventListener("click",()=>{t.classList.toggle("open")},!1)}</script><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>