[{"content":"👨‍💻簡介 陣列就像是一個儲存相同類型資料的容器，你可以想像成裝滿了一樣東西的盒子，每個東西都叫做陣列元素。這種類型可以是基本的，像是整數或字串，也可以是你自己定義的型別。不過陣列有個限制，就是大小一旦確定就無法改變。在Go語言裡，陣列的長度也是型別的一部分。舉例來說，[5]int和[10]int就是不同的型別。雖然它們都是整數陣列，但因為長度不同，所以視為不同的資料型別，不能直接互相給值或操作。這麼做是為了在長度上更加嚴謹，不會混淆不同大小的陣列，增加了資料的安全性。\n另一個類似的東西是切片（Slice），這東西可以想像成動態的序列，可以根據需要自由地增加或減少。不過，為了更好地理解切片，我們先學學陣列的使用。\n陣列的基本概念 陣列是由一組元素所組成的固定大小的資料結構，每個元素都有一個相應的索引。陣列的大小在宣告時就需要確定，並且在後續操作中無法改變。\n宣告和初始化陣列 在 Go 中，宣告和初始化陣列可以使用以下的語法：\nvar arr1 [3]int // 創建一個整數陣列，大小為 3 arr2 := [4]string{\u0026#34;A\u0026#34;, \u0026#34;B\u0026#34;} // 創建一個包含 4 個字串元素的陣列 arr3 := [...]int{1, 2, 3} // 自動推斷陣列大小為 3 你也可以在宣告陣列的同時，使用指定索引的方式來初始化陣列：\narr := [...]int{1: 10, 3: 30} // 陣列的值為 [0 10 0 30] 陣列的基本操作 取得陣列元素 陣列的元素可以通過索引來存取，索引從 0 開始計數。\nnumbers := [5]int{10, 20, 30, 40, 50} firstNumber := numbers[0] // 存取第一個元素，值為 10 secondNumber := numbers[1] // 存取第二個元素，值為 20 假設我們有一個陣列 arr := [5]int{1, 2, 3, 4, 5}。\narr[:] 表示整個陣列： arr := [5]int{1, 2, 3, 4, 5} arr_new := arr[:] fmt.Println(arr_new) // 輸出：[1 2 3 4 5] arr[i:] 表示從索引 i 到陣列末尾的陣列： arr := [5]int{1, 2, 3, 4, 5} startIndex := 2 arr_new := arr[startIndex:] fmt.Println(arr_new) // 輸出：[3 4 5] arr[:i] 表示從陣列開頭到索引 i-1 的切片： arr := [5]int{1, 2, 3, 4, 5} endIndex := 3 arr_new := arr[:endIndex] fmt.Println(arr_new) // 輸出：[1 2 3] 修改陣列元素 我們可以修改陣列中的元素，例如： var arr = [...]int{1, 2, 3} arr[0] = 5 fmt.Println(arr) // 輸出：[5 2 3] 遍歷陣列 可以使用傳統的索引方式或 range 來遍歷陣列中的元素：\nnumbers := [5]int{10, 20, 30, 40, 50} // 使用傳統的索引方式遍歷陣列 for i := 0; i \u0026lt; len(numbers); i++ { fmt.Println(numbers[i]) } // 使用 range 遍歷陣列 for _, num := range numbers { fmt.Println(num) } for i := range numbers { fmt.Println(numbers[i]) } range 是一個內建函式，用於遍歷陣列、切片、映射等集合型資料。在這個範例中，我們使用 range 來遍歷 numbers 陣列中的每個元素，並將每個元素的值賦值給 num 變數。\n陣列的特性、限制與使用場景 陣列的特性 固定大小： 陣列在宣告時需要確定大小，且大小不可改變。這意味著一旦陣列被創建，其大小將保持不變。 相同類型元素： 陣列內的元素必須是相同的類型，可以是內建的基本數據類型（如整數、浮點數）或自定義的結構體。 連續儲存： 陣列中的元素在記憶體中是連續儲存的，這有助於提高存取效率，因為 CPU 可以預取接下來的元素。 值類型： 陣列是值類型，當陣列被賦值給另一個陣列時，實際上是對數據的複製，而不是引用。 陣列是值類型，這意味著當你賦值或傳遞陣列時，實際上是複製整個陣列的內容。因此，對副本的修改不會影響原始陣列的值：\nvar array1 = [...]int{1, 2, 3} array2 := array1 array2[0] = 3 fmt.Println(array1, array2) // 輸出：[1 2 3] [3 2 3] 這上面的代碼展示了陣列的值類型特性。改變array2的值並不會影響array1的值。\n陣列的限制 固定大小： 陣列在宣告時需要指定固定的大小，且無法在運行時動態改變。這意味著陣列的容量是固定的，可能會限制資料集合的彈性。 資源浪費： 如果分配了比實際使用更大的陣列，可能會浪費記憶體。而若分配比需求小的陣列，可能會限制數據的存儲。 不適合動態資料： 由於固定大小，陣列不太適合儲存動態增減的資料集合，這方面切片（Slice）更適合。 使用場景 固定大小需求： 當你確定資料集合的大小是固定的，且不會變動時，陣列是一個不錯的選擇，如一週的天數、一個月的天數等。 簡單的資料儲存： 如果你僅需要儲存一些數值，且不需要動態調整大小，陣列可以很好地滿足需求。 記憶體效能要求： 陣列在記憶體中是連續儲存的，這可以提供更好的存取效能，特別是當資料量較小時。 多維資料： 陣列可以用於建立多維資料結構，例如矩陣，如果資料的結構相對固定，陣列是一個不錯的選擇。 資料安全性： 陣列的大小固定，這可以防止意外的資料溢位，有助於維護資料的安全性。 常見用法 取得陣列長度 使用內建函式len()即可取得陣列長度 var a[10]int fmt.Println(len(a)) 計算陣列元素總和 numbers := [5]int{10, 20, 30, 40, 50} var sum int for _, num := range numbers { sum += num } fmt.Println(\u0026#34;總和：\u0026#34;, sum) // 輸出總和：150 計算陣列元素平均值 numbers := [5]float64{98, 93, 77, 82, 83} var sum float64 for _, num := range numbers { sum += num } average := sum / float64(len(numbers)) fmt.Printf(\u0026#34;平均值：%.2f\\n\u0026#34;, average) // 輸出平均值：86.60 尋找最大和最小值 numbers := [5]int{10, 20, 30, 40, 50} max := numbers[0] min := numbers[0] for _, num := range numbers { if num \u0026gt; max { max = num } if num \u0026lt; min { min = num } } fmt.Println(\u0026#34;最大值：\u0026#34;, max) // 輸出最大值：50 fmt.Println(\u0026#34;最小值：\u0026#34;, min) // 輸出最小值：10 陣列反轉 numbers := [5]int{10, 20, 30, 40, 50} reversedNumbers := [5]int{} for i, j := 0, len(numbers)-1; i \u0026lt; len(numbers); i, j = i+1, j-1 { reversedNumbers[j] = numbers[i] } fmt.Println(\u0026#34;反轉陣列：\u0026#34;, reversedNumbers) // 輸出反轉陣列：[50 40 30 20 10] 小結 陣列在Go語言中是一個基本的資料結構，用來固定儲存相同類型的元素。雖然使用受限，但在需要保持順序和固定大小的資料集合時非常實用。它在儲存資料、計算總和、平均值等方面扮演重要角色。陣列能透過索引初始化，特定位置賦值，其他位置保留預設值。無論使用索引或range，都能輕鬆迭代陣列元素，進行各種操作。陣列值需相同類型，且在記憶體中連續儲存，存取效率高。但記住，陣列大小固定，儲存可變數量元素可考慮使用切片。\n📚Reference Effective Go - The Go Programming Language [Golang] Slice and Array | PJCHENder 未整理筆記 ","permalink":"https://sz9751210.github.io/posts/go-array/","summary":"👨‍💻簡介 陣列就像是一個儲存相同類型資料的容器，你可以想像成裝滿了一樣東西的盒子，每個東西都叫做陣列元素。這種類型可以是基本的，像是整數或字串，也可以是你自己定義的型別。不過陣列有個限制，就是大小一旦確定就無法改變。在Go語言裡，陣列的長度也是型別的一部分。舉例來說，[5]int和[10]int就是不同的型別。雖然它們都是整數陣列，但因為長度不同，所以視為不同的資料型別，不能直接互相給值或操作。這麼做是為了在長度上更加嚴謹，不會混淆不同大小的陣列，增加了資料的安全性。\n另一個類似的東西是切片（Slice），這東西可以想像成動態的序列，可以根據需要自由地增加或減少。不過，為了更好地理解切片，我們先學學陣列的使用。\n陣列的基本概念 陣列是由一組元素所組成的固定大小的資料結構，每個元素都有一個相應的索引。陣列的大小在宣告時就需要確定，並且在後續操作中無法改變。\n宣告和初始化陣列 在 Go 中，宣告和初始化陣列可以使用以下的語法：\nvar arr1 [3]int // 創建一個整數陣列，大小為 3 arr2 := [4]string{\u0026#34;A\u0026#34;, \u0026#34;B\u0026#34;} // 創建一個包含 4 個字串元素的陣列 arr3 := [...]int{1, 2, 3} // 自動推斷陣列大小為 3 你也可以在宣告陣列的同時，使用指定索引的方式來初始化陣列：\narr := [...]int{1: 10, 3: 30} // 陣列的值為 [0 10 0 30] 陣列的基本操作 取得陣列元素 陣列的元素可以通過索引來存取，索引從 0 開始計數。\nnumbers := [5]int{10, 20, 30, 40, 50} firstNumber := numbers[0] // 存取第一個元素，值為 10 secondNumber := numbers[1] // 存取第二個元素，值為 20 假設我們有一個陣列 arr := [5]int{1, 2, 3, 4, 5}。","title":"陣列：Go語言中的數據小倉庫"},{"content":"👨‍💻簡介 本文簡單介紹了 Go 語言的流程控制概念，涵蓋了從條件語句到迴圈，再到 range 遍歷數據結構，以及 goto 與標籤 label 的應用。主要知識點為如何使用 if 語句進行條件判斷，以及在不同情況下運用 switch 語句。此外，還探討了 for 迴圈和 range 的運用，以及在特定情境下使用 goto 與 label。\n條件語句 在 Go 語言中，我們可以使用條件語句來根據不同的條件執行不同的程式碼塊。常見的條件語句包括：\nif 語句 if 語句用來檢查一個條件是否成立，如果條件為真，就執行相關的程式碼塊。例如：\nage := 18 if age \u0026gt;= 18 { fmt.Println(\u0026#34;你已成年\u0026#34;) } else { fmt.Println(\u0026#34;你還未成年\u0026#34;) } 我們也可以使用 else if 分支處理多種情況：\nage := 25 if age \u0026lt; 18 { fmt.Println(\u0026#34;你還未成年\u0026#34;) } else if age \u0026gt;= 18 \u0026amp;\u0026amp; age \u0026lt; 60 { fmt.Println(\u0026#34;你已成年，但尚未退休\u0026#34;) } else { fmt.Println(\u0026#34;你已退休\u0026#34;) } 我們甚至可以在 if 語句中宣告並初始化一個變數，然後根據條件進行判斷：\nif num2 := 10; num2 \u0026gt;= 10 { fmt.Println(\u0026#34;變數 num2 大於等於 10\u0026#34;) } switch 語句 switch 語句用來根據不同的值進行不同的處理。我們可以使用 switch 來避免多個 if 判斷。例如：\nday := \u0026#34;Sunday\u0026#34; switch day { case \u0026#34;Monday\u0026#34;: fmt.Println(\u0026#34;星期一\u0026#34;) case \u0026#34;Tuesday\u0026#34;: fmt.Println(\u0026#34;星期二\u0026#34;) case \u0026#34;Sunday\u0026#34;: fmt.Println(\u0026#34;星期天\u0026#34;) default: fmt.Println(\u0026#34;其他天\u0026#34;) } 我們也可以在 switch 語句中宣告並初始化一個變數，然後根據其值進行判斷：\nswitch day := \u0026#34;Sunday\u0026#34;; day { case \u0026#34;Monday\u0026#34;: fmt.Println(\u0026#34;星期一\u0026#34;) case \u0026#34;Tuesday\u0026#34;: fmt.Println(\u0026#34;星期二\u0026#34;) case \u0026#34;Sunday\u0026#34;: fmt.Println(\u0026#34;星期天\u0026#34;) default: fmt.Println(\u0026#34;其他天\u0026#34;) } 我們甚至可以在 case 中處理多個值，共用相同的程式碼塊，例如：\nday := \u0026#34;Saturday\u0026#34; switch day { case \u0026#34;Monday\u0026#34;, \u0026#34;Tuesday\u0026#34;, \u0026#34;Wednesday\u0026#34;, \u0026#34;Thursday\u0026#34;, \u0026#34;Friday\u0026#34;: fmt.Println(\u0026#34;工作日\u0026#34;) case \u0026#34;Saturday\u0026#34;, \u0026#34;Sunday\u0026#34;: fmt.Println(\u0026#34;週末\u0026#34;) default: fmt.Println(\u0026#34;其他\u0026#34;) } 迴圈 迴圈是一種重複執行程式碼塊的結構。Go 語言提供了幾種迴圈方式：\nfor 迴圈 for 迴圈用來重複執行一段程式碼塊，可以指定初始值、條件和遞增方式。例如：\nfor i := 0; i \u0026lt; 5; i++ { fmt.Println(i) } while 迴圈 Go 語言中沒有 while 關鍵字，但我們可以使用 for 迴圈來實現類似的功能：\nnum := 0 for num \u0026lt; 5 { fmt.Println(num) num++ } 無限迴圈 我們可以使用 for 迴圈來創建無限迴圈，例如：\nfor { fmt.Println(\u0026#34;無限迴圈\u0026#34;) } 使用 range 遍歷數據結構 除了上述的迴圈方式外，我們還可以使用 range 關鍵字來遍歷數組、切片、字串、映射等數據結構。例如：\nnumbers := []int{1, 2, 3, 4, 5} for index, value := range numbers { fmt.Printf(\u0026#34;索引 %d 的值為 %d\\n\u0026#34;, index, value) } word := \u0026#34;Hello\u0026#34; for index, char := range word { fmt.Printf(\u0026#34;索引 %d 的字符為 %c\\n\u0026#34;, index, char) } 跳出與繼續 在迴圈中，我們可以使用 break 來提前結束迴圈，使用 continue 來跳過本次迭代，繼續下一次迭代。\nfor i := 0; i \u0026lt; 5; i++ { if i == 2 { continue // 跳過本次迭代，繼續下一次迭代 } if i == 4 { break // 提前結束迴圈 } fmt.Println(i) } 跳轉語句 goto 在某些情況下，我們可能需要使用 goto 來直接跳轉到程式碼中的指定標籤位置。然而，goto 往往會讓程式碼變得複雜且難以理解，因此在實際開發中應謹慎使用。\nfunc main() { i := 0 Loop: fmt.Println(i) i++ if i \u0026lt; 5 { goto Loop } } 標籤 label label 是一種用於標記程式碼位置的方式，通常與 goto 一起使用。較少使用 label 和 goto 的程式碼更容易閱讀和維護。以下是一個使用 label 和 goto 的範例：\nfunc main() { outer := 0 LoopOuter: for outer \u0026lt; 3 { inner := 0 LoopInner: for inner \u0026lt; 3 { fmt.Printf(\u0026#34;外部迴圈：%d，內部迴圈：%d\\n\u0026#34;, outer, inner) inner++ goto LoopInner } outer++ goto LoopOuter } } 注意事項 在使用條件語句時，確保清楚地理解不同分支的執行情況，避免邏輯錯誤。 在使用迴圈時，謹記設定適當的終止條件，以免陷入無限迴圈。 📚Reference Effective Go - The Go Programming Language [Golang] 流程控制 Control Flow | PJCHENder 未整理筆記 ","permalink":"https://sz9751210.github.io/posts/go-control-flow/","summary":"👨‍💻簡介 本文簡單介紹了 Go 語言的流程控制概念，涵蓋了從條件語句到迴圈，再到 range 遍歷數據結構，以及 goto 與標籤 label 的應用。主要知識點為如何使用 if 語句進行條件判斷，以及在不同情況下運用 switch 語句。此外，還探討了 for 迴圈和 range 的運用，以及在特定情境下使用 goto 與 label。\n條件語句 在 Go 語言中，我們可以使用條件語句來根據不同的條件執行不同的程式碼塊。常見的條件語句包括：\nif 語句 if 語句用來檢查一個條件是否成立，如果條件為真，就執行相關的程式碼塊。例如：\nage := 18 if age \u0026gt;= 18 { fmt.Println(\u0026#34;你已成年\u0026#34;) } else { fmt.Println(\u0026#34;你還未成年\u0026#34;) } 我們也可以使用 else if 分支處理多種情況：\nage := 25 if age \u0026lt; 18 { fmt.Println(\u0026#34;你還未成年\u0026#34;) } else if age \u0026gt;= 18 \u0026amp;\u0026amp; age \u0026lt; 60 { fmt.Println(\u0026#34;你已成年，但尚未退休\u0026#34;) } else { fmt.","title":"探索 Go 語言的流程控制"},{"content":"👨‍💻簡介 本文快速介紹了 Go 語言中的各種運算符，從數學計算到邏輯判斷，包括自增自減、賦值、比較和位運算。透過實例和清晰的解釋，快速掌握如何在程式中運用這些運算符。\n算術運算符 在 Go 語言中，我們可以使用各種算術運算符來執行基本的數學運算。以下是一些常用的算術運算符：\n+：加法運算，用來將兩個數相加。 -：減法運算，用來從一個數中減去另一個數。 *：乘法運算，用來將兩個數相乘。 /：除法運算，用來將一個數除以另一個數。 %：求餘運算，用來得到兩個數相除的餘數。 例如：\na := 5 b := 3 c := a + b // c 的值是 8 d := a * b // d 的值是 15 此外，我們還有自增和自減運算符，它們用來讓變數的值增加或減少 1：\n++：自增運算符，將變數的值增加 1。 --：自減運算符，將變數的值減少 1。 舉個例子：\nx := 10 x++ // x 的值變成了 11 y := 5 y-- // y 的值變成了 4 賦值運算符 賦值運算符用來將一個值賦給一個變數。我們常見的賦值運算符有：\n=：將右邊的值賦給左邊的變數。 +=：先將右邊的值加到左邊的變數上，然後再將結果賦給左邊的變數。 -=：先從左邊的變數中減去右邊的值，然後再將結果賦給左邊的變數。 *=：先將左邊的變數乘以右邊的值，然後再將結果賦給左邊的變數。 /=：先將左邊的變數除以右邊的值，然後再將結果賦給左邊的變數。 %=：先將左邊的變數除以右邊的值取餘數，然後再將結果賦給左邊的變數。 簡單範例如下：\na := 10 b := 5 // = a = 20 // a 的值變成了 20 // += a += b // 等同於 a = a + b，所以 a 的值變成了 25 // -= a -= b // 等同於 a = a - b，所以 a 的值變成了 20 // *= a *= b // 等同於 a = a * b，所以 a 的值變成了 100 // /= a /= b // 等同於 a = a / b，所以 a 的值變成了 20 // %= a %= b // 等同於 a = a % b，所以 a 的值變成了 0 比較運算符 比較運算符用來比較兩個值的大小或者是否相等。我們常用的比較運算符有：\n==：判斷兩個值是否相等。 !=：判斷兩個值是否不相等。 \u0026lt;：判斷左邊的值是否小於右邊的值。 \u0026gt;：判斷左邊的值是否大於右邊的值。 \u0026lt;=：判斷左邊的值是否小於等於右邊的值。 \u0026gt;=：判斷左邊的值是否大於等於右邊的值。 以下為使用範例：\nx := 10 y := 5 isEqual := x == y // false，因為 x 不等於 y isNotEqual := x != y // true，因為 x 不等於 y isLess := x \u0026lt; y // false，因為 x 不小於 y isGreater := x \u0026gt; y // true，因為 x 大於 y isLessOrEqual := x \u0026lt;= y // false，因為 x 不小於等於 y isGreaterOrEqual := x \u0026gt;= y // true，因為 x 大於等於 y 邏輯運算符 邏輯運算符用來執行邏輯操作。我們常用的邏輯運算符有：\n\u0026amp;\u0026amp;：邏輯與，用來判斷多個條件是否同時滿足。 ||：邏輯或，用來判斷多個條件是否至少有一個滿足。 !：邏輯非，用來取反一個條件的結果。 以下為使用範例：\np := true q := false andResult := p \u0026amp;\u0026amp; q // false，因為 p 和 q 不都為 true orResult := p || q // true，因為 p 或 q 至少有一個為 true notResult := !p // false，因為 p 為 true，取反後為 false 位運算符 位運算符用來在二進制位級別執行操作。我們常用的位運算符有：\n\u0026amp;：按位與，對每一位進行與操作。 |：按位或，對每一位進行或操作。 ^：按位異或，對每一位進行異或操作。 \u0026lt;\u0026lt;：左移，將二進制位向左移動指定的位數。 \u0026gt;\u0026gt;：右移，將二進制位向右移動指定的位數。 以下為使用範例：\na := 5 // 二進制表示：0101 b := 3 // 二進制表示：0011 andResult := a \u0026amp; b // 二進制表示：0001，十進制表示：1 orResult := a | b // 二進制表示：0111，十進制表示：7 xorResult := a ^ b // 二進制表示：0110，十進制表示：6 leftShiftResult := a \u0026lt;\u0026lt; 1 // 二進制表示：1010，十進制表示：10 rightShiftResult := a \u0026gt;\u0026gt; 1 // 二進制表示：0010，十進制表示：2 其他運算符 其他運算符用來執行一些特定的操作。我們常用的其他運算符有：\n\u0026amp;：取地址，用來獲取變數的內存地址。 *：指針，用來聲明指針變數。 \u0026lt;-：通道操作符，用來發送和接收通道消息。 以下為使用範例：\nvar num int = 42 ptr := \u0026amp;num // ptr 現在包含 num 的內存地址 var value int = *ptr // value 現在包含 ptr 所指向的內存中的值 ch := make(chan int) // 創建一個整數通道 ch \u0026lt;- 10 // 將值 10 發送到通道 ch 中 receivedValue := \u0026lt;-ch // 從通道 ch 接收值並存儲在 receivedValue 中 📚Reference The Go Programming Language Specification - The Go Programming Language Go Operators - GeeksforGeeks ","permalink":"https://sz9751210.github.io/posts/go-operator/","summary":"👨‍💻簡介 本文快速介紹了 Go 語言中的各種運算符，從數學計算到邏輯判斷，包括自增自減、賦值、比較和位運算。透過實例和清晰的解釋，快速掌握如何在程式中運用這些運算符。\n算術運算符 在 Go 語言中，我們可以使用各種算術運算符來執行基本的數學運算。以下是一些常用的算術運算符：\n+：加法運算，用來將兩個數相加。 -：減法運算，用來從一個數中減去另一個數。 *：乘法運算，用來將兩個數相乘。 /：除法運算，用來將一個數除以另一個數。 %：求餘運算，用來得到兩個數相除的餘數。 例如：\na := 5 b := 3 c := a + b // c 的值是 8 d := a * b // d 的值是 15 此外，我們還有自增和自減運算符，它們用來讓變數的值增加或減少 1：\n++：自增運算符，將變數的值增加 1。 --：自減運算符，將變數的值減少 1。 舉個例子：\nx := 10 x++ // x 的值變成了 11 y := 5 y-- // y 的值變成了 4 賦值運算符 賦值運算符用來將一個值賦給一個變數。我們常見的賦值運算符有：\n=：將右邊的值賦給左邊的變數。 +=：先將右邊的值加到左邊的變數上，然後再將結果賦給左邊的變數。 -=：先從左邊的變數中減去右邊的值，然後再將結果賦給左邊的變數。 *=：先將左邊的變數乘以右邊的值，然後再將結果賦給左邊的變數。 /=：先將左邊的變數除以右邊的值，然後再將結果賦給左邊的變數。 %=：先將左邊的變數除以右邊的值取餘數，然後再將結果賦給左邊的變數。 簡單範例如下：","title":"Go 語言的各種運算符"},{"content":"甚麼是secret 在 Kubernetes 裡，Secret 就像是一個保險箱，可以放你任何不想公開的東西。比如說密碼、API 金鑰、憑證等，這樣的資料可能會被放在 Pod 裡，但你可以用 Secret 來避免直接在應用程式的程式碼中暴露這些機密資料。 可以說 Secret 就像是 ConfigMap 的一個好朋友，但更專門用來保護機密資料的地方。\n為甚麼需要secret 最主要的用意是保護你的敏感資訊，不讓它們在 Pod 或容器中以明文流傳。這樣可以讓我們的應用程式變得更安全，減少機密資訊外洩的風險。還能讓你的秘密資料在不同 Pod 之間分享，並且保有安全性。\n何時使用secret 保存必要應用程式的憑證，如 TLS 證書，以確保安全通信。 儲存應用程式所需的金鑰，包括外部服務的 API 金鑰，確保安全連接。 保管敏感的環境變數，如資料庫密碼等機密驗證資訊，維護應用程式安全性。 安全儲存驗證資訊，如 OAuth 令牌，用於與其他應用程式進行安全交互。 維持隱私的配置設定，如設定文件、金鑰路徑等，確保敏感資訊不外洩。 secret的類型有哪些 內建類型 用途 Opaque 使用者定義的任意資料 kubernetes.io/service-account-token 服務帳戶令牌 kubernetes.io/dockercfg ~/.dockercfg 檔案的序列化形式 kubernetes.io/dockerconfigjson ~/.docker/config.json 檔案的序列化形式 kubernetes.io/basic-auth 用於基本身份驗證的憑證 kubernetes.io/ssh-auth 用於 SSH 身份驗證的憑證 kubernetes.io/tls 用於 TLS 客戶端或伺服器端的資料 bootstrap.kubernetes.io/token 啟動引導令牌資料 如何撰寫使用secret 建立secret 聲明式 apiVersion: v1 kind: Secret metadata: name: my-secret data: username: YWRtaW4= # Base64 編碼的 \u0026#34;admin\u0026#34; password: c2VjcmV0cGFzc3dvcmQ= # Base64 編碼的 \u0026#34;secretpassword\u0026#34; 宣告式 從命令行傳遞資訊建立secret kubectl create secret generic my-secret --from-literal=username=admin --from-literal=password=secretpassword 從檔案建立secret kubectl create secret generic my-secret --from-file=path/to/username.txt --from-file=path/to/password.txt 使用secret 我們可以用剛剛創建的 my-secret 來做以下的範例\nsecret作為環境變數 apiVersion: v1 kind: Pod metadata: name: secret-env-demo-pod spec: containers: - name: demo-container image: busybox command: [\u0026#34;/bin/sh\u0026#34;, \u0026#34;-c\u0026#34;, \u0026#34;echo Username: $USERNAME \u0026amp;\u0026amp; echo Password: $PASSWORD\u0026#34;] env: - name: USERNAME valueFrom: secretKeyRef: name: my-secret key: username - name: PASSWORD valueFrom: secretKeyRef: name: my-secret key: password restartPolicy: Never 透過kubectl logs secret-env-demo-pod查看log\nUsername: admin Password: secretpassword 將secret掛載到一個或多個容器 apiVersion: v1 kind: Pod metadata: name: secret-volume-demo-pod spec: containers: - name: first-container image: busybox command: [\u0026#34;/bin/sh\u0026#34;, \u0026#34;-c\u0026#34;, \u0026#34;cat /etc/secret/username\u0026#34;] volumeMounts: - name: secret-volume mountPath: /etc/secret - name: second-container image: busybox command: [\u0026#34;/bin/sh\u0026#34;, \u0026#34;-c\u0026#34;, \u0026#34;cat /etc/secret/password\u0026#34;] volumeMounts: - name: secret-volume mountPath: /etc/secret volumes: - name: secret-volume secret: secretName: my-secret 使用以下命令檢查輸出\nkubectl logs secret-volume-demo-pod -c first-container kubectl logs secret-volume-demo-pod -c second-container output\n## first-container admin ## second-container secretpassword secret作為拉取private registry image時使用 apiVersion: v1 kind: Pod metadata: name: secret-imagepull-demo-pod spec: containers: - name: demo-container image: \u0026lt;private_registry_image\u0026gt; imagePullSecrets: - name: my-secret secret有哪些特點 強大的資料加密：Secret 的一大優點在於它可以對敏感資料進行強大的加密保護。這保障了秘密資訊不會輕易被未授權的人看到，大幅減低了資訊外洩的風險。 Base64 編碼的轉換：Secret 在儲存資料時會使用 Base64 編碼，但是請注意這並非最高等級的安全標準，它不能取代真正的加密方法。這樣的編碼能夠保護資料，但需要在操作時謹慎以保障資訊安全。 簡便的整合：透過 Secret，我們能夠輕鬆地將敏感資料整合到應用程式中，例如透過環境變數、掛載資料夾等方式，讓 Pod 可以無縫地使用這些敏感資料。 安全的資訊分享：Secret 也提供了一種安全的方式，讓不同的 Pod 或其他 Kubernetes 資源可以共用敏感資訊，同時保持資料的保密性。這讓不同部分的應用能夠互相協作，同時不會威脅資訊安全。 Reference Secret | Kubernetes ","permalink":"https://sz9751210.github.io/posts/k8s-secret/","summary":"甚麼是secret 在 Kubernetes 裡，Secret 就像是一個保險箱，可以放你任何不想公開的東西。比如說密碼、API 金鑰、憑證等，這樣的資料可能會被放在 Pod 裡，但你可以用 Secret 來避免直接在應用程式的程式碼中暴露這些機密資料。 可以說 Secret 就像是 ConfigMap 的一個好朋友，但更專門用來保護機密資料的地方。\n為甚麼需要secret 最主要的用意是保護你的敏感資訊，不讓它們在 Pod 或容器中以明文流傳。這樣可以讓我們的應用程式變得更安全，減少機密資訊外洩的風險。還能讓你的秘密資料在不同 Pod 之間分享，並且保有安全性。\n何時使用secret 保存必要應用程式的憑證，如 TLS 證書，以確保安全通信。 儲存應用程式所需的金鑰，包括外部服務的 API 金鑰，確保安全連接。 保管敏感的環境變數，如資料庫密碼等機密驗證資訊，維護應用程式安全性。 安全儲存驗證資訊，如 OAuth 令牌，用於與其他應用程式進行安全交互。 維持隱私的配置設定，如設定文件、金鑰路徑等，確保敏感資訊不外洩。 secret的類型有哪些 內建類型 用途 Opaque 使用者定義的任意資料 kubernetes.io/service-account-token 服務帳戶令牌 kubernetes.io/dockercfg ~/.dockercfg 檔案的序列化形式 kubernetes.io/dockerconfigjson ~/.docker/config.json 檔案的序列化形式 kubernetes.io/basic-auth 用於基本身份驗證的憑證 kubernetes.io/ssh-auth 用於 SSH 身份驗證的憑證 kubernetes.io/tls 用於 TLS 客戶端或伺服器端的資料 bootstrap.kubernetes.io/token 啟動引導令牌資料 如何撰寫使用secret 建立secret 聲明式 apiVersion: v1 kind: Secret metadata: name: my-secret data: username: YWRtaW4= # Base64 編碼的 \u0026#34;admin\u0026#34; password: c2VjcmV0cGFzc3dvcmQ= # Base64 編碼的 \u0026#34;secretpassword\u0026#34; 宣告式 從命令行傳遞資訊建立secret kubectl create secret generic my-secret --from-literal=username=admin --from-literal=password=secretpassword 從檔案建立secret kubectl create secret generic my-secret --from-file=path/to/username.","title":"Kubernetes Secret"},{"content":"👨‍💻簡介 Go 語言有各種資料型別，分為基本型別和複合型別。基本型別包括：\n整數、浮點數、布林值、字串 複合型別包括：\n陣列、片段、結構、函式、對映、通道、介面 等。 整數型別 整數型別有許多種，像是 int8、int16、int32、int64。我們可以依據實際需求選擇。\n你甚至可以使用 int 關鍵字，它會依據不同作業系統自動選擇大小：\n在 32 位作業系統：int 會變成 int32 在 64 位作業系統：int 會變成 int64 但是，別忘了，數字型別還有其範圍和特點。\n型別 位元組數 最小值 最大值 次方範圍 int8 1 -128 127 -2^7 至 2^7-1 int16 2 -32,768 32,767 -2^15 至 2^15-1 int32 4 -2,147,483,648 2,147,483,647 -2^31 至 2^31-1 int64 8 -9,223,372,036,854,775,808 9,223,372,036,854,775,807 -2^63 至 2^63-1 uint8 1 0 255 0 至 2^8-1 uint16 2 0 65,535 0 至 2^16-1 uint32 4 0 4,294,967,295 0 至 2^32-1 uint64 8 0 18,446,744,073,709,551,615 0 至 2^64-1 可以通過 unsafe.Sizeof 來查看不同長度的整數，在記憶體中的儲存空間。\nvar num2 = 12 fmt.Println(unsafe.Sizeof(num2)) 轉換型別 要進行型別轉換，只需在變數前面指定目標型別即可。\nvar a1 int16 = 10 var a2 int32 = 12 var a3 = int32(a1) + a2 fmt.Println(a3) 但當高位轉低位時，可能會有精度損失。例如，從 16 位轉為 8 位，可能會有數據丟失。\nvar n1 int16 = 130 fmt.Println(int8(n1)) // 變成 -126 數值字面量(literal) 自 Go 1.13 版本起，你可以使用數值字面量語法，以二進制、八進制或十六進制格式來定義數字：\nv := 0b00101101 // 代表二進制的101101 v := 0o377 // 代表八進制的377 進制轉換 你可以透過不同進制來表示數字，例如：\nvar number = 17 fmt.Printf(\u0026#34;原樣輸出：%v\\n\u0026#34;, number) fmt.Printf(\u0026#34;十進制輸出：%d\\n\u0026#34;, number) fmt.Printf(\u0026#34;八進制輸出：%o\\n\u0026#34;, number) fmt.Printf(\u0026#34;二進制輸出：%b\\n\u0026#34;, number) fmt.Printf(\u0026#34;十六進制輸出：%x\\n\u0026#34;, number) 浮點數型別 Go 語言支援兩種浮點數型別：float32 和 float64。這兩種浮點數遵循 IEEE754 標準：\nfloat32 的最大範圍約為 3.4e38，你可以使用常數 math.MaxFloat32 來表示。 float64 的最大範圍約為 1.8e308，你可以使用常數 math.MaxFloat64 來表示。 打印浮點數時，可以使用 fmt 套件的 %f 來控制小數點位數：\nvar pi = math.Pi fmt.Printf(\u0026#34;預設小數點後6位：%f\\n\u0026#34;, pi) fmt.Printf(\u0026#34;小數點後保留2位：%.2f\\n\u0026#34;, pi) 浮點數精度問題 幾乎所有程式語言都會有精度損失的問題，這在計算機科學中是常見的問題。例如：\nd := 1129.6 fmt.Println(d * 100) // 輸出 112959.99999999 如果需要高精度計算，可以考慮使用第三方套件來解決，例如：\nshopspring/decimal: 在 Go 中實現的任意精度固定小數點數字 (github.com)\n布林型別 定義布林型別很簡單：\nvar fl = false if fl { fmt.Println(\u0026#34;true\u0026#34;) } else { fmt.Println(\u0026#34;false\u0026#34;) } 字串型別 在 Go 語言中，字串是原生資料型別，與其他型別一樣使用。Go 語言內部使用 UTF-8 編碼來表示字串。你可以在雙引號（\u0026quot;）中放置內容來表示字串，甚至可以在程式碼中添加非 ASCII 字元。\ns1 := \u0026#34;hello\u0026#34; s2 := \u0026#34;你好\u0026#34; 如果想要定義多行字串，可以使用反引號：\nvar str = `這是第一行 這是第二行` fmt.Println(str) 字串還支援許多常見的操作，例如計算長度、串接、分割、判斷是否包含、前綴和後綴判斷、尋找子字串位置等。\n字串常見操作 len(str)：計算長度 + 或 fmt.Sprintf：串接字串 strings.Split：分割字串 strings.Contains：判斷是否包含 strings.HasPrefix，strings.HasSuffix：前綴/後綴判斷 strings.Index()，strings.LastIndex()：子字串出現的位置 strings.Join()：合併操作 strings.Index()：判斷在字串中的位置 byte 和 rune 型別 構成每個字串的元素稱為「字符」，可以通過遍歷字串元素獲取字符。字符使用單引號 \u0026rsquo;\u0026rsquo; 包裹起來。\nGo語言中的字符有以下兩種型別：\nuint8型別：也叫byte型，代表了ACII碼的一個字符 rune型別：代表一個UTF-8字符 當需要處理中文、日文或其他複合字符時，就需要使用rune型別。rune型別實際上是一個int32。\nGo使用了特殊的rune型別來處理Unicode，讓基於Unicode的文本處理更加方便。也可以使用byte型進行默認字串處理，性能和擴展性都得到考慮。\n需要注意的是，在Go語言中，一個漢字佔用3個位元組（UTF-8編碼），一個字母佔用1個位元組。\npackage main import \u0026#34;fmt\u0026#34; func main() { var a byte = \u0026#39;a\u0026#39; fmt.Println(a) // 輸出ASCII碼值，直接輸出byte（字符）時，顯示字符對應的碼值 fmt.Printf(\u0026#34;%c\u0026#34;, a) // 輸出字符 \u0026#39;a\u0026#39; s := \u0026#34;你好 golang\u0026#34; for i := 0; i \u0026lt; len(s); i++ { fmt.Printf(\u0026#34;%v(%c)\\t\u0026#34;, s[i], s[i]) // 使用 len 循環輸出 ASCII 碼 } for index, v := range s { fmt.Println(index, v) // 通過rune打印UTF-8字符 } } 修改字串 要修改字串，需要先將其轉換成[]rune 或 []byte型別，完成後再轉換成string型別。無論哪種轉換都會重新分配內存，並複製位元組陣列。\n轉換為[]byte型別\ns1 := \u0026#34;big\u0026#34; byteS1 := []byte(s1) byteS1[0] = \u0026#39;p\u0026#39; fmt.Println(string(byteS1)) 轉換為rune型別\ns2 := \u0026#34;你好golang\u0026#34; byteS2 := []rune(s2) byteS2[0] = \u0026#39;我\u0026#39; fmt.Println(string(byteS2)) 基本型別轉換 數值型別轉換 // 整數和浮點數之間的轉換 var aa int8 = 20 var bb int16 = 40 fmt.Println(int16(aa) + bb) // 建議從整數轉換為浮點數 var cc int8 = 20 var dd float32 = 40 fmt.Println(float32(cc) + dd) 建議從低位轉換為高位，這樣可以避免丟失精度。\n轉換為字串型別 轉換為字串型別有兩種方法，一是使用 fmt.Sprintf()，二是使用 strconv 套件的函式。\n使用 fmt.Sprintf()：\n// 字串型別轉換 var i int = 20 var f float64 = 12.456 var t bool = true var b byte = \u0026#39;a\u0026#39; str1 := fmt.Sprintf(\u0026#34;%d\u0026#34;, i) fmt.Printf(\u0026#34;類型：%v-%T \\n\u0026#34;, str1, str1) str2 := fmt.Sprintf(\u0026#34;%f\u0026#34;, f) fmt.Printf(\u0026#34;類型：%v-%T \\n\u0026#34;, str2, str2) str3 := fmt.Sprintf(\u0026#34;%t\u0026#34;, t) fmt.Printf(\u0026#34;類型：%v-%T \\n\u0026#34;, str3, str3) str4 := fmt.Sprintf(\u0026#34;%c\u0026#34;, b) fmt.Printf(\u0026#34;類型：%v-%T \\n\u0026#34;, str4, str4) 使用 strconv 套件的函式：\n// 將int型別轉換為str型別 var num1 int64 = 20 s1 := strconv.FormatInt(num1, 10) fmt.Printf(\u0026#34;轉換：%v - %T\u0026#34;, s1, s1) // 將float型別轉換為string型別 var num2 float64 = 3.1415926 /* 參數1：要轉換的值 參數2：格式化型別 \u0026#39;f\u0026#39;表示float，\u0026#39;b\u0026#39;表示二進制，‘e’表示十進制 參數3：表示保留的小數點，-1表示不格式化小數點 參數4：格式化的型別，傳入64位或32位 */ s2 := strconv.FormatFloat(num2, \u0026#39;f\u0026#39;, -1, 64) fmt.Printf(\u0026#34;轉換：%v-%T\u0026#34;, s2, s2) 字串轉換為數值型別 將字串轉換為數值型別也很容易，使用 strconv 套件即可：\nstr := \u0026#34;10\u0026#34; // 第一個參數：需要轉換的數值，第二個參數：進制，參數三：32位或64位 num,_ = strconv.ParseInt(str, 10, 64) // 轉換為float型別 str2 := \u0026#34;3.141592654\u0026#34; num,_ = strconv.ParseFloat(str2, 10) 記得檢查轉換錯誤（例如無效的字串格式），這就是 _ 的作用。\n📚Reference\nGo Data Types (w3schools.com) Data Types in Go - GeeksforGeeks [Golang] 資料型別 Data Types | PJCHENder 未整理筆記 ","permalink":"https://sz9751210.github.io/posts/golang-datatype/","summary":"👨‍💻簡介 Go 語言有各種資料型別，分為基本型別和複合型別。基本型別包括：\n整數、浮點數、布林值、字串 複合型別包括：\n陣列、片段、結構、函式、對映、通道、介面 等。 整數型別 整數型別有許多種，像是 int8、int16、int32、int64。我們可以依據實際需求選擇。\n你甚至可以使用 int 關鍵字，它會依據不同作業系統自動選擇大小：\n在 32 位作業系統：int 會變成 int32 在 64 位作業系統：int 會變成 int64 但是，別忘了，數字型別還有其範圍和特點。\n型別 位元組數 最小值 最大值 次方範圍 int8 1 -128 127 -2^7 至 2^7-1 int16 2 -32,768 32,767 -2^15 至 2^15-1 int32 4 -2,147,483,648 2,147,483,647 -2^31 至 2^31-1 int64 8 -9,223,372,036,854,775,808 9,223,372,036,854,775,807 -2^63 至 2^63-1 uint8 1 0 255 0 至 2^8-1 uint16 2 0 65,535 0 至 2^16-1 uint32 4 0 4,294,967,295 0 至 2^32-1 uint64 8 0 18,446,744,073,709,551,615 0 至 2^64-1 可以通過 unsafe.","title":"Golang 的資料型別一覽"},{"content":"👨‍💻簡介 在 Golang 中，你可以使用不同的方式來宣告變數和常數。宣告變數時，可以直接指定值，或者使用型別推導，更簡單地用 := 來宣告局部變數。另外，還可以一次宣告多個變數，相同型別的變數可以一起宣告，或者使用括號宣告不同型別的變數。常數則使用 const 關鍵字宣告，確保值不變，有助於提高程式碼的可讀性和穩定性。\n變數的聲明 在 Golang 裡，變數是程式中保存資料的容器。變數名稱由字母、數字、底線組成，但首個字符不能是數字。Golang 的關鍵字和保留字都不能用作變數名稱。\n變數的宣告和初始化方式多種多樣，在使用變數之前，需要先聲明變數。在同一範圍內，不允許重複聲明相同的變數。而且，一旦聲明變數，就必須在之後的程式碼中使用它。\n如果變數在聲明後沒有進行初始化，則打印出來的值將是空的。\n如何定義變數 單變數宣告 普通聲明(variable declaration) 使用 var 關鍵字進行普通聲明，然後指定變數名稱和類型，再賦予初始值。 var name string name = \u0026#34;Alan\u0026#34; 帶初始化的聲明(direct define)： 可以直接指定變數的類型和初始值。 var age int = 25 也可以省略類型，讓變數類型根據初始值自動推斷。\nvar age = 25 簡短變數聲明(short declaration) 在函式內部，可以使用簡化的 := 語法同時宣告並初始化變數。 注意：簡短變數聲明只能用於局部變數，不能用於全局變數的聲明。\nfoo := \u0026#34;hello\u0026#34; bar := 100 多變數宣告 普通聲明 您可以同時宣告多個相同類型的變數。 var a, b int a = 10 b = 20 帶初始化的聲明(direct define)： 可以直接指定多個變數的類型和初始值。 var x, y int = 5, 8 也可以省略類型，讓變數類型根據初始值自動推斷。\nvar x, y = 5, 8 使用簡短變數聲明： 同樣也可以使用簡化的 := 語法同時宣告多個變數。 x, y := 5, 8 使用括號的平行賦值 使用括號 () 可以同時宣告多個不同類型的變數並賦予初始值。 var( foo string bar int ) var ( foo = 5 bar = \u0026#34;abc\u0026#34; ) var ( name string = \u0026#34;Alice\u0026#34; age int = 25 country string = \u0026#34;USA\u0026#34; ) 匿名變數 使用 _ 符號表示匿名變數，適用於不需要使用的變數。\n_, result := calculateSomething() 常數的定義與使用 常數是不會變動的值，可用於定義程式運行期間不會改變的數值。使用 const 關鍵字宣告常數，確保值不變，增強程式碼可讀性和穩定性。\n常數的聲明與變數的聲明非常相似，只需將 var 改成 const，並在聲明時必須賦值。\n// 定義常數 pi，可以在程式的任何地方使用 const pi = 3.14 // 同時宣告兩個常數 const( A = \u0026#34;A\u0026#34; B = \u0026#34;B\u0026#34; ) // 同時宣告多個常數，省略值則與上一行相同 const( A = \u0026#34;A\u0026#34; B C ) 使用 iota 的 Const 常數 iota 是 Golang 的常數計數器，僅能在常數表達式中使用。iota 在每次出現 const 關鍵字時，都會重置為 0（位於 const 區塊的第一行之前）。每新增一行常數聲明，iota 計數一次。\nconst a = iota // a = 0 const ( b = iota // b = 0 c // c = 1 d // d = 2 ) // 可在一開始即決定初始值 const ( b = iota+1 // b = 1 c // c = 2 d // d = 3 ) // 使用 _ 跳過某些值 const ( b = iota // b = 0 _ d // d = 2 ) 📚Reference Effective Go - The Go Programming Language A Tour of Go(variable) A Tour of Go(const) ","permalink":"https://sz9751210.github.io/posts/go-variable-and-const/","summary":"👨‍💻簡介 在 Golang 中，你可以使用不同的方式來宣告變數和常數。宣告變數時，可以直接指定值，或者使用型別推導，更簡單地用 := 來宣告局部變數。另外，還可以一次宣告多個變數，相同型別的變數可以一起宣告，或者使用括號宣告不同型別的變數。常數則使用 const 關鍵字宣告，確保值不變，有助於提高程式碼的可讀性和穩定性。\n變數的聲明 在 Golang 裡，變數是程式中保存資料的容器。變數名稱由字母、數字、底線組成，但首個字符不能是數字。Golang 的關鍵字和保留字都不能用作變數名稱。\n變數的宣告和初始化方式多種多樣，在使用變數之前，需要先聲明變數。在同一範圍內，不允許重複聲明相同的變數。而且，一旦聲明變數，就必須在之後的程式碼中使用它。\n如果變數在聲明後沒有進行初始化，則打印出來的值將是空的。\n如何定義變數 單變數宣告 普通聲明(variable declaration) 使用 var 關鍵字進行普通聲明，然後指定變數名稱和類型，再賦予初始值。 var name string name = \u0026#34;Alan\u0026#34; 帶初始化的聲明(direct define)： 可以直接指定變數的類型和初始值。 var age int = 25 也可以省略類型，讓變數類型根據初始值自動推斷。\nvar age = 25 簡短變數聲明(short declaration) 在函式內部，可以使用簡化的 := 語法同時宣告並初始化變數。 注意：簡短變數聲明只能用於局部變數，不能用於全局變數的聲明。\nfoo := \u0026#34;hello\u0026#34; bar := 100 多變數宣告 普通聲明 您可以同時宣告多個相同類型的變數。 var a, b int a = 10 b = 20 帶初始化的聲明(direct define)： 可以直接指定多個變數的類型和初始值。 var x, y int = 5, 8 也可以省略類型，讓變數類型根據初始值自動推斷。","title":"淺談 Golang 變數與常數：宣告、初始化與使用"},{"content":"👨‍💻簡介 在這篇文章裡，會簡單介紹幾個關鍵的基本概念和語法結構，加快上手這門程式語言。 文件組成\n📦文件組成 一個典型的 Go 語言程式由以下幾個部分構成，讓我們逐一來看：\nPackage 宣告 程式的一開始會有一個 package 宣告，用以指定目前的檔案隸屬於哪個程式套件（package）。\npackage main 匯入套件 我們可以透過 import 關鍵字引入所需的套件（packages）。這些套件提供各式功能，協助我們輕鬆進行開發。\nimport ( \u0026#34;fmt\u0026#34; ) 函式定義 在 Go 語言中，程式邏輯主要由函式（functions）所組成。以下是主要函式 main 的定義，它是每個 Go 程式的起點。\nfunc main() { fmt.Println(\u0026#34;Hello World!\u0026#34;) } 📝語法要點 在編寫 Go 程式時，有幾個語法上的重要要點需要注意：\n語句可以透過換行或分號（;）來分隔。 左大括號 { 不應該單獨出現在一行的開頭，應該與其他語句放在同一行。 🔍註解的用法 在程式碼中，註解可以為程式邏輯提供解釋和說明。Go 語言支援兩種註解格式：\n單行註解：\n// 這是單行註解的範例 多行註解（C 風格）：\n/* 這是多行註解的範例， 可以跨越多行並提供更多細節說明。 */ 📚參考資料 Go Syntax (w3schools.com) ","permalink":"https://sz9751210.github.io/posts/go-syntax/","summary":"👨‍💻簡介 在這篇文章裡，會簡單介紹幾個關鍵的基本概念和語法結構，加快上手這門程式語言。 文件組成\n📦文件組成 一個典型的 Go 語言程式由以下幾個部分構成，讓我們逐一來看：\nPackage 宣告 程式的一開始會有一個 package 宣告，用以指定目前的檔案隸屬於哪個程式套件（package）。\npackage main 匯入套件 我們可以透過 import 關鍵字引入所需的套件（packages）。這些套件提供各式功能，協助我們輕鬆進行開發。\nimport ( \u0026#34;fmt\u0026#34; ) 函式定義 在 Go 語言中，程式邏輯主要由函式（functions）所組成。以下是主要函式 main 的定義，它是每個 Go 程式的起點。\nfunc main() { fmt.Println(\u0026#34;Hello World!\u0026#34;) } 📝語法要點 在編寫 Go 程式時，有幾個語法上的重要要點需要注意：\n語句可以透過換行或分號（;）來分隔。 左大括號 { 不應該單獨出現在一行的開頭，應該與其他語句放在同一行。 🔍註解的用法 在程式碼中，註解可以為程式邏輯提供解釋和說明。Go 語言支援兩種註解格式：\n單行註解：\n// 這是單行註解的範例 多行註解（C 風格）：\n/* 這是多行註解的範例， 可以跨越多行並提供更多細節說明。 */ 📚參考資料 Go Syntax (w3schools.com) ","title":"🚀入門 Go 語言：關鍵概念、語法結構與實用技巧✨"},{"content":"👨‍💻如何在go中驗證SSL憑證 因之前玩過監控證書，最近在接觸golang因此來看看有甚麼方法能夠取得憑證到期日，最後發現有crypto/tls這個module可以用，驗證步驟簡單三步如下\n1. 確認網站是否有SSL證書 package main import ( \u0026#34;crypto/tls\u0026#34; ) func main() { conn, err := tls.Dial(\u0026#34;tcp\u0026#34;, \u0026#34;example.com:80\u0026#34;, nil) if err != nil { panic(\u0026#34;Server doesn\u0026#39;t support SSL certificate err: \u0026#34; + err.Error()) } } 上述程式碼首先使用 tls.Dial 建立TLS連線，語法規則為\ntls.Dial(protocol, website, tls config) 連線成功則返回一個tls.Conn\n執行後會噴以下錯誤\npanic: Server doesn\u0026#39;t support SSL certificate err: tls: first record does not look like a TLS handshake goroutine 1 [running]: 接著將網站改為google重新執行一次程式碼，沒有任何輸出表示正常，也代表網站有啟用SSL\npackage main import ( \u0026#34;crypto/tls\u0026#34; ) func main() { conn, err := tls.Dial(\u0026#34;tcp\u0026#34;, \u0026#34;www.google.com:443\u0026#34;, nil) if err != nil { panic(\u0026#34;Server doesn\u0026#39;t support SSL certificate err: \u0026#34; + err.Error()) } } 2. 確認SSL憑證和網站hostname是否吻合 可使用conn.VerifyHostname驗證server的憑證與hostname是否吻合\npackage main import ( \u0026#34;crypto/tls\u0026#34; ) func main() { conn, err := tls.Dial(\u0026#34;tcp\u0026#34;, \u0026#34;www.google.com:443\u0026#34;, nil) if err != nil { panic(\u0026#34;Server doesn\u0026#39;t support SSL certificate err: \u0026#34; + err.Error()) } err = conn.VerifyHostname(\u0026#34;www.google.com\u0026#34;) if err != nil { panic(\u0026#34;Hostname doesn\u0026#39;t match with certificate: \u0026#34; + err.Error()) } } 3. 驗證SSL憑證的到期日 我們可以透過conn.ConnectionState().PeerCertificates來取得憑證，然後透過NotAfter來取得憑證到期日\npackage main import ( \u0026#34;crypto/tls\u0026#34; \u0026#34;fmt\u0026#34; ) func main() { conn, err := tls.Dial(\u0026#34;tcp\u0026#34;, \u0026#34;www.google.com:443\u0026#34;, nil) if err != nil { panic(\u0026#34;Server doesn\u0026#39;t support SSL certificate err: \u0026#34; + err.Error()) } err = conn.VerifyHostname(\u0026#34;www.google.com\u0026#34;) if err != nil { panic(\u0026#34;Hostname doesn\u0026#39;t match with certificate: \u0026#34; + err.Error()) } expiry := conn.ConnectionState().PeerCertificates[0] fmt.Printf(\u0026#34;Issuer Name: %s\\n\u0026#34;, expiry.Issuer) fmt.Printf(\u0026#34;Expiry: %s \\n\u0026#34;, expiry.NotAfter.Format(\u0026#34;2006-01-02\u0026#34;)) fmt.Printf(\u0026#34;Common Name: %s \\n\u0026#34;, expiry.Issuer.CommonName) } 📚Reference How to Validate SSL Certificates in Go (freecodecamp.org) go - Get remote ssl certificate in golang - Stack Overflow ","permalink":"https://sz9751210.github.io/posts/how-to-validate-ssl-certificates-in-go/","summary":"👨‍💻如何在go中驗證SSL憑證 因之前玩過監控證書，最近在接觸golang因此來看看有甚麼方法能夠取得憑證到期日，最後發現有crypto/tls這個module可以用，驗證步驟簡單三步如下\n1. 確認網站是否有SSL證書 package main import ( \u0026#34;crypto/tls\u0026#34; ) func main() { conn, err := tls.Dial(\u0026#34;tcp\u0026#34;, \u0026#34;example.com:80\u0026#34;, nil) if err != nil { panic(\u0026#34;Server doesn\u0026#39;t support SSL certificate err: \u0026#34; + err.Error()) } } 上述程式碼首先使用 tls.Dial 建立TLS連線，語法規則為\ntls.Dial(protocol, website, tls config) 連線成功則返回一個tls.Conn\n執行後會噴以下錯誤\npanic: Server doesn\u0026#39;t support SSL certificate err: tls: first record does not look like a TLS handshake goroutine 1 [running]: 接著將網站改為google重新執行一次程式碼，沒有任何輸出表示正常，也代表網站有啟用SSL\npackage main import ( \u0026#34;crypto/tls\u0026#34; ) func main() { conn, err := tls.","title":"如何在go中驗證SSL憑證"},{"content":"👨‍💻簡介 今天早上在下kubectl get pods時，突然跳出了以下錯誤\nwarning\rUnable to connect to the server: x509: certificate has expired or is not yet valid\r下了kubeadm alpha certs check-expiration之後才發現原來是憑證過期 因此紀錄一下解決過程\nInformation environment NAME=\u0026#34;CentOS Linux\u0026#34; VERSION=\u0026#34;7 (Core)\u0026#34; ID=\u0026#34;centos\u0026#34; ID_LIKE=\u0026#34;rhel fedora\u0026#34; VERSION_ID=\u0026#34;7\u0026#34; PRETTY_NAME=\u0026#34;CentOS Linux 7 (Core)\u0026#34; ANSI_COLOR=\u0026#34;0;31\u0026#34; CPE_NAME=\u0026#34;cpe:/o:centos:centos:7\u0026#34; HOME_URL=\u0026#34;https://www.centos.org/\u0026#34; BUG_REPORT_URL=\u0026#34;https://bugs.centos.org/\u0026#34; CENTOS_MANTISBT_PROJECT=\u0026#34;CentOS-7\u0026#34; CENTOS_MANTISBT_PROJECT_VERSION=\u0026#34;7\u0026#34; REDHAT_SUPPORT_PRODUCT=\u0026#34;centos\u0026#34; REDHAT_SUPPORT_PRODUCT_VERSION=\u0026#34;7\u0026#34; docker version Client: Version: 1.13.1 API version: 1.26 Package version: docker-1.13.1-162.git64e9980.el7.centos.x86_64 Go version: go1.10.3 Git commit: 64e9980/1.13.1 Built: Wed Jul 1 14:56:42 2020 OS/Arch: linux/amd64 Server: Version: 1.13.1 API version: 1.26 (minimum version 1.12) Package version: docker-1.13.1-162.git64e9980.el7.centos.x86_64 Go version: go1.10.3 Git commit: 64e9980/1.13.1 Built: Wed Jul 1 14:56:42 2020 OS/Arch: linux/amd64 Experimental: false kubeadm version kubeadm version: \u0026amp;version.Info{Major:\u0026#34;1\u0026#34;, Minor:\u0026#34;18\u0026#34;, GitVersion:\u0026#34;v1.18.6\u0026#34;, GitCommit:\u0026#34;dff82dc0de47299ab66c83c626e08b245ab19037\u0026#34;, GitTreeState:\u0026#34;clean\u0026#34;, BuildDate:\u0026#34;2020-07-15T16:56:34Z\u0026#34;, GoVersion:\u0026#34;go1.13.9\u0026#34;, Compiler:\u0026#34;gc\u0026#34;, Platform:\u0026#34;linux/amd64\u0026#34;} k8s version Client Version: version.Info{Major:\u0026#34;1\u0026#34;, Minor:\u0026#34;18\u0026#34;, GitVersion:\u0026#34;v1.18.6\u0026#34;, GitCommit:\u0026#34;dff82dc0de47299ab66c83c626e08b245ab19037\u0026#34;, GitTreeState:\u0026#34;clean\u0026#34;, BuildDate:\u0026#34;2020-07-15T16:58:53Z\u0026#34;, GoVersion:\u0026#34;go1.13.9\u0026#34;, Compiler:\u0026#34;gc\u0026#34;, Platform:\u0026#34;linux/amd64\u0026#34;} Server Version: version.Info{Major:\u0026#34;1\u0026#34;, Minor:\u0026#34;18\u0026#34;, GitVersion:\u0026#34;v1.18.6\u0026#34;, GitCommit:\u0026#34;dff82dc0de47299ab66c83c626e08b245ab19037\u0026#34;, GitTreeState:\u0026#34;clean\u0026#34;, BuildDate:\u0026#34;2020-07-15T16:51:04Z\u0026#34;, GoVersion:\u0026#34;go1.13.9\u0026#34;, Compiler:\u0026#34;gc\u0026#34;, Platform:\u0026#34;linux/amd64\u0026#34;} 💡解決步驟 1. 更新憑證 執行以下命令備份現有k8s 憑證 $ mkdir -p $HOME/k8s-old-certs/pki $ /bin/cp -p /etc/kubernetes/pki/*.* $HOME/k8s-old-certs/pki $ ls -l $HOME/k8s-old-certs/pki/ 輸出類似以下內容:\ntotal 56 -rw-r--r-- 1 root root 1090 Jul 27 2022 apiserver-etcd-client.crt -rw------- 1 root root 1679 Jul 27 2022 apiserver-etcd-client.key -rw-r--r-- 1 root root 1099 Jul 27 2022 apiserver-kubelet-client.crt -rw------- 1 root root 1679 Jul 27 2022 apiserver-kubelet-client.key -rw-r--r-- 1 root root 1229 Jul 27 2022 apiserver.crt -rw------- 1 root root 1675 Jul 27 2022 apiserver.key -rw-r--r-- 1 root root 1025 Jul 25 2020 ca.crt -rw------- 1 root root 1675 Jul 25 2020 ca.key -rw-r--r-- 1 root root 1038 Jul 27 2022 front-proxy-ca.crt -rw------- 1 root root 1675 Jul 27 2022 front-proxy-ca.key -rw-r--r-- 1 root root 1058 Jul 27 2022 front-proxy-client.crt -rw------- 1 root root 1679 Jul 27 2022 front-proxy-client.key -rw------- 1 root root 1679 Jul 25 2020 sa.key -rw------- 1 root root 451 Jul 25 2020 sa.pub 執行以下命令備份現有k8s設定檔 /bin/cp -p /etc/kubernetes/*.conf $HOME/k8s-old-certs ls -ltr $HOME/k8s-old-certs 輸出類似以下內容:\ntotal 36 -rw------- 1 root root 5506 Jul 27 2022 kubelet.conf -rw------- 1 root root 5453 Jul 27 2022 admin.conf -rw------- 1 root root 5489 Jul 27 2022 controller-manager.conf -rw------- 1 root root 5437 Jul 27 2022 scheduler.conf drwxrwxr-x 2 root root 4096 Jul 27 12:05 pki 執行以下命令備份家目錄設定: mkdir -p $HOME/k8s-old-certs/.kube /bin/cp -p ~/.kube/config $HOME/k8s-old-certs/.kube/. ls -l $HOME/k8s-old-certs/.kube/. 輸出類似以下內容:\ntotal 8 -rw------- 1 root root 5454 Jul 27 2022 config 執行以下命令更新所有k8s憑證 kubeadm alpha certs renew all 輸出類似以下內容:\n[renew] Reading configuration from the cluster... [renew] FYI: You can look at this config file with \u0026#39;kubectl -n kube-system get cm kubeadm-config -oyaml\u0026#39; certificate embedded in the kubeconfig file for the admin to use and for kubeadm itself renewed certificate for serving the Kubernetes API renewed certificate the apiserver uses to access etcd renewed certificate for the API server to connect to kubelet renewed certificate embedded in the kubeconfig file for the controller manager to use renewed certificate for liveness probes to healthcheck etcd renewed certificate for etcd nodes to communicate with each other renewed certificate for serving etcd renewed certificate for the front proxy client renewed certificate embedded in the kubeconfig file for the scheduler manager to use renewed 執行以下命令確認憑證是否更新並顯示364天後過期: kubeadm alpha certs check-expiration 輸出類似以下內容:\n[check-expiration] Reading configuration from the cluster... [check-expiration] FYI: You can look at this config file with \u0026#39;kubectl -n kube-system get cm kubeadm-config -oyaml\u0026#39; CERTIFICATE EXPIRES RESIDUAL TIME CERTIFICATE AUTHORITY EXTERNALLY MANAGED admin.conf Jul 26, 2024 04:14 UTC 364d no apiserver Jul 26, 2024 04:15 UTC 364d ca no apiserver-etcd-client Jul 26, 2024 04:15 UTC 364d etcd-ca no apiserver-kubelet-client Jul 26, 2024 04:15 UTC 364d ca no controller-manager.conf Jul 26, 2024 04:15 UTC 364d no etcd-healthcheck-client Jul 26, 2024 04:15 UTC 364d etcd-ca no etcd-peer Jul 26, 2024 04:15 UTC 364d etcd-ca no etcd-server Jul 26, 2024 04:15 UTC 364d etcd-ca no front-proxy-client Jul 26, 2024 04:15 UTC 364d front-proxy-ca no scheduler.conf Jul 26, 2024 04:16 UTC 364d no CERTIFICATE AUTHORITY EXPIRES RESIDUAL TIME EXTERNALLY MANAGED ca Jul 23, 2030 03:21 UTC 6y no etcd-ca Jul 23, 2030 03:21 UTC 6y no front-proxy-ca Jul 24, 2032 03:09 UTC 8y no 2. 確認kubelet設定 這時候下 kubectl get pods可能會噴以下錯誤 warning\rerror: You must be logged in to the server (Unauthorized)\r此時可以使用指令比對一下家目錄的設定檔是否更新\ndiff $HOME/.kube/config/ /etc/kubernetes/admin.conf 如果沒顯示任何輸出，原因是家目錄的設定檔沒更新，因此必須複製一份新的設定檔到家目錄\ncp -i /etc/kubernetes/admin.conf $HOME/.kube/config 接著需要重起kubelet以及相關的docker服務(master與node都要重啟)\nsystemctl restart docker systemctl restart kubelet 如果以上指令沒有輸出表示成功，最後確認是否新的設定檔成功\nkubectl get node NAME STATUS ROLES AGE VERSION master Ready \u0026lt;none\u0026gt; 3y2d v1.18.6 worker1 Ready \u0026lt;none\u0026gt; 3y2d v1.18.6 worker2 Ready \u0026lt;none\u0026gt; 3y2d v1.18.6 以上就是這次更新憑證的過程。\n📚Reference Certificate Management with kubeadm | Kubernetes Kubernetes “x509: certificate has expired or is not yet valid” error | by Guilherme Pereira | Medium K8S: Unable To Connect To The Server: X509: Certificate Has Expired Or Is Not Yet Valid | IvoNet k8s自签证书过期x509: certificate has expired or is not yet valid报错 - cerberus43 - 博客园 (cnblogs.com) ","permalink":"https://sz9751210.github.io/posts/k8s-certificate-expired/","summary":"👨‍💻簡介 今天早上在下kubectl get pods時，突然跳出了以下錯誤\nwarning\rUnable to connect to the server: x509: certificate has expired or is not yet valid\r下了kubeadm alpha certs check-expiration之後才發現原來是憑證過期 因此紀錄一下解決過程\nInformation environment NAME=\u0026#34;CentOS Linux\u0026#34; VERSION=\u0026#34;7 (Core)\u0026#34; ID=\u0026#34;centos\u0026#34; ID_LIKE=\u0026#34;rhel fedora\u0026#34; VERSION_ID=\u0026#34;7\u0026#34; PRETTY_NAME=\u0026#34;CentOS Linux 7 (Core)\u0026#34; ANSI_COLOR=\u0026#34;0;31\u0026#34; CPE_NAME=\u0026#34;cpe:/o:centos:centos:7\u0026#34; HOME_URL=\u0026#34;https://www.centos.org/\u0026#34; BUG_REPORT_URL=\u0026#34;https://bugs.centos.org/\u0026#34; CENTOS_MANTISBT_PROJECT=\u0026#34;CentOS-7\u0026#34; CENTOS_MANTISBT_PROJECT_VERSION=\u0026#34;7\u0026#34; REDHAT_SUPPORT_PRODUCT=\u0026#34;centos\u0026#34; REDHAT_SUPPORT_PRODUCT_VERSION=\u0026#34;7\u0026#34; docker version Client: Version: 1.13.1 API version: 1.26 Package version: docker-1.13.1-162.git64e9980.el7.centos.x86_64 Go version: go1.10.3 Git commit: 64e9980/1.13.1 Built: Wed Jul 1 14:56:42 2020 OS/Arch: linux/amd64 Server: Version: 1.","title":"Kubernetes憑證過期：Unable To Connect To The Server: X509: Certificate Has Expired Or Is Not Yet Valid"},{"content":"👨‍💻簡介 因在wsl環境下使用websocket通訊協議，並在windows使用postman發生連線被拒 嘗試了localhost與127.0.0.1都無效，爬文後找到了一些解決辦法，這邊簡單紀錄一下\n使用wsl的vm ip 建立一組新的wsl ip 操作系統(Operating System) Windows/WSL2\nPostman 版本 10.16\n💡解決辦法 1. 使用WSL的VM IP 可透過以下指令查看IP位址\nip add | grep \u0026quot;eth0\u0026quot; wsl hostname -I 2. 建立一組新的WSL VM IP 在wsl建立一組新的ip，在wsl terminal執行 sudo ip addr add 192.168.99.2/24 broadcast 192.168.99.255 dev eth0 label eth0:1 這行指令將會創建一組新的ip 192.168.99.2 給wsl。\n在windows建立一組新的interface，可在windows command prompt 或 powershell執行 netsh interface ip add address \u0026#34;vEthernet (WSL)\u0026#34; 192.168.99.1 255.255.255.0 這行指令將會創建一組新的interface叫vEthernet (WSL)並分配到ip為192.168.99.1，可透過netsh interface ip show addresses查看是否建立成功。\n📚Reference Cannot connect to websocket server running on WSL via \u0026ldquo;localhost\u0026rdquo; · Issue #11204 · postmanlabs/postman-app-support (github.com) ","permalink":"https://sz9751210.github.io/posts/wsl-websocket/","summary":"👨‍💻簡介 因在wsl環境下使用websocket通訊協議，並在windows使用postman發生連線被拒 嘗試了localhost與127.0.0.1都無效，爬文後找到了一些解決辦法，這邊簡單紀錄一下\n使用wsl的vm ip 建立一組新的wsl ip 操作系統(Operating System) Windows/WSL2\nPostman 版本 10.16\n💡解決辦法 1. 使用WSL的VM IP 可透過以下指令查看IP位址\nip add | grep \u0026quot;eth0\u0026quot; wsl hostname -I 2. 建立一組新的WSL VM IP 在wsl建立一組新的ip，在wsl terminal執行 sudo ip addr add 192.168.99.2/24 broadcast 192.168.99.255 dev eth0 label eth0:1 這行指令將會創建一組新的ip 192.168.99.2 給wsl。\n在windows建立一組新的interface，可在windows command prompt 或 powershell執行 netsh interface ip add address \u0026#34;vEthernet (WSL)\u0026#34; 192.168.99.1 255.255.255.0 這行指令將會創建一組新的interface叫vEthernet (WSL)並分配到ip為192.168.99.1，可透過netsh interface ip show addresses查看是否建立成功。\n📚Reference Cannot connect to websocket server running on WSL via \u0026ldquo;localhost\u0026rdquo; · Issue #11204 · postmanlabs/postman-app-support (github.","title":"WSL環境下使用websocket連線被拒"},{"content":"👨‍💻簡介 《 Zeabur - 部署服務 從未如此簡單》\n從來沒想過部署可以如此的方便快速，第一次接觸到Zeabur的時候覺得他跟一般的雲端服務商差不多，架設網站用個vm之類的，但仔細去摸索後才發現他是個想讓開發人員專注在寫扣這件事上，不需去管任何infra相關事項的一個服務，像是架設wordpress需要sql，就簡單的點兩下即可完成，\n或是自己建立在github的部落格，也是一鍵點擊下去建立，並且厲害的是能自動識別github部落格的類型，主流的hexo、hugo都能自動辨識。\n在介面上則是將一個專案用到的服務集中式的管理，Zeabur能夠全部部署在一起，不需去處理連線的問題，在一個單一的組態檔案中來管理服務所需的所有變數，不需要使用.env下去做設定，讓使用者有開箱即用的一流體驗。\n今天就用Zeabur來快速建立wordpress，讓大家看看Zeabur的使用方式。\n🔰基礎介紹 Zeabur 簡介 Zeabur 是一個主打「一鍵部署」的 PaaS 平台，類似的產品台灣的開發者一般比較流行使用 GitHub Pages（前端）以及 Render、Flyio（後端），Zeabur 相比於這些競爭對手，最大的特點在於：\n官方文件、技術支援都有中文 ，且主機位於 GCP 台灣機房 操作更簡單，把 GitHub 上面的程式部署上線真的只需要「一鍵」 一個專案往往會有前端、後端、資料庫 \u0026hellip; 各種服務，Zeabur 能夠全部部署在一起，方便管理 🎯setup 1. 建立project 登入官網後先點選Create Project來建立一個專案，接著輸入專案名稱並點選create 建立成功就會在主控台看到剛剛建立的專案了，我們點選剛剛建立的專案來繼續建立我們需要的服務 2. 建立service 點選Add Service 2.1 新增mysql service 因為wordpress需要連接mysql，因此我們先建立mysql服務 點下去等個幾秒mysql就建立好了，就是這麼的方便快速\n2.2 新增wordpress database 接著我們點選Connect透過terminal連接到mysql去建立資料庫 建立完成後接著回到專案底下來繼續新增我們的wordpress服務\n2.3 新增wordpress service 到這一步wordpress已完成建立\n2.4 建立wordpress domain 建立完成後來接著建立domain 點選我們剛剛建立成功的domain來訪問我們的wordpress，點開後就會顯示wordpress的相關設定\n2.5 設定wordpress後台 看到這個畫面就代表我們的wordpress已經設定完成了 登入後即可進入到wordpress的後台 點選左上角即可訪問我們的網站 以上就是使用zeabur來架設wordpress的設定過程，統整下來真的都是靠點選來建立所需的服務，並且服務是集中式的管理，也因為架設的主機是在GCP的台灣機房，因此速度體驗上也是沒什麼問題，並且官方有提供免費方案可以提供使用者進行免費試用，有興趣的人可以去嚐鮮體驗看看一建部署的強大威力🤓\n📚Reference 🔗官方網站 -\u0026gt; Zeabur - Deploying your service with one click 🔗Github -\u0026gt; Zeabur (github.com) ","permalink":"https://sz9751210.github.io/posts/zeabur/","summary":"👨‍💻簡介 《 Zeabur - 部署服務 從未如此簡單》\n從來沒想過部署可以如此的方便快速，第一次接觸到Zeabur的時候覺得他跟一般的雲端服務商差不多，架設網站用個vm之類的，但仔細去摸索後才發現他是個想讓開發人員專注在寫扣這件事上，不需去管任何infra相關事項的一個服務，像是架設wordpress需要sql，就簡單的點兩下即可完成，\n或是自己建立在github的部落格，也是一鍵點擊下去建立，並且厲害的是能自動識別github部落格的類型，主流的hexo、hugo都能自動辨識。\n在介面上則是將一個專案用到的服務集中式的管理，Zeabur能夠全部部署在一起，不需去處理連線的問題，在一個單一的組態檔案中來管理服務所需的所有變數，不需要使用.env下去做設定，讓使用者有開箱即用的一流體驗。\n今天就用Zeabur來快速建立wordpress，讓大家看看Zeabur的使用方式。\n🔰基礎介紹 Zeabur 簡介 Zeabur 是一個主打「一鍵部署」的 PaaS 平台，類似的產品台灣的開發者一般比較流行使用 GitHub Pages（前端）以及 Render、Flyio（後端），Zeabur 相比於這些競爭對手，最大的特點在於：\n官方文件、技術支援都有中文 ，且主機位於 GCP 台灣機房 操作更簡單，把 GitHub 上面的程式部署上線真的只需要「一鍵」 一個專案往往會有前端、後端、資料庫 \u0026hellip; 各種服務，Zeabur 能夠全部部署在一起，方便管理 🎯setup 1. 建立project 登入官網後先點選Create Project來建立一個專案，接著輸入專案名稱並點選create 建立成功就會在主控台看到剛剛建立的專案了，我們點選剛剛建立的專案來繼續建立我們需要的服務 2. 建立service 點選Add Service 2.1 新增mysql service 因為wordpress需要連接mysql，因此我們先建立mysql服務 點下去等個幾秒mysql就建立好了，就是這麼的方便快速\n2.2 新增wordpress database 接著我們點選Connect透過terminal連接到mysql去建立資料庫 建立完成後接著回到專案底下來繼續新增我們的wordpress服務\n2.3 新增wordpress service 到這一步wordpress已完成建立\n2.4 建立wordpress domain 建立完成後來接著建立domain 點選我們剛剛建立成功的domain來訪問我們的wordpress，點開後就會顯示wordpress的相關設定\n2.5 設定wordpress後台 看到這個畫面就代表我們的wordpress已經設定完成了 登入後即可進入到wordpress的後台 點選左上角即可訪問我們的網站 以上就是使用zeabur來架設wordpress的設定過程，統整下來真的都是靠點選來建立所需的服務，並且服務是集中式的管理，也因為架設的主機是在GCP的台灣機房，因此速度體驗上也是沒什麼問題，並且官方有提供免費方案可以提供使用者進行免費試用，有興趣的人可以去嚐鮮體驗看看一建部署的強大威力🤓\n📚Reference 🔗官方網站 -\u0026gt; Zeabur - Deploying your service with one click 🔗Github -\u0026gt; Zeabur (github.","title":"Zeabur - 部署服務 從未如此簡單"},{"content":"甚麼是Kubernetes ConfigMap ConfigMap主要功用是儲存我們服務的設定，這使得我們可以將我們的應用服務具備可移植性，當需要相對應的環境參數時，只需要修改ConfigMap，而不需要去更動到image即可更換成新的部屬環境。\n為甚麼需要ConfigMap 最主要的用意是共享相同設定。在初期開發時可能只有幾個服務而直接把設定檔寫死，如果在後期變成微服務的架構下，上百個服務都有自己的設定檔在日後維護下會顯得麻煩，因此有了ConfigMap的出現，幫助我們將環境變數與容器鏡像解藕，便於修改應用設定，減少維護成本\n何時使用ConfigMap，ConfigMap使用場景 ConfigMap通常儲存服務的環境變數、命令行參數、配置文件等非機密資料，使用場景有設定檔與容器鏡像分離、多環境支持、共享設定、動態設定更新等等\nConfigMap有哪些特點 解藕配置 -\u0026gt; 將服務的設定檔與容器鏡像分離，使服務在不重新建置新的容器鏡像可修改和管理設定檔，提高容器鏡像的通用性和靈活性 靈活性 -\u0026gt; ConfigMap支援多種格式，並且需要時可動態更新設定，無須重啟服務或重新佈署容器 共享設定 -\u0026gt; ConfigMap允許多個Pod共享同一份設定檔，確保了使用相同設定檔的Pod的一致性，提高設定的可維護性和一致性 集中管理 -\u0026gt; ConfigMap在K8s集群中可以集中管理所有的ConfigMap，不需要逐個修改Pod的設定 如何撰寫使用ConfigMap 創建ConfigMap Imperative(命令式) --from-literal kubectl create configMap myconfig --from-literal=k1=v1 --from-literal=k2=v2 --from-file kubectl create configMap myconfigfromkey --from-file=fromfilekey=from-key Declarative(聲明式) apiVersion: v1 kind: ConfigMap metadata: name: special-config namespace: default data: special.how: very 使用ConfigMap 使用ConfigMap定義容器環境變量 從單一ConfigMap定義容器環境變量 ConfigMap ## create configmap kubectl create configmap special-config --from-literal=special.how=very Pod apiVersion: v1 kind: Pod metadata: name: dapi-test-pod spec: containers: - name: test-container image: registry.k8s.io/busybox command: [ \u0026#34;/bin/sh\u0026#34;, \u0026#34;-c\u0026#34;, \u0026#34;env\u0026#34; ] env: # 定義環境變量 - name: SPECIAL_LEVEL_KEY valueFrom: ConfigMapKeyRef: # ConfigMap 含有你想要指派給 SPECIAL_LEVEL_KEY 的值 name: special-config # 指定想要指派的 value 的 key key: special.how restartPolicy: Never ## create pod kubectl create -f https://kubernetes.io/examples/pods/pod-single-configmap-env-variable.yaml ## Please use the following command to check the output kubectl logs dapi-test-pod ## output KUBERNETES_SERVICE_PORT=443 KUBERNETES_PORT=tcp://10.96.0.1:443 HOSTNAME=dapi-test-pod SHLVL=1 HOME=/root KUBERNETES_PORT_443_TCP_ADDR=10.96.0.1 PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin KUBERNETES_PORT_443_TCP_PORT=443 KUBERNETES_PORT_443_TCP_PROTO=tcp SPECIAL_LEVEL_KEY=very KUBERNETES_PORT_443_TCP=tcp://10.96.0.1:443 KUBERNETES_SERVICE_PORT_HTTPS=443 PWD=/ KUBERNETES_SERVICE_HOST=10.96.0.1 從上述輸出可以看到環境變量有SPECIAL_LEVEL_KEY=very\n從多個ConfigMap定義容器環境變量 ConfigMap apiVersion: v1 kind: ConfigMap metadata: name: special-config namespace: default data: special.how: very --- apiVersion: v1 kind: ConfigMap metadata: name: env-config namespace: default data: log_level: INFO ## create configmap kubectl create -f https://kubernetes.io/examples/ConfigMap/configmap.yaml Pod apiVersion: v1 kind: Pod metadata: name: dapi-test-pod spec: containers: - name: test-container image: registry.k8s.io/busybox command: [ \u0026#34;/bin/sh\u0026#34;, \u0026#34;-c\u0026#34;, \u0026#34;env\u0026#34; ] env: - name: SPECIAL_LEVEL_KEY valueFrom: ConfigMapKeyRef: name: special-config key: special.how - name: LOG_LEVEL valueFrom: ConfigMapKeyRef: name: env-config key: log_level restartPolicy: Never ## create pod kubectl create -f https://kubernetes.io/examples/pods/pod-multiple-configmap-env-variable.yaml ## Please use the following command to check the output kubectl logs dapi-test-pod ## output KUBERNETES_PORT=tcp://10.96.0.1:443 KUBERNETES_SERVICE_PORT=443 LOG_LEVEL=INFO HOSTNAME=dapi-test-pod SHLVL=1 HOME=/root KUBERNETES_PORT_443_TCP_ADDR=10.96.0.1 PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin KUBERNETES_PORT_443_TCP_PORT=443 KUBERNETES_PORT_443_TCP_PROTO=tcp SPECIAL_LEVEL_KEY=very KUBERNETES_PORT_443_TCP=tcp://10.96.0.1:443 KUBERNETES_SERVICE_PORT_HTTPS=443 PWD=/ KUBERNETES_SERVICE_HOST=10.96.0.1 從上述輸出可以看到環境變量有LOG_LEVEL=INFO和SPECIAL_LEVEL_KEY=very\n在ConfigMap設定key-value pairs定義容器環境變量 ConfigMap apiVersion: v1 kind: ConfigMap metadata: name: special-config namespace: default data: SPECIAL_LEVEL: very SPECIAL_TYPE: charm ## create configmap kubectl create -f https://kubernetes.io/examples/configmap/configmap-multikeys.yaml Pod apiVersion: v1 kind: Pod metadata: name: dapi-test-pod spec: containers: - name: test-container image: registry.k8s.io/busybox command: [ \u0026#34;/bin/sh\u0026#34;, \u0026#34;-c\u0026#34;, \u0026#34;env\u0026#34; ] envFrom: - ConfigMapRef: name: special-config restartPolicy: Never ## create pod kubectl create -f https://kubernetes.io/examples/pods/pod-configmap-envFrom.yaml 我們使用了 envFrom 來將 ConfigMap 中的所有 data 都定義成容器環境變量。\n## Please use the following command to check the output kubectl logs dapi-test-pod ## output KUBERNETES_PORT=tcp://10.96.0.1:443 KUBERNETES_SERVICE_PORT=443 HOSTNAME=dapi-test-pod SHLVL=1 HOME=/root SPECIAL_LEVEL=very KUBERNETES_PORT_443_TCP_ADDR=10.96.0.1 PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin KUBERNETES_PORT_443_TCP_PORT=443 KUBERNETES_PORT_443_TCP_PROTO=tcp KUBERNETES_PORT_443_TCP=tcp://10.96.0.1:443 KUBERNETES_SERVICE_PORT_HTTPS=443 PWD=/ KUBERNETES_SERVICE_HOST=10.96.0.1 SPECIAL_TYPE=charm 從上述輸出可以看到環境變量有SPECIAL_LEVEL=very和SPECIAL_TYPE=charm。\n在Pod commands使用ConfigMap定義的環境變量 ConfigMap apiVersion: v1 kind: ConfigMap metadata: name: special-config namespace: default data: SPECIAL_LEVEL: very SPECIAL_TYPE: charm ## create configmap kubectl create -f https://kubernetes.io/examples/configmap/configmap-multikeys.yaml Pod apiVersion: v1 kind: Pod metadata: name: dapi-test-pod spec: containers: - name: test-container image: registry.k8s.io/busybox command: [ \u0026#34;/bin/echo\u0026#34;, \u0026#34;$(SPECIAL_LEVEL_KEY) $(SPECIAL_TYPE_KEY)\u0026#34; ] env: - name: SPECIAL_LEVEL_KEY valueFrom: ConfigMapKeyRef: name: special-config key: SPECIAL_LEVEL - name: SPECIAL_TYPE_KEY valueFrom: ConfigMapKeyRef: name: special-config key: SPECIAL_TYPE restartPolicy: Never ## create pod kubectl create -f https://kubernetes.io/examples/pods/pod-configmap-env-var-valueFrom.yaml 我們可以使用ConfigMap定義好的環境變量在容器的command和args，使用語法為$(VAR_NAME)\n## Please use the following command to check the output kubectl logs dapi-test-pod ## output very charm 將 ConfigMap 資料加到 Volume 當我們建立ConfigMap使用--from-file，檔名會變成data區塊的key，而內容則會變成該key的value\nConfigMap apiVersion: v1 kind: ConfigMap metadata: name: special-config namespace: default data: SPECIAL_LEVEL: very SPECIAL_TYPE: charm ## create configmap kubectl create -f https://kubernetes.io/examples/configmap/configmap-multikeys.yaml Pod apiVersion: v1 kind: Pod metadata: name: dapi-test-pod spec: containers: - name: test-container image: registry.k8s.io/busybox command: [ \u0026#34;/bin/sh\u0026#34;, \u0026#34;-c\u0026#34;, \u0026#34;ls /etc/config/\u0026#34; ] volumeMounts: - name: config-volume mountPath: /etc/config volumes: - name: config-volume ConfigMap: # 提供container要使用的configmap name name: special-config restartPolicy: Never ## create pod kubectl create -f https://kubernetes.io/examples/pods/pod-configmap-volume.yaml 將ConfigMap name 添加到volumes區塊進行掛載，在此範例中，mountPath會是/etc/config\n## Please use the following command to check the output kubectl logs dapi-test-pod ## output SPECIAL_LEVEL SPECIAL_TYPE 此Pod會去執行ls /etc/config，如果該目錄下有其他檔案會被刪除，因為使用的掛載方式是mountPath\n將ConfigMap資料加到Volume特定路徑 ConfigMap apiVersion: v1 kind: ConfigMap metadata: name: special-config namespace: default data: SPECIAL_LEVEL: very SPECIAL_TYPE: charm ## create configmap kubectl create -f https://kubernetes.io/examples/configmap/configmap-multikeys.yaml Pod apiVersion: v1 kind: Pod metadata: name: dapi-test-pod spec: containers: - name: test-container image: k8s.gcr.io/busybox command: [ \u0026#34;/bin/sh\u0026#34;,\u0026#34;-c\u0026#34;,\u0026#34;cat /etc/config/keys\u0026#34; ] volumeMounts: - name: config-volume mountPath: /etc/config volumes: - name: config-volume ConfigMap: name: special-config items: - key: SPECIAL_LEVEL path: keys restartPolicy: Never ## create pod kubectl create -f https://kubernetes.io/examples/pods/pod-configmap-volume-specific-key.yaml 使用 path 欄位來指定特定 ConfigMap item 到想要的檔案路徑。 在此範例中, SPECIAL_LEVEL item 將會被掛載到 config-volume volume 中的 /etc/config/keys\n## Please use the following command to check the output kubectl logs dapi-test-pod ## output very Reference ConfigMaps | Kubernetes 一文弄懂ConfigMap在K8S中的各种玩法以及应用场景 - 掘金 (juejin.cn) Kubernetes — ConfigMap. 簡單來說, 在我們的應用中, 當我們需要儲存一些較沒有敏感性的設定檔, 像是… | by Ray Lee | 李宗叡 | Learn or Die | Medium Day 18 - 使用 ConfigMaps - iT 邦幫忙::一起幫忙解決難題，拯救 IT 人的一天 (ithome.com.tw) K8s之ConfigMap - Happy Coding, Happy Life (wldandan.github.io) ConfigMap_云容器引擎 CCE_Kubernetes基础知识_配置管理_华为云 (huaweicloud.com) [Kubernetes / K8s] ConfigMap 用於讓不同的微服務共享配置| Configure a Pod to Use a ConfigMap | by KouWei.Lee | k8s筆記 | Medium ","permalink":"https://sz9751210.github.io/posts/k8s-configmap/","summary":"甚麼是Kubernetes ConfigMap ConfigMap主要功用是儲存我們服務的設定，這使得我們可以將我們的應用服務具備可移植性，當需要相對應的環境參數時，只需要修改ConfigMap，而不需要去更動到image即可更換成新的部屬環境。\n為甚麼需要ConfigMap 最主要的用意是共享相同設定。在初期開發時可能只有幾個服務而直接把設定檔寫死，如果在後期變成微服務的架構下，上百個服務都有自己的設定檔在日後維護下會顯得麻煩，因此有了ConfigMap的出現，幫助我們將環境變數與容器鏡像解藕，便於修改應用設定，減少維護成本\n何時使用ConfigMap，ConfigMap使用場景 ConfigMap通常儲存服務的環境變數、命令行參數、配置文件等非機密資料，使用場景有設定檔與容器鏡像分離、多環境支持、共享設定、動態設定更新等等\nConfigMap有哪些特點 解藕配置 -\u0026gt; 將服務的設定檔與容器鏡像分離，使服務在不重新建置新的容器鏡像可修改和管理設定檔，提高容器鏡像的通用性和靈活性 靈活性 -\u0026gt; ConfigMap支援多種格式，並且需要時可動態更新設定，無須重啟服務或重新佈署容器 共享設定 -\u0026gt; ConfigMap允許多個Pod共享同一份設定檔，確保了使用相同設定檔的Pod的一致性，提高設定的可維護性和一致性 集中管理 -\u0026gt; ConfigMap在K8s集群中可以集中管理所有的ConfigMap，不需要逐個修改Pod的設定 如何撰寫使用ConfigMap 創建ConfigMap Imperative(命令式) --from-literal kubectl create configMap myconfig --from-literal=k1=v1 --from-literal=k2=v2 --from-file kubectl create configMap myconfigfromkey --from-file=fromfilekey=from-key Declarative(聲明式) apiVersion: v1 kind: ConfigMap metadata: name: special-config namespace: default data: special.how: very 使用ConfigMap 使用ConfigMap定義容器環境變量 從單一ConfigMap定義容器環境變量 ConfigMap ## create configmap kubectl create configmap special-config --from-literal=special.how=very Pod apiVersion: v1 kind: Pod metadata: name: dapi-test-pod spec: containers: - name: test-container image: registry.","title":"Kubernetes ConfigMap"},{"content":"什麼是 Kubernetes Deployment? 一樣先來個官網解說\nA Deployment provides declarative updates for Pods and ReplicaSets.\nYou describe a desired state in a Deployment, and the Deployment Controller changes the actual state to the desired state at a controlled rate. You can define Deployments to create new ReplicaSets, or to remove existing Deployments and adopt all their resources with new Deployments.\n跟ReplicaSet不同，Deployment的工作主要是為 pod \u0026amp; replicaset 提供了一個宣告式的設定 \u0026amp; 更新方式，透過定義 desired status，Deployment controller 會在所謂的 controlled rate 下達到使用者所期望的狀態，這些機制是由 k8s 自動化完成，因此官方建議應該透過 Deployment 來佈署 pod \u0026amp; replicaset。\n為什麼需要Deployment 因為Pod無法實現自我更新，必須砍掉重建後才會是新的內容，這樣會導致服務中斷，有了Deployment的出現，對Pod進行管理與版本控制，而在Deployment的背後使用Replicaset來確保指定數量的Pod運行，在更新方面，可根據指定的更新策略來控制版本更新。\nDeployment是如何運作的 在k8s中，Pod是最小的資源單位，Pod的副本管理是透過Replicaset實現，而Deployment則是控制Replicaset，並不是直接對Pod進行管理。\n甚麼時候使用Deployment Deployment 在以下情況下適合使用：\n應用程式的部署和管理：Deployment 提供了一個方便且可靠的方式來部署和管理應用程式。它允許您定義應用程式的配置，包括容器映像、資源需求、環境變數等，並確保指定數量的 Pod 在運行。\n滾動更新和回滾：當需要對應用程式進行更新時，Deployment 提供了滾動更新的能力。它可以逐步部署新版本的應用程式，同時確保舊版本的 Pod 在新版本完全運行之前持續提供服務。如果新版本出現問題，Deployment 還允許回滾到先前的版本。\n應用程式的擴展性和負載均衡：Deployment 允許指定應用程式的副本數，以根據需求自動擴展或收縮應用程式的副本數。這使得應用程式能夠彈性地應對流量的變化，確保高效的資源利用和良好的用戶體驗。\n高可用性和容錯能力：Deployment 通過管理多個 Pod 的運行，提供了高可用性和容錯能力。如果某個 Pod 發生故障或需要進行維護，Deployment 會自動替換它，確保應用程式持續運行並提供無中斷的服務。\n多環境部署：如果需要在不同的環境中部署應用程式（如開發、測試、正式），Deployment 提供了一致的部署方式，確保在不同環境中的應用程式配置和版本的一致性，簡化了部署和管理的流程。\nDeployment有哪些特性 產生並管理 ReplicaSet：Deployment 可以自動創建和管理與其關聯的 ReplicaSet 物件。ReplicaSet 確保指定數量的 Pod 實例正在運行，並根據 Deployment 物件的配置來維護所需的 Pod 數量。\n滾動更新和回滾：Deployment 提供了滾動更新的能力，使您能夠逐步將新版本的應用程式部署到生產環境中，同時確保舊版本的 Pod 在新版本完全運行之前持續提供服務。如果新版本出現問題，Deployment 還允許您輕鬆地回滾到先前的版本。\n健康檢查和自我修復：Deployment 可以定期檢查 Pod 的健康狀態，並根據定義的健康檢查條件進行自我修復。如果 Pod 遇到故障或不符合健康檢查條件，Deployment 會自動替換該 Pod，以確保應用程式的高可用性。\n部署策略：Deployment 允許您指定部署策略，例如最大並行部署數量、最大不可用 Pod 數量等。這些策略可用於控制部署的速度和可靠性，並減少對應用程式的影響。\n環境變數和資源配置：Deployment 允許您在運行中的應用程式上動態配置環境變數和資源需求。這使得在不中斷服務的情況下，可以調整應用程式的配置，例如修改連接字串、調整內存和CPU的資源分配等。\n多環境部署：Deployment 可以用於在不同環境（如開發、測試、生產）中部署應用程式，並提供一致的部署方式和管理能力。這使得在不同環境中保持應用程式配置和版本的一致性變得更容易。\n如何使用Deployment 創建deployment apiVersion: apps/v1 # 定義api版本 kind: Deployment # 定義資源類型 metadata: # 定義元數據 name: nginx-deployment labels: app: nginx spec: strategy: type: RollingUpdate # 更新策略 rollingUpdate: maxUnavailable: 25% # 當更新時，無法使用的Pod佔整體Pod數量的比例 maxSurge: 25% # 當更新時，Pod可以超過desired status數量的比例 progressDeadlineSeconds: 600 # 部屬的最長等待時間，當超過則回報\u0026#34;failed progressing\u0026#34; minReadySeconds: 0 # 服務部屬後準備到可接收流量的時間 revisionHistoryLimit: 10 # 可rollback的版本數 replicas: 3 # 副本數 selector: # 定義label selector matchLabels: app: nginx template: # pod template metadata: labels: app: nginx spec: containers: - name: nginx image: nginx:1.14.2 ports: - containerPort: 80 resources: requests: cpu: 200m memory: 512Mi 查看Deployment \u0026gt; kubectl get deployments.apps NAME READY UP-TO-DATE AVAILABLE AGE nginx-deployment 3/3 3 3 24m \u0026gt; kubectl get deployments.apps -o wide NAME READY UP-TO-DATE AVAILABLE AGE CONTAINERS IMAGES SELECTOR nginx-deployment 3/3 3 3 24m nginx nginx:1.8 app=nginx 更新Deployment 更新image版本 \u0026gt; kubectl set image deployment nginx-deployment nginx=nginx:1.9 deployment.apps/nginx-deployment image updated \u0026gt; kubectl get deployments.apps -o wide NAME READY UP-TO-DATE AVAILABLE AGE CONTAINERS IMAGES SELECTOR nginx-deployment 3/3 1 3 37m nginx nginx:1.9 app=nginx 查看更新狀態 \u0026gt; kubectl rollout status deployment nginx-deployment deployment \u0026#34;nginx-deployment\u0026#34; successfully rolled out 修改pod template \u0026gt; kubectl edit deployment nginx-deployment 回退Deployment 檢查Deployment的升級歷史紀錄 \u0026gt; kubectl rollout history deployment nginx-deployment deployment.apps/nginx-deployment REVISION CHANGE-CAUSE 1 nginx:1.7.9 2 nginx:1.8 查看特定版本的紀錄 \u0026gt; kubectl rollout history deployment nginx-deployment --revision=2 deployment.apps/nginx-deployment with revision #2 Pod Template: Labels: app=nginx pod-template-hash=58f44756c Annotations: kubernetes.io/change-cause: nginx:1.8 Containers: nginx: Image: nginx:1.8 Port: 80/TCP Host Port: 0/TCP Environment: \u0026lt;none\u0026gt; Mounts: \u0026lt;none\u0026gt; Volumes: \u0026lt;none\u0026gt; 回退到指定版本 \u0026gt; kubectl rollout undo deployment nginx-deployment --to-revision 1 deployment.apps/nginx-deployment rolled back 擴縮Deployment 指定數量 \u0026gt; kubectl scale deployment nginx-deployment --replicas 2 deployment.apps/nginx-deployment scaled 水平自動擴縮，根據當前Pod的CPU利用率當作擴縮依據 kubectl autoscale deployment nginx-deployment --max 5 --min 3 --cpu-percent 70 如果是使用minikube，得啟用metrics-server的addon\nminikube addons list ## 查看minikube的addon minikube addons enable metrics-server ## 啟用metrics-server的addon\n暫停和恢復Deployment \u0026gt; kubectl rollout pause deployment nginx-deployment deployment.apps/nginx-deployment paused \u0026gt; kubectl rollout resume deployment nginx-deployment deployment.apps/nginx-deployment resumed 在暫停期間任意修改deployment都不會更新，暫停前的狀態將繼續它的功能\nDeployment cheat sheet Reference Deployments | Kubernetes Deployment · Kubernetes 中文指南——云原生应用架构实战手册 (jimmysong.io) Kubernetes 那些事 — Deployment 與 ReplicaSet（一） | by Andy Chen | Andy的技術分享blog | Medium ","permalink":"https://sz9751210.github.io/posts/k8s-deploy/","summary":"什麼是 Kubernetes Deployment? 一樣先來個官網解說\nA Deployment provides declarative updates for Pods and ReplicaSets.\nYou describe a desired state in a Deployment, and the Deployment Controller changes the actual state to the desired state at a controlled rate. You can define Deployments to create new ReplicaSets, or to remove existing Deployments and adopt all their resources with new Deployments.\n跟ReplicaSet不同，Deployment的工作主要是為 pod \u0026amp; replicaset 提供了一個宣告式的設定 \u0026amp; 更新方式，透過定義 desired status，Deployment controller 會在所謂的 controlled rate 下達到使用者所期望的狀態，這些機制是由 k8s 自動化完成，因此官方建議應該透過 Deployment 來佈署 pod \u0026amp; replicaset。","title":"Kubernetes Deployment：Overview"},{"content":"👨‍💻Intro 為了實現vscode在wsl環境下使用ssh連接到gce的需求，在爬文後找到一篇解法，因此記錄下來，方便日後查詢\n🎯setup 建立ssh.bat檔案，並放在windows下任意位置 C:\\Windows\\system32\\wsl.exe ssh %* vscode設定ssh.bat路徑 打開vscode的settings -\u0026gt; extensions -\u0026gt; Remote - SSH -\u0026gt; Remote.SSH.path將ssh.bat所在路徑貼上\n透過管理員身分打開CMD建立連結\nC:\\Users\\User\u0026gt;mklink /D \u0026#34;C:\\Users\\User\\.ssh\u0026#34; \u0026#34;\\\\wsl$\\Ubuntu-20.04\\home\\alan\\.ssh\u0026#34; ## 成功後會顯示以下訊息 已建立 C:\\Users\\User\\.ssh 的符號連結 \u0026lt;\u0026lt;===\u0026gt;\u0026gt; \\\\wsl$\\Ubuntu-20.04\\home\\alan\\.ssh 指令介紹 mklink mklink [option] Source Target mklink：建立連結\n/D ：連結類型為資料夾\nSource：windows連結路徑\nTarget：wsl家目錄的.ssh資料夾\nReference Can I SSH from WSL in Visual Studio Code? - Stack Overflow Using WSL for Remote-SSH in VS Code – Zit Seng\u0026rsquo;s Blog Sync VSCode’s SSH with WSL2 – Zit Seng\u0026rsquo;s Blog Mklink 指令建立 Symbolic Link | ShunNien\u0026rsquo;s Blog ","permalink":"https://sz9751210.github.io/posts/vscode-wsl-ssh/","summary":"👨‍💻Intro 為了實現vscode在wsl環境下使用ssh連接到gce的需求，在爬文後找到一篇解法，因此記錄下來，方便日後查詢\n🎯setup 建立ssh.bat檔案，並放在windows下任意位置 C:\\Windows\\system32\\wsl.exe ssh %* vscode設定ssh.bat路徑 打開vscode的settings -\u0026gt; extensions -\u0026gt; Remote - SSH -\u0026gt; Remote.SSH.path將ssh.bat所在路徑貼上\n透過管理員身分打開CMD建立連結\nC:\\Users\\User\u0026gt;mklink /D \u0026#34;C:\\Users\\User\\.ssh\u0026#34; \u0026#34;\\\\wsl$\\Ubuntu-20.04\\home\\alan\\.ssh\u0026#34; ## 成功後會顯示以下訊息 已建立 C:\\Users\\User\\.ssh 的符號連結 \u0026lt;\u0026lt;===\u0026gt;\u0026gt; \\\\wsl$\\Ubuntu-20.04\\home\\alan\\.ssh 指令介紹 mklink mklink [option] Source Target mklink：建立連結\n/D ：連結類型為資料夾\nSource：windows連結路徑\nTarget：wsl家目錄的.ssh資料夾\nReference Can I SSH from WSL in Visual Studio Code? - Stack Overflow Using WSL for Remote-SSH in VS Code – Zit Seng\u0026rsquo;s Blog Sync VSCode’s SSH with WSL2 – Zit Seng\u0026rsquo;s Blog Mklink 指令建立 Symbolic Link | ShunNien\u0026rsquo;s Blog ","title":"vscode在wsl環境下連接ssh"},{"content":"GitLab不僅是一個源代碼管理工具，它還提供了一個統一的平台，將開發、運營和安全等流程整合在一起。通過GitLab，可以在單一的應用程序中進行專案計劃、源代碼管理、分支控制、CI/CD等操作。不論角色為何，GitLab提供了一個統一的資訊來源，讓你輕鬆地管理和追蹤整個開發流程。它消除了工具鏈的複雜性，提高了端到端流程的可視性，從而幫助組織更快地實現變革。\n本篇文章主要紀錄使用docker建立gitlab的教學\n準備環境 環境 OS Ubuntu 20.04 LTS Gitlab Gitlab-ce:15.8.0-ce.0 Docker Engine 23.0.5 安裝gitlab 在安裝之前，先講解一下gitlab有哪些重要的資料需要掛載的，主要有以下三個路徑\n/var/opt/gitlab: 這個路徑主要儲存GitLab的資料。包括Git repo、用戶資料、配置文件等。掛載到本地後，即使容器發生意外被刪除或重新創建，資料也能夠得到保留，達到數據持久化。\n./gitlab/logs:/var/log/gitlab: 這個路徑主要儲存GitLab的log。log包含GitLab的運行log、錯誤log等重要資訊。掛載到本地後，方便日後查看和管理log，並進行故障排除和監控。\n/etc/gitlab: 這個路徑主要儲存GitLab的設定檔，包含系統設定、用戶權限、外部整合等設定。掛載到本地後，可根據需求進行自定義調整。\n講解完以上重要的掛載路徑後，接下來講解使用docker建立gitlab\ndocker版 docker run -d \\ --name gitlab \\ --restart always \\ --privileged \\ -p 8080:80 \\ -p 443:443 \\ -p 22:22 \\ -v ./gitlab/data:/var/opt/gitlab \\ -v ./gitlab/logs:/var/log/gitlab \\ -v ./gitlab/config:/etc/gitlab \\ gitlab/gitlab-ce:15.8.0-ce.0 docker-compose版 先建立docker-compose.yaml 將以下內容貼上 version: \u0026#34;3.6\u0026#34; services: gitlab: image: gitlab/gitlab-ce:15.8.0-ce.0 container_name: gitlab restart: always privileged: true hostname: \u0026#39;localhost\u0026#39; ports: - \u0026#39;8080:80\u0026#39; - \u0026#39;443:443\u0026#39; - \u0026#39;22:22\u0026#39; volumes: - \u0026#39;./gitlab/data:/var/opt/gitlab\u0026#39; - \u0026#39;./gitlab/logs:/var/log/gitlab\u0026#39; - \u0026#39;./gitlab/config:/etc/gitlab\u0026#39; 執行docker-compose up -d讓gitlab在後台運行 執行docker-compose logs -f檢查gitlab log是否有異常 登入gitlab 打開瀏覽器輸入localhost:8080就會看到以下畫面 預設密碼可進到gitlab容器內下cat /etc/initial_root_password\n成功登入後就可以看到以下畫面，到這一步就已經完成gitlab的建立了\n","permalink":"https://sz9751210.github.io/posts/docker-install-gitlab/","summary":"GitLab不僅是一個源代碼管理工具，它還提供了一個統一的平台，將開發、運營和安全等流程整合在一起。通過GitLab，可以在單一的應用程序中進行專案計劃、源代碼管理、分支控制、CI/CD等操作。不論角色為何，GitLab提供了一個統一的資訊來源，讓你輕鬆地管理和追蹤整個開發流程。它消除了工具鏈的複雜性，提高了端到端流程的可視性，從而幫助組織更快地實現變革。\n本篇文章主要紀錄使用docker建立gitlab的教學\n準備環境 環境 OS Ubuntu 20.04 LTS Gitlab Gitlab-ce:15.8.0-ce.0 Docker Engine 23.0.5 安裝gitlab 在安裝之前，先講解一下gitlab有哪些重要的資料需要掛載的，主要有以下三個路徑\n/var/opt/gitlab: 這個路徑主要儲存GitLab的資料。包括Git repo、用戶資料、配置文件等。掛載到本地後，即使容器發生意外被刪除或重新創建，資料也能夠得到保留，達到數據持久化。\n./gitlab/logs:/var/log/gitlab: 這個路徑主要儲存GitLab的log。log包含GitLab的運行log、錯誤log等重要資訊。掛載到本地後，方便日後查看和管理log，並進行故障排除和監控。\n/etc/gitlab: 這個路徑主要儲存GitLab的設定檔，包含系統設定、用戶權限、外部整合等設定。掛載到本地後，可根據需求進行自定義調整。\n講解完以上重要的掛載路徑後，接下來講解使用docker建立gitlab\ndocker版 docker run -d \\ --name gitlab \\ --restart always \\ --privileged \\ -p 8080:80 \\ -p 443:443 \\ -p 22:22 \\ -v ./gitlab/data:/var/opt/gitlab \\ -v ./gitlab/logs:/var/log/gitlab \\ -v ./gitlab/config:/etc/gitlab \\ gitlab/gitlab-ce:15.8.0-ce.0 docker-compose版 先建立docker-compose.yaml 將以下內容貼上 version: \u0026#34;3.6\u0026#34; services: gitlab: image: gitlab/gitlab-ce:15.8.0-ce.0 container_name: gitlab restart: always privileged: true hostname: \u0026#39;localhost\u0026#39; ports: - \u0026#39;8080:80\u0026#39; - \u0026#39;443:443\u0026#39; - \u0026#39;22:22\u0026#39; volumes: - \u0026#39;.","title":"使用Docker安裝GitLab"},{"content":"服務上雲後有時會需要固定一組IP主動對外發出連線，這時要考慮安全性與獨立性的問題，在爬文後發現了GCP推出的Cloud NAT，本篇文章簡單介紹一下這個工具的使用。\n什麼是Cloud NAT GCP Cloud NAT是GCP上的一種服務，它提供了一個管理和部署Google Cloud上的NAT（Network Address Translation）的解決方案。 GCP Cloud NAT能夠讓使用者在不公開VM或GKE的外網IP情況下，透過共用一組IP對外溝通，外部服務無法直接存取Cloud NAT 閘道後的任何資源，確保了服務的安全性。\n什麼時候使用Cloud NAT 在需要使用私有IP地址與外網連接時，可以使用Cloud NAT。 例如：在Pod訪問外網時需要固定Public IP的情境下會使用到。\n如何使用Cloud NAT 準備環境 設定gcloud至正確專案 gcloud config set project \u0026lt;PROJECT_ID\u0026gt; 建立VPC網路與子網路 建立一台無外網的vm，region選asia-east1 ，zone選asia-east1-b，網路選剛剛建立的nat-network，子網選nat-subnet-192 建立防火牆並允許35.235.240.0/20網段，允許tcp 22 port，目標為無外網的vm 到IAP頁面並選擇SSH和TCP資源設定權限 到剛剛建立的vm curl httpbin.org/ip，此時應該是無法連線到外部\n設定NAT 到Cloud NAT建立NAT gateway，並選擇稍早創建的VPC以及創建Router 這時候在curl一次就會有一組對外ip了，此ip即為nat自動幫我們創建的外部ip 有了 Cloud NAT ，可以在不使用外部ip的情況下，與外網連線且同時阻擋了由外部的存取，增加了不少安全性，降低主機被攻擊的風險。\nReference Cloud NAT overview | Google Cloud Set up Cloud NAT with Compute Engine | Google Cloud 利用 Cloud NAT 維持雲端的獨立性與安全性 - PeerOne Technology 皮偶玩互動科技 - Medium ","permalink":"https://sz9751210.github.io/posts/gcp-cloud-nat/","summary":"服務上雲後有時會需要固定一組IP主動對外發出連線，這時要考慮安全性與獨立性的問題，在爬文後發現了GCP推出的Cloud NAT，本篇文章簡單介紹一下這個工具的使用。\n什麼是Cloud NAT GCP Cloud NAT是GCP上的一種服務，它提供了一個管理和部署Google Cloud上的NAT（Network Address Translation）的解決方案。 GCP Cloud NAT能夠讓使用者在不公開VM或GKE的外網IP情況下，透過共用一組IP對外溝通，外部服務無法直接存取Cloud NAT 閘道後的任何資源，確保了服務的安全性。\n什麼時候使用Cloud NAT 在需要使用私有IP地址與外網連接時，可以使用Cloud NAT。 例如：在Pod訪問外網時需要固定Public IP的情境下會使用到。\n如何使用Cloud NAT 準備環境 設定gcloud至正確專案 gcloud config set project \u0026lt;PROJECT_ID\u0026gt; 建立VPC網路與子網路 建立一台無外網的vm，region選asia-east1 ，zone選asia-east1-b，網路選剛剛建立的nat-network，子網選nat-subnet-192 建立防火牆並允許35.235.240.0/20網段，允許tcp 22 port，目標為無外網的vm 到IAP頁面並選擇SSH和TCP資源設定權限 到剛剛建立的vm curl httpbin.org/ip，此時應該是無法連線到外部\n設定NAT 到Cloud NAT建立NAT gateway，並選擇稍早創建的VPC以及創建Router 這時候在curl一次就會有一組對外ip了，此ip即為nat自動幫我們創建的外部ip 有了 Cloud NAT ，可以在不使用外部ip的情況下，與外網連線且同時阻擋了由外部的存取，增加了不少安全性，降低主機被攻擊的風險。\nReference Cloud NAT overview | Google Cloud Set up Cloud NAT with Compute Engine | Google Cloud 利用 Cloud NAT 維持雲端的獨立性與安全性 - PeerOne Technology 皮偶玩互動科技 - Medium ","title":"GCP Cloud NAT：Overview"},{"content":"什麼是 Kubernetes ReplicaSet? 先來個官網解說\nA ReplicaSet\u0026rsquo;s purpose is to maintain a stable set of replica Pods running at any given time. As such, it is often used to guarantee the availability of a specified number of identical Pods.\n根據上述描述，Replica Set主要的作用是確保始終都有一定數量的相同Pod可用，保證服務的高可用性。\nKubernetes RS是Kubernetes中的一種控制器，主要用於管理Pod的複製和伸縮，確保Pod的數量。RS具有以下幾種特性 自動管理pod的副本數量：確保指定數量的Pod跟使用者所期望的一致(desired status)，如果發生故障或需要擴展，它會自動創建或刪除Pod。 確保Pod的健康狀態：如果發生故障會對失敗的Pod進行重新調度 創建Pod的Template：當需要新的Pod時會根據定義的Pod Template創建 為什麼需要Replicaset? 在Kubernetes集群中，Pod的管理對於系統的可靠性和彈性至關重要。如果一個Pod發生故障，RS會自動創建一個新的Pod來代替它，確保服務繼續運行。同時，當服務需要擴展以滿足流量增加時，Kubernetes RS也可以自動創建額外的Pod。因此RS解決了以下問題：\n確保服務的高可用性和可靠性：RS可以自動維護一定數量的Pod，確保服務在Pod失敗時仍然可以正常運行。 方便服務的擴展：使用RS可以根據需求調整Pod的副本數量，實現服務的快速擴展。 簡化服務管理：RS可以自動調整Pod的數量，減少手動管理的工作量。 Kubernetes Replicaset是如何運作的？ 定義RS，指定所需的Pod副本數量和Pod Template，創建後，ReplicaSet使用定義好的Pod Template創建Pod，並開始監控每個Pod的狀態以及數量是否與定義的一致(desired status)，如果低於指定副本數則會創建Pod，高於指定副本數則會刪除Pod，當Pod被意外刪除時會創建新的Pod來做替代。\n什麼時候使用Replicaset？ 使用RS通常適用於以下情況：\n需要確保一定數量的Pod正在運行，以保持服務的可用性和可靠性。 需要能夠自動擴展和縮小Pod數量，以應對流量變化和其他需求。 希望能夠自動替換發生故障的Pod，以確保服務的連續運行。 需要管理一個服務的多個Pod，並且希望使用Kubernetes提供的自動化功能，例如調度、網路配置和負載平衡。 Kubernetes Replicaset有哪些特性？ 高可用性：RS的目的是維護一個穩定的Pod副本集，確保始終有一定數量的相同Pod可用，從而保證服務的高可用性。\n健康檢查和自動恢復：ReplicaSet可以通過定期檢查Pod副本的健康狀態來確保服務始終運行。當Pod故障或被刪除時，ReplicaSet會自動創建新的Pod來代替故障的Pod，確保服務的可用性及穩定性。\n自動擴縮：RS會監視Pod副本數量，並自動創建或刪除Pod副本以確保Pod副本數量達到指定的數量。使服務可以自動擴展和縮放，以應對不同的負載。\n版本控制：RS允許在不中斷現有服務的情況下部署新版本。在部署新版本之前先創建一些新Pod副本，然後再刪除舊Pod副本，這樣服務就可以實現無間斷的升級。\n動態標籤選擇：RS可以使用標籤選擇器來選擇Pod副本。可以基於Pod的標籤、名稱和其他屬性進行靈活的選擇。\n動態更新：RS支持動態更新，可以在運行時修改Pod的設定，從而實現靈活的應用程序管理。\n如何使用Replicaset? 宣告式(Declarative) 透過創建一個包含Pod Template的yaml檔，定義Pod的Container和其他元素，例如服務的Image和Configure。然後，可以在yaml檔中指定要創建的Pod數量和其他屬性，例如採用哪種調度策略和如何處理故障。 apiVersion: apps/v1 # 定義api版本 kind: ReplicaSet # 定義資源類型 metadata: # 定義元數據 name: frontend labels: app: guestbook tier: frontend spec: # 定義Pod的規格 replicas: 3 # 定義副本數量 selector: matchLabels: tier: frontend # 選擇Pod的Label template: metadata: labels: tier: frontend # 要創建的Pod的Label spec: # 容器規格 containers: - name: php-redis image: gcr.io/google_samples/gb-frontend:v3 在 ReplicaSet 中，.spec.template.metadata.labels 的值必須與 spec.selector.matchLabels 值相匹配，否則該配置會被 API 拒絕。\n命令式(Imperative) 創建RS kubectl create replicaset \u0026lt;replicaset-name\u0026gt; --image=\u0026lt;image-name\u0026gt; --replicas=\u0026lt;number-of-replicas\u0026gt; 查看RS kubectl describe replicaset \u0026lt;replicaset-name\u0026gt; kubectl get replicaset \u0026lt;replicaset-name\u0026gt; 刪除RS kubectl delete replicaset \u0026lt;replicaset-name\u0026gt; 擴縮RS kubectl scale replicaset \u0026lt;replicaset-name\u0026gt; --replicas=\u0026lt;number-of-replicas\u0026gt; 暫停RS更新 kubectl rollout pause replicaset \u0026lt;replicaset-name\u0026gt; 恢復RS更新 kubectl rollout resume replicaset \u0026lt;replicaset-name\u0026gt; 查看RS更新歷史 kubectl rollout history replicaset \u0026lt;replicaset-name\u0026gt; 回滾更新 kubectl rollout undo replicaset \u0026lt;replicaset-name\u0026gt; Reference ReplicaSet | Kubernetes Kubernetes ReplicaSet 介紹 | 小信豬的原始部落 (godleon.github.io) ","permalink":"https://sz9751210.github.io/posts/k8s-rs/","summary":"什麼是 Kubernetes ReplicaSet? 先來個官網解說\nA ReplicaSet\u0026rsquo;s purpose is to maintain a stable set of replica Pods running at any given time. As such, it is often used to guarantee the availability of a specified number of identical Pods.\n根據上述描述，Replica Set主要的作用是確保始終都有一定數量的相同Pod可用，保證服務的高可用性。\nKubernetes RS是Kubernetes中的一種控制器，主要用於管理Pod的複製和伸縮，確保Pod的數量。RS具有以下幾種特性 自動管理pod的副本數量：確保指定數量的Pod跟使用者所期望的一致(desired status)，如果發生故障或需要擴展，它會自動創建或刪除Pod。 確保Pod的健康狀態：如果發生故障會對失敗的Pod進行重新調度 創建Pod的Template：當需要新的Pod時會根據定義的Pod Template創建 為什麼需要Replicaset? 在Kubernetes集群中，Pod的管理對於系統的可靠性和彈性至關重要。如果一個Pod發生故障，RS會自動創建一個新的Pod來代替它，確保服務繼續運行。同時，當服務需要擴展以滿足流量增加時，Kubernetes RS也可以自動創建額外的Pod。因此RS解決了以下問題：\n確保服務的高可用性和可靠性：RS可以自動維護一定數量的Pod，確保服務在Pod失敗時仍然可以正常運行。 方便服務的擴展：使用RS可以根據需求調整Pod的副本數量，實現服務的快速擴展。 簡化服務管理：RS可以自動調整Pod的數量，減少手動管理的工作量。 Kubernetes Replicaset是如何運作的？ 定義RS，指定所需的Pod副本數量和Pod Template，創建後，ReplicaSet使用定義好的Pod Template創建Pod，並開始監控每個Pod的狀態以及數量是否與定義的一致(desired status)，如果低於指定副本數則會創建Pod，高於指定副本數則會刪除Pod，當Pod被意外刪除時會創建新的Pod來做替代。\n什麼時候使用Replicaset？ 使用RS通常適用於以下情況：\n需要確保一定數量的Pod正在運行，以保持服務的可用性和可靠性。 需要能夠自動擴展和縮小Pod數量，以應對流量變化和其他需求。 希望能夠自動替換發生故障的Pod，以確保服務的連續運行。 需要管理一個服務的多個Pod，並且希望使用Kubernetes提供的自動化功能，例如調度、網路配置和負載平衡。 Kubernetes Replicaset有哪些特性？ 高可用性：RS的目的是維護一個穩定的Pod副本集，確保始終有一定數量的相同Pod可用，從而保證服務的高可用性。\n健康檢查和自動恢復：ReplicaSet可以通過定期檢查Pod副本的健康狀態來確保服務始終運行。當Pod故障或被刪除時，ReplicaSet會自動創建新的Pod來代替故障的Pod，確保服務的可用性及穩定性。\n自動擴縮：RS會監視Pod副本數量，並自動創建或刪除Pod副本以確保Pod副本數量達到指定的數量。使服務可以自動擴展和縮放，以應對不同的負載。","title":"Kubernetes ReplicaSet：Overview"},{"content":"什麼是Kubernetes Service？ 先來個官網的解說\nA Kubernetes Service is an abstraction which defines a logical set of Pods and a policy by which to access them.\n白話文就是，訪問Pod用的一個Component。ＸＤ\nKubernetes Service是個抽象概念，通過Service，當我們的Pod創建好後，定義訪問它們的策略，該如何去訪問一群相同邏輯的Pod，給Pod提供一組穩定的IP或是Port。\n因此也可以把Service當作是一種掛在一群運行相同應用程式前面的LoadBalancer，詳見下圖。\n圖片來源\n為什麼需要Kubernetes Service？ 因為在Kubernetes集群中，Pod的IP地址是不穩定的，可能因為重新調度或重啟Container而改變了IP。為了使其他應用程式能夠穩定地訪問Pod，需要使用Kubernetes Service。\nKubernetes Service是如何工作的？ 當Pod啟動時，它們會自動註冊到Kubernetes集群中的一個服務發現機制中，例如Kubernetes DNS或etcd。Service會監聽這個服務發現機制，並根據Label Selector選擇要提供服務的Pod。\n當其他應用程式需要訪問Pod時，它們可以通過Service的IP和Port進行訪問，Service會將請求根據Label Selector轉發到選定的Pod。由於Service的IP和端口是穩定的，即使Pod的IP地址發生變化，其他應用程式依然可以一直使用相同的IP和Port訪問該Pod。\n圖片來源\nKubernetes Service的類型有哪些？ Kubernetes Service有以下四種類型：\nClusterIP: 在Kubernetes集群內部使用，通常用於應用程式的內部通訊。 NodePort: 將Pod暴露到Kubernetes集群的外部，並使用Node的IP和一個Static Port進行訪問。 LoadBalancer: LoadBalancer是ClusterIP和NodePort的一種擴展。在公有雲上使用，使用雲供應商提供的LoadBalancer將流量轉發到Service中的Pod。 ExternalName: 允許服務將外部DNS名稱映射到Kubernetes集群內部的svc名稱上。這樣可以在不修改應用程式代碼的情況下實現外部服務的訪問。 圖片來源 Kubernetes Service有哪些功能？ Kubernetes Service具有以下功能：\n透明地將請求轉發到Pod中，無需修改應用程式代碼。 提供負載均衡，分散流量到多個Pod中。 支持多種協議，例如TCP、UDP和HTTP。 可以設置Session Affinity，將請求路由到相同的Pod。 可以進行Port轉發，將請求轉發到Pod中的不同Port。 支持跨命名空間訪問。 如何創建和管理Kubernetes Service： 要創建 Kubernetes Service，可以使用以下兩種方式： 宣告式(Declarative) kind: Service apiVersion: v1 metadata: name: my-service spec: # type 一共有四種(ClusterIP, NodePort, LoadBalancer, ExternalName)，預設是 ClusterIP type: ClusterIP # 選擇帶有 \u0026#34;app=MyApp\u0026#34; 的 pod selector: app: MyApp # Service 實際對外服務的設定 ports: # 使用的協定與port，預設為TCP - protocol: TCP port: 80 # Pod對外開放的port，如無設定，預設與spec.ports.port相同 targetPort: 9376 透過以上的定義，網路的流向會呈現下方的樣子：\nRequest \u0026lt;---\u0026gt; Service(tcp:80) \u0026lt;---\u0026gt; Endpoint(tcp:9376) \u0026lt;---\u0026gt; Pod\nService 會將符合 Label Selector 設定的 Pod 建立 Endpoint resource object 做搭配。\n命令式(Imperative) kubectl create service nodeport \u0026lt;myservicename\u0026gt; 管理svc，可用以下方式： Svc查詢： kubectl get svc kubectl describe svc kubectl get svc -o wide 顯示Label Selector選定的Label。 Svc的更新：kubectl edit svc Svc的刪除：kubectl delete svc Reference Service | Kubernetes Kubernetes — Service Types Overview | by Ashish Patel | DevOps Mojo | Medium Kubernetes Service 概念詳解 | Kubernetes (tachingchen.com) [Kubernetes] Service Overview | 小信豬的原始部落 (godleon.github.io) ","permalink":"https://sz9751210.github.io/posts/k8s-svc/","summary":"什麼是Kubernetes Service？ 先來個官網的解說\nA Kubernetes Service is an abstraction which defines a logical set of Pods and a policy by which to access them.\n白話文就是，訪問Pod用的一個Component。ＸＤ\nKubernetes Service是個抽象概念，通過Service，當我們的Pod創建好後，定義訪問它們的策略，該如何去訪問一群相同邏輯的Pod，給Pod提供一組穩定的IP或是Port。\n因此也可以把Service當作是一種掛在一群運行相同應用程式前面的LoadBalancer，詳見下圖。\n圖片來源\n為什麼需要Kubernetes Service？ 因為在Kubernetes集群中，Pod的IP地址是不穩定的，可能因為重新調度或重啟Container而改變了IP。為了使其他應用程式能夠穩定地訪問Pod，需要使用Kubernetes Service。\nKubernetes Service是如何工作的？ 當Pod啟動時，它們會自動註冊到Kubernetes集群中的一個服務發現機制中，例如Kubernetes DNS或etcd。Service會監聽這個服務發現機制，並根據Label Selector選擇要提供服務的Pod。\n當其他應用程式需要訪問Pod時，它們可以通過Service的IP和Port進行訪問，Service會將請求根據Label Selector轉發到選定的Pod。由於Service的IP和端口是穩定的，即使Pod的IP地址發生變化，其他應用程式依然可以一直使用相同的IP和Port訪問該Pod。\n圖片來源\nKubernetes Service的類型有哪些？ Kubernetes Service有以下四種類型：\nClusterIP: 在Kubernetes集群內部使用，通常用於應用程式的內部通訊。 NodePort: 將Pod暴露到Kubernetes集群的外部，並使用Node的IP和一個Static Port進行訪問。 LoadBalancer: LoadBalancer是ClusterIP和NodePort的一種擴展。在公有雲上使用，使用雲供應商提供的LoadBalancer將流量轉發到Service中的Pod。 ExternalName: 允許服務將外部DNS名稱映射到Kubernetes集群內部的svc名稱上。這樣可以在不修改應用程式代碼的情況下實現外部服務的訪問。 圖片來源 Kubernetes Service有哪些功能？ Kubernetes Service具有以下功能：\n透明地將請求轉發到Pod中，無需修改應用程式代碼。 提供負載均衡，分散流量到多個Pod中。 支持多種協議，例如TCP、UDP和HTTP。 可以設置Session Affinity，將請求路由到相同的Pod。 可以進行Port轉發，將請求轉發到Pod中的不同Port。 支持跨命名空間訪問。 如何創建和管理Kubernetes Service： 要創建 Kubernetes Service，可以使用以下兩種方式： 宣告式(Declarative) kind: Service apiVersion: v1 metadata: name: my-service spec: # type 一共有四種(ClusterIP, NodePort, LoadBalancer, ExternalName)，預設是 ClusterIP type: ClusterIP # 選擇帶有 \u0026#34;app=MyApp\u0026#34; 的 pod selector: app: MyApp # Service 實際對外服務的設定 ports: # 使用的協定與port，預設為TCP - protocol: TCP port: 80 # Pod對外開放的port，如無設定，預設與spec.","title":"Kubernetes Service：Overview"},{"content":"Kubernetes是現代應用程序開發和部署的重要技術，而Pod是Kubernetes中最小的部署單位。Pod是一個或多個container的集合，它們共享一個網路命名空間和一個網路接口。Pod不僅提供了一個簡單而強大的container環境，還可以用於實現多種container編排方案，例如負載平衡、數據管理、多container協作等。\n本文將深入探討Kubernetes中的Pod，介紹Pod的基本概念、設計原則和實現方式，以及與其他資源的關係。您將學習如何創建和配置Pod，如何使用Kubernetes管理Pod，以及如何通過Pod實現高效、彈性和可靠的應用程序部署。\n什麼是Kubernetes Pod Kubernetes Pod是Kubernetes集群中最小的部署單位。一個Pod可以包含一個或多個container，這些container共享相同的網路和儲存空間。Pod提供了一個環境，讓container可以協同工作，形成一個應用程序。\nPod的結構和特性 Pod包含以下元素：\n共享網路空間 (Networking)：Pod 中的所有container共享相同的網路空間，可以在container之間通過 localhost 進行通信。 共享儲存空間 (Shared Storage)：Pod 中的所有container共享相同的儲存空間，可以在container之間共享文件、環境變量等。 容器 (Containers)：Pod 中可以包含一個或多個container，這些container可以共享同一個網路和儲存空間，方便container之間的互相協作。 存活和重啟策略 (Liveness and Restart Policy)：Pod 的存活策略指定了在容器出現異常情況時，Kubernetes 如何應對，如重新啟動 container 或者將其標記為失敗。Pod 的重啟策略則指定了當 Pod 中的所有 container 都停止運行時，Kubernetes 如何進行重啟。 元數據 (Metadata)：Pod 中包含一些元數據，如 Pod 名稱、命名空間、標籤等，這些元數據可以用於管理和監控 Pod。 Pod的特性包括：\n生命週期短暫 可以擁有多個container 具有唯一的IP地址 具有獨立的儲存空間 具有網路隔離 如何創建和管理Pod 要創建 Kubernetes Pod，可以使用以下兩種方式： 宣告式（Declarative）：使用 YAML 或 JSON 格式的文件來定義 Pod 的結構、元資料和規格，包括 Pod 名稱、container image、資源限制、網路設定等。 apiVersion: v1 kind: Pod metadata: name: my-pod spec: containers: - name: nginx-container image: nginx:latest ports: - containerPort: 80 接著使用kubectl創建pod\nkubectl create -f my-pod.yaml 命令式（Imperative）：命令式方式是通過在命令行中執行指令，將 Pod、Service、Replication Controller 或其他 Kubernetes 資源創建和管理。 kubectl run my-pod --image=nginx --port=80 要管理pod，則有以下幾種方式：\nPod 的查詢：使用 kubectl get pods 或是 kubectl describe pods 命令查詢 Kubernetes 集群中的 Pod，以了解其狀態、命名空間、IP 地址等信息。\nPod 的更新：當container image或配置發生變化時，可以通過kubectl edit pod 來編輯Pod的 YAML 或 JSON 文件，然後使用 kubectl apply 命令來更新 Pod。\nPod 的刪除：使用 kubectl delete pod 命令刪除 Kubernetes 集群中的 Pod。\nPod 的擴展：可以使用 Deployment、ReplicaSet 等 Kubernetes 資源進行 Pod 的擴展，自動創建、管理多個 Pod，以實現應用程序的高可用性。\nPod 的健康檢查：可以定義 Pod 的 LivenessProbe、ReadinessProbe 檢查container是否正常運行，當container不可用時，Kubernetes 會自動重啟container或調度 Pod 到其他節點。\nPod 的日誌查詢：可以使用 kubectl logs pod 命令查詢 Pod 中 container 的日誌，以了解 container 運行情況。\nPod 的port轉發：可以使用 kubectl port-forward pod 命令將 Pod 中 container 的 port 轉發到本地 port，以便進行調試和測試。\nPod的生命週期 Pod的生命週期包括以下階段：\nPending：Pod正在等待Kubernetes集群分配資源 Running：Pod正在運行中 Succeeded：Pod已經完成工作並成功退出 Failed：Pod因為某些原因無法運行或者已經退出 Unknown：Kubernetes無法獲取Pod的狀態 Pod的網路和儲存設定 Pod的網路和儲存設定包括以下方面：\ncontainer的port和協議\n在 Pod 配置中，可以通過 containerPort 屬性來指定container需要暴露的port和協議。下面是一個示例：\napiVersion: v1 kind: Pod metadata: name: web-pod spec: containers: - name: web-container image: nginx ports: - containerPort: 80 protocol: TCP 在這個範例中，定義了一個名為 web-pod 的 Pod，其中包含一個名為 web-container 的container，該container需要暴露 TCP 協議的 80 port。 Pod的IP地址和主機名稱\n在 Pod 中，每個container都有自己的 IP 地址和主機名稱。可以通過 hostname、subdomain 和 ip 屬性來設定它們。\napiVersion: v1 kind: Pod metadata: name: web-pod spec: hostname: web-host subdomain: example.com containers: - name: web-container image: nginx 在這個範例中，定義了一個名為 web-pod 的 Pod，其中包含一個名為 web-container 的container。還通過 hostname 屬性設定了container的主機名稱為 web-host，通過 subdomain 屬性設定了container的子域名為 example.com。 Pod的網路策略\n在 Kubernetes 中，可以通過 networkPolicy 屬性設定 Pod 的網路策略，以控制哪些 Pod 可以訪問該 Pod。\napiVersion: v1 kind: Pod metadata: name: web-pod spec: containers: - name: web-container image: nginx networkPolicy: podSelector: matchLabels: app: web ingress: - from: - podSelector: matchLabels: app: db 在這個範例中，定義了一個名為 web-pod 的 Pod，其中包含一個名為 web-container 的container。通過 networkPolicy 屬性設定了該 Pod 的網路策略，只允許來自標籤為 app=db 的 Pod 訪問它。 Pod的儲存設定\n在 Pod 中，可以通過 volumes 屬性設定儲存設定。\napiVersion: v1 kind: Pod metadata: name: web-pod spec: containers: - name: web-container image: nginx volumeMounts: - name: data-volume mountPath: /data volumes: - name: data-volume emptyDir: {} 在這個範例中，定義了一個名為 web-pod 的 Pod，其中包含一個名為 web-container 的container。通過 volumeMounts 屬性設定了一個名為 data-volume 的卷並將其掛載到container的 /data 目錄下，並通過 volumes 屬性定義了這個卷的內容，這裡使用了一個 emptyDir 卷，表示它是一個空目錄。\nReference Pod | Kubernetes ","permalink":"https://sz9751210.github.io/posts/k8s-pod/","summary":"Kubernetes是現代應用程序開發和部署的重要技術，而Pod是Kubernetes中最小的部署單位。Pod是一個或多個container的集合，它們共享一個網路命名空間和一個網路接口。Pod不僅提供了一個簡單而強大的container環境，還可以用於實現多種container編排方案，例如負載平衡、數據管理、多container協作等。\n本文將深入探討Kubernetes中的Pod，介紹Pod的基本概念、設計原則和實現方式，以及與其他資源的關係。您將學習如何創建和配置Pod，如何使用Kubernetes管理Pod，以及如何通過Pod實現高效、彈性和可靠的應用程序部署。\n什麼是Kubernetes Pod Kubernetes Pod是Kubernetes集群中最小的部署單位。一個Pod可以包含一個或多個container，這些container共享相同的網路和儲存空間。Pod提供了一個環境，讓container可以協同工作，形成一個應用程序。\nPod的結構和特性 Pod包含以下元素：\n共享網路空間 (Networking)：Pod 中的所有container共享相同的網路空間，可以在container之間通過 localhost 進行通信。 共享儲存空間 (Shared Storage)：Pod 中的所有container共享相同的儲存空間，可以在container之間共享文件、環境變量等。 容器 (Containers)：Pod 中可以包含一個或多個container，這些container可以共享同一個網路和儲存空間，方便container之間的互相協作。 存活和重啟策略 (Liveness and Restart Policy)：Pod 的存活策略指定了在容器出現異常情況時，Kubernetes 如何應對，如重新啟動 container 或者將其標記為失敗。Pod 的重啟策略則指定了當 Pod 中的所有 container 都停止運行時，Kubernetes 如何進行重啟。 元數據 (Metadata)：Pod 中包含一些元數據，如 Pod 名稱、命名空間、標籤等，這些元數據可以用於管理和監控 Pod。 Pod的特性包括：\n生命週期短暫 可以擁有多個container 具有唯一的IP地址 具有獨立的儲存空間 具有網路隔離 如何創建和管理Pod 要創建 Kubernetes Pod，可以使用以下兩種方式： 宣告式（Declarative）：使用 YAML 或 JSON 格式的文件來定義 Pod 的結構、元資料和規格，包括 Pod 名稱、container image、資源限制、網路設定等。 apiVersion: v1 kind: Pod metadata: name: my-pod spec: containers: - name: nginx-container image: nginx:latest ports: - containerPort: 80 接著使用kubectl創建pod","title":"Kubernetes Pod：Overview"},{"content":"標題：5 ChatGPT features to boost your daily work\n連結：5 ChatGPT features to boost your daily work | by Josep Ferrer | Geek Culture | Jan, 2023 | Medium\n機器學習技術正逐漸地應用到日常工作之中，ChatGPT 便是其中之一。ChatGPT 是由 OpenAI 訓練的一個大型語言模型，它能夠根據輸入的文字，生成各種形式的回應，包括文字、代碼和語言翻譯等。\n在這篇文章中，作者將介紹 ChatGPT 的五個強大功能，這些功能可以幫助開發者提高工作效率和生產力。\n產生語言框架：ChatGPT 可以生成編碼框架，幫助開發人員更快速地開始編碼。\n研究和比較：ChatGPT 可以幫助使用者對不同主題進行研究和比較，包括比較產品、服務、技術、公司等等。\n理解代碼：ChatGPT 可以分析並幫助使用者理解代碼，包括程式語言、代碼段和概念等。\n為代碼添加註釋：ChatGPT 可以根據輸入的代碼，產生相應的註釋，幫助使用者更輕鬆地理解代碼和更有效地與團隊成員協作。\n使用特定風格重寫代碼：ChatGPT 可以根據輸入的代碼，重寫代碼並生成相應的代碼風格，以滿足不同的編碼標準和最佳實踐。\n","permalink":"https://sz9751210.github.io/posts/5-chatgpt-features-to-boost-your-daily-work/","summary":"標題：5 ChatGPT features to boost your daily work\n連結：5 ChatGPT features to boost your daily work | by Josep Ferrer | Geek Culture | Jan, 2023 | Medium\n機器學習技術正逐漸地應用到日常工作之中，ChatGPT 便是其中之一。ChatGPT 是由 OpenAI 訓練的一個大型語言模型，它能夠根據輸入的文字，生成各種形式的回應，包括文字、代碼和語言翻譯等。\n在這篇文章中，作者將介紹 ChatGPT 的五個強大功能，這些功能可以幫助開發者提高工作效率和生產力。\n產生語言框架：ChatGPT 可以生成編碼框架，幫助開發人員更快速地開始編碼。\n研究和比較：ChatGPT 可以幫助使用者對不同主題進行研究和比較，包括比較產品、服務、技術、公司等等。\n理解代碼：ChatGPT 可以分析並幫助使用者理解代碼，包括程式語言、代碼段和概念等。\n為代碼添加註釋：ChatGPT 可以根據輸入的代碼，產生相應的註釋，幫助使用者更輕鬆地理解代碼和更有效地與團隊成員協作。\n使用特定風格重寫代碼：ChatGPT 可以根據輸入的代碼，重寫代碼並生成相應的代碼風格，以滿足不同的編碼標準和最佳實踐。","title":"閱讀筆記：5 ChatGPT features to boost your daily work"},{"content":"Intro👨‍💻 在gcp環境下使用ansible playbook 建立k8s cluster，目前base image為centos 7，安裝方式類似elk stack，一樣先等master安裝完後產生token，接著安裝slave。\n使用的CRI為containerd，CNI為calico\n資料夾結構 . ├── README.md ├── create_k8s_master_instance.yaml ├── create_k8s_slave_instance.yaml ├── files │ ├── instance │ └── k8s ├── group_vars │ └── all ├── inventory │ └── k8s.cluster.host ├── inventory.instance.create.yml.example ├── k8s-setup.sh ├── roles │ ├── instance │ ├── k8s │ ├── monitor │ └── ops_agent └── vars ├── instance ├── k8s └── monitor 使用指南 設定機器資訊：複製好inventory.instance.create.yml.example後，可參考inventory裡的設定，主要設定gcp的資訊， 設定group_vars的env.yml，改成自己的gcp的專案以及要設定的region 可使用k8s-setup.sh進行一鍵安裝 sh ./k8s-setup.sh 建置流程 k8s_master -\u0026gt; k8s_slave\n指令 ANSIBLE_HOST_KEY_CHECKING=False ansible-playbook -i inventory.instance.create.yml create_xxx_instance.yaml -v 安裝完後可以去master切成root確認是否有組成cluster\n預計添加功能 添加自定義CRI與CNI 可選k8s版本 可依照base image進行相對應的安裝 Reference Install Kubernetes Cluster on CentOS 7 with kubeadm | ComputingForGeeks\nAutomating Kubernetes Cluster Using Ansible | by Shubham Mehta | Medium\n🔗專案repo –\u0026gt; sz9751210/ansible-k8s (github.com)\n","permalink":"https://sz9751210.github.io/posts/ansible-k8s/","summary":"Intro👨‍💻 在gcp環境下使用ansible playbook 建立k8s cluster，目前base image為centos 7，安裝方式類似elk stack，一樣先等master安裝完後產生token，接著安裝slave。\n使用的CRI為containerd，CNI為calico\n資料夾結構 . ├── README.md ├── create_k8s_master_instance.yaml ├── create_k8s_slave_instance.yaml ├── files │ ├── instance │ └── k8s ├── group_vars │ └── all ├── inventory │ └── k8s.cluster.host ├── inventory.instance.create.yml.example ├── k8s-setup.sh ├── roles │ ├── instance │ ├── k8s │ ├── monitor │ └── ops_agent └── vars ├── instance ├── k8s └── monitor 使用指南 設定機器資訊：複製好inventory.instance.create.yml.example後，可參考inventory裡的設定，主要設定gcp的資訊， 設定group_vars的env.yml，改成自己的gcp的專案以及要設定的region 可使用k8s-setup.sh進行一鍵安裝 sh ./k8s-setup.sh 建置流程 k8s_master -\u0026gt; k8s_slave","title":"ansible k8s"},{"content":"標題：15 Best Practices when working with Docker\n連結：15 Best Practices when working with Docker | by Ali Zeynalli | Dec, 2022 | Medium\n本篇文章作者根據經驗以及自身研究整理出了15個使用Docker的技巧與提示\n1. 進行中的工作不應保存在未命名、已停止的容器中 如果進行中的工作保存在不好的容器中，可能會導致資料丟失、風險以及安全問題、不利於協作\n2. 定期清理Image 幫助釋放存儲空間，優化Docker引擎性能，減少安全風險，以及維持主機整潔，易於管理。\n3. 使用授權的相依套件 可以帶來更好的合法性、安全性、可靠性、支持性和法律責任。\n4. 將變化很大的部分放在 DockerFile 的末尾 因為Docker會將每個步驟緩存為一個單獨的容器，重複的操作將不會重新執行，將變化較大的部分放在最後可提高性能\n5. 不要在容器啟動時就獲取相依套件 避免在容器啟動時獲取依賴包帶來的問題，並提高容器的啟動速度和可管理性。最佳實踐是在構建Image時就獲取依賴包，並將它們打包到Image中。另外，還可以使用多階段構建和緩存等技術來優化構建過程，提高構建速度和效率。\n6. 不要掛載共享資料夾 有助於提高容器的可移植性、安全性、可重現性和可管理性。\n7. 保持Image simple and small 可以提高應用程序的可移植性、降低安全風險、減少Image大小、提高Image構建和管理效率。\n8. 從頭開始構建 最大限度地減少相依\n9. Tag Image 使用合理的Tag，有助於對Image進行排序\n10. 使用小型基礎Image 例如-slim或-alpine，可以帶來更明確的依賴項、更少的儲存、更少的安全漏洞和攻擊面以及更快的構建時間。\n11. 使用官方Image 帶來可靠性、安全性、活躍的社群支持以及易用性等好處。\n12. 創建臨時容器 Dockerfile定義的Image應該盡可能是臨時的，提供隔離環境、避免依賴衝突、快速清理、易於重複，提高工作效率與可靠性，方便快速測試，不必擔心對主機有影響。\n13. 使用multi-stage構建 幫助減小Docker Image的大小，優化構建速度，簡化構建過程，以及提高Docker Image的安全性。\n14. 將多行參數進行排序 將多個RUN命令組合起來，減少Image層數、構建時間、優化Image緩存、增加Dockerfile可讀性。\n15. 使用.Dockerignore 從構建中排除不必要的文件，減少Image大小並增加構建速度。\n","permalink":"https://sz9751210.github.io/posts/15-best-practices-when-working-with-docker/","summary":"標題：15 Best Practices when working with Docker\n連結：15 Best Practices when working with Docker | by Ali Zeynalli | Dec, 2022 | Medium\n本篇文章作者根據經驗以及自身研究整理出了15個使用Docker的技巧與提示\n1. 進行中的工作不應保存在未命名、已停止的容器中 如果進行中的工作保存在不好的容器中，可能會導致資料丟失、風險以及安全問題、不利於協作\n2. 定期清理Image 幫助釋放存儲空間，優化Docker引擎性能，減少安全風險，以及維持主機整潔，易於管理。\n3. 使用授權的相依套件 可以帶來更好的合法性、安全性、可靠性、支持性和法律責任。\n4. 將變化很大的部分放在 DockerFile 的末尾 因為Docker會將每個步驟緩存為一個單獨的容器，重複的操作將不會重新執行，將變化較大的部分放在最後可提高性能\n5. 不要在容器啟動時就獲取相依套件 避免在容器啟動時獲取依賴包帶來的問題，並提高容器的啟動速度和可管理性。最佳實踐是在構建Image時就獲取依賴包，並將它們打包到Image中。另外，還可以使用多階段構建和緩存等技術來優化構建過程，提高構建速度和效率。\n6. 不要掛載共享資料夾 有助於提高容器的可移植性、安全性、可重現性和可管理性。\n7. 保持Image simple and small 可以提高應用程序的可移植性、降低安全風險、減少Image大小、提高Image構建和管理效率。\n8. 從頭開始構建 最大限度地減少相依\n9. Tag Image 使用合理的Tag，有助於對Image進行排序\n10. 使用小型基礎Image 例如-slim或-alpine，可以帶來更明確的依賴項、更少的儲存、更少的安全漏洞和攻擊面以及更快的構建時間。\n11. 使用官方Image 帶來可靠性、安全性、活躍的社群支持以及易用性等好處。\n12. 創建臨時容器 Dockerfile定義的Image應該盡可能是臨時的，提供隔離環境、避免依賴衝突、快速清理、易於重複，提高工作效率與可靠性，方便快速測試，不必擔心對主機有影響。\n13. 使用multi-stage構建 幫助減小Docker Image的大小，優化構建速度，簡化構建過程，以及提高Docker Image的安全性。","title":"閱讀筆記：15 Best Practices when working with Docker"},{"content":"👨‍💻簡介 什麼是crontab Crontab 是一個 Unix 系統下的定時任務管理工具。它允許用戶自動在特定時間執行指令或程式，而無需人工干預。Crontab 文件中的每一行都代表一個定時任務，其中指定了任務執行的時間，以及要執行的指令或程式。\ncrontab用在哪 適用於週期性的任務，例如每天定時備份檔案，或者每周定時發送報表等等。使用 Crontab 可以大大簡化這些任務的管理，避免因人為錯誤而導致的問題。\n語法 crontab [ -e [UserName] | -l [UserName] | -r [UserName] | -v [UserName] | File ] 選項 參數 說明 -e UserName 編輯crontab -l UserName 顯示當前用戶的crontab -r UserName 移除當前用戶的crontab -v UserName 顯示當前用戶的cron jobs狀態 格式 # ┌───────────── 分鐘 (0 - 59) # │ ┌─────────── 小時 (0 - 23) # │ │ ┌───────── 日 (1 - 31) # │ │ │ ┌─────── 月 (1 - 12) # │ │ │ │ ┌───── 星期幾 (0 - 7，0 是週日，6 是週六，7 也是週日) # │ │ │ │ │ # * * * * * /path/to/command 範例 查看自己的crontab crontab -l 查看指定用戶的crontab sudo crontab -u alan -l 編輯crontab crontab -e 編輯指定用戶的crontab sudo crontab -u alan -e 刪除crontab crontab -r 擴展 參數 說明 crontab格式 @reboot 每次重開機執行一次 @yearly 每年執行一次 0 0 1 1 * @annualy 每年執行一次 0 0 1 1 * @monthly 每月執行一次 0 0 1 * * @weekly 每週執行一次 0 0 * * 0 @daily 每天執行一次 0 0 * * * @hourly 每小時執行一次 0 * * * * 限制特定用戶執行crontab 使用場景：系統安全性考量 使用到的檔案 /etc/cron.allow：白名單 /etc/cron.deny：黑名單 如果 /etc/cron.allow 與 /etc/cron.deny 兩個設定檔都不存在，則就只有系統管理者 root 能夠使用 crontab。\n範例：允許user1可以用crontab echo \u0026#34;user1\u0026#34; \u0026gt; /etc/cron.allow Reference 鳥哥私房菜 - 第十五章、例行性工作排程(crontab) (vbird.org) Linux 設定 crontab 例行性工作排程教學與範例 - G. T. Wang (gtwang.org) How to allow only specific non-root user(s) to use crontab – The Geek Diary ","permalink":"https://sz9751210.github.io/posts/linux-crontab/","summary":"👨‍💻簡介 什麼是crontab Crontab 是一個 Unix 系統下的定時任務管理工具。它允許用戶自動在特定時間執行指令或程式，而無需人工干預。Crontab 文件中的每一行都代表一個定時任務，其中指定了任務執行的時間，以及要執行的指令或程式。\ncrontab用在哪 適用於週期性的任務，例如每天定時備份檔案，或者每周定時發送報表等等。使用 Crontab 可以大大簡化這些任務的管理，避免因人為錯誤而導致的問題。\n語法 crontab [ -e [UserName] | -l [UserName] | -r [UserName] | -v [UserName] | File ] 選項 參數 說明 -e UserName 編輯crontab -l UserName 顯示當前用戶的crontab -r UserName 移除當前用戶的crontab -v UserName 顯示當前用戶的cron jobs狀態 格式 # ┌───────────── 分鐘 (0 - 59) # │ ┌─────────── 小時 (0 - 23) # │ │ ┌───────── 日 (1 - 31) # │ │ │ ┌─────── 月 (1 - 12) # │ │ │ │ ┌───── 星期幾 (0 - 7，0 是週日，6 是週六，7 也是週日) # │ │ │ │ │ # * * * * * /path/to/command 範例 查看自己的crontab crontab -l 查看指定用戶的crontab sudo crontab -u alan -l 編輯crontab crontab -e 編輯指定用戶的crontab sudo crontab -u alan -e 刪除crontab crontab -r 擴展 參數 說明 crontab格式 @reboot 每次重開機執行一次 @yearly 每年執行一次 0 0 1 1 * @annualy 每年執行一次 0 0 1 1 * @monthly 每月執行一次 0 0 1 * * @weekly 每週執行一次 0 0 * * 0 @daily 每天執行一次 0 0 * * * @hourly 每小時執行一次 0 * * * * 限制特定用戶執行crontab 使用場景：系統安全性考量 使用到的檔案 /etc/cron.","title":"Linux 定時任務[crontab]"},{"content":"Intro🧑‍💻 紀錄有哪些方式可以ssh到gce機器\n放key到中繼資料 Compute Enging -\u0026gt; 中繼資料 -\u0026gt; 安全殼層金鑰 使用TCP Tunneling\ngcloud compute start-iap-tunnel --project project-id --zone vm-zone --local-host-port 127.0.0.1:10001 vm-host 22 使用gcloud ssh gcloud compute ssh --zone vm-zone vm-host --tunnel-through-iap --project project-id 可編寫tunnel的script\n## dev gcloud compute start-iap-tunnel dev-border 22 --local-host-port 127.0.0.1:10120 --zone asia-east1-b --project gcp-project \u0026amp; ## test gcloud compute start-iap-tunnel test-border 22 --local-host-port localhost:10121 --zone asia-east1-b --project gcp-project \u0026amp; ## prod gcloud compute start-iap-tunnel prod-border 22 --zone asia-east1-b --local-host-port 127.0.0.1:10122 --project gcp-project \u0026amp; Reference 使用 IAP 进行 TCP 转发 | Identity-Aware Proxy | Google Cloud SSH TCP Tunneling using Google Cloud SDK Identity Aware Proxy Commands (github.com) ","permalink":"https://sz9751210.github.io/posts/gcp%E8%B7%B3%E6%9D%BF%E6%A9%9Fssh%E7%9B%B8%E9%97%9C%E8%A8%AD%E5%AE%9A/","summary":"Intro🧑‍💻 紀錄有哪些方式可以ssh到gce機器\n放key到中繼資料 Compute Enging -\u0026gt; 中繼資料 -\u0026gt; 安全殼層金鑰 使用TCP Tunneling\ngcloud compute start-iap-tunnel --project project-id --zone vm-zone --local-host-port 127.0.0.1:10001 vm-host 22 使用gcloud ssh gcloud compute ssh --zone vm-zone vm-host --tunnel-through-iap --project project-id 可編寫tunnel的script\n## dev gcloud compute start-iap-tunnel dev-border 22 --local-host-port 127.0.0.1:10120 --zone asia-east1-b --project gcp-project \u0026amp; ## test gcloud compute start-iap-tunnel test-border 22 --local-host-port localhost:10121 --zone asia-east1-b --project gcp-project \u0026amp; ## prod gcloud compute start-iap-tunnel prod-border 22 --zone asia-east1-b --local-host-port 127.","title":"gcp遠端連線的幾種方式"},{"content":"簡介👩‍💻 最近在研究terraform與ansible的整合，不過還在摸索中，機器的版控對於維運來講相對重要，這時候有terraform的出現，在建立機器後會隨之產生機器的狀態檔，而ansible則是在建立好機器後幫助我完成我所需的機器相關設定\n這是一款terraform結合ansible的小玩具，在gcp環境下使用terraform幫我建置好機器，接著使用local exec執行ansible的playbook完成機器的設定\n資料夾結構 ├───ansible-playbook │ ├───group_vars │ │ └───all │ ├───roles │ │ ├───instance │ │ │ └───tasks │ │ └───ops_agent │ │ └───tasks │ └───vars │ └───instance ├───modules │ └───main.tf │ └───variables.tf └───roles └───general └───general.tf ansible-playbook：放置ansible相關工具 modules：放置主要使用的resource以及定義好的變數 roles：放置自定義參數 使用指南 先建立gcp sa給terraform可以有建立vm的權限，接著可以下\nterraform init -\u0026gt; 先讓terraform下載相關的repo terraform plan -\u0026gt; 查看terraform會做哪些事情，一開始都會先去檢查狀態檔，最上面代表動作，此範例為create，最下面的plan代表總共有4個resource會add terraform apply -\u0026gt; 建立機器指令，apply一樣會把plan的部分也顯示出來，並詢問是否要繼續，打上yes後便會開始建置機器 terraform destroy -\u0026gt; 機器建立完要刪除時下這指令，destroy一樣會去檢查狀態檔，這次的動作為destroy，最下面的plan顯示4個資源會被destroy terraform show -\u0026gt; 可以顯示當前terraform的狀態 🔗專案repo \u0026ndash;\u0026gt; https://github.com/sz9751210/terraform-demo\n","permalink":"https://sz9751210.github.io/posts/terraform-ansible/","summary":"簡介👩‍💻 最近在研究terraform與ansible的整合，不過還在摸索中，機器的版控對於維運來講相對重要，這時候有terraform的出現，在建立機器後會隨之產生機器的狀態檔，而ansible則是在建立好機器後幫助我完成我所需的機器相關設定\n這是一款terraform結合ansible的小玩具，在gcp環境下使用terraform幫我建置好機器，接著使用local exec執行ansible的playbook完成機器的設定\n資料夾結構 ├───ansible-playbook │ ├───group_vars │ │ └───all │ ├───roles │ │ ├───instance │ │ │ └───tasks │ │ └───ops_agent │ │ └───tasks │ └───vars │ └───instance ├───modules │ └───main.tf │ └───variables.tf └───roles └───general └───general.tf ansible-playbook：放置ansible相關工具 modules：放置主要使用的resource以及定義好的變數 roles：放置自定義參數 使用指南 先建立gcp sa給terraform可以有建立vm的權限，接著可以下\nterraform init -\u0026gt; 先讓terraform下載相關的repo terraform plan -\u0026gt; 查看terraform會做哪些事情，一開始都會先去檢查狀態檔，最上面代表動作，此範例為create，最下面的plan代表總共有4個resource會add terraform apply -\u0026gt; 建立機器指令，apply一樣會把plan的部分也顯示出來，並詢問是否要繼續，打上yes後便會開始建置機器 terraform destroy -\u0026gt; 機器建立完要刪除時下這指令，destroy一樣會去檢查狀態檔，這次的動作為destroy，最下面的plan顯示4個資源會被destroy terraform show -\u0026gt; 可以顯示當前terraform的狀態 🔗專案repo \u0026ndash;\u0026gt; https://github.com/sz9751210/terraform-demo","title":"terraform-ansible"},{"content":"安裝與設定所需依賴 安裝依賴套件 sudo yum install -y curl policycoreutils-python openssh-server perl 啟動 SSH 服務 sudo systemctl enable sshd sudo systemctl start sshd 防火牆開啟網頁要用的PORT網頁 sudo firewall-cmd --permanent --add-service=http sudo firewall-cmd --permanent --add-service=https sudo systemctl reload firewalld 安裝 SMTP Server (Postfix)，發送通知email用 sudo yum install postfix sudo systemctl enable postfix sudo systemctl start postfix 添加gitlab repo以及安裝package Add Gitlab package 可自行選擇要安裝CE版還是EE版，如果要安裝EE版則把gitlab-ce改成gitlab-ee即可 curl https://packages.gitlab.com/install/repositories/gitlab/gitlab-ce/script.rpm.sh | sudo bash Install Gitlab 這邊建置是使用內網，因此使用http的方式下去做設定 sudo EXTERNAL_URL=\u0026#34;http://{{ internal_ip }}\u0026#34; yum install -y gitlab-ce reference Download and install GitLab | GitLab\n","permalink":"https://sz9751210.github.io/posts/centos7%E5%AE%89%E8%A3%9Dgitlab/","summary":"安裝與設定所需依賴 安裝依賴套件 sudo yum install -y curl policycoreutils-python openssh-server perl 啟動 SSH 服務 sudo systemctl enable sshd sudo systemctl start sshd 防火牆開啟網頁要用的PORT網頁 sudo firewall-cmd --permanent --add-service=http sudo firewall-cmd --permanent --add-service=https sudo systemctl reload firewalld 安裝 SMTP Server (Postfix)，發送通知email用 sudo yum install postfix sudo systemctl enable postfix sudo systemctl start postfix 添加gitlab repo以及安裝package Add Gitlab package 可自行選擇要安裝CE版還是EE版，如果要安裝EE版則把gitlab-ce改成gitlab-ee即可 curl https://packages.gitlab.com/install/repositories/gitlab/gitlab-ce/script.rpm.sh | sudo bash Install Gitlab 這邊建置是使用內網，因此使用http的方式下去做設定 sudo EXTERNAL_URL=\u0026#34;http://{{ internal_ip }}\u0026#34; yum install -y gitlab-ce reference Download and install GitLab | GitLab","title":"Centos 7 安裝gitlab"},{"content":"使用Rake task 將user_name改成要變更密碼的user name即可\nsudo gitlab-rake \u0026#34;gitlab:password:reset[user_name]\u0026#34; 使用Rails console 開啟rails console sudo gitlab-rails console 取得user 透過username user = User.find_by_username \u0026#39;user_name\u0026#39; 透過userID user = User.find(uid) 透過email user = User.find_by(email: \u0026#39;user@example.com\u0026#39;) 重置密碼 new_password = \u0026#39;my_new_password\u0026#39; user.password = new_password user.password_confirmation = new_password 儲存修改 user.save! 退出console exit ","permalink":"https://sz9751210.github.io/posts/gitlab-%E4%BF%AE%E6%94%B9%E5%AF%86%E7%A2%BC/","summary":"使用Rake task 將user_name改成要變更密碼的user name即可\nsudo gitlab-rake \u0026#34;gitlab:password:reset[user_name]\u0026#34; 使用Rails console 開啟rails console sudo gitlab-rails console 取得user 透過username user = User.find_by_username \u0026#39;user_name\u0026#39; 透過userID user = User.find(uid) 透過email user = User.find_by(email: \u0026#39;user@example.com\u0026#39;) 重置密碼 new_password = \u0026#39;my_new_password\u0026#39; user.password = new_password user.password_confirmation = new_password 儲存修改 user.save! 退出console exit ","title":"Gitlab 修改密碼"},{"content":"題目描述 將一個已經排序好的list中重複的數字刪去，並回傳list長度，必須以in-place的方式處理，不能使用額外的空間\n解題思路 使用兩個指針，一個紀錄都沒重複的次數(slow)，一個紀錄當前沒重複的數字(fast)，如果重複，則更新沒重複的數字\nPython class Solution: def removeDuplicates(self, nums: List[int]) -\u0026gt; int: n = len(nums) if n \u0026lt; 2: return n slow, fast = 1, 1 for fast in range(1,n): if nums[fast-1] != nums[fast]: nums[slow] = nums[fast] slow += 1 return slow Golang func removeDuplicates(nums []int) int { n := len(nums) if n \u0026lt; 2 { return n } slow, fast := 1, 1 for fast \u0026lt; n { if nums[fast-1] != nums[fast] { nums[slow] = nums[fast] slow++ } fast++ } return slow } ","permalink":"https://sz9751210.github.io/posts/leetcode-26/","summary":"題目描述 將一個已經排序好的list中重複的數字刪去，並回傳list長度，必須以in-place的方式處理，不能使用額外的空間\n解題思路 使用兩個指針，一個紀錄都沒重複的次數(slow)，一個紀錄當前沒重複的數字(fast)，如果重複，則更新沒重複的數字\nPython class Solution: def removeDuplicates(self, nums: List[int]) -\u0026gt; int: n = len(nums) if n \u0026lt; 2: return n slow, fast = 1, 1 for fast in range(1,n): if nums[fast-1] != nums[fast]: nums[slow] = nums[fast] slow += 1 return slow Golang func removeDuplicates(nums []int) int { n := len(nums) if n \u0026lt; 2 { return n } slow, fast := 1, 1 for fast \u0026lt; n { if nums[fast-1] !","title":"leetcode 26. Remove Duplicates from Sorted Array"},{"content":"題目描述 給一個長度固定的list，將裡面出現的0做複製，並將剩餘的元素往右移\n解題思路 使用單指針做遍歷，條件有兩個，都符合才做處理\n假如當前元素為0 考慮最後一個元素也為0要小於list長度 Python class Solution: def duplicateZeros(self, arr: List[int]) -\u0026gt; None: \u0026#34;\u0026#34;\u0026#34; Do not return anything, modify arr in-place instead. \u0026#34;\u0026#34;\u0026#34; i = 0 while i \u0026lt; len(arr): if arr[i] == 0 and i + 1 \u0026lt; len(arr): arr.insert(i+1, 0) arr.pop() i += 1 i += 1 Golang func duplicateZeros(arr []int) { for i := 0; i \u0026lt; len(arr); i++ { if arr[i] == 0 \u0026amp;\u0026amp; i+1 \u0026lt; len(arr) { arr = append(arr[:i+1], arr[i:len(arr)-1]...) i ++ } } } ","permalink":"https://sz9751210.github.io/posts/leetcode-1089/","summary":"題目描述 給一個長度固定的list，將裡面出現的0做複製，並將剩餘的元素往右移\n解題思路 使用單指針做遍歷，條件有兩個，都符合才做處理\n假如當前元素為0 考慮最後一個元素也為0要小於list長度 Python class Solution: def duplicateZeros(self, arr: List[int]) -\u0026gt; None: \u0026#34;\u0026#34;\u0026#34; Do not return anything, modify arr in-place instead. \u0026#34;\u0026#34;\u0026#34; i = 0 while i \u0026lt; len(arr): if arr[i] == 0 and i + 1 \u0026lt; len(arr): arr.insert(i+1, 0) arr.pop() i += 1 i += 1 Golang func duplicateZeros(arr []int) { for i := 0; i \u0026lt; len(arr); i++ { if arr[i] == 0 \u0026amp;\u0026amp; i+1 \u0026lt; len(arr) { arr = append(arr[:i+1], arr[i:len(arr)-1].","title":"leetcode 1089 - Duplicate Zeros"},{"content":"題目描述 給一個列表以及一個列表裡兩數相加起來的數，返回此兩數的列表位置\n解題思路 可用字典結構當作存取位置用，並用遍歷將相減後還沒有出現的數存進字典裡，之後如果有遍歷到字典裡的數即可立馬返回位置\n一樣使用雙指針，將list的index跟element分組做排序，因此新的list為由小到大，接著使用雙指針，一個指向頭一個指向尾，相加如果小於target則代表start太小，相加如果大於target代表end太大\nPython 原本想用兩個for去解決\nclass Solution: def twoSum(self, nums: List[int], target: int) -\u0026gt; List[int]: for i in range(len(nums)): left = nums[i+1:] for j in range(len(left)): if (nums[i] + left[j]) == target: return i, j+i+1 但提交後噴了time limit exceeded\n1.\nclass Solution: def twoSum(self, nums: List[int], target: int) -\u0026gt; List[int]: dict = {} for i in range(len(nums)): if target - nums[i] not in dict: dict[nums[i]] = i else: return [dict[target - nums[i]], i] class Solution: def twoSum(self, nums: List[int], target: int) -\u0026gt; List[int]: list_ele_idx = [(ele, idx) for idx, ele in enumerate(nums)] # 主要讓ele在前，使sort生效，因此前面會寫成(ele, idx)，讓ele可以排序 list_ele_idx.sort() start, end = 0, len(nums)-1 while(start \u0026lt; end): if list_ele_idx[start][0] + list_ele_idx[end][0] == target: return sorted([list_ele_idx[start][1], list_ele_idx[end][1]]) elif list_ele_idx[start][0] + list_ele_idx[end][0] \u0026lt; target: # need bigger start += 1 else: # nums[start] + nums[end] \u0026gt; target: # need smaller end -= 1 else: return [-1, -1] ","permalink":"https://sz9751210.github.io/posts/leetcode-01/","summary":"題目描述 給一個列表以及一個列表裡兩數相加起來的數，返回此兩數的列表位置\n解題思路 可用字典結構當作存取位置用，並用遍歷將相減後還沒有出現的數存進字典裡，之後如果有遍歷到字典裡的數即可立馬返回位置\n一樣使用雙指針，將list的index跟element分組做排序，因此新的list為由小到大，接著使用雙指針，一個指向頭一個指向尾，相加如果小於target則代表start太小，相加如果大於target代表end太大\nPython 原本想用兩個for去解決\nclass Solution: def twoSum(self, nums: List[int], target: int) -\u0026gt; List[int]: for i in range(len(nums)): left = nums[i+1:] for j in range(len(left)): if (nums[i] + left[j]) == target: return i, j+i+1 但提交後噴了time limit exceeded\n1.\nclass Solution: def twoSum(self, nums: List[int], target: int) -\u0026gt; List[int]: dict = {} for i in range(len(nums)): if target - nums[i] not in dict: dict[nums[i]] = i else: return [dict[target - nums[i]], i] class Solution: def twoSum(self, nums: List[int], target: int) -\u0026gt; List[int]: list_ele_idx = [(ele, idx) for idx, ele in enumerate(nums)] # 主要讓ele在前，使sort生效，因此前面會寫成(ele, idx)，讓ele可以排序 list_ele_idx.","title":"leetcode 01. two sum"},{"content":"題目描述 給定一個數組nums和一個值val，你需要原地移除所有數值等於val的元素，返回移除後數組的新長度。\n時間複雜度為O(1)，不用考慮移除後的數組順序\n解題思路 可先定義好一個指針，拿來加上長度，並用for判別是否為val，最後返回指針長度\n使用雙指針，快的指針去負責遍歷整個list，慢的指針去紀錄是否有遇到題目給的值，是的話就跳過，最後返回slow\nPython class Solution: def removeElement(self, nums: List[int], val: int) -\u0026gt; int: ptr = 0 for num in nums: if num != val: nums[ptr] = num ptr += 1 return ptr class Solution: def removeElement(self, nums: List[int], val: int) -\u0026gt; int: fast = slow = 0 while(fast \u0026lt; len(nums)): if(nums[fast] != val): nums[slow] = nums[fast] slow+=1 fast+=1 return slow Golang func removeElement(nums []int, val int) int { fast, slow := 0, 0 for fast \u0026lt; len(nums) { if nums[fast] != val { nums[slow] = nums[fast] slow++ } fast++ } return slow } ","permalink":"https://sz9751210.github.io/posts/leetcode-27/","summary":"題目描述 給定一個數組nums和一個值val，你需要原地移除所有數值等於val的元素，返回移除後數組的新長度。\n時間複雜度為O(1)，不用考慮移除後的數組順序\n解題思路 可先定義好一個指針，拿來加上長度，並用for判別是否為val，最後返回指針長度\n使用雙指針，快的指針去負責遍歷整個list，慢的指針去紀錄是否有遇到題目給的值，是的話就跳過，最後返回slow\nPython class Solution: def removeElement(self, nums: List[int], val: int) -\u0026gt; int: ptr = 0 for num in nums: if num != val: nums[ptr] = num ptr += 1 return ptr class Solution: def removeElement(self, nums: List[int], val: int) -\u0026gt; int: fast = slow = 0 while(fast \u0026lt; len(nums)): if(nums[fast] != val): nums[slow] = nums[fast] slow+=1 fast+=1 return slow Golang func removeElement(nums []int, val int) int { fast, slow := 0, 0 for fast \u0026lt; len(nums) { if nums[fast] !","title":"leetCode 27. Remove Element"},{"content":"👨‍💻簡介 last 用途：列出目前與過去登入系統的使用者相關資訊 語法 last [OPTIONS] [num,time,name,tty] 參數 參數 說明 -f file 指定登入的日誌檔案(預設是/var/log/wtmp) -num 指定last顯示幾行資訊 -n num 與-num相同 -t time[YYYYMMDDHHMMSS] 顯示指定時間的登入資訊 -R 不顯示主機名 -a 在最後一列顯示主機名 -d 將非本地登入的使用者ip轉換成主機名 -F 顯示所有的登入和登出時間和日期 -i 顯示ip地址而不是主機名 -o 讀取舊的日誌檔案 -w 顯示使用者名稱和域名 -x 顯示系統關機資訊和執行級別的變化資訊 欄位說明 last # output 1 2 3 4 5 alan pts/2 192.168.56.1 Mon Oct 25 21:37 still logged in reboot system boot 3.10.0-1160.42.2 Mon Oct 25 21:16 - 22:39 (01:22) alan pts/0 192.168.56.1 Sun Oct 24 23:18 - 05:47 (06:28) reboot system boot 3.10.0-1160.42.2 Sun Oct 24 23:15 - 22:39 (23:24) alan pts/2 192.168.56.1 Fri Oct 22 02:07 - 05:44 (03:37) 欄位 說明 登入用戶 顯示登錄用戶的姓名 登入終端 顯示用戶如何連接到系統，但如果是重啟進入，則是會顯示system boot 登入主機 顯示從哪連接到系統，欄位可為主機名或是IP位址(遠端)、空值(tty)、kernel版本(重啟)、應用程序(PID.windowID) 登入時間 顯示用戶登入的時間 登出時間 顯示用戶登出的時間，欄位可為時間戳(登出)、still running(開機)、still logged in(用戶登入中)、down(機器關機)、crash(系統崩潰) 基本操作 顯示最近登入的5筆資訊 last -5 or last -n 5 顯示用戶在某時段登入的資訊 last -t 20211026151111 root 顯示終端tty1的登入資訊 last 1 or last tty1 參考資料 Linux last Command | Baeldung on Linux Linux基礎命令—last | IT人 (iter01.com) ","permalink":"https://sz9751210.github.io/posts/linux-last/","summary":"👨‍💻簡介 last 用途：列出目前與過去登入系統的使用者相關資訊 語法 last [OPTIONS] [num,time,name,tty] 參數 參數 說明 -f file 指定登入的日誌檔案(預設是/var/log/wtmp) -num 指定last顯示幾行資訊 -n num 與-num相同 -t time[YYYYMMDDHHMMSS] 顯示指定時間的登入資訊 -R 不顯示主機名 -a 在最後一列顯示主機名 -d 將非本地登入的使用者ip轉換成主機名 -F 顯示所有的登入和登出時間和日期 -i 顯示ip地址而不是主機名 -o 讀取舊的日誌檔案 -w 顯示使用者名稱和域名 -x 顯示系統關機資訊和執行級別的變化資訊 欄位說明 last # output 1 2 3 4 5 alan pts/2 192.168.56.1 Mon Oct 25 21:37 still logged in reboot system boot 3.10.0-1160.42.2 Mon Oct 25 21:16 - 22:39 (01:22) alan pts/0 192.168.56.1 Sun Oct 24 23:18 - 05:47 (06:28) reboot system boot 3.","title":"Linux 列出登入資訊[last]"},{"content":"👨‍💻簡介 id 用途：顯示用戶的ID，以及所屬群組的ID。 語法 id [OPTIONS] userName 參數 參數 說明 -Z, \u0026ndash;context 顯示當前用戶的安全上下文 -g, \u0026ndash;group 顯示所屬群組ID -G, \u0026ndash;groups 顯示所有群組ID -n, \u0026ndash;name 顯示用戶 -r, \u0026ndash;real 顯示實際ID -u, \u0026ndash;user 顯示用戶ID 基本操作 顯示當前用戶訊息 id # output uid=1000(alan) gid=1000(alan) groups=1000(alan),996(vboxsf) context=unconfined_u:unconfined_r:unconfined_t:s0-s0:c0.c1023 顯示用戶群組id id -g # output 1000 顯示指定用戶訊息 id root ","permalink":"https://sz9751210.github.io/posts/linux-id/","summary":"👨‍💻簡介 id 用途：顯示用戶的ID，以及所屬群組的ID。 語法 id [OPTIONS] userName 參數 參數 說明 -Z, \u0026ndash;context 顯示當前用戶的安全上下文 -g, \u0026ndash;group 顯示所屬群組ID -G, \u0026ndash;groups 顯示所有群組ID -n, \u0026ndash;name 顯示用戶 -r, \u0026ndash;real 顯示實際ID -u, \u0026ndash;user 顯示用戶ID 基本操作 顯示當前用戶訊息 id # output uid=1000(alan) gid=1000(alan) groups=1000(alan),996(vboxsf) context=unconfined_u:unconfined_r:unconfined_t:s0-s0:c0.c1023 顯示用戶群組id id -g # output 1000 顯示指定用戶訊息 id root ","title":"Linux 顯示用戶資訊[id]"},{"content":"👨‍💻簡介 passwd 用途：修改使用者密碼 語法 passwd [OPTIONS] username 參數 參數 說明 -k, \u0026ndash;keep-tokens 保留未過期的驗證 token -d, \u0026ndash;delete 刪除 named 帳號的密碼 (只有 root 可執行) -l, \u0026ndash;lock 鎖住 named 帳號的密碼 (只有 root 可執行) -u, \u0026ndash;unlock 解開 named 帳號的密碼鎖定 (只有 root 可執行) -e, \u0026ndash;expire 讓 named 帳號的密碼過期 (只有 root 可執行) -f, \u0026ndash;force 強制作業 -x, \u0026ndash;maximum=DAYS 最大密碼有效期限 (只有 root 可執行) -n, \u0026ndash;minimum=DAYS 最小密碼有效期限 (只有 root 可執行) -w, \u0026ndash;warning=DAYS 用戶在密碼過期前收到警告的天數 (只有root可執行) -i, \u0026ndash;inactive=DAYS 帳號在密碼過期後即將被停用前的天數 (只有root可執行) -S, \u0026ndash;status 回報 named 帳號上的密碼狀態 (只有 root 可執行) \u0026ndash;stdin 由 stdin 讀取新的 token (只有 root 可執行) 基本操作 修改使用者密碼 passwd myuser 顯示使用者密碼狀態 passwd -S myuser # output myuser PS 2021-11-26 0 99999 7 -1 欄位 範例 帳號名稱 myuser 密碼狀態，狀態包含鎖定密碼(LK)、無密碼(NP)與可用密碼(PS) PS 上次修改密碼時間 2021-11-26 密碼最短使用期限，單位為天 0 密碼最長使用期限，單位為天 99999 密碼過期前警告期間，單位為天 7 密碼過期後可使用的期間，單位為天 -1 刪除使用者密碼 passwd -d myuser 讓密碼過期，強制使用者更新密碼 passwd -e myuser # 下次登入時，就會跳出通知說要更改密碼 You are required to change your password immediately (root enforced) WARNING: Your password has expired. You must change your password now and login again! Changing password for user myuser. Changing password for myuser. (current) UNIX password: 鎖定與解鎖使用者密碼 passwd -l myuser 此指令會使/etc/shadow的使用者密碼欄位前面多了!!\n該狀態下使用者無法變更帳號密碼\n要解除鎖定可用-u\npasswd -u myuser 設定密碼期限 # 至少五天才能改一次密碼 passwd -n 5 myuser # 密碼最多只能用30天 passwd -x 30 myuser # 快過期前7天送警告 passwd -w 7 myuser # 寬限期設定，超過5天將無法再登入 passwd -i 5 myuser 參考資料 Linux passwd命令 | 菜鸟教程 (runoob.com) Linux 的 passwd 指令範例教學 - G. T. Wang (gtwang.org) ","permalink":"https://sz9751210.github.io/posts/linux-passwd/","summary":"👨‍💻簡介 passwd 用途：修改使用者密碼 語法 passwd [OPTIONS] username 參數 參數 說明 -k, \u0026ndash;keep-tokens 保留未過期的驗證 token -d, \u0026ndash;delete 刪除 named 帳號的密碼 (只有 root 可執行) -l, \u0026ndash;lock 鎖住 named 帳號的密碼 (只有 root 可執行) -u, \u0026ndash;unlock 解開 named 帳號的密碼鎖定 (只有 root 可執行) -e, \u0026ndash;expire 讓 named 帳號的密碼過期 (只有 root 可執行) -f, \u0026ndash;force 強制作業 -x, \u0026ndash;maximum=DAYS 最大密碼有效期限 (只有 root 可執行) -n, \u0026ndash;minimum=DAYS 最小密碼有效期限 (只有 root 可執行) -w, \u0026ndash;warning=DAYS 用戶在密碼過期前收到警告的天數 (只有root可執行) -i, \u0026ndash;inactive=DAYS 帳號在密碼過期後即將被停用前的天數 (只有root可執行) -S, \u0026ndash;status 回報 named 帳號上的密碼狀態 (只有 root 可執行) \u0026ndash;stdin 由 stdin 讀取新的 token (只有 root 可執行) 基本操作 修改使用者密碼 passwd myuser 顯示使用者密碼狀態 passwd -S myuser # output myuser PS 2021-11-26 0 99999 7 -1 欄位 範例 帳號名稱 myuser 密碼狀態，狀態包含鎖定密碼(LK)、無密碼(NP)與可用密碼(PS) PS 上次修改密碼時間 2021-11-26 密碼最短使用期限，單位為天 0 密碼最長使用期限，單位為天 99999 密碼過期前警告期間，單位為天 7 密碼過期後可使用的期間，單位為天 -1 刪除使用者密碼 passwd -d myuser 讓密碼過期，強制使用者更新密碼 passwd -e myuser # 下次登入時，就會跳出通知說要更改密碼 You are required to change your password immediately (root enforced) WARNING: Your password has expired.","title":"Linux 修改密碼[passwd]"},{"content":"👨‍💻簡介 有時候修改掛載的config檔，無法即時更新，需要重啟pod才會生效，為了解決這個問題，k8s-reloader因此而誕生，透過觀察掛載的configmap或是secret的變化自動對掛載的物件做滾動更新。\n以下為在minikube環境下，透過掛載nginx-config檔並搭配reloader這個插件進行熱部署。\n🔗github-repo : stakater/Reloader: A Kubernetes controller to watch changes in ConfigMap and Secrets and do rolling upgrades on Pods with their associated Deployment, StatefulSet, DaemonSet and DeploymentConfig – [✩Star] if you\u0026rsquo;re using it! (github.com) 🔰基礎介紹 運作原理 Reloader偵測所有資源變化，對有變化的資源使用SHA1計算資源的哈西值 Reloader查看是否有設定相關的annotation，並查看有設定annotation資源的特殊環境變量 對有設定annotation的資源比對其哈希值，如果環境變量中哈希值不同，則更新環境變量，如果環境變量不存在，則創建一個 環境變量名稱 ConfigMap：STAKATER_{configmap_name}_CONFIGMAP ，比如 ConfigMap 的名稱為 foo，則生成的環境變量的名稱為：STAKATER_FOO_CONFIGMAP。 Secret：STAKATER_{secret_name}_SECRET ，比如 Secret 的名稱為 foo，則生成的環境變量的名稱為：STAKATER_FOO_SECRET。 環境變量的值 使用 SHA1 計算的 ConfigMap 或者 Secret 的哈希值。\n版本需求 k8s版本需 \u0026gt;= 1.9\n安裝方式 使用Manifests安裝 kubectl apply -f https://raw.githubusercontent.com/stakater/Reloader/master/deployments/kubernetes/reloader.yaml 使用Kustomize安裝 kubectl apply -k https://github.com/stakater/Reloader/deployments/kubernetes apiVersion: kustomize.config.k8s.io/v1beta1 kind: Kustomization bases: - https://github.com/stakater/Reloader/deployments/kubernetes namespace: reloader 使用Helm安裝 helm repo add stakater https://stakater.github.io/stakater-charts helm repo update helm install stakater/reloader # For helm3 add --generate-name flag or set the release name 預設情況下，reloader會偵測所有namespace的資源，如果要針對單一namespace可使用--set reloader.watchGlobally為false，以下範例為安裝在test namespace並只偵測test namespace底下的資源\nhelm install stakater/reloader --set reloader.watchGlobally=false --namespace test # For helm3 add --generate-name flag or set the release name 使用方式 自動偵測所有資源 設定reloader.stakater.com/auto: \u0026quot;true\u0026quot;\nkind: Deployment metadata: annotations: reloader.stakater.com/auto: \u0026#34;true\u0026#34; spec: template: metadata: 限制只偵測有設定annotations的資源 deploy設定reloader.stakater.com/search: \u0026quot;true\u0026quot;，configmap等資源設定reloader.stakater.com/match: \u0026quot;true\u0026quot;\nkind: Deployment metadata: annotations: reloader.stakater.com/search: \u0026#34;true\u0026#34; spec: template: --- kind: ConfigMap metadata: annotations: reloader.stakater.com/match: \u0026#34;true\u0026#34; data: key: value reloader.stakater.com/auto與reloader.stakater.com/search不能同時使用\n如果使用reloader.stakater.com/auto，則reloader.stakater.com/match不管有沒有設定都會被偵測\n只偵測特定資源 資源使用,做分隔\nConfigmap kind: Deployment metadata: annotations: configmap.reloader.stakater.com/reload: \u0026#34;foo-configmap\u0026#34; spec: template: metadata: Secret kind: Deployment metadata: annotations: secret.reloader.stakater.com/reload: \u0026#34;foo-secret,bar-secret,baz-secret\u0026#34; spec: template: metadata: 🎯setup 部署reloader kubectl apply -f https://raw.githubusercontent.com/stakater/Reloader/master/deployments/kubernetes/reloader.yaml 部署nginx服務\n建立以下檔案 apiVersion: v1 kind: ConfigMap metadata: name: nginx-map annotations: reloader.stakater.com/match: \u0026#34;true\u0026#34; data: test.conf: | server { listen 80; server_name abc.com; location / { root /usr/share/nginx/html ; index index.html index.htm; } } --- apiVersion: apps/v1 kind: Deployment metadata: name: nginx annotations: configmap.reloader.stakater.com/reload: \u0026#34;nginx-map\u0026#34; spec: replicas: 2 selector: matchLabels: service: http-server template: metadata: labels: service: http-server spec: containers: - name: nginx image: sz9751210/nginx-reloader:v1 imagePullPolicy: IfNotPresent ports: - containerPort: 80 volumeMounts: - mountPath: /etc/nginx/conf.d # mount nginx-conf volumn to /etc/nginx/conf.d readOnly: true name: deployment-nginx-conf volumes: - name: deployment-nginx-conf configMap: name: nginx-map # place ConfigMap `nginx-conf` on /etc/nginx --- apiVersion: v1 kind: Service metadata: name: nginx-service spec: selector: service: http-server ports: - port: 80 targetPort: 80 部署 kubectl apply -f k8s-reloader-demo.yaml 打開瀏覽器查看nginx\nminikube service nginx-service --url 預設應該會顯示default page\n這時候將configmap裡的index.html改成index.html1\n這時候刷新頁面就會看到顯示reload page了\nReference stakater/Reloader: A Kubernetes controller to watch changes in ConfigMap and Secrets and do rolling upgrades on Pods with their associated Deployment, StatefulSet, DaemonSet and DeploymentConfig\n【k8s】使用 Reloader 实现热部署\nConfigMap Reloader — Automatically reload new data from ConfigMap/Secret to deployments | by Navratan Lal Gupta | Linux Shots | Medium\n","permalink":"https://sz9751210.github.io/posts/k8s-reloader/","summary":"👨‍💻簡介 有時候修改掛載的config檔，無法即時更新，需要重啟pod才會生效，為了解決這個問題，k8s-reloader因此而誕生，透過觀察掛載的configmap或是secret的變化自動對掛載的物件做滾動更新。\n以下為在minikube環境下，透過掛載nginx-config檔並搭配reloader這個插件進行熱部署。\n🔗github-repo : stakater/Reloader: A Kubernetes controller to watch changes in ConfigMap and Secrets and do rolling upgrades on Pods with their associated Deployment, StatefulSet, DaemonSet and DeploymentConfig – [✩Star] if you\u0026rsquo;re using it! (github.com) 🔰基礎介紹 運作原理 Reloader偵測所有資源變化，對有變化的資源使用SHA1計算資源的哈西值 Reloader查看是否有設定相關的annotation，並查看有設定annotation資源的特殊環境變量 對有設定annotation的資源比對其哈希值，如果環境變量中哈希值不同，則更新環境變量，如果環境變量不存在，則創建一個 環境變量名稱 ConfigMap：STAKATER_{configmap_name}_CONFIGMAP ，比如 ConfigMap 的名稱為 foo，則生成的環境變量的名稱為：STAKATER_FOO_CONFIGMAP。 Secret：STAKATER_{secret_name}_SECRET ，比如 Secret 的名稱為 foo，則生成的環境變量的名稱為：STAKATER_FOO_SECRET。 環境變量的值 使用 SHA1 計算的 ConfigMap 或者 Secret 的哈希值。\n版本需求 k8s版本需 \u0026gt;= 1.9\n安裝方式 使用Manifests安裝 kubectl apply -f https://raw.","title":"k8s-reloader"},{"content":"👨‍💻簡介 timedatectl 用途：修改系統時間 語法 timedatectl [OPTIONS] command 參數 參數 說明 \u0026ndash;no-pager 不將程序的輸出內容管道(pipe)給分頁程序 \u0026ndash;no-ask-password 在執行特權操作時不向用戶索要密碼。 -H \u0026ndash;host=[USER@]HOST 操作指定的遠程主機 -M \u0026ndash;machine=CONTAINER 在本地容器內執行操作。 必須明確指定容器的名稱。 \u0026ndash;adjust-system-clock 當使用set-local-rtc命令時，若使用了此選項，則表示根據RTC時間來更新系統時鐘。若未使用此選項，則表示根據系統時鐘來更新RTC時間 指令 指令 說明 status 顯示系統時鐘與RTC的當前狀態， 包括時區設置與網絡時間同步服務的狀態。 set-time TIME 將系統時鐘設爲指定的時間， 並同時更新RTC時間。 [TIME] 是一個形如 \u0026ldquo;2012-10-30 18:17:16\u0026quot;的時間字符串。 set-timezone ZONE 設置系統時區，也就是更新 /etc/localtime 軟連接的指向。 可以用下面的 list-timezones命令列出所有可用時區。 如果RTC被設爲本地時間， 此命令還會同時更新RTC時間。 list-timezones 列出所有可用時區，每行一個。 列出的值可以用作前述 set-timezone 命令的參數。 set-local-rtc BOOL 設爲 \u0026ldquo;no\u0026rdquo; 表示在RTC中存儲UTC時間； 設爲 \u0026ldquo;yes\u0026rdquo; 表示在RTC中存儲本地時間。應該盡一切可能在RTC中存儲UTC時間 set-ntp BOOL 是否開啓網絡時間同步。 設爲 \u0026ldquo;yes\u0026rdquo; 則啓用並啓動 systemd-timesyncd.service 服務， 設爲\u0026quot;no\u0026rdquo; 則停止並停用它 基本操作 顯示當前系統時間 timedatectl or timedatectl status 開啟網路時間同步服務 timedatectl set-ntp true 設定日期與時間 # 改時間和日期 timedatectl set-time \u0026#34;2021-11-01 10:10:00\u0026#34; # 只改日期 timedatectl set-time \u0026#34;2021-11-01\u0026#34; timedatectl set-time 20211101 # 只改時間 timedatectl set-time \u0026#34;10:10:00\u0026#34; timedatectl set-time 10:10:00 檢查時區 timedatectl list-timezones # 根據地理位置查看時區 timedatectl list-timezones | grep \u0026#34;Asia/B.*\u0026#34; 設定時區 timedatectl set-timezone \u0026#34;Asia/Taipei\u0026#34; # 設定為世界協調時間(UTC) timedatectl set-timezone UTC 參考資料 Ubuntu Manpage: timedatectl - 控制系統的時間與日期 Linux 手動更改系統時間：date、hwclock 與 timedatectl 指令用法教學 - G. T. Wang (gtwang.org) Linux下使用timedatectl命令時間時區操作詳解_osc_02985929 - MdEditor (gushiciku.cn) 相關指令 date hwclock ","permalink":"https://sz9751210.github.io/posts/linux-timedatectl/","summary":"👨‍💻簡介 timedatectl 用途：修改系統時間 語法 timedatectl [OPTIONS] command 參數 參數 說明 \u0026ndash;no-pager 不將程序的輸出內容管道(pipe)給分頁程序 \u0026ndash;no-ask-password 在執行特權操作時不向用戶索要密碼。 -H \u0026ndash;host=[USER@]HOST 操作指定的遠程主機 -M \u0026ndash;machine=CONTAINER 在本地容器內執行操作。 必須明確指定容器的名稱。 \u0026ndash;adjust-system-clock 當使用set-local-rtc命令時，若使用了此選項，則表示根據RTC時間來更新系統時鐘。若未使用此選項，則表示根據系統時鐘來更新RTC時間 指令 指令 說明 status 顯示系統時鐘與RTC的當前狀態， 包括時區設置與網絡時間同步服務的狀態。 set-time TIME 將系統時鐘設爲指定的時間， 並同時更新RTC時間。 [TIME] 是一個形如 \u0026ldquo;2012-10-30 18:17:16\u0026quot;的時間字符串。 set-timezone ZONE 設置系統時區，也就是更新 /etc/localtime 軟連接的指向。 可以用下面的 list-timezones命令列出所有可用時區。 如果RTC被設爲本地時間， 此命令還會同時更新RTC時間。 list-timezones 列出所有可用時區，每行一個。 列出的值可以用作前述 set-timezone 命令的參數。 set-local-rtc BOOL 設爲 \u0026ldquo;no\u0026rdquo; 表示在RTC中存儲UTC時間； 設爲 \u0026ldquo;yes\u0026rdquo; 表示在RTC中存儲本地時間。應該盡一切可能在RTC中存儲UTC時間 set-ntp BOOL 是否開啓網絡時間同步。 設爲 \u0026ldquo;yes\u0026rdquo; 則啓用並啓動 systemd-timesyncd.service 服務， 設爲\u0026quot;no\u0026rdquo; 則停止並停用它 基本操作 顯示當前系統時間 timedatectl or timedatectl status 開啟網路時間同步服務 timedatectl set-ntp true 設定日期與時間 # 改時間和日期 timedatectl set-time \u0026#34;2021-11-01 10:10:00\u0026#34; # 只改日期 timedatectl set-time \u0026#34;2021-11-01\u0026#34; timedatectl set-time 20211101 # 只改時間 timedatectl set-time \u0026#34;10:10:00\u0026#34; timedatectl set-time 10:10:00 檢查時區 timedatectl list-timezones # 根據地理位置查看時區 timedatectl list-timezones | grep \u0026#34;Asia/B.","title":"Linux 修改時間[timedatectl]"},{"content":"👨‍💻簡介 sed(stream editor) 用途：用於處理文件，字串取代、複製、刪除等功能，進行處理時並不會改變當前的檔案，而是將處理過程存放在[模式空間]的緩衝區，結束目前的指令後輸出，接著再處理下一個指令直到結束 語法 sed [OPTIONS] script or inputfile 參數(常用) 參數 說明 -n, \u0026ndash;quiet, \u0026ndash;silent 沈默模式 -e script, \u0026ndash;expression=script 直接在命令模式設定好script來進行編輯 -f script檔案, \u0026ndash;file=script檔案 使用指定的script檔案來進行編輯 -i 修改檔案，常用於自動化腳本 動作 說明 a 新增，在指定的行數的「下一行」插入字串。未指定行數的話則是在「每一行」之後插入字串 c 取代，替換指定行數為預替換的字串 d 刪除，刪除指定的行。常與-i選項搭配，用來修改檔案時移除不需要的行 i 插入，與a相同，差別在於a指令是在指定行數之後插入，i是在指定行數之前插入 p 列印，通常搭配-n選項做使用，只列印出受影響的行數 s 取代，支持正則表達式，用來取代字串 flags 說明 [0-9] 數字表示只搜尋或者取代第 N 個數字所指示的那個樣板字串 g 全部取代 I 忽略大小寫 w 把符合的結果寫入檔案。和加了 -n 選項搭配 p 旗標的結果一樣。此旗標如果有和其它旗標搭配使用，必須放在最後面 基本操作 參數 搭配文件sed.txt\nI have a pen, I have an apple Ah Apple pen I have a pen, I have pineapple Ah Pineapple pen Apple pen Pineapple pen Ah Pen Pie Pineapple Apple Pen Pen Pie Pineapple Apple Pen 使用-n沈默模式 # 使用s取代每一行第一次出現的have修改成had sed -n \u0026#39;s/have/had/1p\u0026#39; sed.txt # 透過沈默模式修改文件，默認不會印出東西，需搭配p則會顯示有修改的行 使用-e設定規則 # 把檔案中每行第一次出現的的pen換成pencil並存到sed_output.txt，-e為默認選項，可加可不加 sed -e \u0026#39;s/pen/pencil/\u0026#39; sed.txt \u0026gt; sed_output.txt # 多條件方式，有-e不需要分號分隔，無-e則需要做分隔 sed -e \u0026#39;s/pen/pencil/\u0026#39; -e \u0026#39;s/have/had/\u0026#39; sed.txt sed \u0026#39;s/pen/pencil/; s/have/had/\u0026#39; sed.txt 使用-f指定script檔案進行修改 假設有個script檔案sed_command.txt如下\ns/pen/pencil/ s/have/had/ # 將每一行第一次出現的pen以及have做替換 sed -f sed_command.txt sed.txt 使用-i直接修改檔案 sed -i \u0026#39;s/pen/pencil/\u0026#39; sed.txt 動作 使用a新增字串 # 在第一行之後新增字串 sed \u0026#39;1a I have both\u0026#39; sed.txt # 多行新增，在第一行到第四行這四行的後面都新增字串 sed \u0026#39;1,4a I have both\u0026#39; sed.txt 使用c做字串替換 # 取代第二行，改為I have both sed \u0026#39;2c I have both\u0026#39; sed.txt # 多行取代，將1到5行壓縮為一行並改為字串 sed \u0026#39;1,5c I have both\u0026#39; sed.txt 使用d進行刪除指定行或字串行 # 刪除第一行 sed 1d sed.txt # 刪除一到五行 sed 1,5d sed.txt # 刪除pen出現的行 sed \u0026#39;/pen/d\u0026#39; sed.txt 使用i進行插入 # 在第一行之前插入字串 sed \u0026#39;1i I have both\u0026#39; sed.txt # 在第一到第三行的每行之前插入字串 sed \u0026#39;1,3i I have both\u0026#39; sed.txt 使用p進行列印出影響行，通常配合-n選項搭配使用 # 將have取代為had並列印出來 sed -n \u0026#39;s/have/had/1p\u0026#39; sed.txt 使用s做字串取代 語法格式\ns/regexp/replacement/[flags] 參考資料 sed, a stream editor (gnu.org) Linux sed 命令 | 菜鸟教程 (runoob.com) 在 Linux 命令列中轉換大小寫 | IT人 (iter01.com) Linux 指令 SED 用法教學、取代範例、詳解 - TerryL Linux sed 字串取代用法與範例 | ShengYu Talk (shengyu7697.github.io) ","permalink":"https://sz9751210.github.io/posts/linux-sed/","summary":"👨‍💻簡介 sed(stream editor) 用途：用於處理文件，字串取代、複製、刪除等功能，進行處理時並不會改變當前的檔案，而是將處理過程存放在[模式空間]的緩衝區，結束目前的指令後輸出，接著再處理下一個指令直到結束 語法 sed [OPTIONS] script or inputfile 參數(常用) 參數 說明 -n, \u0026ndash;quiet, \u0026ndash;silent 沈默模式 -e script, \u0026ndash;expression=script 直接在命令模式設定好script來進行編輯 -f script檔案, \u0026ndash;file=script檔案 使用指定的script檔案來進行編輯 -i 修改檔案，常用於自動化腳本 動作 說明 a 新增，在指定的行數的「下一行」插入字串。未指定行數的話則是在「每一行」之後插入字串 c 取代，替換指定行數為預替換的字串 d 刪除，刪除指定的行。常與-i選項搭配，用來修改檔案時移除不需要的行 i 插入，與a相同，差別在於a指令是在指定行數之後插入，i是在指定行數之前插入 p 列印，通常搭配-n選項做使用，只列印出受影響的行數 s 取代，支持正則表達式，用來取代字串 flags 說明 [0-9] 數字表示只搜尋或者取代第 N 個數字所指示的那個樣板字串 g 全部取代 I 忽略大小寫 w 把符合的結果寫入檔案。和加了 -n 選項搭配 p 旗標的結果一樣。此旗標如果有和其它旗標搭配使用，必須放在最後面 基本操作 參數 搭配文件sed.txt\nI have a pen, I have an apple Ah Apple pen I have a pen, I have pineapple Ah Pineapple pen Apple pen Pineapple pen Ah Pen Pie Pineapple Apple Pen Pen Pie Pineapple Apple Pen 使用-n沈默模式 # 使用s取代每一行第一次出現的have修改成had sed -n \u0026#39;s/have/had/1p\u0026#39; sed.","title":"Linux 修改字串[sed]"},{"content":"👨‍💻簡介 grep 用途：查找文件內符合條件的字符串 語法 grep [-abcEFGhHilLnqrsvVwxy][-A\u0026lt;顯示行數\u0026gt;][-B\u0026lt;顯示列數\u0026gt;][-C\u0026lt;顯示列數\u0026gt;][-d\u0026lt;進行動作\u0026gt;][-e\u0026lt;範本樣式\u0026gt;][-f\u0026lt;範本文件\u0026gt;][--help][範本樣式][文件或目錄...] 參數 正規表示式選項 說明 -E, \u0026ndash;extended-regexp 使用擴展正則表達式 -F, \u0026ndash;fixed-strings 將樣式視為固定字符串的列表 -G, \u0026ndash;basic-regexp 將樣式視為普通的表示法來使用 -P, \u0026ndash;perl-regexp 將樣式視為perl的表示法來使用 -e, \u0026ndash;regexp=PATTERN 指定字符串做為查找文件內容的樣式 -f, \u0026ndash;file=FILE 指定規則文件，其內容含有一個或多個規則樣式，讓grep查找符合規則條件的文件內容，格式為每行一個規則樣式 -i, \u0026ndash;ignore-case 忽略大小寫的差異 -w, \u0026ndash;word-regexp 只匹配整個單詞，而不是字符串的一部分 -x, \u0026ndash;line-regexp 只顯示全列符合的列 -z, \u0026ndash;null-data 設定資料列結尾為空白位元組，非換列符號 -s, \u0026ndash;no-messages 不顯示不存在或無匹配文本的錯誤信息 -v, \u0026ndash;invert-match 將匹配的資料排除 參數 說明 -m, \u0026ndash;max-count=NUM 在達到 NUM 符合項目後停止 -b, \u0026ndash;byte-offset 在顯示符合樣式的那一行之前，標示出該行第一個字符的編號 -n, \u0026ndash;line-number 標示匹配文字的行號 \u0026ndash;line-buffered 輸出每列後清除輸出 -H, \u0026ndash;with-filename 印出每個符合項目的檔名 -h, \u0026ndash;no-filename 查詢多文件時不顯示文件名 \u0026ndash;label=LABEL 以 LABEL 作標準輸入的檔名前綴 -o, \u0026ndash;only-matching 只顯示每列中符合 PATTERN 的部分 -q, \u0026ndash;quiet, \u0026ndash;silent 不顯示任何信息 \u0026ndash;binary-files=TYPE 設定二進制檔案為 TYPE 的檔案;TYPE 為 \u0026ldquo;binary\u0026rdquo;、\u0026ldquo;text\u0026rdquo; 或 \u0026ldquo;without-match\u0026rdquo; -a, \u0026ndash;text 不要忽略二進制的數據 -I 不匹配二進制的東西 -d, \u0026ndash;directories=ACTION 目錄操作的動作，讀取、遞歸、跳過 -D, \u0026ndash;devices=ACTION 設置對設備的動作，FIFO和管道的操作，動作有，讀取、跳過 -r, \u0026ndash;recursive 在指定目錄與其子目錄下所有的檔案中，搜尋指定的關鍵字 -R, \u0026ndash;dereference-recursive 與-r相同，但遵循軟連結 \u0026ndash;include=FILE_PATTERN 從特定的檔案中尋找關鍵字 \u0026ndash;exclude=FILE_PATTERN 跳過匹配FILE_PATTERN 的文件和目錄 \u0026ndash;exclude-from=FILE 跳過所有除FILE 以外的文件 \u0026ndash;exclude-dir=PATTERN 跳過匹配PATTERN 的目錄 -L, \u0026ndash;files-without-match 列出不匹配的文件名 -l, \u0026ndash;files-with-matches 只列出匹配的文件名 -c, \u0026ndash;count 只輸出匹配行的計數 -Z, \u0026ndash;null 在搜尋的字串後面印出空字符 內容控制 說明 -B, \u0026ndash;before-context=NUM 顯示前幾行 -A, \u0026ndash;after-context=NUM 顯示後幾行 -C, \u0026ndash;context=NUM, -NUM 顯示前後各幾行 \u0026ndash;group-separator=SEP 使用A、-B或-C時，在組之間打印SEP而不是\u0026ndash;線 \u0026ndash;no-group-separator 使用A、-B或-C時，在組之間不打印seperator \u0026ndash;color[=WHEN],\u0026ndash;colour[=WHEN] 使用顏色標示的方式，將成功匹配的部分文字標示出來，方便使用者閱讀。顏色標示功能可以透過 --color=never、--color=always、--color=auto 這幾種參數來關閉、開啟或設為自動 -U, \u0026ndash;binary 使用標誌高亮匹配字串 -u, \u0026ndash;unix-byte-offsets 使用標誌高亮匹配字串 基本操作 指定文件查詢關鍵字 # 在file這個文件裡尋找test關鍵字 grep test file 透過匹配方式搜尋 # 在/etc/目錄下所有.conf檔搜尋linux關鍵字 grep linux /etc/*.conf 不分大小寫搜尋 # 在當前目錄底下搜尋linux關鍵字 grep -i linux . 反向匹配 # 在當前目錄下，顯示不包含linux的行 grep -v linux . 顯示行號 grep -n linux . 遞迴搜尋檔案 # 在當前目錄及其子目錄下，搜尋linux關鍵字 grep -r linux . # 在當前目錄及其子目錄下，並且檔名為log結尾的文件，搜尋linux關鍵字 grep -r --include=\u0026#34;*.log\u0026#34; linux . 不顯示錯誤訊息 grep linux . 2\u0026gt;/dev/null 顯示前後幾行 # 多顯示後一行 grep -A 1 linux . # 多顯示前一行 grep -B 1 linux . # 多顯示前後各一行 grep -C 1 linux . 實用範例 # 依照時間排序並計算哪個時間log數量最多 grep -oP \u0026#39;2021:[0-2][0-9]:[0-5][0-9]\u0026#39;| sort | uniq -c 參考資料 grep linux 命令 在线中文手册 (51yip.com) grep(1) - Linux manual page (man7.org) Linux 匹配文字 grep 指令用法教學與範例 - G. T. Wang (gtwang.org) ","permalink":"https://sz9751210.github.io/posts/linux-grep/","summary":"👨‍💻簡介 grep 用途：查找文件內符合條件的字符串 語法 grep [-abcEFGhHilLnqrsvVwxy][-A\u0026lt;顯示行數\u0026gt;][-B\u0026lt;顯示列數\u0026gt;][-C\u0026lt;顯示列數\u0026gt;][-d\u0026lt;進行動作\u0026gt;][-e\u0026lt;範本樣式\u0026gt;][-f\u0026lt;範本文件\u0026gt;][--help][範本樣式][文件或目錄...] 參數 正規表示式選項 說明 -E, \u0026ndash;extended-regexp 使用擴展正則表達式 -F, \u0026ndash;fixed-strings 將樣式視為固定字符串的列表 -G, \u0026ndash;basic-regexp 將樣式視為普通的表示法來使用 -P, \u0026ndash;perl-regexp 將樣式視為perl的表示法來使用 -e, \u0026ndash;regexp=PATTERN 指定字符串做為查找文件內容的樣式 -f, \u0026ndash;file=FILE 指定規則文件，其內容含有一個或多個規則樣式，讓grep查找符合規則條件的文件內容，格式為每行一個規則樣式 -i, \u0026ndash;ignore-case 忽略大小寫的差異 -w, \u0026ndash;word-regexp 只匹配整個單詞，而不是字符串的一部分 -x, \u0026ndash;line-regexp 只顯示全列符合的列 -z, \u0026ndash;null-data 設定資料列結尾為空白位元組，非換列符號 -s, \u0026ndash;no-messages 不顯示不存在或無匹配文本的錯誤信息 -v, \u0026ndash;invert-match 將匹配的資料排除 參數 說明 -m, \u0026ndash;max-count=NUM 在達到 NUM 符合項目後停止 -b, \u0026ndash;byte-offset 在顯示符合樣式的那一行之前，標示出該行第一個字符的編號 -n, \u0026ndash;line-number 標示匹配文字的行號 \u0026ndash;line-buffered 輸出每列後清除輸出 -H, \u0026ndash;with-filename 印出每個符合項目的檔名 -h, \u0026ndash;no-filename 查詢多文件時不顯示文件名 \u0026ndash;label=LABEL 以 LABEL 作標準輸入的檔名前綴 -o, \u0026ndash;only-matching 只顯示每列中符合 PATTERN 的部分 -q, \u0026ndash;quiet, \u0026ndash;silent 不顯示任何信息 \u0026ndash;binary-files=TYPE 設定二進制檔案為 TYPE 的檔案;TYPE 為 \u0026ldquo;binary\u0026rdquo;、\u0026ldquo;text\u0026rdquo; 或 \u0026ldquo;without-match\u0026rdquo; -a, \u0026ndash;text 不要忽略二進制的數據 -I 不匹配二進制的東西 -d, \u0026ndash;directories=ACTION 目錄操作的動作，讀取、遞歸、跳過 -D, \u0026ndash;devices=ACTION 設置對設備的動作，FIFO和管道的操作，動作有，讀取、跳過 -r, \u0026ndash;recursive 在指定目錄與其子目錄下所有的檔案中，搜尋指定的關鍵字 -R, \u0026ndash;dereference-recursive 與-r相同，但遵循軟連結 \u0026ndash;include=FILE_PATTERN 從特定的檔案中尋找關鍵字 \u0026ndash;exclude=FILE_PATTERN 跳過匹配FILE_PATTERN 的文件和目錄 \u0026ndash;exclude-from=FILE 跳過所有除FILE 以外的文件 \u0026ndash;exclude-dir=PATTERN 跳過匹配PATTERN 的目錄 -L, \u0026ndash;files-without-match 列出不匹配的文件名 -l, \u0026ndash;files-with-matches 只列出匹配的文件名 -c, \u0026ndash;count 只輸出匹配行的計數 -Z, \u0026ndash;null 在搜尋的字串後面印出空字符 內容控制 說明 -B, \u0026ndash;before-context=NUM 顯示前幾行 -A, \u0026ndash;after-context=NUM 顯示後幾行 -C, \u0026ndash;context=NUM, -NUM 顯示前後各幾行 \u0026ndash;group-separator=SEP 使用A、-B或-C時，在組之間打印SEP而不是\u0026ndash;線 \u0026ndash;no-group-separator 使用A、-B或-C時，在組之間不打印seperator \u0026ndash;color[=WHEN],\u0026ndash;colour[=WHEN] 使用顏色標示的方式，將成功匹配的部分文字標示出來，方便使用者閱讀。顏色標示功能可以透過 --color=never、--color=always、--color=auto 這幾種參數來關閉、開啟或設為自動 -U, \u0026ndash;binary 使用標誌高亮匹配字串 -u, \u0026ndash;unix-byte-offsets 使用標誌高亮匹配字串 基本操作 指定文件查詢關鍵字 # 在file這個文件裡尋找test關鍵字 grep test file 透過匹配方式搜尋 # 在/etc/目錄下所有.","title":"Linux 篩選字串[grep]"},{"content":"👨‍💻簡介 rsync 用途：用來複製與備份檔案的工具，它可以處理本機或遠端的檔案同步工作 語法 rsync [OPTIONS] src [dest/user@host:dest] 參數 參數 說明 -v, \u0026ndash;verbose verbose 模式，輸出比較詳細的訊息 -r, \u0026ndash;recursive 遞迴（recursive）備份所有子目錄下的目錄與檔案 -a, \u0026ndash;archive 封裝備份模式，相當於 -rlptgoD，遞迴備份所有子目錄下的目錄與檔案，保留連結檔、檔案的擁有者、群組、權限以及時間戳記 -z, \u0026ndash;compress 啟用壓縮，可減少網路傳輸資料量 -h, \u0026ndash;human-readable 將數字以比較容易閱讀的格式輸出 -q, –quiet 與 -v 相反，安靜模式，略過正常資訊，僅顯示錯誤訊息 -l, –links 複製連結而不是連結內容 -g, –group 保留檔案的原始群組狀態(權限不足則無法繼承) -o, –owner 保留檔案的原始擁有者(權限不足則無法繼承) -t,–times 保留檔案的原始時間參數 -e 使用的通道協定，例如使用 ssh 通道，則 -e ssh -u, \u0026ndash;update 在備份時會略過所有已經存在於目的端，且文件時間比要備份的檔案為新的檔案 -p, \u0026ndash;perms 表示要保留檔案的權限資訊 -D 表示要保留設備檔案資訊 \u0026ndash;delete 刪除來源端已經不存在但在目的端存在的檔案 \u0026ndash;force 當目的端的目錄被覆蓋時，就強制先刪除該目錄 \u0026ndash;bwlimit=RATE 限制資料傳輸速度上限 \u0026ndash;progress 即時顯示傳輸進度 \u0026ndash;exclude=PATTERN 排除符合匹配的檔案 \u0026ndash;include=PATTERN 只備份符合匹配的檔案 \u0026ndash;min-size=SIZE 指定備份檔案的最小值 \u0026ndash;max-size=SIZE 指定備份檔案的最大值 \u0026ndash;remove-source-files 自動刪除來源檔案 -n, \u0026ndash;dry-run debug模式，測試rsync餐數 \u0026ndash;existing 只更新既有的檔案，排除新增的檔案 -i, \u0026ndash;itemize-changes 查看個別檔案的變動資訊 基本操作 複製本地端檔案或目錄 rsync -avh mylog.log /local/path/ rsync -avh /mypath /home/alan/ 本地備份至遠端，將本地myfile.gz備份到遠端/remote/path/目錄下 rsync -avzh ./myfile.gz host@ip:/remote/path/ 遠端備份至本地 rsync -avzh host@ip:/remote/path/myfile.gz /local/path 限制網速 rsync -avzh --bwlimit=100k host@ip:/remote/path/myfile.gz /local/path 顯示傳輸進度 rsync -avzh --progress host@ip:/remote/path/myfile.gz /local/path 同步刪除目的端檔案 rsync -avzh --delete host@ip:/remote/path/myfile.gz /local/path 備份特定檔案 # 排除掉結尾為.txt的檔案 rsync -avh --exclude \u0026#39;*.txt\u0026#39; src/path dest/path # 只備份結尾為.txt的檔案 rsync -avh --include \u0026#39;*.txt\u0026#39; src/path dest/path 限制檔案大小 # 只備份1mb以上的檔案 rsync -avh --min-size=1m src/path dest/path # 只備份最大1k的檔案 rsync -avh --max-size=1k src/path dest/path # 只備份1k以上1mb以下的檔案 rsync -avh --min-size=1k --max-size=1m src/path dest/path 自動刪除來源檔案 # 將src/path的檔案備份到dest/path後清空，相當於mv的效果 rsync -avh --remove-source-files src/path dest/path 10, 測試rsync參數\nrsync -avh --dry-run src/path dest/path 搭配crontab做定期備份 # m h dom mon dow command 0 5 * * 1 rsync -a /path/to/folder /path/to/backup/ 只更新已存在的檔案 rsync -avh --existing src/path dest/path 參考資料 Rsync Command in Linux with Examples | Linuxize Linux 使用 rsync 遠端檔案同步與備份工具教學與範例 - G. T. Wang (gtwang.org) Linux下如何使用Rsync備份伺服器重要資料 | IT人 (iter01.com) 相關指令 scp ","permalink":"https://sz9751210.github.io/posts/linux-rsync/","summary":"👨‍💻簡介 rsync 用途：用來複製與備份檔案的工具，它可以處理本機或遠端的檔案同步工作 語法 rsync [OPTIONS] src [dest/user@host:dest] 參數 參數 說明 -v, \u0026ndash;verbose verbose 模式，輸出比較詳細的訊息 -r, \u0026ndash;recursive 遞迴（recursive）備份所有子目錄下的目錄與檔案 -a, \u0026ndash;archive 封裝備份模式，相當於 -rlptgoD，遞迴備份所有子目錄下的目錄與檔案，保留連結檔、檔案的擁有者、群組、權限以及時間戳記 -z, \u0026ndash;compress 啟用壓縮，可減少網路傳輸資料量 -h, \u0026ndash;human-readable 將數字以比較容易閱讀的格式輸出 -q, –quiet 與 -v 相反，安靜模式，略過正常資訊，僅顯示錯誤訊息 -l, –links 複製連結而不是連結內容 -g, –group 保留檔案的原始群組狀態(權限不足則無法繼承) -o, –owner 保留檔案的原始擁有者(權限不足則無法繼承) -t,–times 保留檔案的原始時間參數 -e 使用的通道協定，例如使用 ssh 通道，則 -e ssh -u, \u0026ndash;update 在備份時會略過所有已經存在於目的端，且文件時間比要備份的檔案為新的檔案 -p, \u0026ndash;perms 表示要保留檔案的權限資訊 -D 表示要保留設備檔案資訊 \u0026ndash;delete 刪除來源端已經不存在但在目的端存在的檔案 \u0026ndash;force 當目的端的目錄被覆蓋時，就強制先刪除該目錄 \u0026ndash;bwlimit=RATE 限制資料傳輸速度上限 \u0026ndash;progress 即時顯示傳輸進度 \u0026ndash;exclude=PATTERN 排除符合匹配的檔案 \u0026ndash;include=PATTERN 只備份符合匹配的檔案 \u0026ndash;min-size=SIZE 指定備份檔案的最小值 \u0026ndash;max-size=SIZE 指定備份檔案的最大值 \u0026ndash;remove-source-files 自動刪除來源檔案 -n, \u0026ndash;dry-run debug模式，測試rsync餐數 \u0026ndash;existing 只更新既有的檔案，排除新增的檔案 -i, \u0026ndash;itemize-changes 查看個別檔案的變動資訊 基本操作 複製本地端檔案或目錄 rsync -avh mylog.","title":"Linux 同步檔案[rsync]"},{"content":"👨‍💻簡介 find 用途：在目錄中找尋文件 語法 find path [OPTIONS] 參數(常用) 參數 說明 -mount, -xdev 只檢查和指定目錄在同一個文件系統下的文件，避免列出其它文件系統中的文件 -amin n 指定檔案的最後存取時間，單位為分鐘，在過去n分鐘內被存取過 -anewer file 比文件file更晚被存取過的文件 -atime n 指定檔案的最後存取時間（access time），單位為天 -cmin n 指定檔案狀態相關資訊最後修改的時間，單位為分鐘 -cnewer file 比文件file更新的文件 -ctime n 指定檔案狀態相關資訊最後修改的時間（status time），單位為天 -mtime n 指定檔案的最後修改時間（modification time），單位為天 -mmin n 指定檔案的最後修改時間，單位為分鐘 -empty 搜尋空檔案 -ipath p, -path p 路徑名稱符合 p 的文件，ipath 會忽略大小寫 -name name, -iname name 文件名稱符合 name 的文件。 iname 會忽略大小寫 -size n 指定檔案的大小 -type c 指定檔案的類型 -perm 指定檔案的權限 -user 指定檔案擁有者 -group 指定檔案的群組 -exec 對使用find的搜尋結果執行特定指令 基本操作 指定檔名搜尋 # 搜尋在當前目錄底下，檔名為file.txt的檔案 find . -name file.txt # 透過正則搜尋符合的匹配txt檔案 find . -name \u0026#34;*.txt\u0026#34; # 使用絕對路徑不分大小寫搜尋檔案 find /home -iname file.txt 指定檔案修改與存取時間搜尋 # 搜尋當前目錄下過去5天內檔案狀態有被存取過的檔案 find . -atime -5 # 搜尋當前目錄下過去5分鐘檔案狀態有被修改過的檔案 find . -cmin -5 # 搜尋當前目錄下，上次修改時間是在5天以上、10天以下的檔案 find . -mtime +5 -mtime -10 atime（Accesstime）指的是文件最後一次被訪問的時間； mtime（Modifytime）指的是文件內容被修改的時間，但不包括權限的修改，比如用vim編輯器修改內容； ctime（Changetime）指的是文件的權限、擁有者、所屬組及鏈接數發上改變的時間。 指定檔案類型搜尋 # 搜尋當前目錄及子目錄下，類型為文件 find . -type f # 搜尋當前目錄及子目錄下，類型為目錄 find . -type d b: 區塊裝置文件 c: 字型裝置文件 d: 目錄 p: 具名的pipe(FIFO) f: 一般的檔案 l: 連結檔，如果與 -L 或 -follow 參數同時使用時，就只會搜尋到有問題的連結檔，如果想要與 -L 同時使用，請改用 -xtype s: socket 檔案 指定檔案權限搜尋 # 搜尋當前目錄下權限為777的檔案 find . -type f -perm 777 # 搜尋當前目錄下權限不是777的檔案 find . -type f ! -perm 777 # 搜尋當前目錄下權限為644而且有SGID的檔案 find . -type f -perm 2644 # 搜尋當前目錄下，user只有read的權限的檔案 find . -type f -perm /u=r 如果不帶有任何前綴，則只有完全符合的檔案才會成功匹配 如果帶有-，則代表同時符合，任何一類用戶（ugo）的權限中的每一位（rwx）都要同時符合mode所表示的條件，9位權限之間存在“與”關係。 如果帶有/，則代表至少符合，任何一類用戶（ugo）的權限中的任何一位（rwx）符合mode所表示的條件即可，9位權限之間存在“或”關係。 指定檔案屬性搜尋 # 搜尋當前目錄下，user為root的檔案 find . -user root # 搜尋當前目錄下，group為root的檔案 find . -group root 指定檔案大小搜尋 # 搜尋當前目錄下，檔案大小剛好是50MB的檔案 find . -size 50M # 搜尋當前目錄下，檔案大小介於50MB到100MB之間的檔案 find . -size +50M -size -100M # 搜尋當前目錄下，大於100MB的檔案並將其刪除 find . -size +100M -exec rm -rf {} \\; 指定搜尋空檔案與隱藏檔案 # 搜尋當前目錄下的空目錄 find . -type d -empty # 搜尋當前目錄下的隱藏檔案 find . -type f -name \u0026#34;.*\u0026#34; 實用範例 # 搜尋當前目錄下，檔案大小在10MB以上的log檔，並將其刪除 find . -type f -name *.log -size +10M -exec rm {} \\; # 搜尋當前目錄下所有的php檔案，並找尋有關鍵字ok以及匹配處的以下5行 find ./ -name \\*.php -exec grep -wnHA5 ok {} \\; # 搜尋當前目錄下所有檔案，並找出有network關鍵字的檔案 find . -name \u0026#34;*\u0026#34; | xargs grep \u0026#34;network\u0026#34; 在 -exec 前面是 find 指令找出想要的檔案，在 -exec 後面的 command 是要執行的指令, 而 { } 包著的是找到的檔案或目錄，後面需要加上 ; 完結。\n參考資料 man find SGID Unix/Linux 的 find 指令使用教學、技巧與範例整理 根据文件属性或权限进行find查找 使用 Linux find 尋找檔案/尋找資料夾 Linux find 指令的 exec 參數 ","permalink":"https://sz9751210.github.io/posts/linux-find/","summary":"👨‍💻簡介 find 用途：在目錄中找尋文件 語法 find path [OPTIONS] 參數(常用) 參數 說明 -mount, -xdev 只檢查和指定目錄在同一個文件系統下的文件，避免列出其它文件系統中的文件 -amin n 指定檔案的最後存取時間，單位為分鐘，在過去n分鐘內被存取過 -anewer file 比文件file更晚被存取過的文件 -atime n 指定檔案的最後存取時間（access time），單位為天 -cmin n 指定檔案狀態相關資訊最後修改的時間，單位為分鐘 -cnewer file 比文件file更新的文件 -ctime n 指定檔案狀態相關資訊最後修改的時間（status time），單位為天 -mtime n 指定檔案的最後修改時間（modification time），單位為天 -mmin n 指定檔案的最後修改時間，單位為分鐘 -empty 搜尋空檔案 -ipath p, -path p 路徑名稱符合 p 的文件，ipath 會忽略大小寫 -name name, -iname name 文件名稱符合 name 的文件。 iname 會忽略大小寫 -size n 指定檔案的大小 -type c 指定檔案的類型 -perm 指定檔案的權限 -user 指定檔案擁有者 -group 指定檔案的群組 -exec 對使用find的搜尋結果執行特定指令 基本操作 指定檔名搜尋 # 搜尋在當前目錄底下，檔名為file.","title":"Linux 查找文件[find]"},{"content":"👨‍💻簡介 logrotate 用途：日誌文件管理工具，用於切割日誌，壓縮轉存，刪除舊的日誌文件，並創建新的日誌文件 預設配置文件位置： /etc/logrotate.conf /etc/logrotate.d 運行機制 logrotate是透過cron來運行的，透過/etc/cron.daily/logrotate這腳本，如要查看cron.daily運行方式，可查看/etc/anacrontab\n# /etc/anacrontab: configuration file for anacron # See anacron(8) and anacrontab(5) for details. SHELL=/bin/sh PATH=/sbin:/bin:/usr/sbin:/usr/bin MAILTO=root # the maximal random delay added to the base delay of the jobs RANDOM_DELAY=45 # the jobs will be started during the following hours only START_HOURS_RANGE=3-22 #period in days delay in minutes job-identifier command 1\t5\tcron.daily\tnice run-parts /etc/cron.daily 7\t25\tcron.weekly\tnice run-parts /etc/cron.weekly @monthly 45\tcron.monthly\tnice run-parts /etc/cron.monthly 上面可看到執行cron.daily是在凌晨3.到22.之間，並且隨機延遲45分鐘\n語法 logrotate [OPTIONS] config_file 參數 選項 說明 -d, \u0026ndash;debug debug模式，測試配置文件是否有錯誤 -f, \u0026ndash;force 強制轉儲文件 -m, \u0026ndash;mail=command 壓縮日誌後，發送日誌到指定郵箱 -s, \u0026ndash;state=statefile 使用指定的狀態文件 -v, \u0026ndash;verbose 顯示轉儲過程 -l, \u0026ndash;log=STRING log file 設定檔參數 說明 compress 在輪循任務完成後，已輪循的歸檔將使用 gzip 進行壓縮 compresscmd 指定壓縮工具，默認為gzip uncompresscmd 指定解壓縮工具，默認為gunziip compressext 指定要在壓縮日誌文件上使用的擴展名，默認遵循配置的壓縮命令 compressoptions 壓縮指令的選項配置\u0008， copy 製作log檔的副本，與create互斥 copytruncate 用於還在打開中的日誌文件，把當前日誌備份並截斷 create mode owner group 以指定的權限創建全新的日誌文件，同時 logrotate 也會重命名原始日誌文件 daily 日誌文件將按天輪循 dateext 使用當前日期作為命名格式 dateformat format_string 配合dateext使用，緊跟在下一行出現，定義文件切割後的文件名，必須配合dateext使用，只支持%Y %m %d %s這四個參數 delaycompress 和 compress 一起使用時，轉儲的日誌文件到下一次轉儲時才壓縮 extension ext 維護擴展名 ifempty 即使是空文件也轉儲 include file_or_directory 將logrotate格式的檔案或是目錄整個引進或 mail address 把轉儲的日誌文件發送到指定的 E-mail 地址 mailfirst 當啟用mail參數時，寄出剛rotated的文件 maillast 使用 mail 命令時，郵寄即將到期的文件，而不是剛剛旋轉的文件 maxage count 刪除超過count天的rotated日誌 minsize size 日誌文件在大於size字節時rotated，但不會在額外指定的時間間隔（每天、每週、每月或每年）之前輪換。使用minsize時，會同時考慮日誌文件的大小和時間戳，size選項則不會 missingok 在日誌輪循期間，任何錯誤將被忽略，例如\u0026quot;文件無法找到\u0026quot;之類的錯誤 monthly 日誌文件將按月輪循 nocompress 不壓縮 nocopy 不複製 nocopytruncate 備份日誌文件但是不截斷 nocreate 不建立新的日誌文件 nodelaycompress 覆蓋 delaycompress 選項，轉儲同時壓縮 nodateext rotate不帶日期 nomail 轉儲時不發送日誌文件 nomissingok log檔不存在會噴錯 noolddir 轉儲後的日誌文件和當前日誌文件放在同一個目錄下 nosharedscripts Run prerotate and postrotate scripts for every log file which is rotated noshred 刪除舊log時不要使用shred。 notifempty 如果日誌文件為空，輪循不會進行 olddir directory 儲後的日誌文件放入指定的目錄，必須和當前日誌文件在同一個文件系統 postrotate/endscript 在所有其它指令完成後，postrotate和endscript裡面指定的命令將被執行 prerotate/endscript 在轉儲以前需要執行的命令可以放入這個對，這兩個關鍵字必須單獨成行 firstaction/endscript firstaction以及endscript之間優先執行 lastaction/endscript lastaction以及endscript之間最後執行 rotate count 指定日誌文件刪除之前轉儲的次數，一次將存儲count個歸檔日誌。對於第count+1個歸檔，時間最久的歸檔將被刪除，0指沒有備份 size size 當日誌文件到達指定的大小時才轉儲 sharedscripts 運行postrotate腳本，作用是在所有日誌都輪轉後統一執行一次腳本。如果沒有配置這個，那麼每個日誌輪轉後都會執行一次腳本 shred 使用shred -u而不是unlink()刪除log文件。這應該確保log在預定刪除後不可讀 shredcycles count 要求 GNU shred(1) 在刪除之前覆蓋日誌文件計數次數 start count This is the number to use as the base for rotation. tabooext [+] list 不轉儲指定擴展名的文件 weekly 日誌文件將按週輪循 yearly 日誌文件將按年輪循 基本操作 調用/etc/logrotate.d下配置的所有日誌 logrotate /etc/logrotate.conf 指定logrotate檔 logrotate /etc/logrotate.d/logrotate_file 使用debug模式進行故障排除 logrotate -d /etc/logrotate.d/logrotate_file 強制rotate logrotate -df /etc/logrotate.d/logrotate_file 顯示rotate過程 logrotate -v /etc/logrotate.d/logrotate_file 配置文件案例 syslog /var/log/cron /var/log/maillog /var/log/messages /var/log/secure /var/log/spooler { missingok sharedscripts postrotate /bin/kill -HUP `cat /var/run/syslogd.pid 2\u0026gt; /dev/null` 2\u0026gt; /dev/null || true endscript } jenkins /var/log/jenkins/jenkins.log /var/log/jenkins/access_log { compress dateext maxage 365 rotate 99 size=+4096k notifempty missingok create 644 copytruncate } nginx /var/log/nginx/*.log /var/log/nginx/*/*.log{ daily missingok rotate 14 compress delaycompress notifempty create 640 root adm sharedscripts postrotate [ ! -f /var/run/nginx.pid ] || kill -USR1 `cat /var/run/nginx.pid` endscript } 參考資料 Linux 日志切割神器 logrotate 原理介绍和配置详解 | HelloDog (wsgzao.github.io) logrotate(8) - Linux man page (die.net) logrotate机制和原理 — 0xFEE1C001 (lightxue.com) How to Use logrotate to Manage Log Files | Linode 系统运维|Linux日志文件总管——logrotate 系统运维|Linux日志文件总管——logrotate (51cto.com) Logrotate 因為父目錄權限而執行失敗 – Mr. 沙先生 (shazi.info) 相關指令(可選) ","permalink":"https://sz9751210.github.io/posts/linux-logrotate/","summary":"👨‍💻簡介 logrotate 用途：日誌文件管理工具，用於切割日誌，壓縮轉存，刪除舊的日誌文件，並創建新的日誌文件 預設配置文件位置： /etc/logrotate.conf /etc/logrotate.d 運行機制 logrotate是透過cron來運行的，透過/etc/cron.daily/logrotate這腳本，如要查看cron.daily運行方式，可查看/etc/anacrontab\n# /etc/anacrontab: configuration file for anacron # See anacron(8) and anacrontab(5) for details. SHELL=/bin/sh PATH=/sbin:/bin:/usr/sbin:/usr/bin MAILTO=root # the maximal random delay added to the base delay of the jobs RANDOM_DELAY=45 # the jobs will be started during the following hours only START_HOURS_RANGE=3-22 #period in days delay in minutes job-identifier command 1\t5\tcron.daily\tnice run-parts /etc/cron.daily 7\t25\tcron.weekly\tnice run-parts /etc/cron.weekly @monthly 45\tcron.","title":"Linux 日誌管理[logrotate]"},{"content":"👨‍💻簡介 cut 用途：文字處理工具，可以將每一行文字的部分字元或是欄位擷取出來 語法 cut [OPTIONS] FILE 參數 參數 說明 -b, \u0026ndash;bytes=LIST 擷取指定的範圍，以 bytes 作為單位 -c, \u0026ndash;characters=LIST 擷取指定的範圍，以字元數量作為單位 -d, \u0026ndash;delimiter=DELIM 指定分隔字元，預設是用 tab 作為分隔 -f, \u0026ndash;fields=LIST 輸出指定的範圍，這個是每行資料的第幾個欄位作為區分 -n with -b: don\u0026rsquo;t split multibyte characters \u0026ndash;complement 排除未擷取的欄位 -s, \u0026ndash;only-delimited 如果該行沒有分隔字元，不會顯示該行資料 \u0026ndash;output-delimiter=字串 改變輸出欄位的分隔字元 基本操作 擷取字元 # 擷取從第二個字元到最後 cut -c 2- file # 擷取從開始到第二個字元 cut -c -2 file # 擷取第2-3,5-8,10-12個字元 cut -c 2-3,5-8,10-12 file 排除字元 # 排除2-5字元，其餘都擷取 cut -c 2-5 --complement 擷取欄位 # 將逗號當作分隔符，擷取第二個欄位 cut -d , -f 2 file # 將逗號當作分隔符，擷取第1-3個欄位以及第五個欄位 cut -d , -f 1-3,5 file 排除欄位 # 排除第二個欄位，擷取剩餘的欄位 cut -d , -f 2 --complement file 改變輸出欄位分隔字元 # 將逗號當作分隔符，擷取第1,3欄位並將分隔符從,改成: cut -d , -f 1,3 --output-delimiter=\u0026#34;:\u0026#34; 組合技 # 找出所有python程式的PID與指令內容 ps aux | grep python | sed \u0026#39;s/\\s\\+/ /g\u0026#39; | cut -d \u0026#39; \u0026#39; -f 2,11- 參考資料 Linux 的 cut 擷取部份字元、欄位指令教學與常用範例整理 - G. T. Wang (gtwang.org) cut 指令: 擷取檔案每行指定範圍資料 (ltsplus.com) Bash Cut Command with Examples (linuxhint.com) 相關指令(可選) sed awk ","permalink":"https://sz9751210.github.io/posts/linux-cut/","summary":"👨‍💻簡介 cut 用途：文字處理工具，可以將每一行文字的部分字元或是欄位擷取出來 語法 cut [OPTIONS] FILE 參數 參數 說明 -b, \u0026ndash;bytes=LIST 擷取指定的範圍，以 bytes 作為單位 -c, \u0026ndash;characters=LIST 擷取指定的範圍，以字元數量作為單位 -d, \u0026ndash;delimiter=DELIM 指定分隔字元，預設是用 tab 作為分隔 -f, \u0026ndash;fields=LIST 輸出指定的範圍，這個是每行資料的第幾個欄位作為區分 -n with -b: don\u0026rsquo;t split multibyte characters \u0026ndash;complement 排除未擷取的欄位 -s, \u0026ndash;only-delimited 如果該行沒有分隔字元，不會顯示該行資料 \u0026ndash;output-delimiter=字串 改變輸出欄位的分隔字元 基本操作 擷取字元 # 擷取從第二個字元到最後 cut -c 2- file # 擷取從開始到第二個字元 cut -c -2 file # 擷取第2-3,5-8,10-12個字元 cut -c 2-3,5-8,10-12 file 排除字元 # 排除2-5字元，其餘都擷取 cut -c 2-5 --complement 擷取欄位 # 將逗號當作分隔符，擷取第二個欄位 cut -d , -f 2 file # 將逗號當作分隔符，擷取第1-3個欄位以及第五個欄位 cut -d , -f 1-3,5 file 排除欄位 # 排除第二個欄位，擷取剩餘的欄位 cut -d , -f 2 --complement file 改變輸出欄位分隔字元 # 將逗號當作分隔符，擷取第1,3欄位並將分隔符從,改成: cut -d , -f 1,3 --output-delimiter=\u0026#34;:\u0026#34; 組合技 # 找出所有python程式的PID與指令內容 ps aux | grep python | sed \u0026#39;s/\\s\\+/ /g\u0026#39; | cut -d \u0026#39; \u0026#39; -f 2,11- 參考資料 Linux 的 cut 擷取部份字元、欄位指令教學與常用範例整理 - G.","title":"Linux 擷取部分字元[cut]"},{"content":"刪除本地分支 先使用 git branch -a(all) 列出所有分支，再使用 -d(delete) 後面接著要刪除的分支名稱即可\ngit branch -a # *master # test # remote/origin/master # remote/origin/test git branch -d test # Deleted branch test (was ########). 刪除遠程分支 刪除遠程分支必須使用 git push 加上 --delete 參數，並且必須在push後加上 remote name\ngit branch -a # *master # test # remote/origin/master # remote/origin/test git push origin --delete test # To \u0026lt;URL of your repository\u0026gt;.git # - [deleted] test 參考資料 How to delete remote branches in Git (educative.io) ","permalink":"https://sz9751210.github.io/posts/git-%E5%88%AA%E9%99%A4%E9%81%A0%E7%A8%8B%E5%88%86%E6%94%AF/","summary":"刪除本地分支 先使用 git branch -a(all) 列出所有分支，再使用 -d(delete) 後面接著要刪除的分支名稱即可\ngit branch -a # *master # test # remote/origin/master # remote/origin/test git branch -d test # Deleted branch test (was ########). 刪除遠程分支 刪除遠程分支必須使用 git push 加上 --delete 參數，並且必須在push後加上 remote name\ngit branch -a # *master # test # remote/origin/master # remote/origin/test git push origin --delete test # To \u0026lt;URL of your repository\u0026gt;.git # - [deleted] test 參考資料 How to delete remote branches in Git (educative.","title":"git-刪除遠程分支"},{"content":"安裝環境 windows 10 python 3.8.0 安裝步驟 1.下載python 網址:Python\n點擊Download\n選擇windows的可執行安裝檔，目前大多都以64位元為主 2.安裝過程 2. 3. 4. 3.檢查環境 1. 2. 3. 4. 5. 6. 7. ","permalink":"https://sz9751210.github.io/posts/python-installation/","summary":"安裝環境 windows 10 python 3.8.0 安裝步驟 1.下載python 網址:Python\n點擊Download\n選擇windows的可執行安裝檔，目前大多都以64位元為主 2.安裝過程 2. 3. 4. 3.檢查環境 1. 2. 3. 4. 5. 6. 7. ","title":"python-installation"},{"content":"👨‍💻簡介 cp(copy) 用途：複製檔案(copy)和目錄 語法 cp [OPTIONS] SOURCE DEST 參數 參數 說明 -a, \u0026ndash;archive 效果同-dpR，保留連結、文件屬性，並複製目錄下的所有內容，通常在複製目錄時使用 \u0026ndash;attributes-only 只複製文件的屬性，內容不複製 \u0026ndash;backup[=CONTROL] 備份每個現有的目標文件 -b 不接受參數版的\u0026ndash;backup \u0026ndash;copy-contents 遞歸模式下複製特殊文件的內容 -d 複製時保留軟連結 -f, \u0026ndash;force 強制覆蓋已經存在的目標文件，不會跳出提示 -i, \u0026ndash;interactive 與-f選項相反，在覆蓋目標文件之前給出提示，要求用戶確認是否覆蓋，回答 y 時目標文件將被覆蓋。 -H 跟隨源文件命令行中顯式給出的符號鏈接 -l, \u0026ndash;link 使用硬鏈接取代複製 -L, \u0026ndash;dereference 總是跟隨源文件中的符號鏈接 -n, \u0026ndash;no-clobber 不要覆寫已有的文件（覆蓋先前給出的 -i 選項） -P, \u0026ndash;no-dereference 永遠不要跟隨源文件中的符號鏈接 -p 不接受參數版的\u0026ndash;preserve \u0026ndash;preserve[=ATTR_LIST] 除複製文件的內容外，還把修改時間和訪問權限也複製到新文件中。保留指定的屬性（默認：模式、從屬關係、時間戳），如果可能的話還有額外屬性：上下文、鏈接（links）、xattr、all \u0026ndash;no-preserve=ATTR_LIST 不要保留指定的屬性 \u0026ndash;parents 在目標目錄下使用完整的源文件名 -R, -r, \u0026ndash;recursive 遞歸複製目錄 \u0026ndash;reflink[=WHEN] 控制克隆/寫入時複製（CoW）副本。詳情見下文 \u0026ndash;remove-destination 打開目的 \u0026ndash;sparse=WHEN 控制稀疏文件的創建。詳情見下文 \u0026ndash;strip-trailing-slashes 移除每個源文件參數後的任何末尾斜槓 -s, \u0026ndash;symbolic-link 建立軟連結而不是複制 -S, \u0026ndash;suffix=後置字串 覆蓋原本的備份後綴 -t, \u0026ndash;target-directory=目錄 將所有源文件參數給出的內容複製到目標目錄中 -T, \u0026ndash;no-target-directory 將目標文件當作普通文件對待（而不是目錄） -u, \u0026ndash;update 僅在源文件比目標文件新，或者目標文件不存在的情況下複製 -v, \u0026ndash;verbose 顯示覆蓋訊息 -x, \u0026ndash;one-file-system 停留在當前文件系統中 -Z 將目標文件的 SELinux 安全上下文設置為默認類型 \u0026ndash;context[=CTX] 類似-Z，或者如果給定了上下文（CTX）那麼將SELinux或者SMACK 安全上下文設置爲給定值 默認情況下，程序會使用一種粗糙的啓發式算法探測源文件是否是稀疏的，若判定爲稀疏，則目標文件也會以稀疏形式創建。這個行爲可以通過\n--sparse=auto指定。若指定 --sparse=always，將在源文件包含足夠多內容爲零的字節序列時將其視作稀疏文件。使用 --sparse=never 以禁止創建稀疏文件。 當指定了--reflink[=always]時，進行輕量級複製，其中的數據塊僅在被修改時進行復制。如果這樣的複製失敗，或無法實行，或者指定了--reflink=auto時，回退到標準複製。\n備份的後綴爲\u0026quot;~\u0026quot;，除非設置了--suffix或者SIMPLE_BACKUP_SUFFIX。版本控制方式可以使用 --backup選項或者VERSION_CONTROL環境變量進行指定。可用的值如下：\nnone, off：永遠不製作備份（即使給出了 \u0026ndash;backup ） numbered, t：製作編號的備份 existing, nil：如果已編號副本存在則編號，否則採用簡單方式 simple, never：總是製作簡單備份 作爲一個特例，cp將在同時給出force選項與backup選項，並且源文件和目標文件是同一個已存在普通文件的情況下製作備份副本。 基本操作 複製目錄 cp -r source/ destdir 複製並改名 cp aaa bbb 複製目錄及屬性 cp -rp source/ destdir 複製多檔到單目錄下 cp aaa bbb destdir 透過匹配複製 cp *.log dest 參考資料 Ubuntu Manpage: cp - 複製文件和目錄 Linux cp 指令用法 (link.idv.tw) Linux cp Command Examples (linuxhint.com) ","permalink":"https://sz9751210.github.io/posts/linux-cp/","summary":"👨‍💻簡介 cp(copy) 用途：複製檔案(copy)和目錄 語法 cp [OPTIONS] SOURCE DEST 參數 參數 說明 -a, \u0026ndash;archive 效果同-dpR，保留連結、文件屬性，並複製目錄下的所有內容，通常在複製目錄時使用 \u0026ndash;attributes-only 只複製文件的屬性，內容不複製 \u0026ndash;backup[=CONTROL] 備份每個現有的目標文件 -b 不接受參數版的\u0026ndash;backup \u0026ndash;copy-contents 遞歸模式下複製特殊文件的內容 -d 複製時保留軟連結 -f, \u0026ndash;force 強制覆蓋已經存在的目標文件，不會跳出提示 -i, \u0026ndash;interactive 與-f選項相反，在覆蓋目標文件之前給出提示，要求用戶確認是否覆蓋，回答 y 時目標文件將被覆蓋。 -H 跟隨源文件命令行中顯式給出的符號鏈接 -l, \u0026ndash;link 使用硬鏈接取代複製 -L, \u0026ndash;dereference 總是跟隨源文件中的符號鏈接 -n, \u0026ndash;no-clobber 不要覆寫已有的文件（覆蓋先前給出的 -i 選項） -P, \u0026ndash;no-dereference 永遠不要跟隨源文件中的符號鏈接 -p 不接受參數版的\u0026ndash;preserve \u0026ndash;preserve[=ATTR_LIST] 除複製文件的內容外，還把修改時間和訪問權限也複製到新文件中。保留指定的屬性（默認：模式、從屬關係、時間戳），如果可能的話還有額外屬性：上下文、鏈接（links）、xattr、all \u0026ndash;no-preserve=ATTR_LIST 不要保留指定的屬性 \u0026ndash;parents 在目標目錄下使用完整的源文件名 -R, -r, \u0026ndash;recursive 遞歸複製目錄 \u0026ndash;reflink[=WHEN] 控制克隆/寫入時複製（CoW）副本。詳情見下文 \u0026ndash;remove-destination 打開目的 \u0026ndash;sparse=WHEN 控制稀疏文件的創建。詳情見下文 \u0026ndash;strip-trailing-slashes 移除每個源文件參數後的任何末尾斜槓 -s, \u0026ndash;symbolic-link 建立軟連結而不是複制 -S, \u0026ndash;suffix=後置字串 覆蓋原本的備份後綴 -t, \u0026ndash;target-directory=目錄 將所有源文件參數給出的內容複製到目標目錄中 -T, \u0026ndash;no-target-directory 將目標文件當作普通文件對待（而不是目錄） -u, \u0026ndash;update 僅在源文件比目標文件新，或者目標文件不存在的情況下複製 -v, \u0026ndash;verbose 顯示覆蓋訊息 -x, \u0026ndash;one-file-system 停留在當前文件系統中 -Z 將目標文件的 SELinux 安全上下文設置為默認類型 \u0026ndash;context[=CTX] 類似-Z，或者如果給定了上下文（CTX）那麼將SELinux或者SMACK 安全上下文設置爲給定值 默認情況下，程序會使用一種粗糙的啓發式算法探測源文件是否是稀疏的，若判定爲稀疏，則目標文件也會以稀疏形式創建。這個行爲可以通過","title":"Linux 複製檔案[cp]"},{"content":"因為git忽略的原則為之前沒有被追蹤的檔案，因此可能開發到一半才會需要新增gitignore來進行忽略，但是失效\n解決的辦法為刪掉本地快取(改變成未被追蹤的狀態)，接著在新增要忽略的檔案到gitignore裡\ngit rm -r --cached . git add . git commit -m \u0026#34;init gitignore\u0026#34; ","permalink":"https://sz9751210.github.io/posts/gitignore%E5%A4%B1%E6%95%88%E7%9A%84%E8%A7%A3%E6%B1%BA%E8%BE%A6%E6%B3%95/","summary":"因為git忽略的原則為之前沒有被追蹤的檔案，因此可能開發到一半才會需要新增gitignore來進行忽略，但是失效\n解決的辦法為刪掉本地快取(改變成未被追蹤的狀態)，接著在新增要忽略的檔案到gitignore裡\ngit rm -r --cached . git add . git commit -m \u0026#34;init gitignore\u0026#34; ","title":"gitignore失效的解決辦法"},{"content":"👨‍💻簡介 chmod(change mode) 用途：控制用戶對文件的權限，linux 的文件權限分為三種身分，owner/group/others，而權限也分為三種，read/write/execute，權重如下表格 權限 權重 r 4 w 2 x 1 語法 chmod [OPTIONS] [mode] [檔案或目錄] 參數 參數 說明 -c, \u0026ndash;changes 效果類似\u0026quot;-v\u0026quot;參數，但僅回報更改的部分。 -f, \u0026ndash;silent, \u0026ndash;quiet 不顯示錯誤資訊。 -v, \u0026ndash;verbose 顯示指令執行過程。 \u0026ndash;no-preserve-root 取消對 root 文件系統的保護 \u0026ndash;preserve-root 保留對 root 文件系統的保護 \u0026ndash;reference=RFILE 把指定文件或目錄的權限全部設成和參考文件或目錄的權限相同。 -R, \u0026ndash;recursive 遞迴處理，將指定目錄下的所有檔及子目錄一併處理。 符號模式 who(用戶類型) 說明 u(user) 所有者 g(group) 所屬組 o(others) 其他用戶 a(all) 所有用戶，等於ugo operator 說明 + 新增權限 - 移除權限 = 設定權限 模式 說明 r 可讀權限 w 可寫權限 x 可執行權限 絕對模式 參數 權限 rwx 7 讀+寫+執行 rwx 6 讀+寫 rw- 5 讀+執行 r-x 4 只讀 r\u0026ndash; 3 寫+執行 -wx 2 只寫 -w- 1 只執行 \u0026ndash;x 0 無 \u0026mdash; 基本操作 將檔案變成user可執行 假設原本檔案權限為-rw-rw-r--\n指令 mode chmod u+x chmod u=rwx chmod 764 將檔案設定user可寫，group以及others無法寫 假設原本檔案權限為-r--rw-rw-\n指令 mode chmod u+w,go-w chmod u=rw,go=r chmod 644 將資料夾底下的權限都設定一樣的 chmod -R a+r dirName ","permalink":"https://sz9751210.github.io/posts/linux-chmod/","summary":"👨‍💻簡介 chmod(change mode) 用途：控制用戶對文件的權限，linux 的文件權限分為三種身分，owner/group/others，而權限也分為三種，read/write/execute，權重如下表格 權限 權重 r 4 w 2 x 1 語法 chmod [OPTIONS] [mode] [檔案或目錄] 參數 參數 說明 -c, \u0026ndash;changes 效果類似\u0026quot;-v\u0026quot;參數，但僅回報更改的部分。 -f, \u0026ndash;silent, \u0026ndash;quiet 不顯示錯誤資訊。 -v, \u0026ndash;verbose 顯示指令執行過程。 \u0026ndash;no-preserve-root 取消對 root 文件系統的保護 \u0026ndash;preserve-root 保留對 root 文件系統的保護 \u0026ndash;reference=RFILE 把指定文件或目錄的權限全部設成和參考文件或目錄的權限相同。 -R, \u0026ndash;recursive 遞迴處理，將指定目錄下的所有檔及子目錄一併處理。 符號模式 who(用戶類型) 說明 u(user) 所有者 g(group) 所屬組 o(others) 其他用戶 a(all) 所有用戶，等於ugo operator 說明 + 新增權限 - 移除權限 = 設定權限 模式 說明 r 可讀權限 w 可寫權限 x 可執行權限 絕對模式 參數 權限 rwx 7 讀+寫+執行 rwx 6 讀+寫 rw- 5 讀+執行 r-x 4 只讀 r\u0026ndash; 3 寫+執行 -wx 2 只寫 -w- 1 只執行 \u0026ndash;x 0 無 \u0026mdash; 基本操作 將檔案變成user可執行 假設原本檔案權限為-rw-rw-r--","title":"Linux 修改權限[chmod]"},{"content":"紀錄一下hugo的建置過程\n1. 安裝hugo windows安裝 Chocolatey choco install hugo -confirm Scoop scoop install hugo macos安裝 brew install hugo linux安裝 sudo apt-get install hugo 2. 建立網站 hugo new site myblog -f yaml 3. 下載主題 git clone https://github.com/adityatelange/hugo-PaperMod themes/PaperMod --depth=1 4. 建立about, tags page 建立about page hugo new about.md 修改config檔 menu: main: - identifier: tags name: tags url: /tags/ weight: 1 - identifier: about name: about url: /about/ weight: 2 5. 依照需求美化版面 Hugo PaperMod 優化\n6. 推到github 修改config檔的baseURL為自己的github.io網址 刪掉theme底下的.git，如果有自己修改的話就版控這個主題 將自己的github.io的repo設定成submodule git submodule add git@github.com:sz9751210/sz9751210.github.io.git public 在myblog下hugo生成靜態網頁 到public資料夾將生成的檔案都推到github.io的repo 到自己的github page查看結果 ","permalink":"https://sz9751210.github.io/posts/hugo-setup/","summary":"紀錄一下hugo的建置過程\n1. 安裝hugo windows安裝 Chocolatey choco install hugo -confirm Scoop scoop install hugo macos安裝 brew install hugo linux安裝 sudo apt-get install hugo 2. 建立網站 hugo new site myblog -f yaml 3. 下載主題 git clone https://github.com/adityatelange/hugo-PaperMod themes/PaperMod --depth=1 4. 建立about, tags page 建立about page hugo new about.md 修改config檔 menu: main: - identifier: tags name: tags url: /tags/ weight: 1 - identifier: about name: about url: /about/ weight: 2 5. 依照需求美化版面 Hugo PaperMod 優化","title":"Hugo Setup"},{"content":"簡單紀錄一下papermod主題的優化，持續更新\u0026hellip;\n1. 目錄放側邊 替換以下路徑的code layouts/partials/toc.html\n{{- $headers := findRE \u0026#34;\u0026lt;h[1-6].*?\u0026gt;(.|\\n])+?\u0026lt;/h[1-6]\u0026gt;\u0026#34; .Content -}} {{- $has_headers := ge (len $headers) 1 -}} {{- if $has_headers -}} \u0026lt;aside id=\u0026#34;toc-container\u0026#34; class=\u0026#34;toc-container wide\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;toc\u0026#34;\u0026gt; \u0026lt;details {{if (.Param \u0026#34;TocOpen\u0026#34;) }} open{{ end }}\u0026gt; \u0026lt;summary accesskey=\u0026#34;c\u0026#34; title=\u0026#34;(Alt + C)\u0026#34;\u0026gt; \u0026lt;span class=\u0026#34;details\u0026#34;\u0026gt;{{- i18n \u0026#34;toc\u0026#34; | default \u0026#34;Table of Contents\u0026#34; }}\u0026lt;/span\u0026gt; \u0026lt;/summary\u0026gt; \u0026lt;div class=\u0026#34;inner\u0026#34;\u0026gt; {{- $largest := 6 -}} {{- range $headers -}} {{- $headerLevel := index (findRE \u0026#34;[1-6]\u0026#34; . 1) 0 -}} {{- $headerLevel := len (seq $headerLevel) -}} {{- if lt $headerLevel $largest -}} {{- $largest = $headerLevel -}} {{- end -}} {{- end -}} {{- $firstHeaderLevel := len (seq (index (findRE \u0026#34;[1-6]\u0026#34; (index $headers 0) 1) 0)) -}} {{- $.Scratch.Set \u0026#34;bareul\u0026#34; slice -}} \u0026lt;ul\u0026gt; {{- range seq (sub $firstHeaderLevel $largest) -}} \u0026lt;ul\u0026gt; {{- $.Scratch.Add \u0026#34;bareul\u0026#34; (sub (add $largest .) 1) -}} {{- end -}} {{- range $i, $header := $headers -}} {{- $headerLevel := index (findRE \u0026#34;[1-6]\u0026#34; . 1) 0 -}} {{- $headerLevel := len (seq $headerLevel) -}} {{/* get id=\u0026#34;xyz\u0026#34; */}} {{- $id := index (findRE \u0026#34;(id=\\\u0026#34;(.*?)\\\u0026#34;)\u0026#34; $header 9) 0 }} {{- /* strip id=\u0026#34;\u0026#34; to leave xyz, no way to get regex capturing groups in hugo */ -}} {{- $cleanedID := replace (replace $id \u0026#34;id=\\\u0026#34;\u0026#34; \u0026#34;\u0026#34;) \u0026#34;\\\u0026#34;\u0026#34; \u0026#34;\u0026#34; }} {{- $header := replaceRE \u0026#34;\u0026lt;h[1-6].*?\u0026gt;((.|\\n])+?)\u0026lt;/h[1-6]\u0026gt;\u0026#34; \u0026#34;$1\u0026#34; $header -}} {{- if ne $i 0 -}} {{- $prevHeaderLevel := index (findRE \u0026#34;[1-6]\u0026#34; (index $headers (sub $i 1)) 1) 0 -}} {{- $prevHeaderLevel := len (seq $prevHeaderLevel) -}} {{- if gt $headerLevel $prevHeaderLevel -}} {{- range seq $prevHeaderLevel (sub $headerLevel 1) -}} \u0026lt;ul\u0026gt; {{/* the first should not be recorded */}} {{- if ne $prevHeaderLevel . -}} {{- $.Scratch.Add \u0026#34;bareul\u0026#34; . -}} {{- end -}} {{- end -}} {{- else -}} \u0026lt;/li\u0026gt; {{- if lt $headerLevel $prevHeaderLevel -}} {{- range seq (sub $prevHeaderLevel 1) -1 $headerLevel -}} {{- if in ($.Scratch.Get \u0026#34;bareul\u0026#34;) . -}} \u0026lt;/ul\u0026gt; {{/* manually do pop item */}} {{- $tmp := $.Scratch.Get \u0026#34;bareul\u0026#34; -}} {{- $.Scratch.Delete \u0026#34;bareul\u0026#34; -}} {{- $.Scratch.Set \u0026#34;bareul\u0026#34; slice}} {{- range seq (sub (len $tmp) 1) -}} {{- $.Scratch.Add \u0026#34;bareul\u0026#34; (index $tmp (sub . 1)) -}} {{- end -}} {{- else -}} \u0026lt;/ul\u0026gt; \u0026lt;/li\u0026gt; {{- end -}} {{- end -}} {{- end -}} {{- end }} \u0026lt;li\u0026gt; \u0026lt;a href=\u0026#34;#{{- $cleanedID -}}\u0026#34; aria-label=\u0026#34;{{- $header | plainify -}}\u0026#34;\u0026gt;{{- $header | safeHTML -}}\u0026lt;/a\u0026gt; {{- else }} \u0026lt;li\u0026gt; \u0026lt;a href=\u0026#34;#{{- $cleanedID -}}\u0026#34; aria-label=\u0026#34;{{- $header | plainify -}}\u0026#34;\u0026gt;{{- $header | safeHTML -}}\u0026lt;/a\u0026gt; {{- end -}} {{- end -}} \u0026lt;!-- {{- $firstHeaderLevel := len (seq (index (findRE \u0026#34;[1-6]\u0026#34; (index $headers 0) 1) 0)) -}} --\u0026gt; {{- $firstHeaderLevel := $largest }} {{- $lastHeaderLevel := len (seq (index (findRE \u0026#34;[1-6]\u0026#34; (index $headers (sub (len $headers) 1)) 1) 0)) }} \u0026lt;/li\u0026gt; {{- range seq (sub $lastHeaderLevel $firstHeaderLevel) -}} {{- if in ($.Scratch.Get \u0026#34;bareul\u0026#34;) (add . $firstHeaderLevel) }} \u0026lt;/ul\u0026gt; {{- else }} \u0026lt;/ul\u0026gt; \u0026lt;/li\u0026gt; {{- end -}} {{- end }} \u0026lt;/ul\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/details\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/aside\u0026gt; \u0026lt;script\u0026gt; let activeElement; let elements; window.addEventListener(\u0026#39;DOMContentLoaded\u0026#39;, function (event) { checkTocPosition(); elements = document.querySelectorAll(\u0026#39;h1[id],h2[id],h3[id],h4[id],h5[id],h6[id]\u0026#39;); // Make the first header active activeElement = elements[0]; const id = encodeURI(activeElement.getAttribute(\u0026#39;id\u0026#39;)).toLowerCase(); document.querySelector(`.inner ul li a[href=\u0026#34;#${id}\u0026#34;]`).classList.add(\u0026#39;active\u0026#39;); }, false); window.addEventListener(\u0026#39;resize\u0026#39;, function(event) { checkTocPosition(); }, false); window.addEventListener(\u0026#39;scroll\u0026#39;, () =\u0026gt; { // Check if there is an object in the top half of the screen or keep the last item active activeElement = Array.from(elements).find((element) =\u0026gt; { if ((getOffsetTop(element) - window.pageYOffset) \u0026gt; 0 \u0026amp;\u0026amp; (getOffsetTop(element) - window.pageYOffset) \u0026lt; window.innerHeight/2) { return element; } }) || activeElement elements.forEach(element =\u0026gt; { const id = encodeURI(element.getAttribute(\u0026#39;id\u0026#39;)).toLowerCase(); if (element === activeElement){ document.querySelector(`.inner ul li a[href=\u0026#34;#${id}\u0026#34;]`).classList.add(\u0026#39;active\u0026#39;); } else { document.querySelector(`.inner ul li a[href=\u0026#34;#${id}\u0026#34;]`).classList.remove(\u0026#39;active\u0026#39;); } }) }, false); const main = parseInt(getComputedStyle(document.body).getPropertyValue(\u0026#39;--article-width\u0026#39;), 10); const toc = parseInt(getComputedStyle(document.body).getPropertyValue(\u0026#39;--toc-width\u0026#39;), 10); const gap = parseInt(getComputedStyle(document.body).getPropertyValue(\u0026#39;--gap\u0026#39;), 10); function checkTocPosition() { const width = document.body.scrollWidth; if (width - main - (toc * 2) - (gap * 4) \u0026gt; 0) { document.getElementById(\u0026#34;toc-container\u0026#34;).classList.add(\u0026#34;wide\u0026#34;); } else { document.getElementById(\u0026#34;toc-container\u0026#34;).classList.remove(\u0026#34;wide\u0026#34;); } } function getOffsetTop(element) { if (!element.getClientRects().length) { return 0; } let rect = element.getBoundingClientRect(); let win = element.ownerDocument.defaultView; return rect.top + win.pageYOffset; } \u0026lt;/script\u0026gt; {{- end }} 在\\themes\\PaperMod\\assets\\css\\extended底下新建一個.css檔，命名為toc-left.css\n:root { --nav-width: 1380px; --article-width: 650px; --toc-width: 300px; } .toc { margin: 0 2px 40px 2px; border: 1px solid var(--border); background: var(--entry); border-radius: var(--radius); padding: 0.4em; } .toc-container.wide { position: absolute; height: 100%; border-right: 1px solid var(--border); left: calc((var(--toc-width) + var(--gap)) * -1); top: calc(var(--gap) * 2); width: var(--toc-width); } .wide .toc { position: sticky; top: var(--gap); border: unset; background: unset; border-radius: unset; width: 100%; margin: 0 2px 40px 2px; } .toc details summary { cursor: zoom-in; margin-inline-start: 20px; padding: 12px 0; } .toc details[open] summary { font-weight: 500; } .toc-container.wide .toc .inner { margin: 0; } .active { font-size: 110%; font-weight: 600; } .toc ul { list-style-type: circle; } .toc .inner { margin: 0 0 0 20px; padding: 0px 15px 15px 20px; font-size: 16px; /*目录显示高度*/ max-height: 83vh; overflow-y: auto; } .toc .inner::-webkit-scrollbar-thumb { /*滚动条*/ background: var(--border); border: 7px solid var(--theme); border-radius: var(--radius); } .toc li ul { margin-inline-start: calc(var(--gap) * 0.5); list-style-type: none; } .toc li { list-style: none; font-size: 0.95rem; padding-bottom: 5px; } .toc li a:hover { color: var(--secondary); } 2. 主頁圖片縮小擺右側 到layouts/_default/list.html，新增一個div，命名為post-info，把entry-header以及entry-content包進去 \u0026lt;article class=\u0026#34;{{ $class }}\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;post-info\u0026#34;\u0026gt; \u0026lt;!--加在這裡--\u0026gt; \u0026lt;header class=\u0026#34;entry-header\u0026#34;\u0026gt; \u0026lt;h2\u0026gt; {{- .Title }} {{- if .Draft }}\u0026lt;sup\u0026gt;\u0026lt;span class=\u0026#34;entry-isdraft\u0026#34;\u0026gt;\u0026amp;nbsp;\u0026amp;nbsp;[draft]\u0026lt;/span\u0026gt;\u0026lt;/sup\u0026gt;{{- end }} \u0026lt;/h2\u0026gt; \u0026lt;/header\u0026gt; {{- if (ne (.Param \u0026#34;hideSummary\u0026#34;) true) }} \u0026lt;div class=\u0026#34;entry-content\u0026#34;\u0026gt; \u0026lt;p\u0026gt;{{ .Summary | plainify | htmlUnescape }}{{ if .Truncated }}...{{ end }}\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; {{- end }} {{- if not (.Param \u0026#34;hideMeta\u0026#34;) }} \u0026lt;footer class=\u0026#34;entry-footer\u0026#34;\u0026gt; {{- partial \u0026#34;post_meta.html\u0026#34; . -}} \u0026lt;/footer\u0026gt; {{- end }} \u0026lt;/div\u0026gt; \u0026lt;!--加在這裡--\u0026gt; \u0026lt;!-- 下面這兩行從原本的\u0026lt;article class=\u0026#34;{{ $class }}\u0026#34;\u0026gt;和\u0026lt;header class=\u0026#34;entry-header\u0026#34;\u0026gt;搬下來 --\u0026gt; {{- $isHidden := (site.Params.cover.hidden | default site.Params.cover.hiddenInList) }} {{- partial \u0026#34;cover.html\u0026#34; (dict \u0026#34;cxt\u0026#34; . \u0026#34;IsHome\u0026#34; true \u0026#34;isHidden\u0026#34; $isHidden) }} \u0026lt;a class=\u0026#34;entry-link\u0026#34; aria-label=\u0026#34;post link to {{ .Title | plainify }}\u0026#34; href=\u0026#34;{{ .Permalink }}\u0026#34;\u0026gt;\u0026lt;/a\u0026gt; \u0026lt;/article\u0026gt; {{- end }} 在\\themes\\PaperMod\\assets\\css\\extended底下新建一個.css檔，命名為image-left.css .post-entry { display: flex; flex-direction: row; align-items: center; } .entry-cover { overflow: hidden; padding-left: 18px; height: 100%; width: 50%; margin-bottom: unset; } .post-info { display: inline-block; overflow: hidden; width: 90%; } 修改主頁與內文的差異\n在layouts/partials/cover.html，複製一份並命名為cover1.html 把cover1.html裡的\u0026lt;figure class=\u0026quot;entry-cover\u0026quot;\u0026gt;改為\u0026lt;figure class=\u0026quot;entry-cover1\u0026quot;\u0026gt; 在layouts/_default/single.html把{{- partial \u0026quot;cover.html\u0026quot; (dict \u0026quot;cxt\u0026quot; . \u0026quot;IsHome\u0026quot; false \u0026quot;isHidden\u0026quot; $isHidden) }}改為{{- partial \u0026quot;cover1.html\u0026quot; (dict \u0026quot;cxt\u0026quot; . \u0026quot;IsHome\u0026quot; false \u0026quot;isHidden\u0026quot; $isHidden) }} 3. Mac風格的code blocks 在\\themes\\PaperMod\\assets\\css\\extended底下新建一個.css檔，命名為mac-code-blocks.css\npre { position: relative; padding: 30px 10px 10px 10px; } .post-content pre code { font-family: Consolas; } pre::after { display: block; content: \u0026#34; \u0026#34;; position: absolute; border-radius: 50%; background: #ff5f56; width: 12px; height: 12px; top: 0; left: 12px; margin-top: 12px; -webkit-box-shadow: 20px 0 #ffbd2e, 40px 0 #27c93f; box-shadow: 20px 0 #ffbd2e, 40px 0 #27c93f; } 4. 讓tags與categories頁面的文章也顯示縮圖 assets/css/common/post-entry.css\n.tag-entry .entry-cover { display: flex; } ","permalink":"https://sz9751210.github.io/posts/hugo-papermod-enforce/","summary":"簡單紀錄一下papermod主題的優化，持續更新\u0026hellip;\n1. 目錄放側邊 替換以下路徑的code layouts/partials/toc.html\n{{- $headers := findRE \u0026#34;\u0026lt;h[1-6].*?\u0026gt;(.|\\n])+?\u0026lt;/h[1-6]\u0026gt;\u0026#34; .Content -}} {{- $has_headers := ge (len $headers) 1 -}} {{- if $has_headers -}} \u0026lt;aside id=\u0026#34;toc-container\u0026#34; class=\u0026#34;toc-container wide\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;toc\u0026#34;\u0026gt; \u0026lt;details {{if (.Param \u0026#34;TocOpen\u0026#34;) }} open{{ end }}\u0026gt; \u0026lt;summary accesskey=\u0026#34;c\u0026#34; title=\u0026#34;(Alt + C)\u0026#34;\u0026gt; \u0026lt;span class=\u0026#34;details\u0026#34;\u0026gt;{{- i18n \u0026#34;toc\u0026#34; | default \u0026#34;Table of Contents\u0026#34; }}\u0026lt;/span\u0026gt; \u0026lt;/summary\u0026gt; \u0026lt;div class=\u0026#34;inner\u0026#34;\u0026gt; {{- $largest := 6 -}} {{- range $headers -}} {{- $headerLevel := index (findRE \u0026#34;[1-6]\u0026#34; .","title":"Hugo PaperMod 優化"},{"content":" Know How, Know Why, Know What and When 把時間花在哪裡，成就就在哪裡 time is your most valuable resource, speed is your best friend 用實作來學習，永遠是初學的王道!以實戰來練習，永遠是進階的捷徑! Practice makes perfect. All experience comes from mistakes. Don\u0026rsquo;t be one of the leeches. ","permalink":"https://sz9751210.github.io/quote/","summary":" Know How, Know Why, Know What and When 把時間花在哪裡，成就就在哪裡 time is your most valuable resource, speed is your best friend 用實作來學習，永遠是初學的王道!以實戰來練習，永遠是進階的捷徑! Practice makes perfect. All experience comes from mistakes. Don\u0026rsquo;t be one of the leeches. ","title":"Quote"},{"content":"👨‍💻簡介 chgrp(change group) 用途：用於改變文件或目錄的所屬群組 語法 chgrp [OPTIONS] [文件或目錄] 參數 參數 說明 -c, \u0026ndash;changes 效果類似\u0026quot;-v\u0026quot;參數，但僅回報更改的部分。 -f, \u0026ndash;silent, \u0026ndash;quiet 不顯示錯誤資訊。 -v, \u0026ndash;verbose 顯示指令執行過程。 \u0026ndash;dereference 與-h相反，只對連結的對象做修改，而不是連結本身 -h, \u0026ndash;no-dereference 只對軟連結的檔作修改，而不更動其他任何相關檔。 \u0026ndash;no-preserve-root 取消對 root 文件系統的保護 \u0026ndash;preserve-root 保留對 root 文件系統的保護 \u0026ndash;reference=RFILE 把指定文件或目錄的所屬群組全部設成和參考文件或目錄的所屬群組相同。 -R, \u0026ndash;recursive 遞迴處理，將指定目錄下的所有檔及子目錄一併處理。 -H 如果命令行參數是軟連結到一個目錄，遍歷它 -L 遍歷每個軟連結到目錄的鏈接 -P 不遍歷任何軟連結（默認） 基本操作 改變文件的群組屬性 將test的所屬組更改為alan\nchgrp alan test 根據指定文件改變文件的群組屬性 test2參考test的群組屬性，使得test與test2的群組屬性相同\nchgrp --reference=test test2 ","permalink":"https://sz9751210.github.io/posts/linux-chgrp/","summary":"👨‍💻簡介 chgrp(change group) 用途：用於改變文件或目錄的所屬群組 語法 chgrp [OPTIONS] [文件或目錄] 參數 參數 說明 -c, \u0026ndash;changes 效果類似\u0026quot;-v\u0026quot;參數，但僅回報更改的部分。 -f, \u0026ndash;silent, \u0026ndash;quiet 不顯示錯誤資訊。 -v, \u0026ndash;verbose 顯示指令執行過程。 \u0026ndash;dereference 與-h相反，只對連結的對象做修改，而不是連結本身 -h, \u0026ndash;no-dereference 只對軟連結的檔作修改，而不更動其他任何相關檔。 \u0026ndash;no-preserve-root 取消對 root 文件系統的保護 \u0026ndash;preserve-root 保留對 root 文件系統的保護 \u0026ndash;reference=RFILE 把指定文件或目錄的所屬群組全部設成和參考文件或目錄的所屬群組相同。 -R, \u0026ndash;recursive 遞迴處理，將指定目錄下的所有檔及子目錄一併處理。 -H 如果命令行參數是軟連結到一個目錄，遍歷它 -L 遍歷每個軟連結到目錄的鏈接 -P 不遍歷任何軟連結（默認） 基本操作 改變文件的群組屬性 將test的所屬組更改為alan\nchgrp alan test 根據指定文件改變文件的群組屬性 test2參考test的群組屬性，使得test與test2的群組屬性相同\nchgrp --reference=test test2 ","title":"Linux 修改群組[chgrp]"},{"content":"專注於學習devops的菜雞工程師，凡事力求一鍵部署，喜歡寫一些小玩具嘗試新技術，時而分享好書的閱讀心得以及好文。\n","permalink":"https://sz9751210.github.io/about/","summary":"專注於學習devops的菜雞工程師，凡事力求一鍵部署，喜歡寫一些小玩具嘗試新技術，時而分享好書的閱讀心得以及好文。","title":"關於我"},{"content":"👨‍💻簡介 less 用途：對文件或其它輸出進行分頁顯示的工具，可查看壓縮檔 語法 less [OPTIONS] fileName 參數 參數 說明 -b \u0026lt;緩衝區大小\u0026gt; 設置緩衝區的大小 -e 當文件顯示結束後，自動離開 -f 強迫打開特殊文件，例如外圍設備代號、目錄和二進制文件 -g 只標誌最後搜索的關鍵詞 -i 忽略搜索時的大小寫 -m 顯示類似more指令的百分比 -N 顯示每行的行號 -o \u0026lt;文件名\u0026gt; 將less 輸出的內容在指定文件中保存起來 -Q 不使用警告音 -s 顯示連續空行為一行 -S 行過長時間將超出部分捨棄 -x \u0026lt;數字\u0026gt; 將「tab」鍵顯示為規定的數字空格 less模式下 用法 說明 /字符串 向下搜索「字符串」的功能 ?字符串 向上搜索「字符串」的功能 n 重複前一個搜索（與 / 或 ? 有關） N 反向重複前一個搜索（與 / 或 ? 有關） b 向後翻一頁 d 向後翻半頁 h 顯示幫助界面 q/ZZ 退出less 指令 u 向前滾動半頁 y 向前滾動一行 空格鍵 滾動一頁 回車鍵 滾動一行 j 下一行 k 上一行 [pagedown]： 向下翻動一頁 [pageup]： 向上翻動一頁 F 類似 tail -f 的效果，讀取寫入文件的最新內容， 按 ctrl+C 停止。 v 使用配置的編輯器進入編輯模式， shift+ZZ 保存退出到 less 查看模式。 g 移動到第一行 G 移動到最後一行 \u0026amp;pattern 僅顯示匹配模式的行，而不是整個文件 ma 使用 a 標記文本的當前位置 \u0026lsquo;a 導航到標記 a 處 :n 切換到下一個文件 :p 切換到上一個文件 基本操作 less test ","permalink":"https://sz9751210.github.io/posts/linux-less/","summary":"👨‍💻簡介 less 用途：對文件或其它輸出進行分頁顯示的工具，可查看壓縮檔 語法 less [OPTIONS] fileName 參數 參數 說明 -b \u0026lt;緩衝區大小\u0026gt; 設置緩衝區的大小 -e 當文件顯示結束後，自動離開 -f 強迫打開特殊文件，例如外圍設備代號、目錄和二進制文件 -g 只標誌最後搜索的關鍵詞 -i 忽略搜索時的大小寫 -m 顯示類似more指令的百分比 -N 顯示每行的行號 -o \u0026lt;文件名\u0026gt; 將less 輸出的內容在指定文件中保存起來 -Q 不使用警告音 -s 顯示連續空行為一行 -S 行過長時間將超出部分捨棄 -x \u0026lt;數字\u0026gt; 將「tab」鍵顯示為規定的數字空格 less模式下 用法 說明 /字符串 向下搜索「字符串」的功能 ?字符串 向上搜索「字符串」的功能 n 重複前一個搜索（與 / 或 ? 有關） N 反向重複前一個搜索（與 / 或 ? 有關） b 向後翻一頁 d 向後翻半頁 h 顯示幫助界面 q/ZZ 退出less 指令 u 向前滾動半頁 y 向前滾動一行 空格鍵 滾動一頁 回車鍵 滾動一行 j 下一行 k 上一行 [pagedown]： 向下翻動一頁 [pageup]： 向上翻動一頁 F 類似 tail -f 的效果，讀取寫入文件的最新內容， 按 ctrl+C 停止。 v 使用配置的編輯器進入編輯模式， shift+ZZ 保存退出到 less 查看模式。 g 移動到第一行 G 移動到最後一行 \u0026amp;pattern 僅顯示匹配模式的行，而不是整個文件 ma 使用 a 標記文本的當前位置 \u0026lsquo;a 導航到標記 a 處 :n 切換到下一個文件 :p 切換到上一個文件 基本操作 less test ","title":"Linux 分頁查看檔案[less]"},{"content":"👨‍💻簡介 tail 用途：印出結尾，與 head 相法的功用 語法 tail [option] [fileName] 參數 參數 說明 -n \u0026lt;行數\u0026gt; 顯示尾部 N 行的訊息 (N 為數字) -c \u0026lt;字節數\u0026gt; 顯示尾部倒數 N bytes 的字元 (N 為數字) -q 隱藏文件名 -v 顯示文件名 -f 循環讀取，持續監看最新追加的內容，常用於查閱正在改變的日誌文件。 基本操作 假設有一個檔案 tail_test 長這樣\ntest1 test2 test3 查看後 2 行 tail -n 2 head_test # output test2 test3 查看後兩個字 head -c 2 tail_test # output t3% 顯示文件名 tail -v tail_test # output ==\u0026gt; tail_test \u0026lt;== test1 test2 test3 相關指令(可選) grep sort ","permalink":"https://sz9751210.github.io/posts/linux-tail/","summary":"👨‍💻簡介 tail 用途：印出結尾，與 head 相法的功用 語法 tail [option] [fileName] 參數 參數 說明 -n \u0026lt;行數\u0026gt; 顯示尾部 N 行的訊息 (N 為數字) -c \u0026lt;字節數\u0026gt; 顯示尾部倒數 N bytes 的字元 (N 為數字) -q 隱藏文件名 -v 顯示文件名 -f 循環讀取，持續監看最新追加的內容，常用於查閱正在改變的日誌文件。 基本操作 假設有一個檔案 tail_test 長這樣\ntest1 test2 test3 查看後 2 行 tail -n 2 head_test # output test2 test3 查看後兩個字 head -c 2 tail_test # output t3% 顯示文件名 tail -v tail_test # output ==\u0026gt; tail_test \u0026lt;== test1 test2 test3 相關指令(可選) grep sort ","title":"Linux 查看結尾文字[tail]"},{"content":"👨‍💻簡介 head 用途：用來顯示開頭的文字區塊，看該檔案頭部 (預設為 10 行) 語法 head [option] [fileName] 參數 參數 說明 -n \u0026lt;行數\u0026gt; 顯示前 N 行的訊息 (N 為數字) -c \u0026lt;字節數\u0026gt; 顯示前 N bytes 的字元 (N 為數字) -q 隱藏文件名 -v 顯示文件名 基本操作 假設有一個檔案 head_test 長這樣\ntest1 test2 test3 查看前 2 行 head -n 2 head_test # output test1 test2 查看前兩個字 head -c 2 head_test # output te% 顯示文件名 head -v head_test # output ==\u0026gt; head_test \u0026lt;== test1 test2 test3 ","permalink":"https://sz9751210.github.io/posts/linux-head/","summary":"\u003ch2 id=\"簡介\"\u003e👨‍💻簡介\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003ehead\u003c/li\u003e\n\u003cli\u003e用途：用來顯示開頭的文字區塊，看該檔案頭部 (預設為 10 行)\u003c/li\u003e\n\u003c/ul\u003e","title":"Linux 查看開頭文字[head]"},{"content":"👨‍💻簡介 cat 用途：查看文件，把檔案串連接後傳到基本輸出 語法 cat [-AbeEnstTuv] [--help] [--version] fileName 參數 參數 說明 -A, \u0026ndash;show-all 等價於-vET -b, \u0026ndash;number-nonblank 和 -n 相似，只不過對於空白行不編號 -e 等價於-vE -E, \u0026ndash;show-ends 在每一行末端加入$ -n, \u0026ndash;number 由 1 開始對所有輸出的行數編號 -s, \u0026ndash;squeeze-blank 當遇到有連續兩行以上的空白行，就代換為一行的空白行 -t 等價於-vT -T, \u0026ndash;show-tabs 以^I 取代 TAB -u 輸出時不必經過緩衝區。（原來是預設為使用緩衝區）。 -v, \u0026ndash;show-nonprinting 除了 LFD 及 TAB 之外，使用^及 M-表示法顯示字元 \u0026ndash;help 列出幫助資訊 \u0026ndash;version 列出版本資訊 基本操作 查看檔案 cat test1 查看檔案並顯示行號 假設有個檔案test2長這樣\ntest1 test2 cat -n test2 # ountput 1 test1 2 3 4 test2 如果要對空白行取消編號的話可改用-b選項\ncat -b test2 # ountput 1 test1 2 test2 如果要把一行以上的空白行合併為一行可使用-s選項\ncat -s test2 # output aaa bbb ","permalink":"https://sz9751210.github.io/posts/linux-cat/","summary":"\u003ch2 id=\"簡介\"\u003e👨‍💻簡介\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003ecat\u003c/li\u003e\n\u003cli\u003e用途：查看文件，把檔案串連接後傳到基本輸出\u003c/li\u003e\n\u003c/ul\u003e","title":"Linux 查看檔案[cat]"},{"content":"👨‍💻簡介 chown(change owner) 用途：變更文件或目錄的權限 語法 chmod [OPTIONS] [user:group] file or dir 參數 參數 說明 -c, \u0026ndash;changes 效果類似-v，但僅回傳更改的部分 -f, \u0026ndash;silent, \u0026ndash;quiet 不顯示錯誤訊息 -v, \u0026ndash;verbose 顯示指令執行過程 \u0026ndash;dereference 效果和-h參數相同 -h, \u0026ndash;no-dereference 只對軟連結的文件做修改，而不更動其它任何相關文件 \u0026ndash;from=CURRENT_OWNER:CURRENT_GROUP 確認修改前的擁有者及所屬群組正確才進行修改 \u0026ndash;no-preserve-root do not treat \u0026lsquo;/\u0026rsquo; specially (the default) \u0026ndash;preserve-root fail to operate recursively on \u0026lsquo;/\u0026rsquo; \u0026ndash;reference=RFILE 把指定文件或目錄的擁有者與所屬群組全都改成和參考文件或目錄一樣 -R, \u0026ndash;recursive 遞歸處理，將指定目錄下的所有文件以及子目錄一併處理 -H if a command line argument is a symbolic link to a directory, traverse it -L traverse every symbolic link to a directory encountered -P do not traverse any symbolic links (default) 基本操作 將檔案或目錄修改擁有者 chown alan file1 將檔案或目錄修改所屬群組 chown :alangroup file1 同時修改擁有者及所屬組 chown alan:alangroup file1 遞歸修改整個資料夾裡的所有檔案 chown -R alan:alangroup dir 顯示執行結果 chown -v alan:alangroup file1 不顯示錯誤訊息 chown -f alan:alangroup file1 參考文件屬性進行修改 chown --reference=reffile file1 事先確認擁有者與群組在進行修改 chown --from=root:root alan:alangroup file1 只確認擁有者或是群組 # 只確認擁有者 chown --from=root alan:alangroup file1 # 只確認所屬組 chown --from=:root alan:alangroup file1 參考資料 Linux 更改檔案擁有者與群組，chown 指令使用教學與範例 - G. T. Wang (gtwang.org) ","permalink":"https://sz9751210.github.io/posts/linux-chown/","summary":"👨‍💻簡介 chown(change owner) 用途：變更文件或目錄的權限 語法 chmod [OPTIONS] [user:group] file or dir 參數 參數 說明 -c, \u0026ndash;changes 效果類似-v，但僅回傳更改的部分 -f, \u0026ndash;silent, \u0026ndash;quiet 不顯示錯誤訊息 -v, \u0026ndash;verbose 顯示指令執行過程 \u0026ndash;dereference 效果和-h參數相同 -h, \u0026ndash;no-dereference 只對軟連結的文件做修改，而不更動其它任何相關文件 \u0026ndash;from=CURRENT_OWNER:CURRENT_GROUP 確認修改前的擁有者及所屬群組正確才進行修改 \u0026ndash;no-preserve-root do not treat \u0026lsquo;/\u0026rsquo; specially (the default) \u0026ndash;preserve-root fail to operate recursively on \u0026lsquo;/\u0026rsquo; \u0026ndash;reference=RFILE 把指定文件或目錄的擁有者與所屬群組全都改成和參考文件或目錄一樣 -R, \u0026ndash;recursive 遞歸處理，將指定目錄下的所有文件以及子目錄一併處理 -H if a command line argument is a symbolic link to a directory, traverse it -L traverse every symbolic link to a directory encountered -P do not traverse any symbolic links (default) 基本操作 將檔案或目錄修改擁有者 chown alan file1 將檔案或目錄修改所屬群組 chown :alangroup file1 同時修改擁有者及所屬組 chown alan:alangroup file1 遞歸修改整個資料夾裡的所有檔案 chown -R alan:alangroup dir 顯示執行結果 chown -v alan:alangroup file1 不顯示錯誤訊息 chown -f alan:alangroup file1 參考文件屬性進行修改 chown --reference=reffile file1 事先確認擁有者與群組在進行修改 chown --from=root:root alan:alangroup file1 只確認擁有者或是群組 # 只確認擁有者 chown --from=root alan:alangroup file1 # 只確認所屬組 chown --from=:root alan:alangroup file1 參考資料 Linux 更改檔案擁有者與群組，chown 指令使用教學與範例 - G.","title":"Linux 修改目錄權限[chown]"},{"content":"👨‍💻簡介 幫自己紀錄一下如何處理linux機器的指標\nCPU top(交互模式) top P b x y top(預設指定CPU) top -o %CPU ps ps aux --sort -pcpu MEM top top M b x y top(預設指定MEM) top -o %MEM ps ps aux --sort -pmem swap free free -h vmstat vmstat swapon swapon -s proc_file cat /proc/swaps shell for file in /proc/*/status ; do awk \u0026#39;/VmSwap|Name/{printf $2 \u0026#34; \u0026#34; $3}END{ print \u0026#34;\u0026#34;}\u0026#39; $file; done | sort -k 2 -n -r | less 參考資料 8 Useful Commands to Monitor Swap Space Usage in Linux (tecmint.com) Linux Find Out What Process Are Using Swap Space - nixCraft (cyberciti.biz) 筆記: Linux 建立 Swap, 以及 Swap 使用狀況監控, OOM @mini box 迷你盒子 - nidBox親子盒子 Linux 查看正在吃 swap 的程式 – Tsung\u0026rsquo;s Blog (longwin.com.tw) disk df df -h du du -shc /path/* du -h -x --max-depth=1 conn netstat # 查看80 port的總連線數 netstat -na | grep 80 | wc -l # 統計連線的ip netstat -ntu | grep ESTAB | awk \u0026#39;{print $5}\u0026#39; | cut -d: -f1 | sort | uniq -c | sort -nr ","permalink":"https://sz9751210.github.io/posts/%E7%B3%BB%E7%B5%B1%E7%95%B0%E5%B8%B8%E6%8C%87%E6%A8%99%E9%99%A4%E9%8C%AF/","summary":"\u003ch2 id=\"簡介\"\u003e👨‍💻簡介\u003c/h2\u003e\n\u003cp\u003e幫自己紀錄一下如何處理linux機器的指標\u003c/p\u003e","title":"系統異常指標除錯"},{"content":"📔心得 之前因為常需要跑devops相關工具，因此開發環境完全是用Ubuntu的圖形化介面，但偶爾會遇到一些延遲以及小bug，偶然的機會下發現在windows設定git-bash似乎也能達到一樣的效果，也能順便增加對windows開發人員生態系的了解，因此本篇主要是針對如何設定美麗的terminal以及vscode也整合，紀錄一下以便日後查詢\n👨‍💻簡介 欲安裝項目\nwindows terminal git-bash zsh oh-my-zsh p10k plugins 🎯setup 安裝windows terminal 點開市集搜尋windows terminal，windows 11用戶預設已安裝\n安裝git-bash for windows 到官網下載windows版本，需注意記得打勾git-bash for windows terminal\n安裝zsh 去msys2下載zsh的二進制檔案\n解壓縮並複製zsh覆蓋到git安裝目錄\noh-my-zsh 安裝oh-my-zsh 打開git-bash輸入以下指令進行安裝\nsh -c \u0026#34;$(curl -fsSL https://raw.githubusercontent.com/ohmyzsh/ohmyzsh/master/tools/install.sh)\u0026#34; 設定預設啟動zsh 在家目錄新增.bashrc，以我的範例為C:\\Users\\alan\\.bashrc，把以下的code貼上\nif [ -t 1 ]; then exec zsh fi p10k 安裝相對應字體 這邊使用FireCode當做範例，下載好後解壓縮並安裝 🔗下載連結 \u0026ndash;\u0026gt; Nerd Fonts - Iconic font aggregator, glyphs/icons collection, \u0026amp; fonts patcher\n打開終端機並選擇設定，選擇git-bash -\u0026gt; 外觀 -\u0026gt; 字體，選擇FiraCode NF\n安裝p10k 透過git下載p10k到家目錄下\ngit clone --depth=1 https://github.com/romkatv/powerlevel10k.git ${ZSH_CUSTOM:-$HOME/.oh-my-zsh/custom}/themes/powerlevel10k 修改~/.zshrc的ZSH_THEME\n設定p10k 重新讀取zsh 設定檔\nsource ~/.zshrc 會進入p10k的樣式設定，這時候樣式都會正常，因為前面已經安裝相對應的字體，\n接著就按照說明完成樣式設定，就能開始享受在linux環境下幾乎一樣的終端機體驗🚀\n安裝插件 zsh-syntax-highlighting 語法高亮 官方安裝指南\ngit clone https://github.com/zsh-users/zsh-syntax-highlighting.git ${ZSH_CUSTOM:-~/.oh-my-zsh/custom}/plugins/zsh-syntax-highlighting 在.zshrc加入插件\nzsh-autosuggestions 自動補全 官方安裝指南\ngit clone https://github.com/zsh-users/zsh-autosuggestions ${ZSH_CUSTOM:-~/.oh-my-zsh/custom}/plugins/zsh-autosuggestions 在.zshrc加入插件\n插件都安裝好後就重載設定檔即可\n","permalink":"https://sz9751210.github.io/posts/windows-terminal-setup/","summary":"\u003ch2 id=\"心得\"\u003e📔心得\u003c/h2\u003e\n\u003cp\u003e之前因為常需要跑devops相關工具，因此開發環境完全是用Ubuntu的圖形化介面，但偶爾會遇到一些延遲以及小bug，偶然的機會下發現在windows設定git-bash似乎也能達到一樣的效果，也能順便增加對windows開發人員生態系的了解，因此本篇主要是針對如何設定美麗的terminal以及vscode也整合，紀錄一下以便日後查詢\u003c/p\u003e\n\u003ch2 id=\"簡介\"\u003e👨‍💻簡介\u003c/h2\u003e\n\u003cp\u003e欲安裝項目\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003ewindows terminal\u003c/li\u003e\n\u003cli\u003egit-bash\u003c/li\u003e\n\u003cli\u003ezsh\u003c/li\u003e\n\u003cli\u003eoh-my-zsh\u003c/li\u003e\n\u003cli\u003ep10k\u003c/li\u003e\n\u003cli\u003eplugins\u003c/li\u003e\n\u003c/ul\u003e","title":"windows terminal + git-bash + zsh + oh-my-zsh"},{"content":"📔心得 之前都介紹docker監控container，這次來點不一樣的，直接裝在k8s裡面去監控pod的一些指標。\n基本的指標像是cpu, mem, pod數量, node數量等等，都能透過kube-state-metrics完成，而如果想要監控一些流量的指標，像是tcp連線數，tw數等，則是需要另外在服務的pod裡另外寫node-exporter的container，組成side-car的形式，讓exporter將指標送往prometheus。\n在撰寫的過程，遇到比較大的難題是prometheus的config檔撰寫，一開始打算使用docker-compose的方式起monitor服務，然後去call k8s cluster取得相關指標，但常常call不到服務，可能是因為minikube的關係，在本地也跑docker，最後改成直接安裝在k8s裡面，另外建立一個namespace放監控相關的服務，有機會在測試kind以及k3s。\ndemo用的deploy使用skaffold這本地開發k8s的神器，搭配kustomize可讓我依據所需測試的環境下去做自動佈署，有機會再另外介紹這工具。\n之後預計會再新增prometheus adapter，讓我的prometheus metrics可以成為我hpa的擴縮判斷，因為基本的hpa指標只有cpu以及mem，如果可以依照網路流量變大，幫我擴展pod，當流量變小時幫我縮pod，讓我能自定義指標，相信使用k8s的效益會更大。\n🔗詳細專案位置 \u0026ndash;\u0026gt; https://github.com/sz9751210/k8s-monitor\n👨‍💻簡介 在minikube環境下安裝prometheus以及grafana監控 k8s\ndemo-deploy：測試用deployment 使用skaffold搭配kustomize的方式下去佈署 prometheus, kube-state-metrics：撈取服務相關指標 grafana：監控UI 🎯setup start minikube minikube start deploy demo-deployment cd demo-deploy \u0026amp;\u0026amp; skaffold run -p prod install monitor sh ./install_monitor.sh setting data source 使用上面執行完的grafana url http://192.168.x.x:xxx 輸入帳號密碼：admin 選擇data source -\u0026gt; add data source -\u0026gt; prometheus url設定為http://prometheus:9090 -\u0026gt; 點擊save import grafana ui 點擊左上角回到首頁並選擇旁邊的dashboard -\u0026gt; import 到grafana/dashboard/複製dashboard.json貼到grafana並點擊load -\u0026gt; import ✅TODO 使用壓測pod去測試hpa 使用prometheus-adapter自定義指標 ","permalink":"https://sz9751210.github.io/posts/k8s-monitor/","summary":"\u003ch2 id=\"心得\"\u003e📔心得\u003c/h2\u003e\n\u003cp\u003e之前都介紹docker監控container，這次來點不一樣的，直接裝在k8s裡面去監控pod的一些指標。\u003c/p\u003e\n\u003cp\u003e基本的指標像是cpu, mem, pod數量, node數量等等，都能透過kube-state-metrics完成，而如果想要監控一些流量的指標，像是tcp連線數，tw數等，則是需要另外在服務的pod裡另外寫node-exporter的container，組成side-car的形式，讓exporter將指標送往prometheus。\u003c/p\u003e\n\u003cp\u003e在撰寫的過程，遇到比較大的難題是prometheus的config檔撰寫，一開始打算使用docker-compose的方式起monitor服務，然後去call k8s cluster取得相關指標，但常常call不到服務，可能是因為minikube的關係，在本地也跑docker，最後改成直接安裝在k8s裡面，另外建立一個namespace放監控相關的服務，有機會在測試kind以及k3s。\u003c/p\u003e\n\u003cp\u003edemo用的deploy使用skaffold這本地開發k8s的神器，搭配kustomize可讓我依據所需測試的環境下去做自動佈署，有機會再另外介紹這工具。\u003c/p\u003e\n\u003cp\u003e之後預計會再新增prometheus adapter，讓我的prometheus metrics可以成為我hpa的擴縮判斷，因為基本的hpa指標只有cpu以及mem，如果可以依照網路流量變大，幫我擴展pod，當流量變小時幫我縮pod，讓我能自定義指標，相信使用k8s的效益會更大。\u003c/p\u003e\n\u003cp\u003e🔗詳細專案位置 \u0026ndash;\u0026gt; \u003ca href=\"https://github.com/sz9751210/k8s-monitor\"\u003ehttps://github.com/sz9751210/k8s-monitor\u003c/a\u003e\u003c/p\u003e","title":"K8S-monitor"},{"content":"📚讀後心得 當初在研究Elastic Stack，ILM這部份還不熟時，剛好搜尋到喬叔的鐵人賽文章，閱讀時彷彿挖到了寶，對於Index的管理講解得非常透徹，從Index如何被建立，使用Template以及Alias，再到導入ILM以及搭配Rollover以及Shrink等方式達到索引、搜尋、儲存等最佳化，一步一步穩定順利的完成，真的很感動。\n之前使用Elastic Stack並沒有使用到ILM的配置，所以單個Index可能會超過官方建議的大小，並且使用的是以一天為單位，但實務上並非每個服務都是固定的大小，因此導入ILM對於整體的效能會有更好的幫助，並且使用三溫暖架構，讓最新的log都放在效能較好的機器上，較舊的log則隨著自定義的時間轉移到效能較差的機器上，讓搜尋能有更好的體驗。\n而Rollover的使用，當資料量達到設定的條件、或是時間過太久，將Index進行rotate，產生新的Index來接收新的資料，讓原先的Index依照ILM的設定進入下一個warm phase階段。\nForce Merge以及Shrink則是針對Segment Files數量以及Shards數量進行合併達到最佳化，Segment files的單檔愈大，總數愈少，空間使用率愈好，而已刪除的文件，會是透過「標示為刪除」的方式紀錄在新的Segment File，並且會等到merge時才真正的刪除，因此Force Merge將Shard中的Segment Files進行合併，可以釋放被標記要被刪除的文件在原先是read-only的Segment File所佔用的空間，藉此提升搜尋效率，；而Shrink則是減少Shards的數量，變少的規則是原先數值的因數，減少Shard的數量，增加Shard的大小，好處是可以提升搜尋的效率，儲存利用率也會較佳，壞處是如果Cluster rebalancing時成本較高，並且會限制資料被分散處理的能力，因此建議使用在較舊的資料上下去做優化處理。\n書中還有提到很多最佳化的技巧，例如Shards建議的大小、memory cache的建議大小、Indexing大量資料時的處理方式等等，各種神奇的優化技巧可以讓你針對自己的使用情境下去做測試以及改善，讓你的Elastic Stack頭好壯壯，最後也感謝喬叔的經驗分享，讓我在研究Elastic Stack上少走了很多彎路，底下會放上鐵人賽的連結。\n🔗【喬叔帶你上手Elastic Stack】總目錄 \u0026ndash;\u0026gt; https://ithelp.ithome.com.tw/users/20129543/ironman/3148\n","permalink":"https://sz9751210.github.io/posts/%E5%96%AC%E5%8F%94%E5%B8%B6%E4%BD%A0%E4%B8%8A%E6%89%8Belastic-stackelasticsearch%E7%9A%84%E6%9C%80%E4%BD%B3%E5%AF%A6%E8%B8%90%E8%88%87%E6%9C%80%E4%BD%B3%E5%8C%96%E6%8A%80%E5%B7%A7/","summary":"\u003ch2 id=\"讀後心得\"\u003e📚讀後心得\u003c/h2\u003e\n\u003cp\u003e當初在研究Elastic Stack，ILM這部份還不熟時，剛好搜尋到喬叔的鐵人賽文章，閱讀時彷彿挖到了寶，對於Index的管理講解得非常透徹，從Index如何被建立，使用Template以及Alias，再到導入ILM以及搭配Rollover以及Shrink等方式達到索引、搜尋、儲存等最佳化，一步一步穩定順利的完成，真的很感動。\u003c/p\u003e\n\u003cp\u003e之前使用Elastic Stack並沒有使用到ILM的配置，所以單個Index可能會超過官方建議的大小，並且使用的是以一天為單位，但實務上並非每個服務都是固定的大小，因此導入ILM對於整體的效能會有更好的幫助，並且使用三溫暖架構，讓最新的log都放在效能較好的機器上，較舊的log則隨著自定義的時間轉移到效能較差的機器上，讓搜尋能有更好的體驗。\u003c/p\u003e","title":"喬叔帶你上手Elastic Stack：Elasticsearch的最佳實踐與最佳化技巧"},{"content":"👀QUICK REVIEW The book in 3 Sentences 用三段話說明這本書的內容1\n像管理公司一樣管理自己，像享受遊戲一樣享受生活 硬實力決定起點，軟實力決定能走多快多遠 Learning, Doing, Learning and Teaching Purpose of the book 書的目的\n教導你如何成為全方位的軟體開發人員 期望給你各方面有用、實用又可用的忠告。 告訴你軟技能的重要性 My Top 3 Quotes 我最喜歡的 3 句 Quotes\n越努力將船駛向失敗，從相反方向吹來的成功之風就越強 唯有讓我參與其中，才是真正的學習 信念轉成思想 思想化作文字 文字觸發行動 行動成為習慣 習慣建立價值 價值決定命運 📚讀後心得 本書不教你寫程式，教導你程式以外的實用技能，讓你知道一名成功的軟體開發人員，不能只會寫code，還要有精彩的人生。\n書中作者很系統的歸納了程序員職業發展的方方面面，包括職業目標、公司選擇、如何學習、如何理財、健康和精神、自我認知等等，或許其中的一些觀點之前都零散的接觸過，這裡作者能結合自己的經驗，將這些話題一一展開，，並且引發了我更多的思考，而這些思考，將貫穿我整個職業生涯乃至人生。\n全文總共分為如下幾個方面：\n職業：職業的各個方面，包括面試，辭職，個人創業。把自己當成一家公司看待，不過我們這家公司只為一個客戶服務，就是我們工作的單位。 自我行銷：包括行銷重要性，一致性，網絡行銷等。 學習：十步學習法。尋找導師\u0026amp;\u0026amp;成為導師。 生產力：番茄鐘，定量執行法。也從科學的角度解釋瞭如何更有生產力。 理財：觀念大多數來自其他理財書籍。例如窮爸爸富爸爸。 健身：健身重要性。以及應該用上科技工具。 心靈：講述如何保持正面心態，擁抱失敗，跳脫舒適圈。 讀這本書最有感的地方是學習的篇章，作者提出的十步驟學習法讓我印象深刻，重點如下\n要先知道全貌，有初步的了解，然後決定想學習範圍，並把大主題拆成小主題，方便設定目標。 透過設定的目標，尋找相關的資源，並建立學習計劃。 對自己的目標學習最小量的知識，足以讓接下來的實作可完成。 實作當作是玩玩具，邊動手操作邊玩邊學，儘可能讓自己所設定的目標，學習計劃都使用上，做一個小小的專題，增加對自己所學的瞭解。 把自己所學到的知識，用自己的話講出來，化輸入為輸出。 另外還有生產力那個章節，番茄鐘的使用也讓我很有共鳴，利用番茄鐘工作法，可以知道自己的生產力落在哪個範圍，畢竟我們一天的專注力有限，如何分配事情的先後順序變得更為重要。\n","permalink":"https://sz9751210.github.io/posts/soft-skills-%E8%BB%9F%E5%AF%A6%E5%8A%9B%E8%BB%9F%E9%AB%94%E9%96%8B%E7%99%BC%E4%BA%BA%E5%93%A1%E7%9A%84%E7%94%9F%E5%AD%98%E6%89%8B%E5%86%8A/","summary":"\u003ch2 id=\"quick-review\"\u003e👀QUICK REVIEW\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003eThe book in 3 Sentences 用三段話說明這本書的內容1\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e像管理公司一樣管理自己，像享受遊戲一樣享受生活\u003c/li\u003e\n\u003cli\u003e硬實力決定起點，軟實力決定能走多快多遠\u003c/li\u003e\n\u003cli\u003eLearning, Doing, Learning and Teaching\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003ePurpose of the book 書的目的\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e教導你如何成為全方位的軟體開發人員\u003c/li\u003e\n\u003cli\u003e期望給你各方面有用、實用又可用的忠告。\u003c/li\u003e\n\u003cli\u003e告訴你軟技能的重要性\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eMy Top 3 Quotes 我最喜歡的 3 句 Quotes\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e越努力將船駛向失敗，從相反方向吹來的成功之風就越強\u003c/li\u003e\n\u003cli\u003e唯有讓我參與其中，才是真正的學習\u003c/li\u003e\n\u003cli\u003e信念轉成思想 思想化作文字 文字觸發行動 行動成為習慣 習慣建立價值 價值決定命運\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e","title":"Soft Skills 軟實力｜軟體開發人員的生存手冊"},{"content":"📔心得 上次使用docker建立起ELK-stack，最近剛好在研究ansible，所以也寫了一下使用playbook的方式建立起ELK-stack。\n撰寫的過程中，先從官方文件查看安裝流程，接著再去找ansible相對應的module，在目錄結構的劃分也學習到了不少，從一開始只有一個main.yml慢慢獨立出來有一個根目錄的yml再去include task，並學會如何使用template以及vars。\n在撰寫template時，使用到了jinja2語法，直接可以套用vars，讓我的template複製進去就都載入好我要的參數，並且可以依照我的inventory動態設定我的參數，真的有夠強大。\n最後要感謝凍仁大的ansible教程，許多學習資訊都是從凍仁大的ansible git book學到的，會把網址放在下面，有興趣的可以去參考一下，寫得很簡潔明瞭，讓新手也能很快上手，尤其是使用docker-compose就能練習ansible的部份，使用jupyter notebook下去跑ansible module有夠方便。\n🔗凍仁大ansible指南 \u0026ndash;\u0026gt; 現代 IT 人一定要知道的 Ansible 自動化組態技巧\n🔗Ansible-ELK repo \u0026ndash;\u0026gt; Ansible-ELK\n👨‍💻簡介 在gcp環境下使用ansible playbook 建立elk stack\nelasticsearch：主要會先需要先跑init master，接著再去跑seed host去加入master組成cluster架構，邏輯上還有可修改的地方，目前先以兩份yaml分開跑下去做建立，在跑完init master後會先建立iim以及index template logstash：直接將pipeline等設定都複製進去 📁資料夾結構 . ├── create_elasticsearch_master_instance.yaml ├── create_elasticsearch_slave_instance.yaml ├── create_filebeat_instance.yaml ├── create_kibana_instance.yaml ├── create_logstash_instance.yaml ├── files │ ├── elasticsearch │ │ ├── api.sh │ │ ├── certs │ │ └── elasticsearch.repo │ ├── kibana │ │ └── kibana.repo │ └── logstash │ ├── conf.d │ │ └── logstash.conf │ ├── logstash.repo │ ├── logstash.yml │ └── pipelines.yml ├── group_vars │ └── all │ ├── env.yml copy.example │ └── package.yml ├── inventory │ └── elk.test.node ├── inventory.instance.create.yml.example ├── README.md ├── roles │ ├── elasticsearch │ │ ├── tasks │ │ │ ├── create_disk.yml │ │ │ ├── install_elastic.yml │ │ │ ├── main.yml │ │ │ ├── setup_disk.yml │ │ │ ├── setup_elastic_master.yml │ │ │ └── setup_elastic_slave.yml │ │ └── templates │ │ └── elasticsearch.yml.j2 │ ├── instance │ │ └── tasks │ │ ├── create.yml │ │ └── setup.yml │ ├── kibana │ │ ├── tasks │ │ │ └── main.yml │ │ └── templates │ │ └── kibana.yml.j2 │ └── logstash │ └── tasks │ └── main.yml └── vars ├── elasticsearch │ ├── elasticsearch_var.yml │ └── elasticsearch_var.yml.example ├── instance │ ├── instance_var.yml │ └── instance_var.yml.example ├── kibana │ ├── kibana_var.yml │ └── kibana_var.yml.example └── logstash ├── logstash_var.yml └── logstash_var.yml.example 🔰基礎介紹 設定機器資訊：複製好inventory.instance.create.yml.example後，可參考inventory裡的設定，主要設定gcp的資訊，elasticsearch的node_role為data_role，可參考以下連結 Elasticsearch Multi-Tier Architecture | Hot, Warm, Cold \u0026amp; Frozen\n設定group_vars的env.yml，改成自己的gcp的專案以及要設定的region\n設定vars裡的相對yml，可參考範例\nelasticsearch：主要設定掛載的硬碟資訊 kibana,logstash：設定elasticsearch的host資訊 🎯setup elasticsearch_master -\u0026gt; elasticsearch_slave -\u0026gt; logstash -\u0026gt; kibana\n指令 ANSIBLE_HOST_KEY_CHECKING=False ansible-playbook -i inventory.instance.create.yml create_xxx_instance.yaml -v ✅TODO elasticsearch playbook 優化 添加filebeat role disk 修改建置資料夾 ","permalink":"https://sz9751210.github.io/posts/ansible-elk/","summary":"\u003ch2 id=\"心得\"\u003e📔心得\u003c/h2\u003e\n\u003cp\u003e上次使用docker建立起ELK-stack，最近剛好在研究ansible，所以也寫了一下使用playbook的方式建立起ELK-stack。\u003c/p\u003e\n\u003cp\u003e撰寫的過程中，先從官方文件查看安裝流程，接著再去找ansible相對應的module，在目錄結構的劃分也學習到了不少，從一開始只有一個main.yml慢慢獨立出來有一個根目錄的yml再去include task，並學會如何使用template以及vars。\u003c/p\u003e\n\u003cp\u003e在撰寫template時，使用到了jinja2語法，直接可以套用vars，讓我的template複製進去就都載入好我要的參數，並且可以依照我的inventory動態設定我的參數，真的有夠強大。\u003c/p\u003e\n\u003cp\u003e最後要感謝凍仁大的ansible教程，許多學習資訊都是從凍仁大的ansible git book學到的，會把網址放在下面，有興趣的可以去參考一下，寫得很簡潔明瞭，讓新手也能很快上手，尤其是使用docker-compose就能練習ansible的部份，使用jupyter notebook下去跑ansible module有夠方便。\u003c/p\u003e\n\u003cp\u003e🔗凍仁大ansible指南 \u0026ndash;\u0026gt; \u003ca href=\"https://chusiang.gitbooks.io/automate-with-ansible/content/\"\u003e現代 IT 人一定要知道的 Ansible 自動化組態技巧\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e🔗Ansible-ELK repo \u0026ndash;\u0026gt; \u003ca href=\"https://github.com/sz9751210/ansible-elk\"\u003eAnsible-ELK\u003c/a\u003e\u003c/p\u003e\n\u003ch2 id=\"簡介\"\u003e👨‍💻簡介\u003c/h2\u003e\n\u003cp\u003e在gcp環境下使用ansible playbook 建立elk stack\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eelasticsearch：主要會先需要先跑init master，接著再去跑seed host去加入master組成cluster架構，邏輯上還有可修改的地方，目前先以兩份yaml分開跑下去做建立，在跑完init master後會先建立iim以及index template\u003c/li\u003e\n\u003cli\u003elogstash：直接將pipeline等設定都複製進去\u003c/li\u003e\n\u003c/ul\u003e","title":"ANSIBLE-ELK"},{"content":"👀QUICK REVIEW The book in 3 Sentences 用三段話說明這本書的內容\n為了學習而寫 闡述是最有效的學習方法 簡要記述內容中提出的主要想法，而不是蒐集引文，並努力思考與其他不同內容的想法連結再一起 Purpose of the book 書的目的\n提供大腦一個外部記憶體去儲存細節與參考資料，讓大腦能專注在發揮創造力與深入的學習 透過原子性將多個重點的大筆記拆解成像是卡片一樣的小筆記 具有連結性，將各個小筆記的點透過關聯性連結成大筆記 My Top 3 Quotes 我最喜歡的 3 句 Quotes\n如果你無法清楚地說出來，你就無法真正的理解 人必須要找出想法的不同之處，掌握其中的差異，不管這些差異式很明顯可見，還是隱藏在概念裡 正確的學習代表的是理解，而理解是指用有意義的方式，連接到已知的知識 📚讀後心得 《 卡片盒筆記：最高效思考筆記術，德國教授超強秘技，促進寫作、學習與思考，使你洞見源源不斷，成為專家 》\n從以前做筆記都是使用資料夾的分類邏輯，接著會碰到如果一篇筆記有兩種以上的概念時，要如何去分類，這問題也是困擾了我很久，在網路上搜尋筆記法，剛好看到obsidian這套軟體，他裏面的反向連結功能真的太強大了，讓我能透過索引的方式去整理我的筆記，讓我的大腦可以更專注在眼前的任務上，也很感謝朱騏老師，在鐵人邦的obsidian系列文幫助了我很多，讓我做筆記有很多的改變，連結我會放在最下面。\n這本書讀完後，讓我對於卡片盒筆記法有更深入的瞭解，這本書不僅僅是教導做筆記的方法，而是一個完整的思考、工作流程和有效學習的方法。\n書中有提到蔡加尼克效應：還未完成的工作項目，會佔據我們的短期記憶，直到完成為止。\n要讓我們的大腦停止去想某件工作，不用等到那件工作做完，只要把他們記下來，並讓自己想像「我會去處理」，這樣大腦就會停止去想它了。\n因為大腦無法區別真正已做完以及未完成的事，如果把某件事記下來，就可以把它從大腦中清除掉。讓一個外部系統去儲存那些還沒做完的事情。\n現在做的筆記，觀眾是未來的自己，因為筆記做完不久，就會回到一無所知的狀態，要表達清楚給未來的自己，就需要真正的理解。\n而如何以有意義的方式，將某個訊息連接到其他訊息？\n第一步是思考某訊息，並把他寫出來，接著是思考這個訊息跟其他脈絡有甚麼關聯性。\n大腦與卡片盒的分工，負責細節與參考資料，確保資料保持客觀完整，讓大腦能夠專注在重要的事情上，而大腦負責自由發揮創造力，更深入的學習與整體性的規劃。\n而卡片盒的用意是，問這張卡片的意義為何？為何連接到某事？跟某事差異？它跟甚麼類似？\n只要連結合理，卡片就能彼此連結，所以卡片盒並不是根據主題分類。\n書中還提到過度井然有序會妨礙學習\n書中舉了教導學生認識不同的藝術風格，首先用傳統的方式，把屬於相同藝術風格的多幅繪畫展示給一組學生看，接著刻意打亂藝術風格給另一組學生看，結果反而是各種不同風格繪畫。\n混在一起的那一組學生，更快學會如何分辨不同的藝術風格。這顯示了與其用主題分類，不如表達清楚各種差異和相同之處，強化規類的能力以及創造合理的分類能力。\n本書搭配obsidian真的是一個完美的搭配，很感謝作者以身作則應用卡片盒筆記法的智慧結晶產出此書。\n🔗【Obsidian 使用教學】總目錄 \u0026ndash;\u0026gt; https://reurl.cc/NRZ9bx\n","permalink":"https://sz9751210.github.io/posts/%E5%8D%A1%E7%89%87%E7%9B%92%E7%AD%86%E8%A8%98%E6%9C%80%E9%AB%98%E6%95%88%E6%80%9D%E8%80%83%E7%AD%86%E8%A8%98%E8%A1%93%E5%BE%B7%E5%9C%8B%E6%95%99%E6%8E%88%E8%B6%85%E5%BC%B7%E7%A7%98%E6%8A%80%E4%BF%83%E9%80%B2%E5%AF%AB%E4%BD%9C%E5%AD%B8%E7%BF%92%E8%88%87%E6%80%9D%E8%80%83%E4%BD%BF%E4%BD%A0%E6%B4%9E%E8%A6%8B%E6%BA%90%E6%BA%90%E4%B8%8D%E6%96%B7%E6%88%90%E7%82%BA%E5%B0%88%E5%AE%B6/","summary":"\u003ch2 id=\"quick-review\"\u003e👀QUICK REVIEW\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003eThe book in 3 Sentences 用三段話說明這本書的內容\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e為了學習而寫\u003c/li\u003e\n\u003cli\u003e闡述是最有效的學習方法\u003c/li\u003e\n\u003cli\u003e簡要記述內容中提出的主要想法，而不是蒐集引文，並努力思考與其他不同內容的想法連結再一起\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003ePurpose of the book 書的目的\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e提供大腦一個外部記憶體去儲存細節與參考資料，讓大腦能專注在發揮創造力與深入的學習\u003c/li\u003e\n\u003cli\u003e透過原子性將多個重點的大筆記拆解成像是卡片一樣的小筆記\u003c/li\u003e\n\u003cli\u003e具有連結性，將各個小筆記的點透過關聯性連結成大筆記\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eMy Top 3 Quotes 我最喜歡的 3 句 Quotes\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e如果你無法清楚地說出來，你就無法真正的理解\u003c/li\u003e\n\u003cli\u003e人必須要找出想法的不同之處，掌握其中的差異，不管這些差異式很明顯可見，還是隱藏在概念裡\u003c/li\u003e\n\u003cli\u003e正確的學習代表的是理解，而理解是指用有意義的方式，連接到已知的知識\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e","title":"卡片盒筆記：最高效思考筆記術，德國教授超強秘技，促進寫作、學習與思考，使你洞見源源不斷，成為專家"},{"content":"📔心得 一直以來都在使用container下去跑測試環境，所以都是使用docker指令下去做除錯，最近因緣際會下找到這一款可以透過UI看全部的container狀態，真的覺得好用到爆炸，所以來介紹一下這款容器化管理神器。\n基本上能用docker指令做到的事情，portainer都能做到，像是docker ps，查看所有container，接著點擊某個container，就會顯示基本的container訊息。裡面能針對這個container查看logs，inspect，stat等等，功能非常齊全。 我自己最常使用的就是docker logs，透過UI可以直接點擊Logs查看，方便很多。\n依照類型也會分出stack，container，image，network，volume等等，都可各別下去做新增，查看與管理，有時候東西建了忘記刪，這邊會顯示unused，打勾後就能一鍵移除。\nportainer從拉image到deploy container都能透過ui完成，對於更新版本也是很有一套，可以透過設定pull latest並點擊recreate進行container的更新，對於常常使用container測試者真的是一大福音。\n👨‍💻簡介 portainer主要讓我們能有個UI介面管理我們的docker，對於初學docker指令不太熟的使用者能快速進入docker的世界，並且可從docker hub一鍵拉取image，設定network、volume等進行快速部署，都可藉由portainer完成。 🎯setup 透過docker-compose.yml建立portainer 建立docker-compose.yml # docker-compose.yml version: \u0026#34;3\u0026#34; services: portainer: image: portainer/portainer-ce volumes: - /var/run/docker.sock:/var/run/docker.sock - portainer_data:/data ports: - 9000:9000 container_name: portainer volumes: portainer_data: {} 執行docker-compose up -d\n設定系統管理員 finish 🔰基礎介紹(本地環境) 1. Dashboard 上面的Environment info為當前本地的系統環境基本資訊 6 core cpu 8.3 ram docker版本為20.10.17 URL為我掛載的docker.sock路徑 底下為當前所有的docker配置 2. Stacks 使用docker-compose起的就會形成一個stack，可顯示當前所跑的stack list，以及這個stack跑的container資訊 如果要自己新增stack可點擊Add stack把自己寫好的docker-compose.yml貼上去並按下Deploy the stack即可建立。 3. Containers 可針對container做啟動停止暫停刪除等等的基本操作，在list介面可顯示當前所有container的基礎資訊。Quick Actions從左到右分別為Logs、Inspect、Stats、Exec Console、Attach Console Logs：方便查看當前container log狀況 Inspect：跟docker inspect一樣，但可視程度較高，有轉成樹狀結構 Stats：可查看cpu、mem、network等使用率，以及顯示當前使用了哪些進程 Exec Console：一鍵進入容器內操作 新增container的方式也是很簡單，透過Add container之後設定image的基本設定即可成功建立container，底下也可設定volume、network等等。 4. Images 這邊最上面可直接輸入image name做pull image的動作，下面則是顯示當前本地所有的images，對於沒再使用的image這邊會顯示Unused真的方便許多，一鍵即可移除，點擊進去可看到image的基本資訊，並且能顯示image layers，對於自己撰寫dockerfile幫助很大。 如果要自己建立image可點擊Build a new image，將自己寫的dockerfile貼上去建立image。 ","permalink":"https://sz9751210.github.io/posts/portainer-intro/","summary":"\u003ch2 id=\"心得\"\u003e📔心得\u003c/h2\u003e\n\u003cp\u003e一直以來都在使用container下去跑測試環境，所以都是使用docker指令下去做除錯，最近因緣際會下找到這一款可以透過UI看全部的container狀態，真的覺得好用到爆炸，所以來介紹一下這款容器化管理神器。\u003c/p\u003e\n\u003cp\u003e基本上能用docker指令做到的事情，portainer都能做到，像是docker ps，查看所有container，接著點擊某個container，就會顯示基本的container訊息。裡面能針對這個container查看logs，inspect，stat等等，功能非常齊全。\n我自己最常使用的就是docker logs，透過UI可以直接點擊Logs查看，方便很多。\u003c/p\u003e\n\u003cp\u003e依照類型也會分出stack，container，image，network，volume等等，都可各別下去做新增，查看與管理，有時候東西建了忘記刪，這邊會顯示unused，打勾後就能一鍵移除。\u003c/p\u003e\n\u003cp\u003eportainer從拉image到deploy container都能透過ui完成，對於更新版本也是很有一套，可以透過設定pull latest並點擊recreate進行container的更新，對於常常使用container測試者真的是一大福音。\u003c/p\u003e\n\u003ch2 id=\"簡介\"\u003e👨‍💻簡介\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003eportainer主要讓我們能有個UI介面管理我們的docker，對於初學docker指令不太熟的使用者能快速進入docker的世界，並且可從docker hub一鍵拉取image，設定network、volume等進行快速部署，都可藉由portainer完成。\u003c/li\u003e\n\u003c/ul\u003e","title":"Portainer：一款圖形化容器管理工具"},{"content":"簡介 因常會在新機器跑container，藉此紀錄安裝過程，順便寫下腳本安裝懶人包 安裝docker 檢查系統中是否已經安裝了docker 執行：ps -ef |grep docker\n如上圖所示，說明系統中並沒有安裝docker\n添加docker-ce倉庫 安裝yum倉庫管理工具 sudo yum update -y sudo yum install -y yum-utils 配置docker yum源 sudo yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo\t安裝docker engine sudo yum install docker-ce docker-ce-cli containerd.io docker-compose-plugin 啟動docker \u0026amp;\u0026amp; 設置開機啟動docker sudo systemctl start docker.service sudo systemctl enable docker.service 安裝docker-compose Install Docker Compose CLI plugin | Docker Documentation\n透過curl下載docker-compose COMPOSE_VERSION=$(curl -s https://api.github.com/repos/docker/compose/releases/latest | grep \u0026#39;tag_name\u0026#39; | cut -d\\\u0026#34; -f4) sh -c \u0026#34;curl -L https://github.com/docker/compose/releases/download/${COMPOSE_VERSION}/docker-compose-`uname -s`-`uname -m` \u0026gt; /usr/local/bin/docker-compose\u0026#34; 將docker-compose變成可執行檔 chmod +x /usr/local/bin/docker-compose 建立連結 ln -s /usr/local/bin/docker-compose docker-compose 確認是否安裝成功 docker-compose -v 腳本自動化安裝docker \u0026amp;\u0026amp; docker-compose #!/bin/bash # ----- Install docker ----- # echo \u0026#34;install docker\u0026#34; sudo yum update -y sudo yum install -y yum-utils sudo yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo sudo yum install docker-ce docker-ce-cli containerd.io docker-compose-plugin # start \u0026amp; enable docker.service sudo systemctl start docker.service sudo systemctl enable docker.service # ----- Install docker-compose ----- # echo \u0026#34;install docker-compose\u0026#34; # get latest docker compose released tag COMPOSE_VERSION=$(curl -s https://api.github.com/repos/docker/compose/releases/latest | grep \u0026#39;tag_name\u0026#39; | cut -d\\\u0026#34; -f4) sudo curl -L \u0026#34;https://github.com/docker/compose/releases/download/${COMPOSE_VERSION}/docker-compose-$(uname -s)-$(uname -m)\u0026#34; -o /usr/local/bin/docker-compose sudo chmod +x /usr/local/bin/docker-compose sudo ln -s /usr/local/bin/docker-compose /usr/bin/docker-compose # Output compose version docker-compose --version exit 0 ","permalink":"https://sz9751210.github.io/posts/centos-%E5%AE%89%E8%A3%9Ddocker-%E5%92%8C-docker-compose/","summary":"\u003ch2 id=\"簡介\"\u003e簡介\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e因常會在新機器跑container，藉此紀錄安裝過程，順便寫下腳本安裝懶人包\u003c/li\u003e\n\u003c/ul\u003e","title":"CentOS 安裝docker 和 docker-compose"},{"content":"📔心得 因最近在研究elk-stack，藉此紀錄一下使用docker-compose建立起elk-stack的架構，在建立的過程中，比較多遇到的是記憶體使用率的配置不足，導致容器無法成功啟動，或是config檔權限的問題，因此在filebeat的部分會直接把config檔放進去並改成root權限。\n之後希望能再增加logstash的pipeline功能，在實務上可多個服務做篩選，以及elasticsearch的資料安全性配置SSL和叢集架構，並導入ILM做log的空間管理。\n監控的部分則是拿之前做的小專案直接套用並呈現，所以整體流程大致上差不多，多了個elasticsearch_exporter，可查看更多elasticsearch的整體狀況，例如index、shard的數量，資料大小，寫入速率等等。\n🔗詳細專案位置 \u0026ndash;\u0026gt; ELFK-stack-monitor\n👨‍💻簡介 🔰ELFK-stack：使用docker-compose建立起elk-stack的架構，主要先從alpine產生假資料並存到filebeat讀取的資料夾，接著filebeat將資料送往logstash，在實務上，會在logstash做filter的功能(未來會新增)，接著送到elasticsearch存起來，並透過kibana的ui下去做搜尋所需的log資料。\n🔰Monitor：使用cadvisor監控所有容器以及elasticsearch_exporter監控elasticsearch的狀態，並把資料送到prometheus儲存起來，最後透過grafana的ui呈現。\n🔰基礎介紹 ⚙️ELFK-stack : alpine+filebeat(送資料) -\u0026gt; logstash(filter) -\u0026gt; elasticsearch(db) -\u0026gt; kibana(ui)\n⚙️Monitor : cadvisor,elasticsearch_exporter(monitor) -\u0026gt; prometheus(db) -\u0026gt; grafana(ui)\n🎯setup 使用docker-compose啟動服務 sudo docker-compose up -d 進到localhost:5601按照以下圖示設定index pattern 可進到localhost:3000查看grafana dashboard，帳密都為admin container-dashboard **\relasticsearch-dashboard ✅TODO 新增log filter 添加ssl cluster架構的elastic ","permalink":"https://sz9751210.github.io/posts/elfk-stack-monitor/","summary":"\u003ch2 id=\"心得\"\u003e📔心得\u003c/h2\u003e\n\u003cp\u003e因最近在研究elk-stack，藉此紀錄一下使用docker-compose建立起elk-stack的架構，在建立的過程中，比較多遇到的是記憶體使用率的配置不足，導致容器無法成功啟動，或是config檔權限的問題，因此在filebeat的部分會直接把config檔放進去並改成root權限。\u003c/p\u003e\n\u003cp\u003e之後希望能再增加logstash的pipeline功能，在實務上可多個服務做篩選，以及elasticsearch的資料安全性配置SSL和叢集架構，並導入ILM做log的空間管理。\u003c/p\u003e\n\u003cp\u003e監控的部分則是拿之前做的小專案直接套用並呈現，所以整體流程大致上差不多，多了個elasticsearch_exporter，可查看更多elasticsearch的整體狀況，例如index、shard的數量，資料大小，寫入速率等等。\u003c/p\u003e\n\u003cp\u003e🔗詳細專案位置 \u0026ndash;\u0026gt; \u003ca href=\"https://github.com/sz9751210/ELFK-stack-monitor\"\u003eELFK-stack-monitor\u003c/a\u003e\u003c/p\u003e\n\u003ch2 id=\"簡介\"\u003e👨‍💻簡介\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e🔰ELFK-stack：使用docker-compose建立起elk-stack的架構，主要先從alpine產生假資料並存到filebeat讀取的資料夾，接著filebeat將資料送往logstash，在實務上，會在logstash做filter的功能(未來會新增)，接著送到elasticsearch存起來，並透過kibana的ui下去做搜尋所需的log資料。\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e🔰Monitor：使用cadvisor監控所有容器以及elasticsearch_exporter監控elasticsearch的狀態，並把資料送到prometheus儲存起來，最後透過grafana的ui呈現。\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e","title":"ELFK-stack-monitor"},{"content":"👨‍💻簡介 🔰ELFK-stack：使用docker-compose建立起tick-stack的架構，撈取的指標從config/telegraf.conf設定，並送往influxdb從起來，chronograf為ui介面，查看撈取的時間序列指標狀態，最後kapacitor則是處理告警的部分．\n流程 ⚙️TICK-stack : telrgraf(送資料) -\u0026gt; influxdb(存資料) -\u0026gt; chronograf(ui) -\u0026gt; kapacitor(alert) 環境建置 本篇github repo在此 -\u0026gt; TICK_Stack-tutorial\ntelegraf設定 使用telegraf.conf設定輸出資料庫\n[[outputs.influxdb]] urls = [\u0026#34;http://influxdb:8086\u0026#34;] database = \u0026#34;telegraf\u0026#34; # 要使用的資料庫 username = \u0026#34;admin\u0026#34; password = \u0026#34;admin\u0026#34; influxdb設定 使用configuration.env設定帳密以及資料庫\n# InfluxDB options INFLUXDB_DB=telegraf INFLUXDB_ADMIN_USER=admin INFLUXDB_ADMIN_PASSWORD=admin kapacitor設定 使用kapacitor.conf\n設定讀取的資料庫 [[influxdb]] enabled = true name = \u0026#34;telegraf\u0026#34; default = false urls = [\u0026#34;http://influxdb:8086\u0026#34;] username = \u0026#34;admin\u0026#34; password = \u0026#34;admin\u0026#34; 設定告警telegram [telegram] enabled = true url = \u0026#34;https://api.telegram.org/bot\u0026#34; token = \u0026#34;bot-token\u0026#34; 啟動環境 docker-compose up 接著去本地chronograf http://IP:8888 設定influxdb以及kapacitor\nhttp:// IP :8086 for influxdb http:// IP :9092 for kapacitor 告警設計 參考cpu_alert.tick.example\n使用告警 透過kapacitor cd /var/lib/kapacitor # cpu_alert為任務task_id # 定義任務 kapacitor define cpu_alert -tick cpu_alert.tick -type stream -dbrp telegraf.autogen # 啟動任務 kapacitor enable cpu_alert # 停止任務 kapacitor disable cpu_alert # 刪除任務 kapacitor delete tasks cpu_alert # 列出所有任務 kapacitor list tasks 透過chronograf 選到左邊的alerting -\u0026gt; write TICKscript 輸入task_id -\u0026gt; 把script貼上 -\u0026gt; 選擇類型為stream -\u0026gt; 選擇db -\u0026gt; 按下儲存後下方會判斷script是否正常 完成後可回到manage task管理當前task 可透過點擊enabled下方圓點一鍵啟動/停用任務 alert history可查看告警訊息\ngreen:OK white:INFO,WARN red:CRIT ============================\n查看alert寫回db訊息 參考資料 https://github.com/sz9751210/docker-telegraf-influx-grafana-stack https://www.influxdata.com/time-series-platform/kapacitor/ https://tanjiti.github.io/2018/12/18/%E5%BC%80%E6%BA%90kapacitor%E6%93%8D%E4%BD%9C%E6%89%8B%E5%86%8C/ ","permalink":"https://sz9751210.github.io/posts/tick-stack-tutorial/","summary":"\u003ch2 id=\"簡介\"\u003e👨‍💻簡介\u003c/h2\u003e\n\u003cp\u003e🔰ELFK-stack：使用docker-compose建立起tick-stack的架構，撈取的指標從config/telegraf.conf設定，並送往influxdb從起來，chronograf為ui介面，查看撈取的時間序列指標狀態，最後kapacitor則是處理告警的部分．\u003c/p\u003e\n\u003ch2 id=\"流程\"\u003e流程\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e⚙️TICK-stack : telrgraf(送資料) -\u0026gt; influxdb(存資料) -\u0026gt; chronograf(ui) -\u0026gt; kapacitor(alert)\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"環境建置\"\u003e環境建置\u003c/h2\u003e\n\u003cp\u003e本篇github repo在此 -\u0026gt;  \u003ca href=\"https://github.com/sz9751210/TICK_Stack-tutorial\"\u003eTICK_Stack-tutorial\u003c/a\u003e\u003c/p\u003e","title":"TICK-Stack-tutorial"},{"content":"Python 基本語法 python 語法的後綴名是以.py 結尾 python 執行方式 使用交互介面執行 使用 python test.py 命令執行 使用./test.py 執行 python 標示符 以單下劃線開頭的屬性，表示是類的私有屬性(包括方法，變量)。如:_foo表示不能直接訪問的類屬性。 以雙下劃線開頭的 __foo 代表類的私有成員； 以雙下劃線開頭和結尾的 __foo__ 代表 Python 里特殊方法專用的標識，如 __init__() 代表類的構造函數。 換行縮進 python 不使用{}來控制 code 範圍，而使用縮進來控制。一般都使用四個空格做縮進(PEP8規定)。 #!/usr/bin/python # -*- coding: UTF-8 -*- print \u0026#34;hello world\u0026#34;; if True: print(\u0026#34;Answer:\u0026#34;); print(\u0026#34;true\u0026#34;); else: print(\u0026#34;Answer:\u0026#34;); # 沒有嚴格縮進，在執行時會報錯 print(\u0026#34;false\u0026#34;); python 引號 Python 可以使用引號(')、雙引號(\u0026quot;)、三引號( ''' 或 \u0026quot;\u0026quot;\u0026quot; ) 來表示字符串。 三引號(\u0026quot;\u0026quot;\u0026quot;)可以由多行組成，是編寫多行文本的快捷語法，常用於文檔字符串。 # 單引號以及雙引號 \u0026#39;This is a string\u0026#39; \u0026#34;This is a string\u0026#34; # 引號包含引號 \u0026#34;We call it \u0026#39;Dog\u0026#39;...... \u0026#34; # 雙引號內可包含單引號 \u0026#39;We call it \u0026#34;Dog\u0026#34;...... \u0026#39; # 單引號內可包含雙引號 # 三雙引號可直接換行 \u0026#34;\u0026#34;\u0026#34;haha, this is a dog.\u0026#34;\u0026#34;\u0026#34; # 三單引號需要換行符 \u0026#39;\u0026#39;\u0026#39;haha, \\ this is a dog.\u0026#39;\u0026#39;\u0026#39; python 注釋 python 中單行註釋採用#開頭 python 中多行註釋使用三個單引號(''')或三個雙引號(\u0026quot;\u0026quot;\u0026quot;) 多行註釋通常用來為 Python 文件、模塊、類或者函數等添加版權或者功能描述信息。 # 單行 # 註釋內容 # 多行 \u0026#39;\u0026#39;\u0026#39;(\u0026#34;\u0026#34;\u0026#34;) 使用 3 個單引號分別作為註釋的開頭和結尾 可以一次性註釋多行內容 這裡面的內容全部是註釋內容 \u0026#39;\u0026#39;\u0026#39;(\u0026#34;\u0026#34;\u0026#34;) Python 空行 函數之間或 class 的方法之間用空行分隔，表示一段新的代碼的開始。class 和函數入口之間也用一行空行分隔，以突出函數入口的開始。 多個語句組成的代碼組 縮進相同的一組語句構成一個代碼塊，我們稱之代碼組。 子句: 像 if、while、def 和 class 這樣的複合語句，首行以關鍵字開始，以冒號( : )結束，該行之後的一行或多行代碼構成代碼組。 if expression: suite elif expression: suite else: suite python 變量類型 變量可以指定不同的數據類型，這些變量可以存儲整數，小數或字符。 python 變量賦值 變量賦值不需要聲明類型，變數的資料型別將根據分配給它的值的型別自動來定義。 每個變量在使用前必須賦值，變量賦值以後該變量才會被創建 不可以取保留字 只能由大小寫字母、數字、 _ 、 中文組成變數名稱 英文字母大小寫視為不同的變數名稱 counter = 100 # 賦值整型變量 miles = 1000.0 # 浮點型 name = \u0026#34;alan\u0026#34; # 字符串 print(count), print(miles), print(name); 多變量賦值，變數之間用，分隔 # 2 被分配給 x，4.124 被分配給 y，字串 Python 被分配給 z。 x, y, z = 2, 4.124, \u0026#34;Python\u0026#34; # 三個變數都是Blue x = y = z = \u0026#34;Blue\u0026#34; 刪除變數 del x python 資料型態 數值型態： int float bool 字串型態： str chr 容器型態： list dict tuple Python 基本的純量類型 整數（int） 浮點數（float） 文字（str） 布林（bool） None（NoneType） 整數和浮點數 整數與浮點數使用數學運算符號進行運算 會搭配運算符號進行運算 + 、 - 、 * 、 / ：加減乘除 ** ：次方 % ：回傳餘數 // ：回傳商數 字串 我們使用成雙的單引號 \u0026rsquo;\u0026rsquo; 或成對的雙引號 \u0026quot;\u0026quot; 來建立文字類型 如果建立的字串有包含不成對的引號，則需要使用跳脫字元\\來完成宣告 python 格式化字串 %-formatting print(\u0026#34;I am %s.%s\u0026#34;%(\u0026#34;Alan\u0026#34;,\u0026#34;wang\u0026#34;)) # output I am Alan.wang str.format()（Python 2.6+） # 基本使用 s = \u0026#39;I am {first_name} {middle_name}. {last_name}\u0026#39; print(s.format(first_name=\u0026#39;Monkey\u0026#39;, middle_name=\u0026#39;D\u0026#39;, last_name=\u0026#39;Luffy\u0026#39;)) # output I am Monkey D. Luffy # 調整輸出樣式：^(居中）、\u0026lt;（向左對齊）、\u0026gt;（向右對齊） print(\u0026#39;{:^10s}\u0026#39;.format(\u0026#39;a\u0026#39;)) # ^：居中對齊，10：寬度為10，s：以string輸出 # output a # 以 {:,} 的方式以逗號分隔數字 print(\u0026#39;{:,}\u0026#39;.format(100000000)) # output 100,000,000 f-string（Python 3.6+） # variables first_name = \u0026#34;Monkey\u0026#34; middle_name = \u0026#34;D\u0026#34; last_name = \u0026#34;Luffy\u0026#34; # f-string f\u0026#34;I am {first_name} {middle_name}. {last_name}\u0026#34; # Output: \u0026#34;I am Monkey D. Luffy\u0026#34; 布林 進行判斷條件或者資料篩選的時候會需要仰賴布林（bool），布林只有 True 與 False 這兩個值。 print(type(True)) print(type(False)) Python（或者絕大多數的程式語言）對於英文的大小寫是敏感的（case-sensitive），像是 True 會被識別為布林，但是 TRUE 或者 true 則會被視作物件名稱。 # recognized as bool print(type(True)) print(type(False)) # recognized as object names print(type(true)) print(type(TRUE)) print(type(false)) print(type(FALSE)) True 跟數值 1 相等； False 跟數值 0 相等。如果在數值運算中納入了布林不會產生任何問題。 print(True == 1) # output：True print(False == 0) # output：True print(1 + True) # output：2 print(1 + False) # output：1 判斷條件簡介 == 、 !=：等於以及不等於 \u0026gt; 、 \u0026gt;= 、 \u0026lt; 、 \u0026lt;=：大於、大於等於、小於以及小於等於 is 、 is not：是否為相同的值與類型 and 、 or：交集與聯集 not：非 in ：是否存在於 None None 是所謂的無值，或者可以用 NA 值（Not Available）或 NaN 值（Not a Number）去體會它 None 是無回傳值函數中的預設輸出值、也是搜索特徵函數找不到情況下的預設輸出值 # 宣告了一個只有 pass 保留字內容的 hello_world() 函數，這就是一個所謂的無回傳值函數 def hello_world(): pass print(hello_world()) # output：None print(type(hello_world())) # output：\u0026lt;class \u0026#39;NoneType\u0026#39;\u0026gt; 判斷純量類型的函數 使用 isinstance(x, classinfo) 函數判斷純量類型，其中 x 輸入物件名稱、 classinfo 輸入類型名稱。 # 判斷是否為整數 print(isinstance(87, int)) # output：True print(isinstance(\u0026#34;87\u0026#34;, int)) # output：False # 判斷是否為浮點數 print(isinstance(87.0, float)) # output：True print(isinstance(87, float)) # output：False # 判斷是否為文字 print(isinstance(\u0026#34;True\u0026#34;, str)) # output：True print(isinstance(True, str)) # output：False # 判斷是否為布林 print(isinstance(False, bool)) # output：True print(isinstance(\u0026#34;False\u0026#34;, bool)) # output：False # 判斷是否為 None print(isinstance(None, type(None))) # output：True print(isinstance(\u0026#34;None\u0026#34;, type(None))) # output：False 使用 type()函數回傳純量類型 my_int = 87 my_float = 8.7 my_str = \u0026#34;Hello Python\u0026#34; bool_true = True bool_false = False none_type = None print(type(my_int)) print(type(my_float)) print(type(my_str)) print(type(bool_true)) print(type(bool_false)) print(type(none_type)) # output ## \u0026lt;class \u0026#39;int\u0026#39;\u0026gt; ## \u0026lt;class \u0026#39;float\u0026#39;\u0026gt; ## \u0026lt;class \u0026#39;str\u0026#39;\u0026gt; ## \u0026lt;class \u0026#39;bool\u0026#39;\u0026gt; ## \u0026lt;class \u0026#39;bool\u0026#39;\u0026gt; ## \u0026lt;class \u0026#39;NoneType\u0026#39;\u0026gt; python 類型轉換 純量轉換 使用與目標轉換類型同名的函數轉換純量類型。\nint()：轉換純量為整數類型 float()：轉換純量為浮點數類型 bool()：轉換純量為布林類型，除了 0 以外的數字都是True str()：轉換純量為文字類型 # 轉換成整數 print(int(8.7)) print(int(True)) print(int(False)) print(int(\u0026#34;87\u0026#34;)) # output 8 1 0 87 # 轉換成浮點數 print(float(87)) print(float(True)) print(float(False)) print(float(\u0026#34;87\u0026#34;)) # output 87.0 1.0 0.0 87.0 # 轉換成布林 print(bool(0)) print(bool(0.0)) print(bool(1)) print(bool(1.0)) print(bool(8.7)) print(bool(-8.7)) # output False False True True True True # 轉換成字串 print(str(87)) print(str(87.0)) print(str(True)) print(str(False)) # output 87 87.0 True False python 運算符 算數運算符 x=5, y=2\n運算符 名稱 範例 + 加法 x + y = 7 - 減法 x - y = 3 * 乘法 x * y = 10 / 除法 x / y = 2.5 % 取餘數 x % y = 1 ** 指數 x ** y = 25 // 取整除 x // y = 2 + 與 * 也可用於字串 (string) ， + 用於字串相接， * 用於複製字串\na = \u0026#34;a\u0026#34; b = a + \u0026#34;b\u0026#34; # 字串連接， b 會等於 \u0026#34;ab\u0026#34; c = a * 3 # 字串重複三倍， c 會等於 \u0026#34;aaa\u0026#34; 賦值運算符 x = 5 = 0101 , 3 = 0011\n運算符 名稱 範例 解答 = 賦值 x = 5 x = 5 += 加法賦值 x += 3 \u0026mdash;\u0026gt; x = x + 3 x = 8 -= 減法賦值 x -= 3 \u0026mdash;\u0026gt; x = x - 3 x = 2 *= 乘法賦值 x * = 3 \u0026mdash;\u0026gt; x = x * 3 x = 15 /= 除法賦值 x /= 3 \u0026mdash;\u0026gt; x = x / 3 x = 1.666\u0026hellip; %= 取餘賦值 x %= 3 \u0026mdash;\u0026gt; x = x % 3 x = 2 //= 取整除賦值 x //= 3 \u0026mdash;\u0026gt; x = x // 3 x = 1 **= 指數賦值 x **= 3 \u0026mdash;\u0026gt; x = x ** 3 x = 125 \u0026amp;= AND 賦值 x \u0026amp;= 3 \u0026mdash;\u0026gt; x = x \u0026amp; 3 x = 1 = 0001 |= OR 賦值 x |= 3 \u0026mdash;\u0026gt; x = x | 3 x = 7 = 0111 ^= XOR 賦值 x ^= 3 \u0026mdash;\u0026gt; x = x ^ 3 x = 6 = 0110 \u0026raquo;= 右移賦值 x \u0026raquo;= 3 \u0026mdash;\u0026gt; x = x \u0026raquo; 3 x = 0 = 0000 = 5 * 1/2**3 = 5/8 \u0026laquo;= 左移賦值 x \u0026laquo;= 3 \u0026mdash;\u0026gt; x = x \u0026laquo; 3 x = 40 = 0010 1000 = 5 * 2**3 = 5 * 8 比較運算符 運算符 名稱 範例 == 相等 x == y != 不相等 x != y \u0026gt; 大於 x \u0026gt; y \u0026lt; 小於 x \u0026lt; y \u0026gt;= 大於等於 x \u0026gt;= y \u0026lt;= 小於等於 x \u0026lt;= y 邏輯(布林)運算符 x = 4\n運算符 名稱 範例 and 與運算 - 兩者為 True，返回 True x \u0026lt; 5 and x \u0026lt; 10 \u0026mdash;\u0026gt; True or 或運算 - 其中一者為 True，返回 True x \u0026lt; 5 or x \u0026lt; 4 \u0026mdash;\u0026gt; True not 非運算 - 兩者為 Faluse，返回 True not(x \u0026lt; 5 and x \u0026lt; 10) \u0026mdash;\u0026gt; False 身分運算符 運算符 描述 範例 is 如果兩個變量是同一個對象(具有相同的記憶體位置)，則返回 True x is y is not 如果兩個變量不是同一個對象(不是指向相同的記憶體位置)，則返回 True x is not y 成員運算符 運算符 描述 範例 in 當 in 前面的變數在後面的序列中時，結果為 True x in y not in 當 in 前面的變數不在後面的序列中時，結果為 True x not in y 位元運算符 a = 5\n運算符 名稱 範例 \u0026amp; AND(位與操作符) - 當兩側數字在該位上都是 1 的時候，結果該位也為 1，否則為 0 a \u0026amp; 2 = 0 = 0000 | OR(位或操作符) - 當兩側數字在該位上只要有一個是 1 的時候，結果該位為 1，否則為 0 a | 2 = 7 = 0111 ^ XOR(位異或操作符) - 當兩側數字對應位二進位制相異時(其中一位為 1，另一位為 0)，結果為 1 a ^ 2 = 7 = ~ NOT(位取反操作符) - 對運算元進行按位取反操作，1 變成 0，0 變成 1 ~a = -6 = -(0101 + 1) = -(0110) \u0026laquo; 左移操作符 - 將 \u0026laquo; 左側的數字左移若干位，右側補 0，左側高位數捨棄 a \u0026laquo; 2 = 20 = 0001 0100 \u0026raquo; 右移操作符 - 將 \u0026raquo; 左側的數字右移若干位，左側補齊 0 a \u0026raquo; 2 = 1 = 0001 python 條件語句與迴圈控制 條件語句：當程式流程在進行的過程，需要根據某個條件來決定是否執行接下來的動作時使用。 迴圈控制：處理資料時，若是想要重複執行某些相同的步驟時，就會使用到迴圈。 條件語句 if 若判斷條件成立，則執行底下縮排的敘述內容；反之，則不動作。 if condition: statement if-else 若condition 為真 (True)，則執行 statement1；反之，則執行statement2。 if condition: statement1 for True condition else: statement2 for False condition if-elif-else elif 的個數是沒有限制的，可以依照自己的需求而定。 if condition1: statement1 for True Condition1 elif condition2 : statement2 for True Condition2 elif condition3 : statement3 for True Condition3 else: statements for Each Condition False 巢狀if ID = input() year = int(ID[1:3]) if year \u0026lt; 4: print(\u0026#34;Graduated\u0026#34;) elif year \u0026lt;= 7 and year \u0026gt;= 4: if year == 7: print(\u0026#34;Freshman\u0026#34;) elif year == 6: print(\u0026#34;Sophomore\u0026#34;) elif year == 5: print(\u0026#34;Junior\u0026#34;) elif year == 4: print(\u0026#34;Senior\u0026#34;) else: print(\u0026#34;Not Registered Yet\u0026#34;) 迴圈控制 單層 for-loop 適用在「已知迴圈數」的問題 for和in中間放自訂變數，in後面可接一個序列(ex. list) 迴圈會依序從序列裡取得元素，將元素指派給前面的自訂變數，並執行迴圈裡的內容 通常會跟range()做一個搭配使用 range(起始值，終止值，遞增(減)值)\nfor x in sequence: # 放要執行的東西 # 迴圈搭配list依序印出內容 sequences = [0, 1,\u0026#39;jason\u0026#39;,2.5] for i in sequences: print(i) # output 0 1 jason 2.5 # 迴圈搭配range()使用 for i in range(3): print(i, end=\u0026#34; \u0026#34;) print() # 換行 for i in range(10,2,-2): print(i, end=\u0026#34; \u0026#34;) # output 0 1 2 10 8 6 4 巢狀 for-loop 迴圈裡面又包覆著其他的迴圈。 處理的問題具有重複執行某段敘述的特性，而且這些敘述受到兩個 (或兩個以上) 的變數來分別控制其變化 # 九九乘法表 for i in range(1, 10): for j in range(1, 10): if j == 9: print(\u0026#34;\\t\u0026#34;, i*j) # j == 9時，換行 else: print(\u0026#34;\\t\u0026#34;, i*j, end = \u0026#39;\u0026#39;) # j \u0026lt; 9時，不換行 while loops 適用在「無法預知迴圈數」的問題 while test_expression: Body of while # 產生1到10的序列 i = 1 while i \u0026lt;= 10: print(i, end=\u0026#34; \u0026#34;) i = i + 1 break 和 continue(迴圈不規則結束) break：中斷迴圈的執行並跳脫迴圈結構，繼續執行迴圈外的敘述。 continue：不中斷迴圈；只跳過迴圈內 continue 後面的剩餘敘述，接著繼續執行下一次的迴圈運作。 規則的結束方式是當迴圈的判斷條件不再符合時，迴圈自然結束；而不規則的迴圈結束則是在迴圈自然結束前，我們已經得到想要的運算結果，利用強制中斷的方式來結束迴圈。\nfor i in \u0026#34;Hey Alan\u0026#34;: if i == \u0026#34;l\u0026#34;: break print(i, end=\u0026#34; \u0026#34;) print() for i in \u0026#34;Hey Alan\u0026#34;: if i == \u0026#34;l\u0026#34;: continue print(i, end=\u0026#34; \u0026#34;) # output H e y A H e y A a n python保留字 定義：語言本身的編譯器中已經定義過的單詞，具有特定含義和用途，使用者不能再將這些單詞作為變數名或函數名、類名使用。 保留字 說明 and 邏輯與操作，用於表示式運算 as 用於轉換資料型別 assert 用於判斷變數或條件表示式的結果 async 用於啟用非同步操作 await 用於非同步操作中等待協程返回 break 中斷迴圈語句的執行 class 定義類 continue 繼續執行下一次迴圈 def 定義函數或方法 del 刪除變數或序列的值 elif 條件語句，與 if、else 結合使用 else 條件語句，與 if、else 結合使用；也可用於異常或迴圈語句 except 包含捕獲異常後的處理程式碼塊，與 try、finally 結合使用 False 含義為假的邏輯值 finally 包含捕獲異常後的始終要呼叫的程式碼塊，與 try、except 結合使用 for 迴圈語句 from 用於匯入模組，與 import 結合使用 global 用於在函數或其他區域性作用域中使用全域性變數 if 條件語句，與 elif、else 結合使用 import 匯入模組，與 from 結合使用 in 判斷變數是否在序列中 is 判斷變數是否為某個類的範例 lambda 定義匿名函數 None 表示一個空物件或是一個特殊的空值 nonlocal 用於在函數或其他作用域中使用外層（非全域性）變數 not 邏輯非操作，用於表示式運算 or 邏輯或操作，用於表示式運算 pass 空的類、方法或函數的預留位置 raise 用於丟擲異常 return 從函數返回計算結果 True 含義為真的邏輯值 try 測試執行可能出現異常的程式碼，與 except, finally 結合使用 while 迴圈語句 with 簡化 Python 的語句 yield 從函數依次返回值 ","permalink":"https://sz9751210.github.io/posts/python-%E5%9F%BA%E7%A4%8E/","summary":"\u003ch2 id=\"python-基本語法\"\u003ePython 基本語法\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003epython 語法的後綴名是以.py 結尾\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"python-執行方式\"\u003epython 執行方式\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e使用交互介面執行\u003c/li\u003e\n\u003cli\u003e使用 python test.py 命令執行\u003c/li\u003e\n\u003cli\u003e使用./test.py 執行\u003c/li\u003e\n\u003c/ul\u003e","title":"python 基礎"},{"content":"CentOS 7 安裝及設定Jenkins 介紹 開源且免費的CI工具，由Java編寫的，提供了持續構建以及部署的功能，是一個自動化的server\n環境 CentOS 7 安裝步驟 1. 添加Jenkins Repository [root@jenkins ~]# wget --no-check-certificate -O /etc/yum.repos.d/jenkins.repo http://pkg.jenkins.io/redhat-stable/jenkins.repo [root@jenkins ~]# rpm --import http://pkg.jenkins.io/redhat-stable/jenkins.io.key 2. 安裝Jenkins以及Java [root@jenkins ~]# yum install -y jenkins java-1.8.0-openjdk 3. 啟動並啟用Jenkins [root@jenkins ~]# systemctl start jenkins* [root@jenkins ~]# systemctl enable jenkins* 4. 在防火牆開啟80以及8080 的port [root@jenkins ~]# firewall-cmd --zone=public --add-port=8080/tcp --permanent success [root@jenkins ~]# firewall-cmd --zone=public --add-service=http --permanent success [root@jenkins ~]# firewall-cmd --reload success 5. 透過網頁打開Jenkins 存取URL：http://:8080\n管理員密碼創建並存儲在日誌文件 /var/log/jenkins/jenkins.log 中。接著透過以下指令取得初始密碼\n[root@localhost ~]# grep -A 5 password /var/log/jenkins/jenkins.log Jenkins initial setup is required. An admin user has been created and a password generated. Please use the following password to proceed to installation: Admin password This may also be found at: /var/lib/jenkins/secrets/initialAdminPassword 接著安裝插件，可直接選Install suggested plugins\n接著來建立管理者帳號\n到此所有設定都已完成，即可開始使用Jenkins\n參考資料 How to install and Configure Jenkins on CentOS 7 and RHEL 7 (linuxtechi.com)\n","permalink":"https://sz9751210.github.io/posts/jenkins-installation-centos/","summary":"\u003ch1 id=\"centos-7-安裝及設定jenkins\"\u003eCentOS 7 安裝及設定Jenkins\u003c/h1\u003e\n\u003ch2 id=\"介紹\"\u003e介紹\u003c/h2\u003e\n\u003cp\u003e開源且免費的CI工具，由Java編寫的，提供了持續構建以及部署的功能，是一個自動化的server\u003c/p\u003e","title":"Jenkins 安裝教學(CentOS)"},{"content":"👀QUICK REVIEW The book in 3 Sentences 用三段話說明這本書的內容\n從歷史帶到實戰的基礎書籍 由淺入深循序漸進的步調講解每個章節的主題 極度白話文的一本書 How the Book Changed Me? 這本書為我帶來什麼改變\n更了解自己對的區塊鏈與加密貨幣的意義 對於詐騙手法有更多的了解以及知名的案例 對於泡沫風險分析有更加的了解 My Top 3 Quotes 我最喜歡的 3 句 Quotes\nDYOR FOMO 量化交易 📚讀後心得 這本書是由知名youtuber 腦哥 所出的一本書，書中用極為白話的口語描述關於區塊鏈與加密貨幣的各種說明。此書主要分成四章，一開始先簡單講解甚麼是加密貨幣，區塊鏈等技術，比特幣的誕生，以及作者對於比特幣的未來看法，接著第二章實戰教學如何購買加密貨幣，交易所的介紹，以及作者看好的加密貨幣類型以及用途，還有幣圈的知識管道分享，以及NFT的簡單介紹，第三章主要先講解詐騙以及泡沫風險分析，諸如龐氏騙局，駭客事件，穩定幣危機，51攻擊等等，最後則是講解在幣圈有哪些獲利方式，從簡單的長期持有到高獲利的合約交易以及有玩樂性質的gamefi，對於新手來說是本極度易上手的書。\n","permalink":"https://sz9751210.github.io/posts/%E6%AF%94%E7%89%B9%E5%B9%A3%E6%8A%95%E8%B3%87%E9%87%91%E5%BE%8B%E5%8A%A0%E5%AF%86%E8%B2%A8%E5%B9%A3%E5%AF%A6%E6%88%B0%E6%95%99%E5%AD%B8%E8%88%87%E9%80%B2%E9%9A%8E%E7%8D%B2%E5%88%A9%E6%B3%95/","summary":"\u003ch2 id=\"quick-review\"\u003e👀QUICK REVIEW\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003eThe book in 3 Sentences 用三段話說明這本書的內容\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e從歷史帶到實戰的基礎書籍\u003c/li\u003e\n\u003cli\u003e由淺入深循序漸進的步調講解每個章節的主題\u003c/li\u003e\n\u003cli\u003e極度白話文的一本書\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eHow the Book Changed Me? 這本書為我帶來什麼改變\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e更了解自己對的區塊鏈與加密貨幣的意義\u003c/li\u003e\n\u003cli\u003e對於詐騙手法有更多的了解以及知名的案例\u003c/li\u003e\n\u003cli\u003e對於泡沫風險分析有更加的了解\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eMy Top 3 Quotes 我最喜歡的 3 句 Quotes\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eDYOR\u003c/li\u003e\n\u003cli\u003eFOMO\u003c/li\u003e\n\u003cli\u003e量化交易\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e","title":"比特幣投資金律：加密貨幣實戰教學與進階獲利法"},{"content":" 題目描述：給一個字串，依照題目給的表格，計算出字串對應的值並做加總\n思路：依照題目給的表格做一個字典，接著定義一個變數做加總，並依照題目所給的前一位的值小於當前的值時，做相對應的處理\nclass Solution: def romanToInt(self, s: str) -\u0026gt; int: numeral_map = {\u0026#34;I\u0026#34;:1, \u0026#34;V\u0026#34;:5, \u0026#34;X\u0026#34;:10, \u0026#34;L\u0026#34;:50, \u0026#34;C\u0026#34;:100, \u0026#34;D\u0026#34;:500, \u0026#34;M\u0026#34;:1000} result = 0 for i in range(len(s)): if i\u0026gt;0 and numeral_map[s[i]] \u0026gt; numeral_map[s[i-1]]: result += numeral_map[s[i]] - 2* numeral_map[s[i-1]] else: result += numeral_map[s[i]] return result ","permalink":"https://sz9751210.github.io/posts/leetcode-13/","summary":" 題目描述：給一個字串，依照題目給的表格，計算出字串對應的值並做加總\n思路：依照題目給的表格做一個字典，接著定義一個變數做加總，並依照題目所給的前一位的值小於當前的值時，做相對應的處理\nclass Solution: def romanToInt(self, s: str) -\u0026gt; int: numeral_map = {\u0026#34;I\u0026#34;:1, \u0026#34;V\u0026#34;:5, \u0026#34;X\u0026#34;:10, \u0026#34;L\u0026#34;:50, \u0026#34;C\u0026#34;:100, \u0026#34;D\u0026#34;:500, \u0026#34;M\u0026#34;:1000} result = 0 for i in range(len(s)): if i\u0026gt;0 and numeral_map[s[i]] \u0026gt; numeral_map[s[i-1]]: result += numeral_map[s[i]] - 2* numeral_map[s[i-1]] else: result += numeral_map[s[i]] return result ","title":"leetCode 13. Roman to Integer"},{"content":"👀QUICK REVIEW The book in 3 Sentences 用三段話說明這本書的內容\n天才並非真的存在，刻意練習才是真正通往專家的唯一途徑 練習的質與量勝過於單純的練習量 專注投入與信念至關重要 How the Book Changed Me? 這本書為我帶來什麼改變\n讓練習在你眼中成為一種投資，而不是耗費 沒有人可以不投注及大量的練習就發展出非凡技能 My Top 3 Quotes 我最喜歡的 3 句 Quotes\n人之所以停止學習、不再進步，不是因為到達天生能力的極限，而是因為某些原因不再練習，或者從未開始練習。 技能越高超，心智表徵越成熟，越了解這領域，代表自己更懂欠缺甚麼，也因此更能發揮刻意練習的效果，磨練技巧可以改善心智表徵，心智表徵又有助於技能進步 當你不再相信自己能達成目標時千萬別放棄，先和自己約定好，等到重回先前水準或突破高原期後再說，到時大概就會繼續下去了。 📚讀後心得 書的目的：教導如何使用刻意練習來達到學習技能並邁向專家的路\nCH1：有目標的練習 第一部分講解目標練習法，透過設定短期目標，並完成來達成整體效果，例如，提升打字速度，長期目標可能是一分鐘200字，目前卡關在一分鐘90字，短期目標可設定一分鐘連續100字三字，利用聚沙成塔的概念便是目標練習法的核心\n目標練習法需要意見回饋，可能像是打字，立即顯示一分鐘打幾個字，要認清自己的弱點，才能做適時的修正\n目標練習法必須跨出舒適圈，每次都有新的挑戰，例如目標一分鐘200字，達成後往250字，逼近自己的極限，成功就在增加字數，失敗就減少\n目標練習法的隱藏關鍵之一是設法克服障礙，例如打字一直卡關，可能是某個手指頭不夠靈活經常按錯，又或是對於鍵盤位置不夠熟悉，克服障礙最理想的做法，是透過尋找並嘗試不同方法來突破瓶頸\n目標練習法總結：設定清楚的目標和實現那些目標的計畫，並找出一個監測進步程度的方式，然後跨出舒適圈，專注地練習，並且要找出維持動機的方法\nCH2：駕馭大腦與身體的適應力 人類大腦會因為密集訓練而成長 改變，大腦的適應力在程度和種類上與身體的非常相似，可透過有意識的刻意練習形塑大腦\n長期訓練會導致與正在培養的技能相關的大腦部位產生變化\n刻意練習的目標卻不僅是發展潛能，還要打造潛能，做到以前做不到的事，恆定性受到挑戰，得離開舒適圈，迫使大腦或身體去適應，做到了，學習不再只是一個實踐某種遺傳命運的方式，而成了按照自己ˋ的選擇掌控個人命運與打造潛能的方法\nCH3：心智表徵 心智表徵，舉例像是打字，想像自己打某些字的指法\n刻意練習講求的正是發展出種種更高效率的心智表徵，讓你可以運用於你正在練習的任何活動中\n心智表徵的一項重要特色是 領域限定性，也就是只適用於正在培養的技能，例如，打字快可能無法運用在寫作上\n盡管短期記憶有其限制，人卻能運用心智表徵快速處理大量資訊，也就是建立心智圖，透過點與點之間的連結\n專家與凡人在心智表徵的差異在於質與量不同，例如可能要打其他比較難的字，會需要想出怎樣才會打得更快，寫程式也是，要考慮如何做出想要的樣子，如何優化，差別在於此\n而建立好的心智表徵，則是盡可能建立多個點，書中以狗為例子，建立了多摸牠們的毛，拍拍牠們的頭，多建立這些點並連成線\n在某個主題上投注的心力越多，心智表徵就越精細，理解 消化新資訊的能力也越強\n專家擁有優越的資訊組織能力\n監控並評估自身表現，必要時調整心智表徵以提升其效能\n本身察覺錯誤的能力高低也影響心智表徵的建立\nCH4：刻意練習的黃金法則 技能越高超，心智表徵越成熟，越了解這領域，代表自己更懂欠缺甚麼，也因此更能發揮刻意練習的效果，磨練技巧可以改善心智表徵，心智表徵又有助於技能進步\n當逼迫自己去做一件新的事，無論是培養新技能或是精進既有技能，同時也是在擴充、加強心智表徵，而這些心智表徵又反過來讓你有可能超越之前的極限。\n沒有人可以不投注及大量的練習就發展出非凡技能\n刻意練習與目標練習法有兩大差異\n該領域必須發展得相當成熟，佼佼者的表現水準和新手有極大差距 刻意練習需要有個老師提供可以幫助學生改善表現的練習活動 刻意練習等於是有方向和方法的目標練習法\n刻意練習特色\n刻意練習培養的技能已經有其他人知道該怎麼做，也已建立成效頗佳的訓練技巧。設計練習方式及負責監督的老師或教練應該熟悉頂尖專家的能力，並清楚該如何以最好的方法培養這些技能 跨出舒適圈後才能奏效，需要學生不斷嘗試去突破現階段的技能水準。這意味著幾乎得傾盡全力，所以往往不會太有樂趣 必須有定義清楚明確的目標，且往往涉及改進想要達到的表現得某個面向，而不能只設定模糊的整體改善目標。整體目標設定完成後，老師或教練會制定計畫，其中的一連串改善細項便會累積成向前邁進的一大步，改進想要達到的表現的某個面向，可以讓學生看見自身表現已經藉由訓練改善了 必須刻意進行，必須全神貫注，有意識地行動。光是遵從老師或教練的指導是不夠的，還得專注於自身練習的具體目標，才能適時調整，以掌控練習過程 刻意練習包含意見回饋，並根據該回饋調整努力方向。訓練初期得到的意見回括多來自老師或教練，他們會監控訓練過程並點出問題，提出解決之道。到後期學生也必須學會自我監督並察覺錯誤，隨之因應調整，而自我監督的本領則仰賴有效的心智表徵 刻意練習技能產生有效的心智表徵，也仰賴心智表徵運作。提升表現和改善心智表徵相輔相成，表現提升了，心智表徵就變得更精細有效，反之亦然，心智表徵有助於監控練習和實際上場時的狀況，讓人以正確的方式行動，也能察覺錯誤，並加以改正。 刻意練習幾乎等於加強或調整先前習得的技能，必須注重該技能的特定面向，努力改善，而隨著時間過去，每一步的改善最終會打造出專家級的表現。因為新技能以既有技能為基礎，老師必須在一開始就教導正確的基本功，這樣學生後來達到更高階的水準時，才不必從頭學習基本技能。 做法:先找出頂尖專家，弄清楚他們做了些甚麼才能如此成功，接著發展出讓自己可以做到那些事的訓練技巧\n有效的意見回饋不只是反應做得正確與否，更會討論過程\n這套方法是否能讓人離開舒適圈，嘗試帶有挑戰性的事務，能否讓人及時獲得與表現和可能的改善方式有關的意見回饋，建立這套方法的人有沒有在該領域找出頂尖專家，又是否了解專家與泛泛之輩的不同，其設計是否著眼於培養該領域專家具備的技能\n如何提升相關技能大於如何傳授相關知識，讓訓練著重於行動而非知識\nCH6：在日常生活中運用刻意練習原則 第一步，找個好老師：老師的重要任務之一，是協助學生發展個人的心智表徵，才能針對表現自我監控和修正，並視個人的改變更換老師，例如沒進步時 專注與投入至關重要：開始分心或覺得輕鬆好玩時，大概就代表沒有進步，想要從中獲得最大益處的關鍵，在於專注，有意識的發展技能並精益求精，學會以這種方式投入，便是提升練習效益最強大的方法。剛開始學著專注於練習的人無法維持數小時的注意力，因此一開始必須將練習時間設定得比較短，然後逐漸拉長。專注與投入至關重要，所以每回的訓練時間較短、但目標清楚，是更快速培養出新技能的最佳方法，在較短的時間內投入百分之百的努力，效果強過花了較長時間卻只投入百分之七十的努力，一旦發現自己無法專注，就結束這回合的訓練，並要確保睡眠充足，才能以最大的專注力進行訓練 沒有老師怎麼辦：有目標的練習或刻意練習的一項特色，在於挑戰做不到的事(離開舒適圈)，反覆練習，聚焦於自己的做法、自己的弱點，以及如何改善。富蘭克林實踐了夢想，是因為他針對寫作的不同面向設計出練習活動。好老師或好教練的主要貢獻之一，便是針對你正在努力培養的技能量身訂做類似的練習；若沒有老師，就得自己設計一套練習活動。漫不經心地重複同一件事毫無助益，重複的目的在發現自己的弱點，並聚焦於加強弱點，嘗試不同的方式改善，直到找出最佳策略為止，例如想加強英語理解能力或聽力，先觀看一步有字幕的影片，接著關掉字幕試著理解，接著打開對答案如此反覆，直到都成功，比起看好幾部片來得更有效率。想在沒有老師的情況下有效練習一項技能，建議記住三個重點：專注投入、意見回饋、解決問題。將技能分成可以有效重複練習和分析的幾個部分，確定弱點何在，並找出解決辦法。要建立有效的心智表徵，便得嘗試重現頂尖專家的成果，從失敗中認識自身弱點後再次嘗試，如此一再重複。心智表徵奏效與否，和採取行動密不可分。不能光憑思考，而是必須透過仿作加強練習，才能建立起自己所追求的心智表徵。 突破高原期，表現不再停滯不前：剛開始學習新事物時進步迅速很正常，不然也至少會穩定向前。一旦碰到停滯不前的狀況，自然會認為自己遭遇難以克服的障礙，因而往往不再試著向前邁進，反而認命地在高原徘徊。這就是各個領域的許多人不再進步的原因。突破瓶頸的最佳方式，就是以新的方法挑戰自己的大腦或身體，比平常更用力地逼迫自己，一點點就好，就像打字，卡在某個組合，就專注練習某個組合的打字節奏，如果要提升打字速度，就縮短一點時間打出平常的單字量，然後分析錯誤從何而來，找出速度快不起來的原因，設計一些練習來提升速度，而不只是再三重覆嘗試。突破高原期方法：先找出進步停滯的原因，犯了哪些錯，何時做錯的，迫使自己離開舒適圈，看哪個問題先顯露出來，設計改善這個問題的練習方法 找出持續不懈的動機：維持動機，可從兩點切入：持續的理由和停止的理由。會停止原本想做的事，是因為停止的理由終究強過於持續的理由，因此想維持動機，可以增強持續的理由或減弱停止的理由，而要讓動機發揮效用，通常必須兩者兼具。減弱停止的理由最有效的做法，撥出固定時間排除其他所有義務和令你分心的事，好好練習。在最佳狀況下要迫使自己練習可能就夠困難了，如果有其他是可以忙，往往會被引誘去做，而且會合理化地告訴自己那件事真的非做不可。經常如此，就會逐漸疏於練習，讓訓練計畫走進死胡同。可好好擬定練習時間，例如早晨，干擾因素最少，好的計畫有助於避開許多可能導致練習時間縮短的事情。找出可能干擾訓練的因素，並盡量減低影響。頂尖專家有兩個習慣，第一個是照顧身體：讓自己睡眠充足，不靠鬧鐘叫醒，並保持身體健康，第二個是將練習時間控制在大約一小時：人無法全神貫注超過一小時太多，訓練初期能集中注意力的時間可能更短，建議想將練習拉長至超過一小時的人每練一小時都休息片刻(番茄鐘)。增加持續的意願，在練習一陣子並看見成果後，技能本身就可能成為動機的一部份，讓你為自己的表現自豪，讓練習在你眼中成為一種投資，而不是耗費，另一個關鍵是相信自己能成功。想放棄可以，但至少先練習到恢復先前的水準，這時便會發現，持續進步的確有可能，之前只不過是一時的挫敗，信念的重要不容忽視。無論是因為退步或進入高原期，當你不再相信自己能達成目標時千萬別放棄，先和自己約定好，等到重回先前水準或突破高原期後再說，到時大概就會繼續下去了。最強而有力的外部動機之一是社會動機，最直接的就是得到他人的認可或欽佩。建立和維持社會動機最好的方法，就是讓自己身邊圍繞著你努力時會給予鼓勵、支持和挑戰的人，邀請興趣相同的人共組團體，或是加入現有的社團，將團體中的夥伴情誼和共同目標化為達成自身目標的額外動機。但本質上，刻意練習絕對是條寂寞的路。盡管可以和志同道合的人組成團體，彼此鼓勵，大多數的進步還是得靠獨自練習。將這條漫長的路分成一連串可達成的目標，一次聚焦一項。刻意練習是能通往實現夢想的路 CH7：邁向非凡的路線圖 專家的養成會經過四個不同的階段：產生興趣、變得認真、全心投入、開闢新路\n產生興趣：許多孩子一開始有動機探索或嘗試新事物，是出於與生俱來的好奇心或遊戲性，因此父母有機會以剛萌芽的興趣做為產開某項活動的跳板。讚美與獲得新技能的滿感會使孩子動力更強。手足間的競爭有激勵的作用。 變得認真：鼓勵，在培養技能和習慣的同時，也維持興趣與動機。協助孩子找到喜歡的相關活動，以維持長時間的動力，也就是培養心智表徵，培養音樂的表徵可以是找尋好聽的音樂，享受獨自在練習室演奏喜愛的曲子帶來的快樂。在這個階段的前半部，父母和老師的鼓勵與支持對孩子的進步至關重要，但等到孩子開始嘗到辛苦努力帶來的果實，就逐漸變得可以自我激勵。 全心投入：技能隨著年齡漸長而退步，多是因為訓練減少或中止。就算年齡增長，一定還是可以學會新技能 開闢新路：創造力其實和下苦功及長時間維持專注的能力相輔相成，這些正是一開始造就他們專家級能力的刻意練習的要素 非凡能力都是大量練習和訓練的結果，奇才或自閉學者無法證明特殊天賦的存在。人之所以停止學習、不再進步，不是因為到達天生能力的極限，而是因為某些原因不再練習，或者從未開始練習。\n刻意練習基本原則：將學習目標分解為一連串具體技能，並設計練習活動以正確的順序教導每一項技能，然後運用意見回饋監控進展。最後的勝利屬於更努力練習的人，而不屬於一開始靠智力或其他天賦佔上風者。\nCH8：如何解釋’’天賦’’這回事 老師在準備教案時，決定學生應該具備哪些能力，遠比決定應該具備那些知識有效，因為培養能力的過程中自然會獲得知識。先列出能力後，再化為一系列具體的學習目標，建立完善的心智表徵。\n設計一系列提點問題和學習任務，幫助他們達到老師訂定的學習目標。各個提點問題和任務的挑選標準是要能開啟討論，藉此鼓勵學生了解、應用正在學習的概念，進而運用這些概念回答問題和完成任務。設計問題另一個目的是激勵學生踏出舒適圈，讓學生思考，並在犯錯時讓學生能獲得即時的回應和改正建議。\nCH9：用刻意練習打造全新的世界 刻意練習原則路線圖：先確認學生應該學會的能力，目標在於技能，而非知識。找出學生學習某項技能應該使用的方式之後，了解專家的作法，尤其重要的是必須盡可能弄清楚專家運用的心智表徵。然後，將技能分解成幾個步驟，每個步驟都應該讓學生離開舒適圈，但又不至於遙不可及。接著開始充分反覆練習和提供意見回饋，也就是嘗試、失敗、意見回饋、再次嘗試，如此一再循環，學生便會在過程中建立起自己的心智表徵。\n協助學生培養某領域技能和心智表徵的最佳方法，便是提供可以模仿和學習的範例，並結合高品質的練習\n之所以不無聊，是因為總有新的跳站和契機\n可塑性與適應力極高的大腦並且搭配正確訓練\n學習變成一種創造能力的方法，而不是引導個人發揮固有能力，使人天生的潛能不具限制，我們醫生做的各式各樣的事情塑造而成，學習不是一種達到潛能的方法，而是發展潛能，創造出自己的潛能，此書將會介紹正確的練習方法(刻意練習)，以及如何應用\n任何領域裡最有效最有用的練習方式都是藉由掌控大腦與身體的適應力，一步步創造出之前不可能擁有的能力\n讀了這本書之後，讓我最有改觀的就是天才是靠努力得來的，並且有目標的大量練習，注重練習的質與量才是真正通往天才的唯一途徑，書中講述了許多被世人認為是天才，但經過自己深入暸解後並非是如此，並且舉例了天才背後不為人知的秘密，’’刻意練習’’，書中也說明了學習並不是引導個人發揮固有能力，而是讓學習變成一種創造能力的方法，學習不是一種達到潛能的方法，而是發展潛能，創造出自己的潛能，並且點破了’’一萬小時法則’’的迷思以及誤解， 讓練習在你眼中成為一種投資，而不是耗費，沒有人可以不投注大量的練習就發展出非凡技能，因此我也打算利用這個方法讓我在學習技能的道路上更有效率以及系統的大量練習，看是否也能讓我頭痛已久的能力也能成為我拿手的技能。\n","permalink":"https://sz9751210.github.io/posts/%E5%88%BB%E6%84%8F%E7%B7%B4%E7%BF%92/","summary":"\u003ch2 id=\"quick-review\"\u003e👀QUICK REVIEW\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003eThe book in 3 Sentences 用三段話說明這本書的內容\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e天才並非真的存在，刻意練習才是真正通往專家的唯一途徑\u003c/li\u003e\n\u003cli\u003e練習的質與量勝過於單純的練習量\u003c/li\u003e\n\u003cli\u003e專注投入與信念至關重要\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eHow the Book Changed Me? 這本書為我帶來什麼改變\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e讓練習在你眼中成為一種投資，而不是耗費\u003c/li\u003e\n\u003cli\u003e沒有人可以不投注及大量的練習就發展出非凡技能\u003c/li\u003e\n\u003cli\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eMy Top 3 Quotes 我最喜歡的 3 句 Quotes\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e人之所以停止學習、不再進步，不是因為到達天生能力的極限，而是因為某些原因不再練習，或者從未開始練習。\u003c/li\u003e\n\u003cli\u003e技能越高超，心智表徵越成熟，越了解這領域，代表自己更懂欠缺甚麼，也因此更能發揮刻意練習的效果，磨練技巧可以改善心智表徵，心智表徵又有助於技能進步\u003c/li\u003e\n\u003cli\u003e當你不再相信自己能達成目標時千萬別放棄，先和自己約定好，等到重回先前水準或突破高原期後再說，到時大概就會繼續下去了。\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e","title":"刻意練習：原創者全面解析, 比天賦更關鍵的學習法"},{"content":"📚讀後心得 讀完心流這本書後，心流對我的生活有很大的改觀，心流，就是我們在做某件事情時，全神貫注進入渾然忘我的狀態，讓我想起有時候在想一段程式，如何做優化，並且一步一步漸漸達成，接著看一下時間，突然就快要下班了，原來我也體驗過心流，那種感覺真的是很美好，整個人很享受當下那種慢慢擊破目標，達成目的的過程，裡面也有講到一段話我覺得很棒，成功，就像幸福一樣，不是追求而來的；它是一個人全心全意投入一件事，而忘卻自我的副產物。所以本書就是在教如何找到自己的心流所在，讓我們能夠變得更快樂，更幸福。\n心流的三個特徵，第一：全神貫注的忘我境界，拿我剛剛想程式碼的例子，從一開始的設計邏輯到實踐，整個過程我是全神貫注的狀態，第二：重建自我內在的秩序，我必須給自己信心，相信自己能夠實現出我所想的方法，第三：目標與即時的回饋，我透過一小段一小段慢慢實踐我所想的方法，並能夠立即知道結果，只要達成這三個，就有機會體驗心流，知道如何控制內在體驗的人們將有能力決定自己的人生品質。當我們進入心流體驗的時間越多，就越能提升自己本身的幸福感、加深對目標的堅持、擁有更積極的心態，讓我們面對未來種種挑戰也不會輕易受到外在的控制。自行作主的信念能使一個人能全心投入目標，行動完全受內在控制\n最後我整理了進入心流的五個步驟\n設定明確並且具有挑戰性的目標 具備一定程度的技能 拆解成階段性任務 屏除外界干擾專心投入 忘卻自我樂在當下 ","permalink":"https://sz9751210.github.io/posts/flow/","summary":"\u003ch2 id=\"讀後心得\"\u003e📚讀後心得\u003c/h2\u003e\n\u003cp\u003e讀完心流這本書後，心流對我的生活有很大的改觀，心流，就是我們在做某件事情時，全神貫注進入渾然忘我的狀態，讓我想起有時候在想一段程式，如何做優化，並且一步一步漸漸達成，接著看一下時間，突然就快要下班了，原來我也體驗過心流，那種感覺真的是很美好，整個人很享受當下那種慢慢擊破目標，達成目的的過程，裡面也有講到一段話我覺得很棒，成功，就像幸福一樣，不是追求而來的；它是一個人全心全意投入一件事，而忘卻自我的副產物。所以本書就是在教如何找到自己的心流所在，讓我們能夠變得更快樂，更幸福。\u003c/p\u003e","title":"心流：高手都在研究的最優體驗心理學"}]