[{"content":"Intro🧑‍💻 紀錄有哪些方式可以ssh到gce機器\n放key到中繼資料 Compute Enging -\u0026gt; 中繼資料 -\u0026gt; 安全殼層金鑰 使用TCP Tunneling\ngcloud compute start-iap-tunnel --project project-id --zone vm-zone --local-host-port 127.0.0.1:10001 vm-host 22 使用gcloud ssh gcloud compute ssh --zone vm-zone vm-host --tunnel-through-iap --project project-id 可編寫tunnel的script\n## dev gcloud compute start-iap-tunnel dev-border 22 --local-host-port 127.0.0.1:10120 --zone asia-east1-b --project gcp-project \u0026amp; ## test gcloud compute start-iap-tunnel test-border 22 --local-host-port localhost:10121 --zone asia-east1-b --project gcp-project \u0026amp; ## prod gcloud compute start-iap-tunnel prod-border 22 --zone asia-east1-b --local-host-port 127.0.0.1:10122 --project gcp-project \u0026amp; Reference 使用 IAP 进行 TCP 转发 | Identity-Aware Proxy | Google Cloud SSH TCP Tunneling using Google Cloud SDK Identity Aware Proxy Commands (github.com) ","permalink":"https://sz9751210.github.io/posts/gcp%E8%B7%B3%E6%9D%BF%E6%A9%9Fssh%E7%9B%B8%E9%97%9C%E8%A8%AD%E5%AE%9A/","summary":"Intro🧑‍💻 紀錄有哪些方式可以ssh到gce機器\n放key到中繼資料 Compute Enging -\u0026gt; 中繼資料 -\u0026gt; 安全殼層金鑰 使用TCP Tunneling\ngcloud compute start-iap-tunnel --project project-id --zone vm-zone --local-host-port 127.0.0.1:10001 vm-host 22 使用gcloud ssh gcloud compute ssh --zone vm-zone vm-host --tunnel-through-iap --project project-id 可編寫tunnel的script\n## dev gcloud compute start-iap-tunnel dev-border 22 --local-host-port 127.0.0.1:10120 --zone asia-east1-b --project gcp-project \u0026amp; ## test gcloud compute start-iap-tunnel test-border 22 --local-host-port localhost:10121 --zone asia-east1-b --project gcp-project \u0026amp; ## prod gcloud compute start-iap-tunnel prod-border 22 --zone asia-east1-b --local-host-port 127.","title":"gcp遠端連線的幾種方式"},{"content":"簡介👩‍💻 最近在研究terraform與ansible的整合，不過還在摸索中，機器的版控對於維運來講相對重要，這時候有terraform的出現，在建立機器後會隨之產生機器的狀態檔，而ansible則是在建立好機器後幫助我完成我所需的機器相關設定\n這是一款terraform結合ansible的小玩具，在gcp環境下使用terraform幫我建置好機器，接著使用local exec執行ansible的playbook完成機器的設定\n資料夾結構 ├───ansible-playbook │ ├───group_vars │ │ └───all │ ├───roles │ │ ├───instance │ │ │ └───tasks │ │ └───ops_agent │ │ └───tasks │ └───vars │ └───instance ├───modules │ └───main.tf │ └───variables.tf └───roles └───general └───general.tf ansible-playbook：放置ansible相關工具 modules：放置主要使用的resource以及定義好的變數 roles：放置自定義參數 使用指南 先建立gcp sa給terraform可以有建立vm的權限，接著可以下\nterraform init -\u0026gt; 先讓terraform下載相關的repo terraform plan -\u0026gt; 查看terraform會做哪些事情，一開始都會先去檢查狀態檔，最上面代表動作，此範例為create，最下面的plan代表總共有4個resource會add terraform apply -\u0026gt; 建立機器指令，apply一樣會把plan的部分也顯示出來，並詢問是否要繼續，打上yes後便會開始建置機器 terraform destroy -\u0026gt; 機器建立完要刪除時下這指令，destroy一樣會去檢查狀態檔，這次的動作為destroy，最下面的plan顯示4個資源會被destroy terraform show -\u0026gt; 可以顯示當前terraform的狀態 🔗專案repo \u0026ndash;\u0026gt; https://github.com/sz9751210/terraform-demo\n","permalink":"https://sz9751210.github.io/posts/terraform-ansible/","summary":"簡介👩‍💻 最近在研究terraform與ansible的整合，不過還在摸索中，機器的版控對於維運來講相對重要，這時候有terraform的出現，在建立機器後會隨之產生機器的狀態檔，而ansible則是在建立好機器後幫助我完成我所需的機器相關設定\n這是一款terraform結合ansible的小玩具，在gcp環境下使用terraform幫我建置好機器，接著使用local exec執行ansible的playbook完成機器的設定\n資料夾結構 ├───ansible-playbook │ ├───group_vars │ │ └───all │ ├───roles │ │ ├───instance │ │ │ └───tasks │ │ └───ops_agent │ │ └───tasks │ └───vars │ └───instance ├───modules │ └───main.tf │ └───variables.tf └───roles └───general └───general.tf ansible-playbook：放置ansible相關工具 modules：放置主要使用的resource以及定義好的變數 roles：放置自定義參數 使用指南 先建立gcp sa給terraform可以有建立vm的權限，接著可以下\nterraform init -\u0026gt; 先讓terraform下載相關的repo terraform plan -\u0026gt; 查看terraform會做哪些事情，一開始都會先去檢查狀態檔，最上面代表動作，此範例為create，最下面的plan代表總共有4個resource會add terraform apply -\u0026gt; 建立機器指令，apply一樣會把plan的部分也顯示出來，並詢問是否要繼續，打上yes後便會開始建置機器 terraform destroy -\u0026gt; 機器建立完要刪除時下這指令，destroy一樣會去檢查狀態檔，這次的動作為destroy，最下面的plan顯示4個資源會被destroy terraform show -\u0026gt; 可以顯示當前terraform的狀態 🔗專案repo \u0026ndash;\u0026gt; https://github.com/sz9751210/terraform-demo","title":"terraform-ansible"},{"content":"安裝與設定所需依賴 安裝依賴套件 sudo yum install -y curl policycoreutils-python openssh-server perl 啟動 SSH 服務 sudo systemctl enable sshd sudo systemctl start sshd 防火牆開啟網頁要用的PORT網頁 sudo firewall-cmd --permanent --add-service=http sudo firewall-cmd --permanent --add-service=https sudo systemctl reload firewalld 安裝 SMTP Server (Postfix)，發送通知email用 sudo yum install postfix sudo systemctl enable postfix sudo systemctl start postfix 添加gitlab repo以及安裝package Add Gitlab package 可自行選擇要安裝CE版還是EE版，如果要安裝EE版則把gitlab-ce改成gitlab-ee即可 curl https://packages.gitlab.com/install/repositories/gitlab/gitlab-ce/script.rpm.sh | sudo bash Install Gitlab 這邊建置是使用內網，因此使用http的方式下去做設定 sudo EXTERNAL_URL=\u0026#34;http://{{ internal_ip }}\u0026#34; yum install -y gitlab-ce reference Download and install GitLab | GitLab\n","permalink":"https://sz9751210.github.io/posts/centos7%E5%AE%89%E8%A3%9Dgitlab/","summary":"安裝與設定所需依賴 安裝依賴套件 sudo yum install -y curl policycoreutils-python openssh-server perl 啟動 SSH 服務 sudo systemctl enable sshd sudo systemctl start sshd 防火牆開啟網頁要用的PORT網頁 sudo firewall-cmd --permanent --add-service=http sudo firewall-cmd --permanent --add-service=https sudo systemctl reload firewalld 安裝 SMTP Server (Postfix)，發送通知email用 sudo yum install postfix sudo systemctl enable postfix sudo systemctl start postfix 添加gitlab repo以及安裝package Add Gitlab package 可自行選擇要安裝CE版還是EE版，如果要安裝EE版則把gitlab-ce改成gitlab-ee即可 curl https://packages.gitlab.com/install/repositories/gitlab/gitlab-ce/script.rpm.sh | sudo bash Install Gitlab 這邊建置是使用內網，因此使用http的方式下去做設定 sudo EXTERNAL_URL=\u0026#34;http://{{ internal_ip }}\u0026#34; yum install -y gitlab-ce reference Download and install GitLab | GitLab","title":"Centos 7 安裝gitlab"},{"content":"使用Rake task 將user_name改成要變更密碼的user name即可\nsudo gitlab-rake \u0026#34;gitlab:password:reset[user_name]\u0026#34; 使用Rails console 開啟rails console sudo gitlab-rails console 取得user 透過username user = User.find_by_username \u0026#39;user_name\u0026#39; 透過userID user = User.find(uid) 透過email user = User.find_by(email: \u0026#39;user@example.com\u0026#39;) 重置密碼 new_password = \u0026#39;my_new_password\u0026#39; user.password = new_password user.password_confirmation = new_password 儲存修改 user.save! 退出console exit ","permalink":"https://sz9751210.github.io/posts/gitlab-%E4%BF%AE%E6%94%B9%E5%AF%86%E7%A2%BC/","summary":"使用Rake task 將user_name改成要變更密碼的user name即可\nsudo gitlab-rake \u0026#34;gitlab:password:reset[user_name]\u0026#34; 使用Rails console 開啟rails console sudo gitlab-rails console 取得user 透過username user = User.find_by_username \u0026#39;user_name\u0026#39; 透過userID user = User.find(uid) 透過email user = User.find_by(email: \u0026#39;user@example.com\u0026#39;) 重置密碼 new_password = \u0026#39;my_new_password\u0026#39; user.password = new_password user.password_confirmation = new_password 儲存修改 user.save! 退出console exit ","title":"Gitlab 修改密碼"},{"content":"題目描述 將一個已經排序好的list中重複的數字刪去，並回傳list長度，必須以in-place的方式處理，不能使用額外的空間\n解題思路 使用兩個指針，一個紀錄都沒重複的次數(slow)，一個紀錄當前沒重複的數字(fast)，如果重複，則更新沒重複的數字\nPython class Solution: def removeDuplicates(self, nums: List[int]) -\u0026gt; int: n = len(nums) if n \u0026lt; 2: return n slow, fast = 1, 1 for fast in range(1,n): if nums[fast-1] != nums[fast]: nums[slow] = nums[fast] slow += 1 return slow Golang func removeDuplicates(nums []int) int { n := len(nums) if n \u0026lt; 2 { return n } slow, fast := 1, 1 for fast \u0026lt; n { if nums[fast-1] != nums[fast] { nums[slow] = nums[fast] slow++ } fast++ } return slow } ","permalink":"https://sz9751210.github.io/posts/leetcode-26/","summary":"題目描述 將一個已經排序好的list中重複的數字刪去，並回傳list長度，必須以in-place的方式處理，不能使用額外的空間\n解題思路 使用兩個指針，一個紀錄都沒重複的次數(slow)，一個紀錄當前沒重複的數字(fast)，如果重複，則更新沒重複的數字\nPython class Solution: def removeDuplicates(self, nums: List[int]) -\u0026gt; int: n = len(nums) if n \u0026lt; 2: return n slow, fast = 1, 1 for fast in range(1,n): if nums[fast-1] != nums[fast]: nums[slow] = nums[fast] slow += 1 return slow Golang func removeDuplicates(nums []int) int { n := len(nums) if n \u0026lt; 2 { return n } slow, fast := 1, 1 for fast \u0026lt; n { if nums[fast-1] !","title":"leetcode 26. Remove Duplicates from Sorted Array"},{"content":"題目描述 給一個長度固定的list，將裡面出現的0做複製，並將剩餘的元素往右移\n解題思路 使用單指針做遍歷，條件有兩個，都符合才做處理\n假如當前元素為0 考慮最後一個元素也為0要小於list長度 Python class Solution: def duplicateZeros(self, arr: List[int]) -\u0026gt; None: \u0026#34;\u0026#34;\u0026#34; Do not return anything, modify arr in-place instead. \u0026#34;\u0026#34;\u0026#34; i = 0 while i \u0026lt; len(arr): if arr[i] == 0 and i + 1 \u0026lt; len(arr): arr.insert(i+1, 0) arr.pop() i += 1 i += 1 Golang func duplicateZeros(arr []int) { for i := 0; i \u0026lt; len(arr); i++ { if arr[i] == 0 \u0026amp;\u0026amp; i+1 \u0026lt; len(arr) { arr = append(arr[:i+1], arr[i:len(arr)-1]...) i ++ } } } ","permalink":"https://sz9751210.github.io/posts/leetcode-1089/","summary":"題目描述 給一個長度固定的list，將裡面出現的0做複製，並將剩餘的元素往右移\n解題思路 使用單指針做遍歷，條件有兩個，都符合才做處理\n假如當前元素為0 考慮最後一個元素也為0要小於list長度 Python class Solution: def duplicateZeros(self, arr: List[int]) -\u0026gt; None: \u0026#34;\u0026#34;\u0026#34; Do not return anything, modify arr in-place instead. \u0026#34;\u0026#34;\u0026#34; i = 0 while i \u0026lt; len(arr): if arr[i] == 0 and i + 1 \u0026lt; len(arr): arr.insert(i+1, 0) arr.pop() i += 1 i += 1 Golang func duplicateZeros(arr []int) { for i := 0; i \u0026lt; len(arr); i++ { if arr[i] == 0 \u0026amp;\u0026amp; i+1 \u0026lt; len(arr) { arr = append(arr[:i+1], arr[i:len(arr)-1].","title":"leetcode 1089 - Duplicate Zeros"},{"content":"題目描述 給一個列表以及一個列表裡兩數相加起來的數，返回此兩數的列表位置\n解題思路 可用字典結構當作存取位置用，並用遍歷將相減後還沒有出現的數存進字典裡，之後如果有遍歷到字典裡的數即可立馬返回位置\n一樣使用雙指針，將list的index跟element分組做排序，因此新的list為由小到大，接著使用雙指針，一個指向頭一個指向尾，相加如果小於target則代表start太小，相加如果大於target代表end太大\nPython 原本想用兩個for去解決\nclass Solution: def twoSum(self, nums: List[int], target: int) -\u0026gt; List[int]: for i in range(len(nums)): left = nums[i+1:] for j in range(len(left)): if (nums[i] + left[j]) == target: return i, j+i+1 但提交後噴了time limit exceeded\nclass Solution: def twoSum(self, nums: List[int], target: int) -\u0026gt; List[int]: dict = {} for i in range(len(nums)): if target - nums[i] not in dict: dict[nums[i]] = i else: return [dict[target - nums[i]], i] class Solution: def twoSum(self, nums: List[int], target: int) -\u0026gt; List[int]: list_ele_idx = [(ele, idx) for idx, ele in enumerate(nums)] # 主要讓ele在前，使sort生效，因此前面會寫成(ele, idx)，讓ele可以排序 list_ele_idx.sort() start, end = 0, len(nums)-1 while(start \u0026lt; end): if list_ele_idx[start][0] + list_ele_idx[end][0] == target: return sorted([list_ele_idx[start][1], list_ele_idx[end][1]]) elif list_ele_idx[start][0] + list_ele_idx[end][0] \u0026lt; target: # need bigger start += 1 else: # nums[start] + nums[end] \u0026gt; target: # need smaller end -= 1 else: return [-1, -1] ","permalink":"https://sz9751210.github.io/posts/leetcode-01/","summary":"題目描述 給一個列表以及一個列表裡兩數相加起來的數，返回此兩數的列表位置\n解題思路 可用字典結構當作存取位置用，並用遍歷將相減後還沒有出現的數存進字典裡，之後如果有遍歷到字典裡的數即可立馬返回位置\n一樣使用雙指針，將list的index跟element分組做排序，因此新的list為由小到大，接著使用雙指針，一個指向頭一個指向尾，相加如果小於target則代表start太小，相加如果大於target代表end太大\nPython 原本想用兩個for去解決\nclass Solution: def twoSum(self, nums: List[int], target: int) -\u0026gt; List[int]: for i in range(len(nums)): left = nums[i+1:] for j in range(len(left)): if (nums[i] + left[j]) == target: return i, j+i+1 但提交後噴了time limit exceeded\nclass Solution: def twoSum(self, nums: List[int], target: int) -\u0026gt; List[int]: dict = {} for i in range(len(nums)): if target - nums[i] not in dict: dict[nums[i]] = i else: return [dict[target - nums[i]], i] class Solution: def twoSum(self, nums: List[int], target: int) -\u0026gt; List[int]: list_ele_idx = [(ele, idx) for idx, ele in enumerate(nums)] # 主要讓ele在前，使sort生效，因此前面會寫成(ele, idx)，讓ele可以排序 list_ele_idx.","title":"leetcode 01. two sum"},{"content":"題目描述 給定一個數組nums和一個值val，你需要原地移除所有數值等於val的元素，返回移除後數組的新長度。\n時間複雜度為O(1)，不用考慮移除後的數組順序\n解題思路 可先定義好一個指針，拿來加上長度，並用for判別是否為val，最後返回指針長度\n使用雙指針，快的指針去負責遍歷整個list，慢的指針去紀錄是否有遇到題目給的值，是的話就跳過，最後返回slow\nPython class Solution: def removeElement(self, nums: List[int], val: int) -\u0026gt; int: ptr = 0 for num in nums: if num != val: nums[ptr] = num ptr += 1 return ptr class Solution: def removeElement(self, nums: List[int], val: int) -\u0026gt; int: fast = slow = 0 while(fast \u0026lt; len(nums)): if(nums[fast] != val): nums[slow] = nums[fast] slow+=1 fast+=1 return slow Golang func removeElement(nums []int, val int) int { fast, slow := 0, 0 for fast \u0026lt; len(nums) { if nums[fast] != val { nums[slow] = nums[fast] slow++ } fast++ } return slow } ","permalink":"https://sz9751210.github.io/posts/leetcode-27/","summary":"題目描述 給定一個數組nums和一個值val，你需要原地移除所有數值等於val的元素，返回移除後數組的新長度。\n時間複雜度為O(1)，不用考慮移除後的數組順序\n解題思路 可先定義好一個指針，拿來加上長度，並用for判別是否為val，最後返回指針長度\n使用雙指針，快的指針去負責遍歷整個list，慢的指針去紀錄是否有遇到題目給的值，是的話就跳過，最後返回slow\nPython class Solution: def removeElement(self, nums: List[int], val: int) -\u0026gt; int: ptr = 0 for num in nums: if num != val: nums[ptr] = num ptr += 1 return ptr class Solution: def removeElement(self, nums: List[int], val: int) -\u0026gt; int: fast = slow = 0 while(fast \u0026lt; len(nums)): if(nums[fast] != val): nums[slow] = nums[fast] slow+=1 fast+=1 return slow Golang func removeElement(nums []int, val int) int { fast, slow := 0, 0 for fast \u0026lt; len(nums) { if nums[fast] !","title":"leetCode 27. Remove Element"},{"content":"👨‍💻簡介 last 用途：列出目前與過去登入系統的使用者相關資訊 語法 last [OPTIONS] [num,time,name,tty] 參數 參數 說明 -f file 指定登入的日誌檔案(預設是/var/log/wtmp) -num 指定last顯示幾行資訊 -n num 與-num相同 -t time[YYYYMMDDHHMMSS] 顯示指定時間的登入資訊 -R 不顯示主機名 -a 在最後一列顯示主機名 -d 將非本地登入的使用者ip轉換成主機名 -F 顯示所有的登入和登出時間和日期 -i 顯示ip地址而不是主機名 -o 讀取舊的日誌檔案 -w 顯示使用者名稱和域名 -x 顯示系統關機資訊和執行級別的變化資訊 欄位說明 last # output 1 2 3 4 5 alan pts/2 192.168.56.1 Mon Oct 25 21:37 still logged in reboot system boot 3.10.0-1160.42.2 Mon Oct 25 21:16 - 22:39 (01:22) alan pts/0 192.168.56.1 Sun Oct 24 23:18 - 05:47 (06:28) reboot system boot 3.10.0-1160.42.2 Sun Oct 24 23:15 - 22:39 (23:24) alan pts/2 192.168.56.1 Fri Oct 22 02:07 - 05:44 (03:37) 欄位 說明 登入用戶 顯示登錄用戶的姓名 登入終端 顯示用戶如何連接到系統，但如果是重啟進入，則是會顯示system boot 登入主機 顯示從哪連接到系統，欄位可為主機名或是IP位址(遠端)、空值(tty)、kernel版本(重啟)、應用程序(PID.windowID) 登入時間 顯示用戶登入的時間 登出時間 顯示用戶登出的時間，欄位可為時間戳(登出)、still running(開機)、still logged in(用戶登入中)、down(機器關機)、crash(系統崩潰) 基本操作 顯示最近登入的5筆資訊 last -5 or last -n 5 顯示用戶在某時段登入的資訊 last -t 20211026151111 root 顯示終端tty1的登入資訊 last 1 or last tty1 參考資料 Linux last Command | Baeldung on Linux Linux基礎命令—last | IT人 (iter01.com) ","permalink":"https://sz9751210.github.io/posts/linux-last/","summary":"👨‍💻簡介 last 用途：列出目前與過去登入系統的使用者相關資訊 語法 last [OPTIONS] [num,time,name,tty] 參數 參數 說明 -f file 指定登入的日誌檔案(預設是/var/log/wtmp) -num 指定last顯示幾行資訊 -n num 與-num相同 -t time[YYYYMMDDHHMMSS] 顯示指定時間的登入資訊 -R 不顯示主機名 -a 在最後一列顯示主機名 -d 將非本地登入的使用者ip轉換成主機名 -F 顯示所有的登入和登出時間和日期 -i 顯示ip地址而不是主機名 -o 讀取舊的日誌檔案 -w 顯示使用者名稱和域名 -x 顯示系統關機資訊和執行級別的變化資訊 欄位說明 last # output 1 2 3 4 5 alan pts/2 192.168.56.1 Mon Oct 25 21:37 still logged in reboot system boot 3.10.0-1160.42.2 Mon Oct 25 21:16 - 22:39 (01:22) alan pts/0 192.168.56.1 Sun Oct 24 23:18 - 05:47 (06:28) reboot system boot 3.","title":"Linux 列出登入資訊[last]"},{"content":"👨‍💻簡介 id 用途：顯示用戶的ID，以及所屬群組的ID。 語法 id [OPTIONS] userName 參數 參數 說明 -Z, \u0026ndash;context 顯示當前用戶的安全上下文 -g, \u0026ndash;group 顯示所屬群組ID -G, \u0026ndash;groups 顯示所有群組ID -n, \u0026ndash;name 顯示用戶 -r, \u0026ndash;real 顯示實際ID -u, \u0026ndash;user 顯示用戶ID 基本操作 顯示當前用戶訊息 id # output uid=1000(alan) gid=1000(alan) groups=1000(alan),996(vboxsf) context=unconfined_u:unconfined_r:unconfined_t:s0-s0:c0.c1023 顯示用戶群組id id -g # output 1000 顯示指定用戶訊息 id root ","permalink":"https://sz9751210.github.io/posts/linux-id/","summary":"👨‍💻簡介 id 用途：顯示用戶的ID，以及所屬群組的ID。 語法 id [OPTIONS] userName 參數 參數 說明 -Z, \u0026ndash;context 顯示當前用戶的安全上下文 -g, \u0026ndash;group 顯示所屬群組ID -G, \u0026ndash;groups 顯示所有群組ID -n, \u0026ndash;name 顯示用戶 -r, \u0026ndash;real 顯示實際ID -u, \u0026ndash;user 顯示用戶ID 基本操作 顯示當前用戶訊息 id # output uid=1000(alan) gid=1000(alan) groups=1000(alan),996(vboxsf) context=unconfined_u:unconfined_r:unconfined_t:s0-s0:c0.c1023 顯示用戶群組id id -g # output 1000 顯示指定用戶訊息 id root ","title":"Linux 顯示用戶資訊[id]"},{"content":"👨‍💻簡介 passwd 用途：修改使用者密碼 語法 passwd [OPTIONS] username 參數 參數 說明 -k, \u0026ndash;keep-tokens 保留未過期的驗證 token -d, \u0026ndash;delete 刪除 named 帳號的密碼 (只有 root 可執行) -l, \u0026ndash;lock 鎖住 named 帳號的密碼 (只有 root 可執行) -u, \u0026ndash;unlock 解開 named 帳號的密碼鎖定 (只有 root 可執行) -e, \u0026ndash;expire 讓 named 帳號的密碼過期 (只有 root 可執行) -f, \u0026ndash;force 強制作業 -x, \u0026ndash;maximum=DAYS 最大密碼有效期限 (只有 root 可執行) -n, \u0026ndash;minimum=DAYS 最小密碼有效期限 (只有 root 可執行) -w, \u0026ndash;warning=DAYS 用戶在密碼過期前收到警告的天數 (只有root可執行) -i, \u0026ndash;inactive=DAYS 帳號在密碼過期後即將被停用前的天數 (只有root可執行) -S, \u0026ndash;status 回報 named 帳號上的密碼狀態 (只有 root 可執行) \u0026ndash;stdin 由 stdin 讀取新的 token (只有 root 可執行) 基本操作 修改使用者密碼 passwd myuser 顯示使用者密碼狀態 passwd -S myuser # output myuser PS 2021-11-26 0 99999 7 -1 欄位 範例 帳號名稱 myuser 密碼狀態，狀態包含鎖定密碼(LK)、無密碼(NP)與可用密碼(PS) PS 上次修改密碼時間 2021-11-26 密碼最短使用期限，單位為天 0 密碼最長使用期限，單位為天 99999 密碼過期前警告期間，單位為天 7 密碼過期後可使用的期間，單位為天 -1 刪除使用者密碼 passwd -d myuser 讓密碼過期，強制使用者更新密碼 passwd -e myuser # 下次登入時，就會跳出通知說要更改密碼 You are required to change your password immediately (root enforced) WARNING: Your password has expired. You must change your password now and login again! Changing password for user myuser. Changing password for myuser. (current) UNIX password: 鎖定與解鎖使用者密碼 passwd -l myuser 此指令會使/etc/shadow的使用者密碼欄位前面多了!!\n該狀態下使用者無法變更帳號密碼\n要解除鎖定可用-u\npasswd -u myuser 設定密碼期限 # 至少五天才能改一次密碼 passwd -n 5 myuser # 密碼最多只能用30天 passwd -x 30 myuser # 快過期前7天送警告 passwd -w 7 myuser # 寬限期設定，超過5天將無法再登入 passwd -i 5 myuser 參考資料 Linux passwd命令 | 菜鸟教程 (runoob.com) Linux 的 passwd 指令範例教學 - G. T. Wang (gtwang.org) ","permalink":"https://sz9751210.github.io/posts/linux-passwd/","summary":"👨‍💻簡介 passwd 用途：修改使用者密碼 語法 passwd [OPTIONS] username 參數 參數 說明 -k, \u0026ndash;keep-tokens 保留未過期的驗證 token -d, \u0026ndash;delete 刪除 named 帳號的密碼 (只有 root 可執行) -l, \u0026ndash;lock 鎖住 named 帳號的密碼 (只有 root 可執行) -u, \u0026ndash;unlock 解開 named 帳號的密碼鎖定 (只有 root 可執行) -e, \u0026ndash;expire 讓 named 帳號的密碼過期 (只有 root 可執行) -f, \u0026ndash;force 強制作業 -x, \u0026ndash;maximum=DAYS 最大密碼有效期限 (只有 root 可執行) -n, \u0026ndash;minimum=DAYS 最小密碼有效期限 (只有 root 可執行) -w, \u0026ndash;warning=DAYS 用戶在密碼過期前收到警告的天數 (只有root可執行) -i, \u0026ndash;inactive=DAYS 帳號在密碼過期後即將被停用前的天數 (只有root可執行) -S, \u0026ndash;status 回報 named 帳號上的密碼狀態 (只有 root 可執行) \u0026ndash;stdin 由 stdin 讀取新的 token (只有 root 可執行) 基本操作 修改使用者密碼 passwd myuser 顯示使用者密碼狀態 passwd -S myuser # output myuser PS 2021-11-26 0 99999 7 -1 欄位 範例 帳號名稱 myuser 密碼狀態，狀態包含鎖定密碼(LK)、無密碼(NP)與可用密碼(PS) PS 上次修改密碼時間 2021-11-26 密碼最短使用期限，單位為天 0 密碼最長使用期限，單位為天 99999 密碼過期前警告期間，單位為天 7 密碼過期後可使用的期間，單位為天 -1 刪除使用者密碼 passwd -d myuser 讓密碼過期，強制使用者更新密碼 passwd -e myuser # 下次登入時，就會跳出通知說要更改密碼 You are required to change your password immediately (root enforced) WARNING: Your password has expired.","title":"Linux 修改密碼[passwd]"},{"content":"👨‍💻簡介 有時候修改掛載的config檔，無法即時更新，需要重啟pod才會生效，為了解決這個問題，k8s-reloader因此而誕生，透過觀察掛載的configmap或是secret的變化自動對掛載的物件做滾動更新。\n以下為在minikube環境下，透過掛載nginx-config檔並搭配reloader這個插件進行熱部署。\n🔗github-repo : stakater/Reloader: A Kubernetes controller to watch changes in ConfigMap and Secrets and do rolling upgrades on Pods with their associated Deployment, StatefulSet, DaemonSet and DeploymentConfig – [✩Star] if you\u0026rsquo;re using it! (github.com) 🔰基礎介紹 運作原理 Reloader偵測所有資源變化，對有變化的資源使用SHA1計算資源的哈西值 Reloader查看是否有設定相關的annotation，並查看有設定annotation資源的特殊環境變量 對有設定annotation的資源比對其哈希值，如果環境變量中哈希值不同，則更新環境變量，如果環境變量不存在，則創建一個 環境變量名稱 ConfigMap：STAKATER_{configmap_name}_CONFIGMAP ，比如 ConfigMap 的名稱為 foo，則生成的環境變量的名稱為：STAKATER_FOO_CONFIGMAP。 Secret：STAKATER_{secret_name}_SECRET ，比如 Secret 的名稱為 foo，則生成的環境變量的名稱為：STAKATER_FOO_SECRET。 環境變量的值 使用 SHA1 計算的 ConfigMap 或者 Secret 的哈希值。\n版本需求 k8s版本需 \u0026gt;= 1.9\n安裝方式 使用Manifests安裝 kubectl apply -f https://raw.githubusercontent.com/stakater/Reloader/master/deployments/kubernetes/reloader.yaml 使用Kustomize安裝 kubectl apply -k https://github.com/stakater/Reloader/deployments/kubernetes apiVersion: kustomize.config.k8s.io/v1beta1 kind: Kustomization bases: - https://github.com/stakater/Reloader/deployments/kubernetes namespace: reloader 使用Helm安裝 helm repo add stakater https://stakater.github.io/stakater-charts helm repo update helm install stakater/reloader # For helm3 add --generate-name flag or set the release name 預設情況下，reloader會偵測所有namespace的資源，如果要針對單一namespace可使用--set reloader.watchGlobally為false，以下範例為安裝在test namespace並只偵測test namespace底下的資源\nhelm install stakater/reloader --set reloader.watchGlobally=false --namespace test # For helm3 add --generate-name flag or set the release name 使用方式 自動偵測所有資源 設定reloader.stakater.com/auto: \u0026quot;true\u0026quot;\nkind: Deployment metadata: annotations: reloader.stakater.com/auto: \u0026#34;true\u0026#34; spec: template: metadata: 限制只偵測有設定annotations的資源 deploy設定reloader.stakater.com/search: \u0026quot;true\u0026quot;，configmap等資源設定reloader.stakater.com/match: \u0026quot;true\u0026quot;\nkind: Deployment metadata: annotations: reloader.stakater.com/search: \u0026#34;true\u0026#34; spec: template: --- kind: ConfigMap metadata: annotations: reloader.stakater.com/match: \u0026#34;true\u0026#34; data: key: value reloader.stakater.com/auto與reloader.stakater.com/search不能同時使用\n如果使用reloader.stakater.com/auto，則reloader.stakater.com/match不管有沒有設定都會被偵測\n只偵測特定資源 資源使用,做分隔\nConfigmap kind: Deployment metadata: annotations: configmap.reloader.stakater.com/reload: \u0026#34;foo-configmap\u0026#34; spec: template: metadata: Secret kind: Deployment metadata: annotations: secret.reloader.stakater.com/reload: \u0026#34;foo-secret,bar-secret,baz-secret\u0026#34; spec: template: metadata: 🎯setup 部署reloader kubectl apply -f https://raw.githubusercontent.com/stakater/Reloader/master/deployments/kubernetes/reloader.yaml 部署nginx服務\n建立以下檔案 apiVersion: v1 kind: ConfigMap metadata: name: nginx-map annotations: reloader.stakater.com/match: \u0026#34;true\u0026#34; data: test.conf: | server { listen 80; server_name abc.com; location / { root /usr/share/nginx/html ; index index.html index.htm; } } --- apiVersion: apps/v1 kind: Deployment metadata: name: nginx annotations: configmap.reloader.stakater.com/reload: \u0026#34;nginx-map\u0026#34; spec: replicas: 2 selector: matchLabels: service: http-server template: metadata: labels: service: http-server spec: containers: - name: nginx image: sz9751210/nginx-reloader:v1 imagePullPolicy: IfNotPresent ports: - containerPort: 80 volumeMounts: - mountPath: /etc/nginx/conf.d # mount nginx-conf volumn to /etc/nginx/conf.d readOnly: true name: deployment-nginx-conf volumes: - name: deployment-nginx-conf configMap: name: nginx-map # place ConfigMap `nginx-conf` on /etc/nginx --- apiVersion: v1 kind: Service metadata: name: nginx-service spec: selector: service: http-server ports: - port: 80 targetPort: 80 部署 kubectl apply -f k8s-reloader-demo.yaml 打開瀏覽器查看nginx\nminikube service nginx-service --url 預設應該會顯示default page\n這時候將configmap裡的index.html改成index.html1\n這時候刷新頁面就會看到顯示reload page了\nReference stakater/Reloader: A Kubernetes controller to watch changes in ConfigMap and Secrets and do rolling upgrades on Pods with their associated Deployment, StatefulSet, DaemonSet and DeploymentConfig\n【k8s】使用 Reloader 实现热部署\nConfigMap Reloader — Automatically reload new data from ConfigMap/Secret to deployments | by Navratan Lal Gupta | Linux Shots | Medium\n","permalink":"https://sz9751210.github.io/posts/k8s-reloader/","summary":"👨‍💻簡介 有時候修改掛載的config檔，無法即時更新，需要重啟pod才會生效，為了解決這個問題，k8s-reloader因此而誕生，透過觀察掛載的configmap或是secret的變化自動對掛載的物件做滾動更新。\n以下為在minikube環境下，透過掛載nginx-config檔並搭配reloader這個插件進行熱部署。\n🔗github-repo : stakater/Reloader: A Kubernetes controller to watch changes in ConfigMap and Secrets and do rolling upgrades on Pods with their associated Deployment, StatefulSet, DaemonSet and DeploymentConfig – [✩Star] if you\u0026rsquo;re using it! (github.com) 🔰基礎介紹 運作原理 Reloader偵測所有資源變化，對有變化的資源使用SHA1計算資源的哈西值 Reloader查看是否有設定相關的annotation，並查看有設定annotation資源的特殊環境變量 對有設定annotation的資源比對其哈希值，如果環境變量中哈希值不同，則更新環境變量，如果環境變量不存在，則創建一個 環境變量名稱 ConfigMap：STAKATER_{configmap_name}_CONFIGMAP ，比如 ConfigMap 的名稱為 foo，則生成的環境變量的名稱為：STAKATER_FOO_CONFIGMAP。 Secret：STAKATER_{secret_name}_SECRET ，比如 Secret 的名稱為 foo，則生成的環境變量的名稱為：STAKATER_FOO_SECRET。 環境變量的值 使用 SHA1 計算的 ConfigMap 或者 Secret 的哈希值。\n版本需求 k8s版本需 \u0026gt;= 1.9\n安裝方式 使用Manifests安裝 kubectl apply -f https://raw.","title":"k8s-reloader"},{"content":"👨‍💻簡介 timedatectl 用途：修改系統時間 語法 timedatectl [OPTIONS] command 參數 參數 說明 \u0026ndash;no-pager 不將程序的輸出內容管道(pipe)給分頁程序 \u0026ndash;no-ask-password 在執行特權操作時不向用戶索要密碼。 -H \u0026ndash;host=[USER@]HOST 操作指定的遠程主機 -M \u0026ndash;machine=CONTAINER 在本地容器內執行操作。 必須明確指定容器的名稱。 \u0026ndash;adjust-system-clock 當使用set-local-rtc命令時，若使用了此選項，則表示根據RTC時間來更新系統時鐘。若未使用此選項，則表示根據系統時鐘來更新RTC時間 指令 指令 說明 status 顯示系統時鐘與RTC的當前狀態， 包括時區設置與網絡時間同步服務的狀態。 set-time TIME 將系統時鐘設爲指定的時間， 並同時更新RTC時間。 [TIME] 是一個形如 \u0026ldquo;2012-10-30 18:17:16\u0026quot;的時間字符串。 set-timezone ZONE 設置系統時區，也就是更新 /etc/localtime 軟連接的指向。 可以用下面的 list-timezones命令列出所有可用時區。 如果RTC被設爲本地時間， 此命令還會同時更新RTC時間。 list-timezones 列出所有可用時區，每行一個。 列出的值可以用作前述 set-timezone 命令的參數。 set-local-rtc BOOL 設爲 \u0026ldquo;no\u0026rdquo; 表示在RTC中存儲UTC時間； 設爲 \u0026ldquo;yes\u0026rdquo; 表示在RTC中存儲本地時間。應該盡一切可能在RTC中存儲UTC時間 set-ntp BOOL 是否開啓網絡時間同步。 設爲 \u0026ldquo;yes\u0026rdquo; 則啓用並啓動 systemd-timesyncd.service 服務， 設爲\u0026quot;no\u0026rdquo; 則停止並停用它 基本操作 顯示當前系統時間 timedatectl or timedatectl status 開啟網路時間同步服務 timedatectl set-ntp true 設定日期與時間 # 改時間和日期 timedatectl set-time \u0026#34;2021-11-01 10:10:00\u0026#34; # 只改日期 timedatectl set-time \u0026#34;2021-11-01\u0026#34; timedatectl set-time 20211101 # 只改時間 timedatectl set-time \u0026#34;10:10:00\u0026#34; timedatectl set-time 10:10:00 檢查時區 timedatectl list-timezones # 根據地理位置查看時區 timedatectl list-timezones | grep \u0026#34;Asia/B.*\u0026#34; 設定時區 timedatectl set-timezone \u0026#34;Asia/Taipei\u0026#34; # 設定為世界協調時間(UTC) timedatectl set-timezone UTC 參考資料 Ubuntu Manpage: timedatectl - 控制系統的時間與日期 Linux 手動更改系統時間：date、hwclock 與 timedatectl 指令用法教學 - G. T. Wang (gtwang.org) Linux下使用timedatectl命令時間時區操作詳解_osc_02985929 - MdEditor (gushiciku.cn) 相關指令 date hwclock ","permalink":"https://sz9751210.github.io/posts/linux-timedatectl/","summary":"👨‍💻簡介 timedatectl 用途：修改系統時間 語法 timedatectl [OPTIONS] command 參數 參數 說明 \u0026ndash;no-pager 不將程序的輸出內容管道(pipe)給分頁程序 \u0026ndash;no-ask-password 在執行特權操作時不向用戶索要密碼。 -H \u0026ndash;host=[USER@]HOST 操作指定的遠程主機 -M \u0026ndash;machine=CONTAINER 在本地容器內執行操作。 必須明確指定容器的名稱。 \u0026ndash;adjust-system-clock 當使用set-local-rtc命令時，若使用了此選項，則表示根據RTC時間來更新系統時鐘。若未使用此選項，則表示根據系統時鐘來更新RTC時間 指令 指令 說明 status 顯示系統時鐘與RTC的當前狀態， 包括時區設置與網絡時間同步服務的狀態。 set-time TIME 將系統時鐘設爲指定的時間， 並同時更新RTC時間。 [TIME] 是一個形如 \u0026ldquo;2012-10-30 18:17:16\u0026quot;的時間字符串。 set-timezone ZONE 設置系統時區，也就是更新 /etc/localtime 軟連接的指向。 可以用下面的 list-timezones命令列出所有可用時區。 如果RTC被設爲本地時間， 此命令還會同時更新RTC時間。 list-timezones 列出所有可用時區，每行一個。 列出的值可以用作前述 set-timezone 命令的參數。 set-local-rtc BOOL 設爲 \u0026ldquo;no\u0026rdquo; 表示在RTC中存儲UTC時間； 設爲 \u0026ldquo;yes\u0026rdquo; 表示在RTC中存儲本地時間。應該盡一切可能在RTC中存儲UTC時間 set-ntp BOOL 是否開啓網絡時間同步。 設爲 \u0026ldquo;yes\u0026rdquo; 則啓用並啓動 systemd-timesyncd.service 服務， 設爲\u0026quot;no\u0026rdquo; 則停止並停用它 基本操作 顯示當前系統時間 timedatectl or timedatectl status 開啟網路時間同步服務 timedatectl set-ntp true 設定日期與時間 # 改時間和日期 timedatectl set-time \u0026#34;2021-11-01 10:10:00\u0026#34; # 只改日期 timedatectl set-time \u0026#34;2021-11-01\u0026#34; timedatectl set-time 20211101 # 只改時間 timedatectl set-time \u0026#34;10:10:00\u0026#34; timedatectl set-time 10:10:00 檢查時區 timedatectl list-timezones # 根據地理位置查看時區 timedatectl list-timezones | grep \u0026#34;Asia/B.","title":"Linux 修改時間[timedatectl]"},{"content":"👨‍💻簡介 sed(stream editor) 用途：用於處理文件，字串取代、複製、刪除等功能，進行處理時並不會改變當前的檔案，而是將處理過程存放在[模式空間]的緩衝區，結束目前的指令後輸出，接著再處理下一個指令直到結束 語法 sed [OPTIONS] script or inputfile 參數(常用) 參數 說明 -n, \u0026ndash;quiet, \u0026ndash;silent 沈默模式 -e script, \u0026ndash;expression=script 直接在命令模式設定好script來進行編輯 -f script檔案, \u0026ndash;file=script檔案 使用指定的script檔案來進行編輯 -i 修改檔案，常用於自動化腳本 動作 說明 a 新增，在指定的行數的「下一行」插入字串。未指定行數的話則是在「每一行」之後插入字串 c 取代，替換指定行數為預替換的字串 d 刪除，刪除指定的行。常與-i選項搭配，用來修改檔案時移除不需要的行 i 插入，與a相同，差別在於a指令是在指定行數之後插入，i是在指定行數之前插入 p 列印，通常搭配-n選項做使用，只列印出受影響的行數 s 取代，支持正則表達式，用來取代字串 flags 說明 [0-9] 數字表示只搜尋或者取代第 N 個數字所指示的那個樣板字串 g 全部取代 I 忽略大小寫 w 把符合的結果寫入檔案。和加了 -n 選項搭配 p 旗標的結果一樣。此旗標如果有和其它旗標搭配使用，必須放在最後面 基本操作 參數 搭配文件sed.txt\nI have a pen, I have an apple Ah Apple pen I have a pen, I have pineapple Ah Pineapple pen Apple pen Pineapple pen Ah Pen Pie Pineapple Apple Pen Pen Pie Pineapple Apple Pen 使用-n沈默模式 # 使用s取代每一行第一次出現的have修改成had sed -n \u0026#39;s/have/had/1p\u0026#39; sed.txt # 透過沈默模式修改文件，默認不會印出東西，需搭配p則會顯示有修改的行 使用-e設定規則 # 把檔案中每行第一次出現的的pen換成pencil並存到sed_output.txt，-e為默認選項，可加可不加 sed -e \u0026#39;s/pen/pencil/\u0026#39; sed.txt \u0026gt; sed_output.txt # 多條件方式，有-e不需要分號分隔，無-e則需要做分隔 sed -e \u0026#39;s/pen/pencil/\u0026#39; -e \u0026#39;s/have/had/\u0026#39; sed.txt sed \u0026#39;s/pen/pencil/; s/have/had/\u0026#39; sed.txt 使用-f指定script檔案進行修改 假設有個script檔案sed_command.txt如下\ns/pen/pencil/ s/have/had/ # 將每一行第一次出現的pen以及have做替換 sed -f sed_command.txt sed.txt 使用-i直接修改檔案 sed -i \u0026#39;s/pen/pencil/\u0026#39; sed.txt 動作 使用a新增字串 # 在第一行之後新增字串 sed \u0026#39;1a I have both\u0026#39; sed.txt # 多行新增，在第一行到第四行這四行的後面都新增字串 sed \u0026#39;1,4a I have both\u0026#39; sed.txt 使用c做字串替換 # 取代第二行，改為I have both sed \u0026#39;2c I have both\u0026#39; sed.txt # 多行取代，將1到5行壓縮為一行並改為字串 sed \u0026#39;1,5c I have both\u0026#39; sed.txt 使用d進行刪除指定行或字串行 # 刪除第一行 sed 1d sed.txt # 刪除一到五行 sed 1,5d sed.txt # 刪除pen出現的行 sed \u0026#39;/pen/d\u0026#39; sed.txt 使用i進行插入 # 在第一行之前插入字串 sed \u0026#39;1i I have both\u0026#39; sed.txt # 在第一到第三行的每行之前插入字串 sed \u0026#39;1,3i I have both\u0026#39; sed.txt 使用p進行列印出影響行，通常配合-n選項搭配使用 # 將have取代為had並列印出來 sed -n \u0026#39;s/have/had/1p\u0026#39; sed.txt 使用s做字串取代 語法格式\ns/regexp/replacement/[flags] 參考資料 sed, a stream editor (gnu.org) Linux sed 命令 | 菜鸟教程 (runoob.com) 在 Linux 命令列中轉換大小寫 | IT人 (iter01.com) Linux 指令 SED 用法教學、取代範例、詳解 - TerryL Linux sed 字串取代用法與範例 | ShengYu Talk (shengyu7697.github.io) ","permalink":"https://sz9751210.github.io/posts/linux-sed/","summary":"👨‍💻簡介 sed(stream editor) 用途：用於處理文件，字串取代、複製、刪除等功能，進行處理時並不會改變當前的檔案，而是將處理過程存放在[模式空間]的緩衝區，結束目前的指令後輸出，接著再處理下一個指令直到結束 語法 sed [OPTIONS] script or inputfile 參數(常用) 參數 說明 -n, \u0026ndash;quiet, \u0026ndash;silent 沈默模式 -e script, \u0026ndash;expression=script 直接在命令模式設定好script來進行編輯 -f script檔案, \u0026ndash;file=script檔案 使用指定的script檔案來進行編輯 -i 修改檔案，常用於自動化腳本 動作 說明 a 新增，在指定的行數的「下一行」插入字串。未指定行數的話則是在「每一行」之後插入字串 c 取代，替換指定行數為預替換的字串 d 刪除，刪除指定的行。常與-i選項搭配，用來修改檔案時移除不需要的行 i 插入，與a相同，差別在於a指令是在指定行數之後插入，i是在指定行數之前插入 p 列印，通常搭配-n選項做使用，只列印出受影響的行數 s 取代，支持正則表達式，用來取代字串 flags 說明 [0-9] 數字表示只搜尋或者取代第 N 個數字所指示的那個樣板字串 g 全部取代 I 忽略大小寫 w 把符合的結果寫入檔案。和加了 -n 選項搭配 p 旗標的結果一樣。此旗標如果有和其它旗標搭配使用，必須放在最後面 基本操作 參數 搭配文件sed.txt\nI have a pen, I have an apple Ah Apple pen I have a pen, I have pineapple Ah Pineapple pen Apple pen Pineapple pen Ah Pen Pie Pineapple Apple Pen Pen Pie Pineapple Apple Pen 使用-n沈默模式 # 使用s取代每一行第一次出現的have修改成had sed -n \u0026#39;s/have/had/1p\u0026#39; sed.","title":"Linux 修改字串[sed]"},{"content":"👨‍💻簡介 grep 用途：查找文件內符合條件的字符串 語法 grep [-abcEFGhHilLnqrsvVwxy][-A\u0026lt;顯示行數\u0026gt;][-B\u0026lt;顯示列數\u0026gt;][-C\u0026lt;顯示列數\u0026gt;][-d\u0026lt;進行動作\u0026gt;][-e\u0026lt;範本樣式\u0026gt;][-f\u0026lt;範本文件\u0026gt;][--help][範本樣式][文件或目錄...] 參數 正規表示式選項 說明 -E, \u0026ndash;extended-regexp 使用擴展正則表達式 -F, \u0026ndash;fixed-strings 將樣式視為固定字符串的列表 -G, \u0026ndash;basic-regexp 將樣式視為普通的表示法來使用 -P, \u0026ndash;perl-regexp 將樣式視為perl的表示法來使用 -e, \u0026ndash;regexp=PATTERN 指定字符串做為查找文件內容的樣式 -f, \u0026ndash;file=FILE 指定規則文件，其內容含有一個或多個規則樣式，讓grep查找符合規則條件的文件內容，格式為每行一個規則樣式 -i, \u0026ndash;ignore-case 忽略大小寫的差異 -w, \u0026ndash;word-regexp 只匹配整個單詞，而不是字符串的一部分 -x, \u0026ndash;line-regexp 只顯示全列符合的列 -z, \u0026ndash;null-data 設定資料列結尾為空白位元組，非換列符號 -s, \u0026ndash;no-messages 不顯示不存在或無匹配文本的錯誤信息 -v, \u0026ndash;invert-match 將匹配的資料排除 參數 說明 -m, \u0026ndash;max-count=NUM 在達到 NUM 符合項目後停止 -b, \u0026ndash;byte-offset 在顯示符合樣式的那一行之前，標示出該行第一個字符的編號 -n, \u0026ndash;line-number 標示匹配文字的行號 \u0026ndash;line-buffered 輸出每列後清除輸出 -H, \u0026ndash;with-filename 印出每個符合項目的檔名 -h, \u0026ndash;no-filename 查詢多文件時不顯示文件名 \u0026ndash;label=LABEL 以 LABEL 作標準輸入的檔名前綴 -o, \u0026ndash;only-matching 只顯示每列中符合 PATTERN 的部分 -q, \u0026ndash;quiet, \u0026ndash;silent 不顯示任何信息 \u0026ndash;binary-files=TYPE 設定二進制檔案為 TYPE 的檔案;TYPE 為 \u0026ldquo;binary\u0026rdquo;、\u0026ldquo;text\u0026rdquo; 或 \u0026ldquo;without-match\u0026rdquo; -a, \u0026ndash;text 不要忽略二進制的數據 -I 不匹配二進制的東西 -d, \u0026ndash;directories=ACTION 目錄操作的動作，讀取、遞歸、跳過 -D, \u0026ndash;devices=ACTION 設置對設備的動作，FIFO和管道的操作，動作有，讀取、跳過 -r, \u0026ndash;recursive 在指定目錄與其子目錄下所有的檔案中，搜尋指定的關鍵字 -R, \u0026ndash;dereference-recursive 與-r相同，但遵循軟連結 \u0026ndash;include=FILE_PATTERN 從特定的檔案中尋找關鍵字 \u0026ndash;exclude=FILE_PATTERN 跳過匹配FILE_PATTERN 的文件和目錄 \u0026ndash;exclude-from=FILE 跳過所有除FILE 以外的文件 \u0026ndash;exclude-dir=PATTERN 跳過匹配PATTERN 的目錄 -L, \u0026ndash;files-without-match 列出不匹配的文件名 -l, \u0026ndash;files-with-matches 只列出匹配的文件名 -c, \u0026ndash;count 只輸出匹配行的計數 -Z, \u0026ndash;null 在搜尋的字串後面印出空字符 內容控制 說明 -B, \u0026ndash;before-context=NUM 顯示前幾行 -A, \u0026ndash;after-context=NUM 顯示後幾行 -C, \u0026ndash;context=NUM, -NUM 顯示前後各幾行 \u0026ndash;group-separator=SEP 使用A、-B或-C時，在組之間打印SEP而不是\u0026ndash;線 \u0026ndash;no-group-separator 使用A、-B或-C時，在組之間不打印seperator \u0026ndash;color[=WHEN],\u0026ndash;colour[=WHEN] 使用顏色標示的方式，將成功匹配的部分文字標示出來，方便使用者閱讀。顏色標示功能可以透過 --color=never、--color=always、--color=auto 這幾種參數來關閉、開啟或設為自動 -U, \u0026ndash;binary 使用標誌高亮匹配字串 -u, \u0026ndash;unix-byte-offsets 使用標誌高亮匹配字串 基本操作 指定文件查詢關鍵字 # 在file這個文件裡尋找test關鍵字 grep test file 透過匹配方式搜尋 # 在/etc/目錄下所有.conf檔搜尋linux關鍵字 grep linux /etc/*.conf 不分大小寫搜尋 # 在當前目錄底下搜尋linux關鍵字 grep -i linux . 反向匹配 # 在當前目錄下，顯示不包含linux的行 grep -v linux . 顯示行號 grep -n linux . 遞迴搜尋檔案 # 在當前目錄及其子目錄下，搜尋linux關鍵字 grep -r linux . # 在當前目錄及其子目錄下，並且檔名為log結尾的文件，搜尋linux關鍵字 grep -r --include=\u0026#34;*.log\u0026#34; linux . 不顯示錯誤訊息 grep linux . 2\u0026gt;/dev/null 顯示前後幾行 # 多顯示後一行 grep -A 1 linux . # 多顯示前一行 grep -B 1 linux . # 多顯示前後各一行 grep -C 1 linux . 實用範例 # 依照時間排序並計算哪個時間log數量最多 grep -oP \u0026#39;2021:[0-2][0-9]:[0-5][0-9]\u0026#39;| sort | uniq -c 參考資料 grep linux 命令 在线中文手册 (51yip.com) grep(1) - Linux manual page (man7.org) Linux 匹配文字 grep 指令用法教學與範例 - G. T. Wang (gtwang.org) ","permalink":"https://sz9751210.github.io/posts/linux-grep/","summary":"👨‍💻簡介 grep 用途：查找文件內符合條件的字符串 語法 grep [-abcEFGhHilLnqrsvVwxy][-A\u0026lt;顯示行數\u0026gt;][-B\u0026lt;顯示列數\u0026gt;][-C\u0026lt;顯示列數\u0026gt;][-d\u0026lt;進行動作\u0026gt;][-e\u0026lt;範本樣式\u0026gt;][-f\u0026lt;範本文件\u0026gt;][--help][範本樣式][文件或目錄...] 參數 正規表示式選項 說明 -E, \u0026ndash;extended-regexp 使用擴展正則表達式 -F, \u0026ndash;fixed-strings 將樣式視為固定字符串的列表 -G, \u0026ndash;basic-regexp 將樣式視為普通的表示法來使用 -P, \u0026ndash;perl-regexp 將樣式視為perl的表示法來使用 -e, \u0026ndash;regexp=PATTERN 指定字符串做為查找文件內容的樣式 -f, \u0026ndash;file=FILE 指定規則文件，其內容含有一個或多個規則樣式，讓grep查找符合規則條件的文件內容，格式為每行一個規則樣式 -i, \u0026ndash;ignore-case 忽略大小寫的差異 -w, \u0026ndash;word-regexp 只匹配整個單詞，而不是字符串的一部分 -x, \u0026ndash;line-regexp 只顯示全列符合的列 -z, \u0026ndash;null-data 設定資料列結尾為空白位元組，非換列符號 -s, \u0026ndash;no-messages 不顯示不存在或無匹配文本的錯誤信息 -v, \u0026ndash;invert-match 將匹配的資料排除 參數 說明 -m, \u0026ndash;max-count=NUM 在達到 NUM 符合項目後停止 -b, \u0026ndash;byte-offset 在顯示符合樣式的那一行之前，標示出該行第一個字符的編號 -n, \u0026ndash;line-number 標示匹配文字的行號 \u0026ndash;line-buffered 輸出每列後清除輸出 -H, \u0026ndash;with-filename 印出每個符合項目的檔名 -h, \u0026ndash;no-filename 查詢多文件時不顯示文件名 \u0026ndash;label=LABEL 以 LABEL 作標準輸入的檔名前綴 -o, \u0026ndash;only-matching 只顯示每列中符合 PATTERN 的部分 -q, \u0026ndash;quiet, \u0026ndash;silent 不顯示任何信息 \u0026ndash;binary-files=TYPE 設定二進制檔案為 TYPE 的檔案;TYPE 為 \u0026ldquo;binary\u0026rdquo;、\u0026ldquo;text\u0026rdquo; 或 \u0026ldquo;without-match\u0026rdquo; -a, \u0026ndash;text 不要忽略二進制的數據 -I 不匹配二進制的東西 -d, \u0026ndash;directories=ACTION 目錄操作的動作，讀取、遞歸、跳過 -D, \u0026ndash;devices=ACTION 設置對設備的動作，FIFO和管道的操作，動作有，讀取、跳過 -r, \u0026ndash;recursive 在指定目錄與其子目錄下所有的檔案中，搜尋指定的關鍵字 -R, \u0026ndash;dereference-recursive 與-r相同，但遵循軟連結 \u0026ndash;include=FILE_PATTERN 從特定的檔案中尋找關鍵字 \u0026ndash;exclude=FILE_PATTERN 跳過匹配FILE_PATTERN 的文件和目錄 \u0026ndash;exclude-from=FILE 跳過所有除FILE 以外的文件 \u0026ndash;exclude-dir=PATTERN 跳過匹配PATTERN 的目錄 -L, \u0026ndash;files-without-match 列出不匹配的文件名 -l, \u0026ndash;files-with-matches 只列出匹配的文件名 -c, \u0026ndash;count 只輸出匹配行的計數 -Z, \u0026ndash;null 在搜尋的字串後面印出空字符 內容控制 說明 -B, \u0026ndash;before-context=NUM 顯示前幾行 -A, \u0026ndash;after-context=NUM 顯示後幾行 -C, \u0026ndash;context=NUM, -NUM 顯示前後各幾行 \u0026ndash;group-separator=SEP 使用A、-B或-C時，在組之間打印SEP而不是\u0026ndash;線 \u0026ndash;no-group-separator 使用A、-B或-C時，在組之間不打印seperator \u0026ndash;color[=WHEN],\u0026ndash;colour[=WHEN] 使用顏色標示的方式，將成功匹配的部分文字標示出來，方便使用者閱讀。顏色標示功能可以透過 --color=never、--color=always、--color=auto 這幾種參數來關閉、開啟或設為自動 -U, \u0026ndash;binary 使用標誌高亮匹配字串 -u, \u0026ndash;unix-byte-offsets 使用標誌高亮匹配字串 基本操作 指定文件查詢關鍵字 # 在file這個文件裡尋找test關鍵字 grep test file 透過匹配方式搜尋 # 在/etc/目錄下所有.","title":"Linux 篩選字串[grep]"},{"content":"👨‍💻簡介 rsync 用途：用來複製與備份檔案的工具，它可以處理本機或遠端的檔案同步工作 語法 rsync [OPTIONS] src [dest/user@host:dest] 參數 參數 說明 -v, \u0026ndash;verbose verbose 模式，輸出比較詳細的訊息 -r, \u0026ndash;recursive 遞迴（recursive）備份所有子目錄下的目錄與檔案 -a, \u0026ndash;archive 封裝備份模式，相當於 -rlptgoD，遞迴備份所有子目錄下的目錄與檔案，保留連結檔、檔案的擁有者、群組、權限以及時間戳記 -z, \u0026ndash;compress 啟用壓縮，可減少網路傳輸資料量 -h, \u0026ndash;human-readable 將數字以比較容易閱讀的格式輸出 -q, –quiet 與 -v 相反，安靜模式，略過正常資訊，僅顯示錯誤訊息 -l, –links 複製連結而不是連結內容 -g, –group 保留檔案的原始群組狀態(權限不足則無法繼承) -o, –owner 保留檔案的原始擁有者(權限不足則無法繼承) -t,–times 保留檔案的原始時間參數 -e 使用的通道協定，例如使用 ssh 通道，則 -e ssh -u, \u0026ndash;update 在備份時會略過所有已經存在於目的端，且文件時間比要備份的檔案為新的檔案 -p, \u0026ndash;perms 表示要保留檔案的權限資訊 -D 表示要保留設備檔案資訊 \u0026ndash;delete 刪除來源端已經不存在但在目的端存在的檔案 \u0026ndash;force 當目的端的目錄被覆蓋時，就強制先刪除該目錄 \u0026ndash;bwlimit=RATE 限制資料傳輸速度上限 \u0026ndash;progress 即時顯示傳輸進度 \u0026ndash;exclude=PATTERN 排除符合匹配的檔案 \u0026ndash;include=PATTERN 只備份符合匹配的檔案 \u0026ndash;min-size=SIZE 指定備份檔案的最小值 \u0026ndash;max-size=SIZE 指定備份檔案的最大值 \u0026ndash;remove-source-files 自動刪除來源檔案 -n, \u0026ndash;dry-run debug模式，測試rsync餐數 \u0026ndash;existing 只更新既有的檔案，排除新增的檔案 -i, \u0026ndash;itemize-changes 查看個別檔案的變動資訊 基本操作 複製本地端檔案或目錄 rsync -avh mylog.log /local/path/ rsync -avh /mypath /home/alan/ 本地備份至遠端，將本地myfile.gz備份到遠端/remote/path/目錄下 rsync -avzh ./myfile.gz host@ip:/remote/path/ 遠端備份至本地 rsync -avzh host@ip:/remote/path/myfile.gz /local/path 限制網速 rsync -avzh --bwlimit=100k host@ip:/remote/path/myfile.gz /local/path 顯示傳輸進度 rsync -avzh --progress host@ip:/remote/path/myfile.gz /local/path 同步刪除目的端檔案 rsync -avzh --delete host@ip:/remote/path/myfile.gz /local/path 備份特定檔案 # 排除掉結尾為.txt的檔案 rsync -avh --exclude \u0026#39;*.txt\u0026#39; src/path dest/path # 只備份結尾為.txt的檔案 rsync -avh --include \u0026#39;*.txt\u0026#39; src/path dest/path 限制檔案大小 # 只備份1mb以上的檔案 rsync -avh --min-size=1m src/path dest/path # 只備份最大1k的檔案 rsync -avh --max-size=1k src/path dest/path # 只備份1k以上1mb以下的檔案 rsync -avh --min-size=1k --max-size=1m src/path dest/path 自動刪除來源檔案 # 將src/path的檔案備份到dest/path後清空，相當於mv的效果 rsync -avh --remove-source-files src/path dest/path 10, 測試rsync參數\nrsync -avh --dry-run src/path dest/path 搭配crontab做定期備份 # m h dom mon dow command 0 5 * * 1 rsync -a /path/to/folder /path/to/backup/ 只更新已存在的檔案 rsync -avh --existing src/path dest/path 參考資料 Rsync Command in Linux with Examples | Linuxize Linux 使用 rsync 遠端檔案同步與備份工具教學與範例 - G. T. Wang (gtwang.org) Linux下如何使用Rsync備份伺服器重要資料 | IT人 (iter01.com) 相關指令 scp ","permalink":"https://sz9751210.github.io/posts/linux-rsync/","summary":"👨‍💻簡介 rsync 用途：用來複製與備份檔案的工具，它可以處理本機或遠端的檔案同步工作 語法 rsync [OPTIONS] src [dest/user@host:dest] 參數 參數 說明 -v, \u0026ndash;verbose verbose 模式，輸出比較詳細的訊息 -r, \u0026ndash;recursive 遞迴（recursive）備份所有子目錄下的目錄與檔案 -a, \u0026ndash;archive 封裝備份模式，相當於 -rlptgoD，遞迴備份所有子目錄下的目錄與檔案，保留連結檔、檔案的擁有者、群組、權限以及時間戳記 -z, \u0026ndash;compress 啟用壓縮，可減少網路傳輸資料量 -h, \u0026ndash;human-readable 將數字以比較容易閱讀的格式輸出 -q, –quiet 與 -v 相反，安靜模式，略過正常資訊，僅顯示錯誤訊息 -l, –links 複製連結而不是連結內容 -g, –group 保留檔案的原始群組狀態(權限不足則無法繼承) -o, –owner 保留檔案的原始擁有者(權限不足則無法繼承) -t,–times 保留檔案的原始時間參數 -e 使用的通道協定，例如使用 ssh 通道，則 -e ssh -u, \u0026ndash;update 在備份時會略過所有已經存在於目的端，且文件時間比要備份的檔案為新的檔案 -p, \u0026ndash;perms 表示要保留檔案的權限資訊 -D 表示要保留設備檔案資訊 \u0026ndash;delete 刪除來源端已經不存在但在目的端存在的檔案 \u0026ndash;force 當目的端的目錄被覆蓋時，就強制先刪除該目錄 \u0026ndash;bwlimit=RATE 限制資料傳輸速度上限 \u0026ndash;progress 即時顯示傳輸進度 \u0026ndash;exclude=PATTERN 排除符合匹配的檔案 \u0026ndash;include=PATTERN 只備份符合匹配的檔案 \u0026ndash;min-size=SIZE 指定備份檔案的最小值 \u0026ndash;max-size=SIZE 指定備份檔案的最大值 \u0026ndash;remove-source-files 自動刪除來源檔案 -n, \u0026ndash;dry-run debug模式，測試rsync餐數 \u0026ndash;existing 只更新既有的檔案，排除新增的檔案 -i, \u0026ndash;itemize-changes 查看個別檔案的變動資訊 基本操作 複製本地端檔案或目錄 rsync -avh mylog.","title":"Linux 同步檔案[rsync]"},{"content":"👨‍💻簡介 find 用途：在目錄中找尋文件 語法 find path [OPTIONS] 參數(常用) 參數 說明 -mount, -xdev 只檢查和指定目錄在同一個文件系統下的文件，避免列出其它文件系統中的文件 -amin n 指定檔案的最後存取時間，單位為分鐘，在過去n分鐘內被存取過 -anewer file 比文件file更晚被存取過的文件 -atime n 指定檔案的最後存取時間（access time），單位為天 -cmin n 指定檔案狀態相關資訊最後修改的時間，單位為分鐘 -cnewer file 比文件file更新的文件 -ctime n 指定檔案狀態相關資訊最後修改的時間（status time），單位為天 -mtime n 指定檔案的最後修改時間（modification time），單位為天 -mmin n 指定檔案的最後修改時間，單位為分鐘 -empty 搜尋空檔案 -ipath p, -path p 路徑名稱符合 p 的文件，ipath 會忽略大小寫 -name name, -iname name 文件名稱符合 name 的文件。 iname 會忽略大小寫 -size n 指定檔案的大小 -type c 指定檔案的類型 -perm 指定檔案的權限 -user 指定檔案擁有者 -group 指定檔案的群組 -exec 對使用find的搜尋結果執行特定指令 基本操作 指定檔名搜尋 # 搜尋在當前目錄底下，檔名為file.txt的檔案 find . -name file.txt # 透過正則搜尋符合的匹配txt檔案 find . -name \u0026#34;*.txt\u0026#34; # 使用絕對路徑不分大小寫搜尋檔案 find /home -iname file.txt 指定檔案修改與存取時間搜尋 # 搜尋當前目錄下過去5天內檔案狀態有被存取過的檔案 find . -atime -5 # 搜尋當前目錄下過去5分鐘檔案狀態有被修改過的檔案 find . -cmin -5 # 搜尋當前目錄下，上次修改時間是在5天以上、10天以下的檔案 find . -mtime +5 -mtime -10 atime（Accesstime）指的是文件最後一次被訪問的時間； mtime（Modifytime）指的是文件內容被修改的時間，但不包括權限的修改，比如用vim編輯器修改內容； ctime（Changetime）指的是文件的權限、擁有者、所屬組及鏈接數發上改變的時間。 指定檔案類型搜尋 # 搜尋當前目錄及子目錄下，類型為文件 find . -type f # 搜尋當前目錄及子目錄下，類型為目錄 find . -type d b: 區塊裝置文件 c: 字型裝置文件 d: 目錄 p: 具名的pipe(FIFO) f: 一般的檔案 l: 連結檔，如果與 -L 或 -follow 參數同時使用時，就只會搜尋到有問題的連結檔，如果想要與 -L 同時使用，請改用 -xtype s: socket 檔案 指定檔案權限搜尋 # 搜尋當前目錄下權限為777的檔案 find . -type f -perm 777 # 搜尋當前目錄下權限不是777的檔案 find . -type f ! -perm 777 # 搜尋當前目錄下權限為644而且有SGID的檔案 find . -type f -perm 2644 # 搜尋當前目錄下，user只有read的權限的檔案 find . -type f -perm /u=r 如果不帶有任何前綴，則只有完全符合的檔案才會成功匹配 如果帶有-，則代表同時符合，任何一類用戶（ugo）的權限中的每一位（rwx）都要同時符合mode所表示的條件，9位權限之間存在“與”關係。 如果帶有/，則代表至少符合，任何一類用戶（ugo）的權限中的任何一位（rwx）符合mode所表示的條件即可，9位權限之間存在“或”關係。 指定檔案屬性搜尋 # 搜尋當前目錄下，user為root的檔案 find . -user root # 搜尋當前目錄下，group為root的檔案 find . -group root 指定檔案大小搜尋 # 搜尋當前目錄下，檔案大小剛好是50MB的檔案 find . -size 50M # 搜尋當前目錄下，檔案大小介於50MB到100MB之間的檔案 find . -size +50M -size -100M # 搜尋當前目錄下，大於100MB的檔案並將其刪除 find . -size +100M -exec rm -rf {} \\; 指定搜尋空檔案與隱藏檔案 # 搜尋當前目錄下的空目錄 find . -type d -empty # 搜尋當前目錄下的隱藏檔案 find . -type f -name \u0026#34;.*\u0026#34; 實用範例 # 搜尋當前目錄下，檔案大小在10MB以上的log檔，並將其刪除 find . -type f -name *.log -size +10M -exec rm {} \\; # 搜尋當前目錄下所有的php檔案，並找尋有關鍵字ok以及匹配處的以下5行 find ./ -name \\*.php -exec grep -wnHA5 ok {} \\; # 搜尋當前目錄下所有檔案，並找出有network關鍵字的檔案 find . -name \u0026#34;*\u0026#34; | xargs grep \u0026#34;network\u0026#34; 在 -exec 前面是 find 指令找出想要的檔案，在 -exec 後面的 command 是要執行的指令, 而 { } 包著的是找到的檔案或目錄，後面需要加上 ; 完結。\n參考資料 man find SGID Unix/Linux 的 find 指令使用教學、技巧與範例整理 根据文件属性或权限进行find查找 使用 Linux find 尋找檔案/尋找資料夾 Linux find 指令的 exec 參數 ","permalink":"https://sz9751210.github.io/posts/linux-find/","summary":"👨‍💻簡介 find 用途：在目錄中找尋文件 語法 find path [OPTIONS] 參數(常用) 參數 說明 -mount, -xdev 只檢查和指定目錄在同一個文件系統下的文件，避免列出其它文件系統中的文件 -amin n 指定檔案的最後存取時間，單位為分鐘，在過去n分鐘內被存取過 -anewer file 比文件file更晚被存取過的文件 -atime n 指定檔案的最後存取時間（access time），單位為天 -cmin n 指定檔案狀態相關資訊最後修改的時間，單位為分鐘 -cnewer file 比文件file更新的文件 -ctime n 指定檔案狀態相關資訊最後修改的時間（status time），單位為天 -mtime n 指定檔案的最後修改時間（modification time），單位為天 -mmin n 指定檔案的最後修改時間，單位為分鐘 -empty 搜尋空檔案 -ipath p, -path p 路徑名稱符合 p 的文件，ipath 會忽略大小寫 -name name, -iname name 文件名稱符合 name 的文件。 iname 會忽略大小寫 -size n 指定檔案的大小 -type c 指定檔案的類型 -perm 指定檔案的權限 -user 指定檔案擁有者 -group 指定檔案的群組 -exec 對使用find的搜尋結果執行特定指令 基本操作 指定檔名搜尋 # 搜尋在當前目錄底下，檔名為file.","title":"Linux 查找文件[find]"},{"content":"👨‍💻簡介 logrotate 用途：日誌文件管理工具，用於切割日誌，壓縮轉存，刪除舊的日誌文件，並創建新的日誌文件 預設配置文件位置： /etc/logrotate.conf /etc/logrotate.d 運行機制 logrotate是透過cron來運行的，透過/etc/cron.daily/logrotate這腳本，如要查看cron.daily運行方式，可查看/etc/anacrontab\n# /etc/anacrontab: configuration file for anacron # See anacron(8) and anacrontab(5) for details. SHELL=/bin/sh PATH=/sbin:/bin:/usr/sbin:/usr/bin MAILTO=root # the maximal random delay added to the base delay of the jobs RANDOM_DELAY=45 # the jobs will be started during the following hours only START_HOURS_RANGE=3-22 #period in days delay in minutes job-identifier command 1\t5\tcron.daily\tnice run-parts /etc/cron.daily 7\t25\tcron.weekly\tnice run-parts /etc/cron.weekly @monthly 45\tcron.monthly\tnice run-parts /etc/cron.monthly 上面可看到執行cron.daily是在凌晨3.到22.之間，並且隨機延遲45分鐘\n語法 logrotate [OPTIONS] config_file 參數 選項 說明 -d, \u0026ndash;debug debug模式，測試配置文件是否有錯誤 -f, \u0026ndash;force 強制轉儲文件 -m, \u0026ndash;mail=command 壓縮日誌後，發送日誌到指定郵箱 -s, \u0026ndash;state=statefile 使用指定的狀態文件 -v, \u0026ndash;verbose 顯示轉儲過程 -l, \u0026ndash;log=STRING log file 設定檔參數 說明 compress 在輪循任務完成後，已輪循的歸檔將使用 gzip 進行壓縮 compresscmd 指定壓縮工具，默認為gzip uncompresscmd 指定解壓縮工具，默認為gunziip compressext 指定要在壓縮日誌文件上使用的擴展名，默認遵循配置的壓縮命令 compressoptions 壓縮指令的選項配置\u0008， copy 製作log檔的副本，與create互斥 copytruncate 用於還在打開中的日誌文件，把當前日誌備份並截斷 create mode owner group 以指定的權限創建全新的日誌文件，同時 logrotate 也會重命名原始日誌文件 daily 日誌文件將按天輪循 dateext 使用當前日期作為命名格式 dateformat format_string 配合dateext使用，緊跟在下一行出現，定義文件切割後的文件名，必須配合dateext使用，只支持%Y %m %d %s這四個參數 delaycompress 和 compress 一起使用時，轉儲的日誌文件到下一次轉儲時才壓縮 extension ext 維護擴展名 ifempty 即使是空文件也轉儲 include file_or_directory 將logrotate格式的檔案或是目錄整個引進或 mail address 把轉儲的日誌文件發送到指定的 E-mail 地址 mailfirst 當啟用mail參數時，寄出剛rotated的文件 maillast 使用 mail 命令時，郵寄即將到期的文件，而不是剛剛旋轉的文件 maxage count 刪除超過count天的rotated日誌 minsize size 日誌文件在大於size字節時rotated，但不會在額外指定的時間間隔（每天、每週、每月或每年）之前輪換。使用minsize時，會同時考慮日誌文件的大小和時間戳，size選項則不會 missingok 在日誌輪循期間，任何錯誤將被忽略，例如\u0026quot;文件無法找到\u0026quot;之類的錯誤 monthly 日誌文件將按月輪循 nocompress 不壓縮 nocopy 不複製 nocopytruncate 備份日誌文件但是不截斷 nocreate 不建立新的日誌文件 nodelaycompress 覆蓋 delaycompress 選項，轉儲同時壓縮 nodateext rotate不帶日期 nomail 轉儲時不發送日誌文件 nomissingok log檔不存在會噴錯 noolddir 轉儲後的日誌文件和當前日誌文件放在同一個目錄下 nosharedscripts Run prerotate and postrotate scripts for every log file which is rotated noshred 刪除舊log時不要使用shred。 notifempty 如果日誌文件為空，輪循不會進行 olddir directory 儲後的日誌文件放入指定的目錄，必須和當前日誌文件在同一個文件系統 postrotate/endscript 在所有其它指令完成後，postrotate和endscript裡面指定的命令將被執行 prerotate/endscript 在轉儲以前需要執行的命令可以放入這個對，這兩個關鍵字必須單獨成行 firstaction/endscript firstaction以及endscript之間優先執行 lastaction/endscript lastaction以及endscript之間最後執行 rotate count 指定日誌文件刪除之前轉儲的次數，一次將存儲count個歸檔日誌。對於第count+1個歸檔，時間最久的歸檔將被刪除，0指沒有備份 size size 當日誌文件到達指定的大小時才轉儲 sharedscripts 運行postrotate腳本，作用是在所有日誌都輪轉後統一執行一次腳本。如果沒有配置這個，那麼每個日誌輪轉後都會執行一次腳本 shred 使用shred -u而不是unlink()刪除log文件。這應該確保log在預定刪除後不可讀 shredcycles count 要求 GNU shred(1) 在刪除之前覆蓋日誌文件計數次數 start count This is the number to use as the base for rotation. tabooext [+] list 不轉儲指定擴展名的文件 weekly 日誌文件將按週輪循 yearly 日誌文件將按年輪循 基本操作 調用/etc/logrotate.d下配置的所有日誌 logrotate /etc/logrotate.conf 指定logrotate檔 logrotate /etc/logrotate.d/logrotate_file 使用debug模式進行故障排除 logrotate -d /etc/logrotate.d/logrotate_file 強制rotate logrotate -df /etc/logrotate.d/logrotate_file 顯示rotate過程 logrotate -v /etc/logrotate.d/logrotate_file 配置文件案例 syslog /var/log/cron /var/log/maillog /var/log/messages /var/log/secure /var/log/spooler { missingok sharedscripts postrotate /bin/kill -HUP `cat /var/run/syslogd.pid 2\u0026gt; /dev/null` 2\u0026gt; /dev/null || true endscript } jenkins /var/log/jenkins/jenkins.log /var/log/jenkins/access_log { compress dateext maxage 365 rotate 99 size=+4096k notifempty missingok create 644 copytruncate } nginx /var/log/nginx/*.log /var/log/nginx/*/*.log{ daily missingok rotate 14 compress delaycompress notifempty create 640 root adm sharedscripts postrotate [ ! -f /var/run/nginx.pid ] || kill -USR1 `cat /var/run/nginx.pid` endscript } 參考資料 Linux 日志切割神器 logrotate 原理介绍和配置详解 | HelloDog (wsgzao.github.io) logrotate(8) - Linux man page (die.net) logrotate机制和原理 — 0xFEE1C001 (lightxue.com) How to Use logrotate to Manage Log Files | Linode 系统运维|Linux日志文件总管——logrotate 系统运维|Linux日志文件总管——logrotate (51cto.com) Logrotate 因為父目錄權限而執行失敗 – Mr. 沙先生 (shazi.info) 相關指令(可選) ","permalink":"https://sz9751210.github.io/posts/linux-logrotate/","summary":"👨‍💻簡介 logrotate 用途：日誌文件管理工具，用於切割日誌，壓縮轉存，刪除舊的日誌文件，並創建新的日誌文件 預設配置文件位置： /etc/logrotate.conf /etc/logrotate.d 運行機制 logrotate是透過cron來運行的，透過/etc/cron.daily/logrotate這腳本，如要查看cron.daily運行方式，可查看/etc/anacrontab\n# /etc/anacrontab: configuration file for anacron # See anacron(8) and anacrontab(5) for details. SHELL=/bin/sh PATH=/sbin:/bin:/usr/sbin:/usr/bin MAILTO=root # the maximal random delay added to the base delay of the jobs RANDOM_DELAY=45 # the jobs will be started during the following hours only START_HOURS_RANGE=3-22 #period in days delay in minutes job-identifier command 1\t5\tcron.daily\tnice run-parts /etc/cron.daily 7\t25\tcron.weekly\tnice run-parts /etc/cron.weekly @monthly 45\tcron.","title":"Linux 日誌管理[logrotate]"},{"content":"👨‍💻簡介 cut 用途：文字處理工具，可以將每一行文字的部分字元或是欄位擷取出來 語法 cut [OPTIONS] FILE 參數 參數 說明 -b, \u0026ndash;bytes=LIST 擷取指定的範圍，以 bytes 作為單位 -c, \u0026ndash;characters=LIST 擷取指定的範圍，以字元數量作為單位 -d, \u0026ndash;delimiter=DELIM 指定分隔字元，預設是用 tab 作為分隔 -f, \u0026ndash;fields=LIST 輸出指定的範圍，這個是每行資料的第幾個欄位作為區分 -n with -b: don\u0026rsquo;t split multibyte characters \u0026ndash;complement 排除未擷取的欄位 -s, \u0026ndash;only-delimited 如果該行沒有分隔字元，不會顯示該行資料 \u0026ndash;output-delimiter=字串 改變輸出欄位的分隔字元 基本操作 擷取字元 # 擷取從第二個字元到最後 cut -c 2- file # 擷取從開始到第二個字元 cut -c -2 file # 擷取第2-3,5-8,10-12個字元 cut -c 2-3,5-8,10-12 file 排除字元 # 排除2-5字元，其餘都擷取 cut -c 2-5 --complement 擷取欄位 # 將逗號當作分隔符，擷取第二個欄位 cut -d , -f 2 file # 將逗號當作分隔符，擷取第1-3個欄位以及第五個欄位 cut -d , -f 1-3,5 file 排除欄位 # 排除第二個欄位，擷取剩餘的欄位 cut -d , -f 2 --complement file 改變輸出欄位分隔字元 # 將逗號當作分隔符，擷取第1,3欄位並將分隔符從,改成: cut -d , -f 1,3 --output-delimiter=\u0026#34;:\u0026#34; 組合技 # 找出所有python程式的PID與指令內容 ps aux | grep python | sed \u0026#39;s/\\s\\+/ /g\u0026#39; | cut -d \u0026#39; \u0026#39; -f 2,11- 參考資料 Linux 的 cut 擷取部份字元、欄位指令教學與常用範例整理 - G. T. Wang (gtwang.org) cut 指令: 擷取檔案每行指定範圍資料 (ltsplus.com) Bash Cut Command with Examples (linuxhint.com) 相關指令(可選) sed awk ","permalink":"https://sz9751210.github.io/posts/linux-cut/","summary":"👨‍💻簡介 cut 用途：文字處理工具，可以將每一行文字的部分字元或是欄位擷取出來 語法 cut [OPTIONS] FILE 參數 參數 說明 -b, \u0026ndash;bytes=LIST 擷取指定的範圍，以 bytes 作為單位 -c, \u0026ndash;characters=LIST 擷取指定的範圍，以字元數量作為單位 -d, \u0026ndash;delimiter=DELIM 指定分隔字元，預設是用 tab 作為分隔 -f, \u0026ndash;fields=LIST 輸出指定的範圍，這個是每行資料的第幾個欄位作為區分 -n with -b: don\u0026rsquo;t split multibyte characters \u0026ndash;complement 排除未擷取的欄位 -s, \u0026ndash;only-delimited 如果該行沒有分隔字元，不會顯示該行資料 \u0026ndash;output-delimiter=字串 改變輸出欄位的分隔字元 基本操作 擷取字元 # 擷取從第二個字元到最後 cut -c 2- file # 擷取從開始到第二個字元 cut -c -2 file # 擷取第2-3,5-8,10-12個字元 cut -c 2-3,5-8,10-12 file 排除字元 # 排除2-5字元，其餘都擷取 cut -c 2-5 --complement 擷取欄位 # 將逗號當作分隔符，擷取第二個欄位 cut -d , -f 2 file # 將逗號當作分隔符，擷取第1-3個欄位以及第五個欄位 cut -d , -f 1-3,5 file 排除欄位 # 排除第二個欄位，擷取剩餘的欄位 cut -d , -f 2 --complement file 改變輸出欄位分隔字元 # 將逗號當作分隔符，擷取第1,3欄位並將分隔符從,改成: cut -d , -f 1,3 --output-delimiter=\u0026#34;:\u0026#34; 組合技 # 找出所有python程式的PID與指令內容 ps aux | grep python | sed \u0026#39;s/\\s\\+/ /g\u0026#39; | cut -d \u0026#39; \u0026#39; -f 2,11- 參考資料 Linux 的 cut 擷取部份字元、欄位指令教學與常用範例整理 - G.","title":"Linux 擷取部分字元[cut]"},{"content":"刪除本地分支 先使用 git branch -a(all) 列出所有分支，再使用 -d(delete) 後面接著要刪除的分支名稱即可\ngit branch -a # *master # test # remote/origin/master # remote/origin/test git branch -d test # Deleted branch test (was ########). 刪除遠程分支 刪除遠程分支必須使用 git push 加上 --delete 參數，並且必須在push後加上 remote name\ngit branch -a # *master # test # remote/origin/master # remote/origin/test git push origin --delete test # To \u0026lt;URL of your repository\u0026gt;.git # - [deleted] test 參考資料 How to delete remote branches in Git (educative.io) ","permalink":"https://sz9751210.github.io/posts/git-%E5%88%AA%E9%99%A4%E9%81%A0%E7%A8%8B%E5%88%86%E6%94%AF/","summary":"刪除本地分支 先使用 git branch -a(all) 列出所有分支，再使用 -d(delete) 後面接著要刪除的分支名稱即可\ngit branch -a # *master # test # remote/origin/master # remote/origin/test git branch -d test # Deleted branch test (was ########). 刪除遠程分支 刪除遠程分支必須使用 git push 加上 --delete 參數，並且必須在push後加上 remote name\ngit branch -a # *master # test # remote/origin/master # remote/origin/test git push origin --delete test # To \u0026lt;URL of your repository\u0026gt;.git # - [deleted] test 參考資料 How to delete remote branches in Git (educative.","title":"git-刪除遠程分支"},{"content":"安裝環境 windows 10 python 3.8.0 安裝步驟 1.下載python 網址:Python\n點擊Download\n選擇windows的可執行安裝檔，目前大多都以64位元為主 2.安裝過程 3.檢查環境 ","permalink":"https://sz9751210.github.io/posts/python-installation/","summary":"安裝環境 windows 10 python 3.8.0 安裝步驟 1.下載python 網址:Python\n點擊Download\n選擇windows的可執行安裝檔，目前大多都以64位元為主 2.安裝過程 3.檢查環境 ","title":"python-installation"},{"content":"👨‍💻簡介 cp(copy) 用途：複製檔案(copy)和目錄 語法 cp [OPTIONS] SOURCE DEST 參數 參數 說明 -a, \u0026ndash;archive 效果同-dpR，保留連結、文件屬性，並複製目錄下的所有內容，通常在複製目錄時使用 \u0026ndash;attributes-only 只複製文件的屬性，內容不複製 \u0026ndash;backup[=CONTROL] 備份每個現有的目標文件 -b 不接受參數版的\u0026ndash;backup \u0026ndash;copy-contents 遞歸模式下複製特殊文件的內容 -d 複製時保留軟連結 -f, \u0026ndash;force 強制覆蓋已經存在的目標文件，不會跳出提示 -i, \u0026ndash;interactive 與-f選項相反，在覆蓋目標文件之前給出提示，要求用戶確認是否覆蓋，回答 y 時目標文件將被覆蓋。 -H 跟隨源文件命令行中顯式給出的符號鏈接 -l, \u0026ndash;link 使用硬鏈接取代複製 -L, \u0026ndash;dereference 總是跟隨源文件中的符號鏈接 -n, \u0026ndash;no-clobber 不要覆寫已有的文件（覆蓋先前給出的 -i 選項） -P, \u0026ndash;no-dereference 永遠不要跟隨源文件中的符號鏈接 -p 不接受參數版的\u0026ndash;preserve \u0026ndash;preserve[=ATTR_LIST] 除複製文件的內容外，還把修改時間和訪問權限也複製到新文件中。保留指定的屬性（默認：模式、從屬關係、時間戳），如果可能的話還有額外屬性：上下文、鏈接（links）、xattr、all \u0026ndash;no-preserve=ATTR_LIST 不要保留指定的屬性 \u0026ndash;parents 在目標目錄下使用完整的源文件名 -R, -r, \u0026ndash;recursive 遞歸複製目錄 \u0026ndash;reflink[=WHEN] 控制克隆/寫入時複製（CoW）副本。詳情見下文 \u0026ndash;remove-destination 打開目的 \u0026ndash;sparse=WHEN 控制稀疏文件的創建。詳情見下文 \u0026ndash;strip-trailing-slashes 移除每個源文件參數後的任何末尾斜槓 -s, \u0026ndash;symbolic-link 建立軟連結而不是複制 -S, \u0026ndash;suffix=後置字串 覆蓋原本的備份後綴 -t, \u0026ndash;target-directory=目錄 將所有源文件參數給出的內容複製到目標目錄中 -T, \u0026ndash;no-target-directory 將目標文件當作普通文件對待（而不是目錄） -u, \u0026ndash;update 僅在源文件比目標文件新，或者目標文件不存在的情況下複製 -v, \u0026ndash;verbose 顯示覆蓋訊息 -x, \u0026ndash;one-file-system 停留在當前文件系統中 -Z 將目標文件的 SELinux 安全上下文設置為默認類型 \u0026ndash;context[=CTX] 類似-Z，或者如果給定了上下文（CTX）那麼將SELinux或者SMACK 安全上下文設置爲給定值 默認情況下，程序會使用一種粗糙的啓發式算法探測源文件是否是稀疏的，若判定爲稀疏，則目標文件也會以稀疏形式創建。這個行爲可以通過\n--sparse=auto指定。若指定 --sparse=always，將在源文件包含足夠多內容爲零的字節序列時將其視作稀疏文件。使用 --sparse=never 以禁止創建稀疏文件。 當指定了--reflink[=always]時，進行輕量級複製，其中的數據塊僅在被修改時進行復制。如果這樣的複製失敗，或無法實行，或者指定了--reflink=auto時，回退到標準複製。\n備份的後綴爲\u0026quot;~\u0026quot;，除非設置了--suffix或者SIMPLE_BACKUP_SUFFIX。版本控制方式可以使用 --backup選項或者VERSION_CONTROL環境變量進行指定。可用的值如下：\nnone, off：永遠不製作備份（即使給出了 \u0026ndash;backup ） numbered, t：製作編號的備份 existing, nil：如果已編號副本存在則編號，否則採用簡單方式 simple, never：總是製作簡單備份 作爲一個特例，cp將在同時給出force選項與backup選項，並且源文件和目標文件是同一個已存在普通文件的情況下製作備份副本。 基本操作 複製目錄 cp -r source/ destdir 複製並改名 cp aaa bbb 複製目錄及屬性 cp -rp source/ destdir 複製多檔到單目錄下 cp aaa bbb destdir 透過匹配複製 cp *.log dest 參考資料 Ubuntu Manpage: cp - 複製文件和目錄 Linux cp 指令用法 (link.idv.tw) Linux cp Command Examples (linuxhint.com) ","permalink":"https://sz9751210.github.io/posts/linux-cp/","summary":"👨‍💻簡介 cp(copy) 用途：複製檔案(copy)和目錄 語法 cp [OPTIONS] SOURCE DEST 參數 參數 說明 -a, \u0026ndash;archive 效果同-dpR，保留連結、文件屬性，並複製目錄下的所有內容，通常在複製目錄時使用 \u0026ndash;attributes-only 只複製文件的屬性，內容不複製 \u0026ndash;backup[=CONTROL] 備份每個現有的目標文件 -b 不接受參數版的\u0026ndash;backup \u0026ndash;copy-contents 遞歸模式下複製特殊文件的內容 -d 複製時保留軟連結 -f, \u0026ndash;force 強制覆蓋已經存在的目標文件，不會跳出提示 -i, \u0026ndash;interactive 與-f選項相反，在覆蓋目標文件之前給出提示，要求用戶確認是否覆蓋，回答 y 時目標文件將被覆蓋。 -H 跟隨源文件命令行中顯式給出的符號鏈接 -l, \u0026ndash;link 使用硬鏈接取代複製 -L, \u0026ndash;dereference 總是跟隨源文件中的符號鏈接 -n, \u0026ndash;no-clobber 不要覆寫已有的文件（覆蓋先前給出的 -i 選項） -P, \u0026ndash;no-dereference 永遠不要跟隨源文件中的符號鏈接 -p 不接受參數版的\u0026ndash;preserve \u0026ndash;preserve[=ATTR_LIST] 除複製文件的內容外，還把修改時間和訪問權限也複製到新文件中。保留指定的屬性（默認：模式、從屬關係、時間戳），如果可能的話還有額外屬性：上下文、鏈接（links）、xattr、all \u0026ndash;no-preserve=ATTR_LIST 不要保留指定的屬性 \u0026ndash;parents 在目標目錄下使用完整的源文件名 -R, -r, \u0026ndash;recursive 遞歸複製目錄 \u0026ndash;reflink[=WHEN] 控制克隆/寫入時複製（CoW）副本。詳情見下文 \u0026ndash;remove-destination 打開目的 \u0026ndash;sparse=WHEN 控制稀疏文件的創建。詳情見下文 \u0026ndash;strip-trailing-slashes 移除每個源文件參數後的任何末尾斜槓 -s, \u0026ndash;symbolic-link 建立軟連結而不是複制 -S, \u0026ndash;suffix=後置字串 覆蓋原本的備份後綴 -t, \u0026ndash;target-directory=目錄 將所有源文件參數給出的內容複製到目標目錄中 -T, \u0026ndash;no-target-directory 將目標文件當作普通文件對待（而不是目錄） -u, \u0026ndash;update 僅在源文件比目標文件新，或者目標文件不存在的情況下複製 -v, \u0026ndash;verbose 顯示覆蓋訊息 -x, \u0026ndash;one-file-system 停留在當前文件系統中 -Z 將目標文件的 SELinux 安全上下文設置為默認類型 \u0026ndash;context[=CTX] 類似-Z，或者如果給定了上下文（CTX）那麼將SELinux或者SMACK 安全上下文設置爲給定值 默認情況下，程序會使用一種粗糙的啓發式算法探測源文件是否是稀疏的，若判定爲稀疏，則目標文件也會以稀疏形式創建。這個行爲可以通過","title":"Linux 複製檔案[cp]"},{"content":"因為git忽略的原則為之前沒有被追蹤的檔案，因此可能開發到一半才會需要新增gitignore來進行忽略，但是失效\n解決的辦法為刪掉本地快取(改變成未被追蹤的狀態)，接著在新增要忽略的檔案到gitignore裡\ngit rm -r --cached . git add . git commit -m \u0026#34;init gitignore\u0026#34; ","permalink":"https://sz9751210.github.io/posts/gitignore%E5%A4%B1%E6%95%88%E7%9A%84%E8%A7%A3%E6%B1%BA%E8%BE%A6%E6%B3%95/","summary":"因為git忽略的原則為之前沒有被追蹤的檔案，因此可能開發到一半才會需要新增gitignore來進行忽略，但是失效\n解決的辦法為刪掉本地快取(改變成未被追蹤的狀態)，接著在新增要忽略的檔案到gitignore裡\ngit rm -r --cached . git add . git commit -m \u0026#34;init gitignore\u0026#34; ","title":"gitignore失效的解決辦法"},{"content":"👨‍💻簡介 chmod(change mode) 用途：控制用戶對文件的權限，linux 的文件權限分為三種身分，owner/group/others，而權限也分為三種，read/write/execute，權重如下表格 權限 權重 r 4 w 2 x 1 語法 chmod [OPTIONS] [mode] [檔案或目錄] 參數 參數 說明 -c, \u0026ndash;changes 效果類似\u0026quot;-v\u0026quot;參數，但僅回報更改的部分。 -f, \u0026ndash;silent, \u0026ndash;quiet 不顯示錯誤資訊。 -v, \u0026ndash;verbose 顯示指令執行過程。 \u0026ndash;no-preserve-root 取消對 root 文件系統的保護 \u0026ndash;preserve-root 保留對 root 文件系統的保護 \u0026ndash;reference=RFILE 把指定文件或目錄的權限全部設成和參考文件或目錄的權限相同。 -R, \u0026ndash;recursive 遞迴處理，將指定目錄下的所有檔及子目錄一併處理。 符號模式 who(用戶類型) 說明 u(user) 所有者 g(group) 所屬組 o(others) 其他用戶 a(all) 所有用戶，等於ugo operator 說明 + 新增權限 - 移除權限 = 設定權限 模式 說明 r 可讀權限 w 可寫權限 x 可執行權限 絕對模式 參數 權限 rwx 7 讀+寫+執行 rwx 6 讀+寫 rw- 5 讀+執行 r-x 4 只讀 r\u0026ndash; 3 寫+執行 -wx 2 只寫 -w- 1 只執行 \u0026ndash;x 0 無 \u0026mdash; 基本操作 將檔案變成user可執行 假設原本檔案權限為-rw-rw-r--\n指令 mode chmod u+x chmod u=rwx chmod 764 將檔案設定user可寫，group以及others無法寫 假設原本檔案權限為-r--rw-rw-\n指令 mode chmod u+w,go-w chmod u=rw,go=r chmod 644 將資料夾底下的權限都設定一樣的 chmod -R a+r dirName ","permalink":"https://sz9751210.github.io/posts/linux-chmod/","summary":"👨‍💻簡介 chmod(change mode) 用途：控制用戶對文件的權限，linux 的文件權限分為三種身分，owner/group/others，而權限也分為三種，read/write/execute，權重如下表格 權限 權重 r 4 w 2 x 1 語法 chmod [OPTIONS] [mode] [檔案或目錄] 參數 參數 說明 -c, \u0026ndash;changes 效果類似\u0026quot;-v\u0026quot;參數，但僅回報更改的部分。 -f, \u0026ndash;silent, \u0026ndash;quiet 不顯示錯誤資訊。 -v, \u0026ndash;verbose 顯示指令執行過程。 \u0026ndash;no-preserve-root 取消對 root 文件系統的保護 \u0026ndash;preserve-root 保留對 root 文件系統的保護 \u0026ndash;reference=RFILE 把指定文件或目錄的權限全部設成和參考文件或目錄的權限相同。 -R, \u0026ndash;recursive 遞迴處理，將指定目錄下的所有檔及子目錄一併處理。 符號模式 who(用戶類型) 說明 u(user) 所有者 g(group) 所屬組 o(others) 其他用戶 a(all) 所有用戶，等於ugo operator 說明 + 新增權限 - 移除權限 = 設定權限 模式 說明 r 可讀權限 w 可寫權限 x 可執行權限 絕對模式 參數 權限 rwx 7 讀+寫+執行 rwx 6 讀+寫 rw- 5 讀+執行 r-x 4 只讀 r\u0026ndash; 3 寫+執行 -wx 2 只寫 -w- 1 只執行 \u0026ndash;x 0 無 \u0026mdash; 基本操作 將檔案變成user可執行 假設原本檔案權限為-rw-rw-r--","title":"Linux 修改權限[chmod]"},{"content":"紀錄一下hugo的建置過程\n1. 安裝hugo windows安裝 Chocolatey choco install hugo -confirm Scoop scoop install hugo macos安裝 brew install hugo linux安裝 sudo apt-get install hugo 2. 建立網站 hugo new site myblog -f yaml 3. 下載主題 git clone https://github.com/adityatelange/hugo-PaperMod themes/PaperMod --depth=1 4. 建立about, tags page 建立about page hugo new about.md 修改config檔 menu: main: - identifier: tags name: tags url: /tags/ weight: 1 - identifier: about name: about url: /about/ weight: 2 5. 依照需求美化版面 Hugo PaperMod 優化\n6. 推到github 修改config檔的baseURL為自己的github.io網址 刪掉theme底下的.git，如果有自己修改的話就版控這個主題 將自己的github.io的repo設定成submodule git submodule add git@github.com:sz9751210/sz9751210.github.io.git public 在myblog下hugo生成靜態網頁 到public資料夾將生成的檔案都推到github.io的repo 到自己的github page查看結果 ","permalink":"https://sz9751210.github.io/posts/hugo-setup/","summary":"紀錄一下hugo的建置過程\n1. 安裝hugo windows安裝 Chocolatey choco install hugo -confirm Scoop scoop install hugo macos安裝 brew install hugo linux安裝 sudo apt-get install hugo 2. 建立網站 hugo new site myblog -f yaml 3. 下載主題 git clone https://github.com/adityatelange/hugo-PaperMod themes/PaperMod --depth=1 4. 建立about, tags page 建立about page hugo new about.md 修改config檔 menu: main: - identifier: tags name: tags url: /tags/ weight: 1 - identifier: about name: about url: /about/ weight: 2 5. 依照需求美化版面 Hugo PaperMod 優化","title":"Hugo Setup"},{"content":"簡單紀錄一下papermod主題的優化，持續更新\u0026hellip;\n1. 目錄放側邊 替換以下路徑的code layouts/partials/toc.html\n{{- $headers := findRE \u0026#34;\u0026lt;h[1-6].*?\u0026gt;(.|\\n])+?\u0026lt;/h[1-6]\u0026gt;\u0026#34; .Content -}} {{- $has_headers := ge (len $headers) 1 -}} {{- if $has_headers -}} \u0026lt;aside id=\u0026#34;toc-container\u0026#34; class=\u0026#34;toc-container wide\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;toc\u0026#34;\u0026gt; \u0026lt;details {{if (.Param \u0026#34;TocOpen\u0026#34;) }} open{{ end }}\u0026gt; \u0026lt;summary accesskey=\u0026#34;c\u0026#34; title=\u0026#34;(Alt + C)\u0026#34;\u0026gt; \u0026lt;span class=\u0026#34;details\u0026#34;\u0026gt;{{- i18n \u0026#34;toc\u0026#34; | default \u0026#34;Table of Contents\u0026#34; }}\u0026lt;/span\u0026gt; \u0026lt;/summary\u0026gt; \u0026lt;div class=\u0026#34;inner\u0026#34;\u0026gt; {{- $largest := 6 -}} {{- range $headers -}} {{- $headerLevel := index (findRE \u0026#34;[1-6]\u0026#34; . 1) 0 -}} {{- $headerLevel := len (seq $headerLevel) -}} {{- if lt $headerLevel $largest -}} {{- $largest = $headerLevel -}} {{- end -}} {{- end -}} {{- $firstHeaderLevel := len (seq (index (findRE \u0026#34;[1-6]\u0026#34; (index $headers 0) 1) 0)) -}} {{- $.Scratch.Set \u0026#34;bareul\u0026#34; slice -}} \u0026lt;ul\u0026gt; {{- range seq (sub $firstHeaderLevel $largest) -}} \u0026lt;ul\u0026gt; {{- $.Scratch.Add \u0026#34;bareul\u0026#34; (sub (add $largest .) 1) -}} {{- end -}} {{- range $i, $header := $headers -}} {{- $headerLevel := index (findRE \u0026#34;[1-6]\u0026#34; . 1) 0 -}} {{- $headerLevel := len (seq $headerLevel) -}} {{/* get id=\u0026#34;xyz\u0026#34; */}} {{- $id := index (findRE \u0026#34;(id=\\\u0026#34;(.*?)\\\u0026#34;)\u0026#34; $header 9) 0 }} {{- /* strip id=\u0026#34;\u0026#34; to leave xyz, no way to get regex capturing groups in hugo */ -}} {{- $cleanedID := replace (replace $id \u0026#34;id=\\\u0026#34;\u0026#34; \u0026#34;\u0026#34;) \u0026#34;\\\u0026#34;\u0026#34; \u0026#34;\u0026#34; }} {{- $header := replaceRE \u0026#34;\u0026lt;h[1-6].*?\u0026gt;((.|\\n])+?)\u0026lt;/h[1-6]\u0026gt;\u0026#34; \u0026#34;$1\u0026#34; $header -}} {{- if ne $i 0 -}} {{- $prevHeaderLevel := index (findRE \u0026#34;[1-6]\u0026#34; (index $headers (sub $i 1)) 1) 0 -}} {{- $prevHeaderLevel := len (seq $prevHeaderLevel) -}} {{- if gt $headerLevel $prevHeaderLevel -}} {{- range seq $prevHeaderLevel (sub $headerLevel 1) -}} \u0026lt;ul\u0026gt; {{/* the first should not be recorded */}} {{- if ne $prevHeaderLevel . -}} {{- $.Scratch.Add \u0026#34;bareul\u0026#34; . -}} {{- end -}} {{- end -}} {{- else -}} \u0026lt;/li\u0026gt; {{- if lt $headerLevel $prevHeaderLevel -}} {{- range seq (sub $prevHeaderLevel 1) -1 $headerLevel -}} {{- if in ($.Scratch.Get \u0026#34;bareul\u0026#34;) . -}} \u0026lt;/ul\u0026gt; {{/* manually do pop item */}} {{- $tmp := $.Scratch.Get \u0026#34;bareul\u0026#34; -}} {{- $.Scratch.Delete \u0026#34;bareul\u0026#34; -}} {{- $.Scratch.Set \u0026#34;bareul\u0026#34; slice}} {{- range seq (sub (len $tmp) 1) -}} {{- $.Scratch.Add \u0026#34;bareul\u0026#34; (index $tmp (sub . 1)) -}} {{- end -}} {{- else -}} \u0026lt;/ul\u0026gt; \u0026lt;/li\u0026gt; {{- end -}} {{- end -}} {{- end -}} {{- end }} \u0026lt;li\u0026gt; \u0026lt;a href=\u0026#34;#{{- $cleanedID -}}\u0026#34; aria-label=\u0026#34;{{- $header | plainify -}}\u0026#34;\u0026gt;{{- $header | safeHTML -}}\u0026lt;/a\u0026gt; {{- else }} \u0026lt;li\u0026gt; \u0026lt;a href=\u0026#34;#{{- $cleanedID -}}\u0026#34; aria-label=\u0026#34;{{- $header | plainify -}}\u0026#34;\u0026gt;{{- $header | safeHTML -}}\u0026lt;/a\u0026gt; {{- end -}} {{- end -}} \u0026lt;!-- {{- $firstHeaderLevel := len (seq (index (findRE \u0026#34;[1-6]\u0026#34; (index $headers 0) 1) 0)) -}} --\u0026gt; {{- $firstHeaderLevel := $largest }} {{- $lastHeaderLevel := len (seq (index (findRE \u0026#34;[1-6]\u0026#34; (index $headers (sub (len $headers) 1)) 1) 0)) }} \u0026lt;/li\u0026gt; {{- range seq (sub $lastHeaderLevel $firstHeaderLevel) -}} {{- if in ($.Scratch.Get \u0026#34;bareul\u0026#34;) (add . $firstHeaderLevel) }} \u0026lt;/ul\u0026gt; {{- else }} \u0026lt;/ul\u0026gt; \u0026lt;/li\u0026gt; {{- end -}} {{- end }} \u0026lt;/ul\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/details\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/aside\u0026gt; \u0026lt;script\u0026gt; let activeElement; let elements; window.addEventListener(\u0026#39;DOMContentLoaded\u0026#39;, function (event) { checkTocPosition(); elements = document.querySelectorAll(\u0026#39;h1[id],h2[id],h3[id],h4[id],h5[id],h6[id]\u0026#39;); // Make the first header active activeElement = elements[0]; const id = encodeURI(activeElement.getAttribute(\u0026#39;id\u0026#39;)).toLowerCase(); document.querySelector(`.inner ul li a[href=\u0026#34;#${id}\u0026#34;]`).classList.add(\u0026#39;active\u0026#39;); }, false); window.addEventListener(\u0026#39;resize\u0026#39;, function(event) { checkTocPosition(); }, false); window.addEventListener(\u0026#39;scroll\u0026#39;, () =\u0026gt; { // Check if there is an object in the top half of the screen or keep the last item active activeElement = Array.from(elements).find((element) =\u0026gt; { if ((getOffsetTop(element) - window.pageYOffset) \u0026gt; 0 \u0026amp;\u0026amp; (getOffsetTop(element) - window.pageYOffset) \u0026lt; window.innerHeight/2) { return element; } }) || activeElement elements.forEach(element =\u0026gt; { const id = encodeURI(element.getAttribute(\u0026#39;id\u0026#39;)).toLowerCase(); if (element === activeElement){ document.querySelector(`.inner ul li a[href=\u0026#34;#${id}\u0026#34;]`).classList.add(\u0026#39;active\u0026#39;); } else { document.querySelector(`.inner ul li a[href=\u0026#34;#${id}\u0026#34;]`).classList.remove(\u0026#39;active\u0026#39;); } }) }, false); const main = parseInt(getComputedStyle(document.body).getPropertyValue(\u0026#39;--article-width\u0026#39;), 10); const toc = parseInt(getComputedStyle(document.body).getPropertyValue(\u0026#39;--toc-width\u0026#39;), 10); const gap = parseInt(getComputedStyle(document.body).getPropertyValue(\u0026#39;--gap\u0026#39;), 10); function checkTocPosition() { const width = document.body.scrollWidth; if (width - main - (toc * 2) - (gap * 4) \u0026gt; 0) { document.getElementById(\u0026#34;toc-container\u0026#34;).classList.add(\u0026#34;wide\u0026#34;); } else { document.getElementById(\u0026#34;toc-container\u0026#34;).classList.remove(\u0026#34;wide\u0026#34;); } } function getOffsetTop(element) { if (!element.getClientRects().length) { return 0; } let rect = element.getBoundingClientRect(); let win = element.ownerDocument.defaultView; return rect.top + win.pageYOffset; } \u0026lt;/script\u0026gt; {{- end }} 在\\themes\\PaperMod\\assets\\css\\extended底下新建一個.css檔，命名為toc-left.css\n:root { --nav-width: 1380px; --article-width: 650px; --toc-width: 300px; } .toc { margin: 0 2px 40px 2px; border: 1px solid var(--border); background: var(--entry); border-radius: var(--radius); padding: 0.4em; } .toc-container.wide { position: absolute; height: 100%; border-right: 1px solid var(--border); left: calc((var(--toc-width) + var(--gap)) * -1); top: calc(var(--gap) * 2); width: var(--toc-width); } .wide .toc { position: sticky; top: var(--gap); border: unset; background: unset; border-radius: unset; width: 100%; margin: 0 2px 40px 2px; } .toc details summary { cursor: zoom-in; margin-inline-start: 20px; padding: 12px 0; } .toc details[open] summary { font-weight: 500; } .toc-container.wide .toc .inner { margin: 0; } .active { font-size: 110%; font-weight: 600; } .toc ul { list-style-type: circle; } .toc .inner { margin: 0 0 0 20px; padding: 0px 15px 15px 20px; font-size: 16px; /*目录显示高度*/ max-height: 83vh; overflow-y: auto; } .toc .inner::-webkit-scrollbar-thumb { /*滚动条*/ background: var(--border); border: 7px solid var(--theme); border-radius: var(--radius); } .toc li ul { margin-inline-start: calc(var(--gap) * 0.5); list-style-type: none; } .toc li { list-style: none; font-size: 0.95rem; padding-bottom: 5px; } .toc li a:hover { color: var(--secondary); } 2. 主頁圖片縮小擺右側 到layouts/_default/list.html，新增一個div，命名為post-info，把entry-header以及entry-content包進去 \u0026lt;article class=\u0026#34;{{ $class }}\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;post-info\u0026#34;\u0026gt; \u0026lt;!--加在這裡--\u0026gt; \u0026lt;header class=\u0026#34;entry-header\u0026#34;\u0026gt; \u0026lt;h2\u0026gt; {{- .Title }} {{- if .Draft }}\u0026lt;sup\u0026gt;\u0026lt;span class=\u0026#34;entry-isdraft\u0026#34;\u0026gt;\u0026amp;nbsp;\u0026amp;nbsp;[draft]\u0026lt;/span\u0026gt;\u0026lt;/sup\u0026gt;{{- end }} \u0026lt;/h2\u0026gt; \u0026lt;/header\u0026gt; {{- if (ne (.Param \u0026#34;hideSummary\u0026#34;) true) }} \u0026lt;div class=\u0026#34;entry-content\u0026#34;\u0026gt; \u0026lt;p\u0026gt;{{ .Summary | plainify | htmlUnescape }}{{ if .Truncated }}...{{ end }}\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; {{- end }} {{- if not (.Param \u0026#34;hideMeta\u0026#34;) }} \u0026lt;footer class=\u0026#34;entry-footer\u0026#34;\u0026gt; {{- partial \u0026#34;post_meta.html\u0026#34; . -}} \u0026lt;/footer\u0026gt; {{- end }} \u0026lt;/div\u0026gt; \u0026lt;!--加在這裡--\u0026gt; \u0026lt;!-- 下面這兩行從原本的\u0026lt;article class=\u0026#34;{{ $class }}\u0026#34;\u0026gt;和\u0026lt;header class=\u0026#34;entry-header\u0026#34;\u0026gt;搬下來 --\u0026gt; {{- $isHidden := (site.Params.cover.hidden | default site.Params.cover.hiddenInList) }} {{- partial \u0026#34;cover.html\u0026#34; (dict \u0026#34;cxt\u0026#34; . \u0026#34;IsHome\u0026#34; true \u0026#34;isHidden\u0026#34; $isHidden) }} \u0026lt;a class=\u0026#34;entry-link\u0026#34; aria-label=\u0026#34;post link to {{ .Title | plainify }}\u0026#34; href=\u0026#34;{{ .Permalink }}\u0026#34;\u0026gt;\u0026lt;/a\u0026gt; \u0026lt;/article\u0026gt; {{- end }} 在\\themes\\PaperMod\\assets\\css\\extended底下新建一個.css檔，命名為image-left.css .post-entry { display: flex; flex-direction: row; align-items: center; } .entry-cover { overflow: hidden; padding-left: 18px; height: 100%; width: 50%; margin-bottom: unset; } .post-info { display: inline-block; overflow: hidden; width: 90%; } 修改主頁與內文的差異\n在layouts/partials/cover.html，複製一份並命名為cover1.html 把cover1.html裡的\u0026lt;figure class=\u0026quot;entry-cover\u0026quot;\u0026gt;改為\u0026lt;figure class=\u0026quot;entry-cover1\u0026quot;\u0026gt; 在layouts/_default/single.html把{{- partial \u0026quot;cover.html\u0026quot; (dict \u0026quot;cxt\u0026quot; . \u0026quot;IsHome\u0026quot; false \u0026quot;isHidden\u0026quot; $isHidden) }}改為{{- partial \u0026quot;cover1.html\u0026quot; (dict \u0026quot;cxt\u0026quot; . \u0026quot;IsHome\u0026quot; false \u0026quot;isHidden\u0026quot; $isHidden) }} 3. Mac風格的code blocks 在\\themes\\PaperMod\\assets\\css\\extended底下新建一個.css檔，命名為mac-code-blocks.css\npre { position: relative; padding: 30px 10px 10px 10px; } .post-content pre code { font-family: Consolas; } pre::after { display: block; content: \u0026#34; \u0026#34;; position: absolute; border-radius: 50%; background: #ff5f56; width: 12px; height: 12px; top: 0; left: 12px; margin-top: 12px; -webkit-box-shadow: 20px 0 #ffbd2e, 40px 0 #27c93f; box-shadow: 20px 0 #ffbd2e, 40px 0 #27c93f; } 4. 讓tags與categories頁面的文章也顯示縮圖 assets/css/common/post-entry.css\n.tag-entry .entry-cover { display: flex; } ","permalink":"https://sz9751210.github.io/posts/hugo-papermod-enforce/","summary":"簡單紀錄一下papermod主題的優化，持續更新\u0026hellip;\n1. 目錄放側邊 替換以下路徑的code layouts/partials/toc.html\n{{- $headers := findRE \u0026#34;\u0026lt;h[1-6].*?\u0026gt;(.|\\n])+?\u0026lt;/h[1-6]\u0026gt;\u0026#34; .Content -}} {{- $has_headers := ge (len $headers) 1 -}} {{- if $has_headers -}} \u0026lt;aside id=\u0026#34;toc-container\u0026#34; class=\u0026#34;toc-container wide\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;toc\u0026#34;\u0026gt; \u0026lt;details {{if (.Param \u0026#34;TocOpen\u0026#34;) }} open{{ end }}\u0026gt; \u0026lt;summary accesskey=\u0026#34;c\u0026#34; title=\u0026#34;(Alt + C)\u0026#34;\u0026gt; \u0026lt;span class=\u0026#34;details\u0026#34;\u0026gt;{{- i18n \u0026#34;toc\u0026#34; | default \u0026#34;Table of Contents\u0026#34; }}\u0026lt;/span\u0026gt; \u0026lt;/summary\u0026gt; \u0026lt;div class=\u0026#34;inner\u0026#34;\u0026gt; {{- $largest := 6 -}} {{- range $headers -}} {{- $headerLevel := index (findRE \u0026#34;[1-6]\u0026#34; .","title":"Hugo PaperMod 優化"},{"content":" Know How, Know Why, Know What and When 把時間花在哪裡，成就就在哪裡 time is your most valuable resource, speed is your best friend 用實作來學習，永遠是初學的王道!以實戰來練習，永遠是進階的捷徑! Practice makes perfect. All experience comes from mistakes. Don\u0026rsquo;t be one of the leeches. ","permalink":"https://sz9751210.github.io/quote/","summary":" Know How, Know Why, Know What and When 把時間花在哪裡，成就就在哪裡 time is your most valuable resource, speed is your best friend 用實作來學習，永遠是初學的王道!以實戰來練習，永遠是進階的捷徑! Practice makes perfect. All experience comes from mistakes. Don\u0026rsquo;t be one of the leeches. ","title":"Quote"},{"content":"👨‍💻簡介 chgrp(change group) 用途：用於改變文件或目錄的所屬群組 語法 chgrp [OPTIONS] [文件或目錄] 參數 參數 說明 -c, \u0026ndash;changes 效果類似\u0026quot;-v\u0026quot;參數，但僅回報更改的部分。 -f, \u0026ndash;silent, \u0026ndash;quiet 不顯示錯誤資訊。 -v, \u0026ndash;verbose 顯示指令執行過程。 \u0026ndash;dereference 與-h相反，只對連結的對象做修改，而不是連結本身 -h, \u0026ndash;no-dereference 只對軟連結的檔作修改，而不更動其他任何相關檔。 \u0026ndash;no-preserve-root 取消對 root 文件系統的保護 \u0026ndash;preserve-root 保留對 root 文件系統的保護 \u0026ndash;reference=RFILE 把指定文件或目錄的所屬群組全部設成和參考文件或目錄的所屬群組相同。 -R, \u0026ndash;recursive 遞迴處理，將指定目錄下的所有檔及子目錄一併處理。 -H 如果命令行參數是軟連結到一個目錄，遍歷它 -L 遍歷每個軟連結到目錄的鏈接 -P 不遍歷任何軟連結（默認） 基本操作 改變文件的群組屬性 將test的所屬組更改為alan\nchgrp alan test 根據指定文件改變文件的群組屬性 test2參考test的群組屬性，使得test與test2的群組屬性相同\nchgrp --reference=test test2 ","permalink":"https://sz9751210.github.io/posts/linux-chgrp/","summary":"👨‍💻簡介 chgrp(change group) 用途：用於改變文件或目錄的所屬群組 語法 chgrp [OPTIONS] [文件或目錄] 參數 參數 說明 -c, \u0026ndash;changes 效果類似\u0026quot;-v\u0026quot;參數，但僅回報更改的部分。 -f, \u0026ndash;silent, \u0026ndash;quiet 不顯示錯誤資訊。 -v, \u0026ndash;verbose 顯示指令執行過程。 \u0026ndash;dereference 與-h相反，只對連結的對象做修改，而不是連結本身 -h, \u0026ndash;no-dereference 只對軟連結的檔作修改，而不更動其他任何相關檔。 \u0026ndash;no-preserve-root 取消對 root 文件系統的保護 \u0026ndash;preserve-root 保留對 root 文件系統的保護 \u0026ndash;reference=RFILE 把指定文件或目錄的所屬群組全部設成和參考文件或目錄的所屬群組相同。 -R, \u0026ndash;recursive 遞迴處理，將指定目錄下的所有檔及子目錄一併處理。 -H 如果命令行參數是軟連結到一個目錄，遍歷它 -L 遍歷每個軟連結到目錄的鏈接 -P 不遍歷任何軟連結（默認） 基本操作 改變文件的群組屬性 將test的所屬組更改為alan\nchgrp alan test 根據指定文件改變文件的群組屬性 test2參考test的群組屬性，使得test與test2的群組屬性相同\nchgrp --reference=test test2 ","title":"Linux 修改群組[chgrp]"},{"content":"專注於學習devops的菜雞工程師，凡事力求一鍵部署，喜歡寫一些小玩具嘗試新技術，時而分享好書的閱讀心得以及好文。\n","permalink":"https://sz9751210.github.io/about/","summary":"專注於學習devops的菜雞工程師，凡事力求一鍵部署，喜歡寫一些小玩具嘗試新技術，時而分享好書的閱讀心得以及好文。","title":"關於我"},{"content":"👨‍💻簡介 less 用途：對文件或其它輸出進行分頁顯示的工具，可查看壓縮檔 語法 less [OPTIONS] fileName 參數 參數 說明 -b \u0026lt;緩衝區大小\u0026gt; 設置緩衝區的大小 -e 當文件顯示結束後，自動離開 -f 強迫打開特殊文件，例如外圍設備代號、目錄和二進制文件 -g 只標誌最後搜索的關鍵詞 -i 忽略搜索時的大小寫 -m 顯示類似more指令的百分比 -N 顯示每行的行號 -o \u0026lt;文件名\u0026gt; 將less 輸出的內容在指定文件中保存起來 -Q 不使用警告音 -s 顯示連續空行為一行 -S 行過長時間將超出部分捨棄 -x \u0026lt;數字\u0026gt; 將「tab」鍵顯示為規定的數字空格 less模式下 用法 說明 /字符串 向下搜索「字符串」的功能 ?字符串 向上搜索「字符串」的功能 n 重複前一個搜索（與 / 或 ? 有關） N 反向重複前一個搜索（與 / 或 ? 有關） b 向後翻一頁 d 向後翻半頁 h 顯示幫助界面 q/ZZ 退出less 指令 u 向前滾動半頁 y 向前滾動一行 空格鍵 滾動一頁 回車鍵 滾動一行 j 下一行 k 上一行 [pagedown]： 向下翻動一頁 [pageup]： 向上翻動一頁 F 類似 tail -f 的效果，讀取寫入文件的最新內容， 按 ctrl+C 停止。 v 使用配置的編輯器進入編輯模式， shift+ZZ 保存退出到 less 查看模式。 g 移動到第一行 G 移動到最後一行 \u0026amp;pattern 僅顯示匹配模式的行，而不是整個文件 ma 使用 a 標記文本的當前位置 \u0026lsquo;a 導航到標記 a 處 :n 切換到下一個文件 :p 切換到上一個文件 基本操作 less test ","permalink":"https://sz9751210.github.io/posts/linux-less/","summary":"👨‍💻簡介 less 用途：對文件或其它輸出進行分頁顯示的工具，可查看壓縮檔 語法 less [OPTIONS] fileName 參數 參數 說明 -b \u0026lt;緩衝區大小\u0026gt; 設置緩衝區的大小 -e 當文件顯示結束後，自動離開 -f 強迫打開特殊文件，例如外圍設備代號、目錄和二進制文件 -g 只標誌最後搜索的關鍵詞 -i 忽略搜索時的大小寫 -m 顯示類似more指令的百分比 -N 顯示每行的行號 -o \u0026lt;文件名\u0026gt; 將less 輸出的內容在指定文件中保存起來 -Q 不使用警告音 -s 顯示連續空行為一行 -S 行過長時間將超出部分捨棄 -x \u0026lt;數字\u0026gt; 將「tab」鍵顯示為規定的數字空格 less模式下 用法 說明 /字符串 向下搜索「字符串」的功能 ?字符串 向上搜索「字符串」的功能 n 重複前一個搜索（與 / 或 ? 有關） N 反向重複前一個搜索（與 / 或 ? 有關） b 向後翻一頁 d 向後翻半頁 h 顯示幫助界面 q/ZZ 退出less 指令 u 向前滾動半頁 y 向前滾動一行 空格鍵 滾動一頁 回車鍵 滾動一行 j 下一行 k 上一行 [pagedown]： 向下翻動一頁 [pageup]： 向上翻動一頁 F 類似 tail -f 的效果，讀取寫入文件的最新內容， 按 ctrl+C 停止。 v 使用配置的編輯器進入編輯模式， shift+ZZ 保存退出到 less 查看模式。 g 移動到第一行 G 移動到最後一行 \u0026amp;pattern 僅顯示匹配模式的行，而不是整個文件 ma 使用 a 標記文本的當前位置 \u0026lsquo;a 導航到標記 a 處 :n 切換到下一個文件 :p 切換到上一個文件 基本操作 less test ","title":"Linux 分頁查看檔案[less]"},{"content":"👨‍💻簡介 tail 用途：印出結尾，與 head 相法的功用 語法 tail [option] [fileName] 參數 參數 說明 -n \u0026lt;行數\u0026gt; 顯示尾部 N 行的訊息 (N 為數字) -c \u0026lt;字節數\u0026gt; 顯示尾部倒數 N bytes 的字元 (N 為數字) -q 隱藏文件名 -v 顯示文件名 -f 循環讀取，持續監看最新追加的內容，常用於查閱正在改變的日誌文件。 基本操作 假設有一個檔案 tail_test 長這樣\ntest1 test2 test3 查看後 2 行 tail -n 2 head_test # output test2 test3 查看後兩個字 head -c 2 tail_test # output t3% 顯示文件名 tail -v tail_test # output ==\u0026gt; tail_test \u0026lt;== test1 test2 test3 相關指令(可選) grep sort ","permalink":"https://sz9751210.github.io/posts/linux-tail/","summary":"👨‍💻簡介 tail 用途：印出結尾，與 head 相法的功用 語法 tail [option] [fileName] 參數 參數 說明 -n \u0026lt;行數\u0026gt; 顯示尾部 N 行的訊息 (N 為數字) -c \u0026lt;字節數\u0026gt; 顯示尾部倒數 N bytes 的字元 (N 為數字) -q 隱藏文件名 -v 顯示文件名 -f 循環讀取，持續監看最新追加的內容，常用於查閱正在改變的日誌文件。 基本操作 假設有一個檔案 tail_test 長這樣\ntest1 test2 test3 查看後 2 行 tail -n 2 head_test # output test2 test3 查看後兩個字 head -c 2 tail_test # output t3% 顯示文件名 tail -v tail_test # output ==\u0026gt; tail_test \u0026lt;== test1 test2 test3 相關指令(可選) grep sort ","title":"Linux 查看結尾文字[tail]"},{"content":"👨‍💻簡介 head 用途：用來顯示開頭的文字區塊，看該檔案頭部 (預設為 10 行) 語法 head [option] [fileName] 參數 參數 說明 -n \u0026lt;行數\u0026gt; 顯示前 N 行的訊息 (N 為數字) -c \u0026lt;字節數\u0026gt; 顯示前 N bytes 的字元 (N 為數字) -q 隱藏文件名 -v 顯示文件名 基本操作 假設有一個檔案 head_test 長這樣\ntest1 test2 test3 查看前 2 行 head -n 2 head_test # output test1 test2 查看前兩個字 head -c 2 head_test # output te% 顯示文件名 head -v head_test # output ==\u0026gt; head_test \u0026lt;== test1 test2 test3 ","permalink":"https://sz9751210.github.io/posts/linux-head/","summary":"\u003ch2 id=\"簡介\"\u003e👨‍💻簡介\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003ehead\u003c/li\u003e\n\u003cli\u003e用途：用來顯示開頭的文字區塊，看該檔案頭部 (預設為 10 行)\u003c/li\u003e\n\u003c/ul\u003e","title":"Linux 查看開頭文字[head]"},{"content":"👨‍💻簡介 cat 用途：查看文件，把檔案串連接後傳到基本輸出 語法 cat [-AbeEnstTuv] [--help] [--version] fileName 參數 參數 說明 -A, \u0026ndash;show-all 等價於-vET -b, \u0026ndash;number-nonblank 和 -n 相似，只不過對於空白行不編號 -e 等價於-vE -E, \u0026ndash;show-ends 在每一行末端加入$ -n, \u0026ndash;number 由 1 開始對所有輸出的行數編號 -s, \u0026ndash;squeeze-blank 當遇到有連續兩行以上的空白行，就代換為一行的空白行 -t 等價於-vT -T, \u0026ndash;show-tabs 以^I 取代 TAB -u 輸出時不必經過緩衝區。（原來是預設為使用緩衝區）。 -v, \u0026ndash;show-nonprinting 除了 LFD 及 TAB 之外，使用^及 M-表示法顯示字元 \u0026ndash;help 列出幫助資訊 \u0026ndash;version 列出版本資訊 基本操作 查看檔案 cat test1 查看檔案並顯示行號 假設有個檔案test2長這樣\ntest1 test2 cat -n test2 # ountput 1 test1 2 3 4 test2 如果要對空白行取消編號的話可改用-b選項\ncat -b test2 # ountput 1 test1 2 test2 如果要把一行以上的空白行合併為一行可使用-s選項\ncat -s test2 # output aaa bbb ","permalink":"https://sz9751210.github.io/posts/linux-cat/","summary":"\u003ch2 id=\"簡介\"\u003e👨‍💻簡介\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003ecat\u003c/li\u003e\n\u003cli\u003e用途：查看文件，把檔案串連接後傳到基本輸出\u003c/li\u003e\n\u003c/ul\u003e","title":"Linux 查看檔案[cat]"},{"content":"👨‍💻簡介 chown(change owner) 用途：變更文件或目錄的權限 語法 chmod [OPTIONS] [user:group] file or dir 參數 參數 說明 -c, \u0026ndash;changes 效果類似-v，但僅回傳更改的部分 -f, \u0026ndash;silent, \u0026ndash;quiet 不顯示錯誤訊息 -v, \u0026ndash;verbose 顯示指令執行過程 \u0026ndash;dereference 效果和-h參數相同 -h, \u0026ndash;no-dereference 只對軟連結的文件做修改，而不更動其它任何相關文件 \u0026ndash;from=CURRENT_OWNER:CURRENT_GROUP 確認修改前的擁有者及所屬群組正確才進行修改 \u0026ndash;no-preserve-root do not treat \u0026lsquo;/\u0026rsquo; specially (the default) \u0026ndash;preserve-root fail to operate recursively on \u0026lsquo;/\u0026rsquo; \u0026ndash;reference=RFILE 把指定文件或目錄的擁有者與所屬群組全都改成和參考文件或目錄一樣 -R, \u0026ndash;recursive 遞歸處理，將指定目錄下的所有文件以及子目錄一併處理 -H if a command line argument is a symbolic link to a directory, traverse it -L traverse every symbolic link to a directory encountered -P do not traverse any symbolic links (default) 基本操作 將檔案或目錄修改擁有者 chown alan file1 將檔案或目錄修改所屬群組 chown :alangroup file1 同時修改擁有者及所屬組 chown alan:alangroup file1 遞歸修改整個資料夾裡的所有檔案 chown -R alan:alangroup dir 顯示執行結果 chown -v alan:alangroup file1 不顯示錯誤訊息 chown -f alan:alangroup file1 參考文件屬性進行修改 chown --reference=reffile file1 事先確認擁有者與群組在進行修改 chown --from=root:root alan:alangroup file1 只確認擁有者或是群組 # 只確認擁有者 chown --from=root alan:alangroup file1 # 只確認所屬組 chown --from=:root alan:alangroup file1 參考資料 Linux 更改檔案擁有者與群組，chown 指令使用教學與範例 - G. T. Wang (gtwang.org) ","permalink":"https://sz9751210.github.io/posts/linux-chown/","summary":"👨‍💻簡介 chown(change owner) 用途：變更文件或目錄的權限 語法 chmod [OPTIONS] [user:group] file or dir 參數 參數 說明 -c, \u0026ndash;changes 效果類似-v，但僅回傳更改的部分 -f, \u0026ndash;silent, \u0026ndash;quiet 不顯示錯誤訊息 -v, \u0026ndash;verbose 顯示指令執行過程 \u0026ndash;dereference 效果和-h參數相同 -h, \u0026ndash;no-dereference 只對軟連結的文件做修改，而不更動其它任何相關文件 \u0026ndash;from=CURRENT_OWNER:CURRENT_GROUP 確認修改前的擁有者及所屬群組正確才進行修改 \u0026ndash;no-preserve-root do not treat \u0026lsquo;/\u0026rsquo; specially (the default) \u0026ndash;preserve-root fail to operate recursively on \u0026lsquo;/\u0026rsquo; \u0026ndash;reference=RFILE 把指定文件或目錄的擁有者與所屬群組全都改成和參考文件或目錄一樣 -R, \u0026ndash;recursive 遞歸處理，將指定目錄下的所有文件以及子目錄一併處理 -H if a command line argument is a symbolic link to a directory, traverse it -L traverse every symbolic link to a directory encountered -P do not traverse any symbolic links (default) 基本操作 將檔案或目錄修改擁有者 chown alan file1 將檔案或目錄修改所屬群組 chown :alangroup file1 同時修改擁有者及所屬組 chown alan:alangroup file1 遞歸修改整個資料夾裡的所有檔案 chown -R alan:alangroup dir 顯示執行結果 chown -v alan:alangroup file1 不顯示錯誤訊息 chown -f alan:alangroup file1 參考文件屬性進行修改 chown --reference=reffile file1 事先確認擁有者與群組在進行修改 chown --from=root:root alan:alangroup file1 只確認擁有者或是群組 # 只確認擁有者 chown --from=root alan:alangroup file1 # 只確認所屬組 chown --from=:root alan:alangroup file1 參考資料 Linux 更改檔案擁有者與群組，chown 指令使用教學與範例 - G.","title":"Linux 修改目錄權限[chown]"},{"content":"👨‍💻簡介 幫自己紀錄一下如何處理linux機器的指標\nCPU top(交互模式) top P b x y top(預設指定CPU) top -o %CPU ps ps aux --sort -pcpu MEM top top M b x y top(預設指定MEM) top -o %MEM ps ps aux --sort -pmem swap free free -h vmstat vmstat swapon swapon -s proc_file cat /proc/swaps shell for file in /proc/*/status ; do awk \u0026#39;/VmSwap|Name/{printf $2 \u0026#34; \u0026#34; $3}END{ print \u0026#34;\u0026#34;}\u0026#39; $file; done | sort -k 2 -n -r | less 參考資料 8 Useful Commands to Monitor Swap Space Usage in Linux (tecmint.com) Linux Find Out What Process Are Using Swap Space - nixCraft (cyberciti.biz) 筆記: Linux 建立 Swap, 以及 Swap 使用狀況監控, OOM @mini box 迷你盒子 - nidBox親子盒子 Linux 查看正在吃 swap 的程式 – Tsung\u0026rsquo;s Blog (longwin.com.tw) disk df df -h du du -shc /path/* du -h -x --max-depth=1 conn netstat # 查看80 port的總連線數 netstat -na | grep 80 | wc -l # 統計連線的ip netstat -ntu | grep ESTAB | awk \u0026#39;{print $5}\u0026#39; | cut -d: -f1 | sort | uniq -c | sort -nr ","permalink":"https://sz9751210.github.io/posts/%E7%B3%BB%E7%B5%B1%E7%95%B0%E5%B8%B8%E6%8C%87%E6%A8%99%E9%99%A4%E9%8C%AF/","summary":"\u003ch2 id=\"簡介\"\u003e👨‍💻簡介\u003c/h2\u003e\n\u003cp\u003e幫自己紀錄一下如何處理linux機器的指標\u003c/p\u003e","title":"系統異常指標除錯"},{"content":"📔心得 之前因為常需要跑devops相關工具，因此開發環境完全是用Ubuntu的圖形化介面，但偶爾會遇到一些延遲以及小bug，偶然的機會下發現在windows設定git-bash似乎也能達到一樣的效果，也能順便增加對windows開發人員生態系的了解，因此本篇主要是針對如何設定美麗的terminal以及vscode也整合，紀錄一下以便日後查詢\n👨‍💻簡介 欲安裝項目\nwindows terminal git-bash zsh oh-my-zsh p10k plugins 🎯setup 安裝windows terminal 點開市集搜尋windows terminal，windows 11用戶預設已安裝\n安裝git-bash for windows 到官網下載windows版本，需注意記得打勾git-bash for windows terminal\n安裝zsh 去msys2下載zsh的二進制檔案\n解壓縮並複製zsh覆蓋到git安裝目錄\noh-my-zsh 安裝oh-my-zsh 打開git-bash輸入以下指令進行安裝\nsh -c \u0026#34;$(curl -fsSL https://raw.githubusercontent.com/ohmyzsh/ohmyzsh/master/tools/install.sh)\u0026#34; 設定預設啟動zsh 在家目錄新增.bashrc，以我的範例為C:\\Users\\alan\\.bashrc，把以下的code貼上\nif [ -t 1 ]; then exec zsh fi p10k 安裝相對應字體 這邊使用FireCode當做範例，下載好後解壓縮並安裝 🔗下載連結 \u0026ndash;\u0026gt; Nerd Fonts - Iconic font aggregator, glyphs/icons collection, \u0026amp; fonts patcher\n打開終端機並選擇設定，選擇git-bash -\u0026gt; 外觀 -\u0026gt; 字體，選擇FiraCode NF\n安裝p10k 透過git下載p10k到家目錄下\ngit clone --depth=1 https://github.com/romkatv/powerlevel10k.git ${ZSH_CUSTOM:-$HOME/.oh-my-zsh/custom}/themes/powerlevel10k 修改~/.zshrc的ZSH_THEME\n設定p10k 重新讀取zsh 設定檔\nsource ~/.zshrc 會進入p10k的樣式設定，這時候樣式都會正常，因為前面已經安裝相對應的字體，\n接著就按照說明完成樣式設定，就能開始享受在linux環境下幾乎一樣的終端機體驗🚀\n安裝插件 zsh-syntax-highlighting 語法高亮 官方安裝指南\ngit clone https://github.com/zsh-users/zsh-syntax-highlighting.git ${ZSH_CUSTOM:-~/.oh-my-zsh/custom}/plugins/zsh-syntax-highlighting 在.zshrc加入插件\nzsh-autosuggestions 自動補全 官方安裝指南\ngit clone https://github.com/zsh-users/zsh-autosuggestions ${ZSH_CUSTOM:-~/.oh-my-zsh/custom}/plugins/zsh-autosuggestions 在.zshrc加入插件\n插件都安裝好後就重載設定檔即可\n","permalink":"https://sz9751210.github.io/posts/windows-terminal-setup/","summary":"\u003ch2 id=\"心得\"\u003e📔心得\u003c/h2\u003e\n\u003cp\u003e之前因為常需要跑devops相關工具，因此開發環境完全是用Ubuntu的圖形化介面，但偶爾會遇到一些延遲以及小bug，偶然的機會下發現在windows設定git-bash似乎也能達到一樣的效果，也能順便增加對windows開發人員生態系的了解，因此本篇主要是針對如何設定美麗的terminal以及vscode也整合，紀錄一下以便日後查詢\u003c/p\u003e\n\u003ch2 id=\"簡介\"\u003e👨‍💻簡介\u003c/h2\u003e\n\u003cp\u003e欲安裝項目\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003ewindows terminal\u003c/li\u003e\n\u003cli\u003egit-bash\u003c/li\u003e\n\u003cli\u003ezsh\u003c/li\u003e\n\u003cli\u003eoh-my-zsh\u003c/li\u003e\n\u003cli\u003ep10k\u003c/li\u003e\n\u003cli\u003eplugins\u003c/li\u003e\n\u003c/ul\u003e","title":"windows terminal + git-bash + zsh + oh-my-zsh"},{"content":"📔心得 之前都介紹docker監控container，這次來點不一樣的，直接裝在k8s裡面去監控pod的一些指標。\n基本的指標像是cpu, mem, pod數量, node數量等等，都能透過kube-state-metrics完成，而如果想要監控一些流量的指標，像是tcp連線數，tw數等，則是需要另外在服務的pod裡另外寫node-exporter的container，組成side-car的形式，讓exporter將指標送往prometheus。\n在撰寫的過程，遇到比較大的難題是prometheus的config檔撰寫，一開始打算使用docker-compose的方式起monitor服務，然後去call k8s cluster取得相關指標，但常常call不到服務，可能是因為minikube的關係，在本地也跑docker，最後改成直接安裝在k8s裡面，另外建立一個namespace放監控相關的服務，有機會在測試kind以及k3s。\ndemo用的deploy使用skaffold這本地開發k8s的神器，搭配kustomize可讓我依據所需測試的環境下去做自動佈署，有機會再另外介紹這工具。\n之後預計會再新增prometheus adapter，讓我的prometheus metrics可以成為我hpa的擴縮判斷，因為基本的hpa指標只有cpu以及mem，如果可以依照網路流量變大，幫我擴展pod，當流量變小時幫我縮pod，讓我能自定義指標，相信使用k8s的效益會更大。\n🔗詳細專案位置 \u0026ndash;\u0026gt; https://github.com/sz9751210/k8s-monitor\n👨‍💻簡介 在minikube環境下安裝prometheus以及grafana監控 k8s\ndemo-deploy：測試用deployment 使用skaffold搭配kustomize的方式下去佈署 prometheus, kube-state-metrics：撈取服務相關指標 grafana：監控UI 🎯setup start minikube minikube start deploy demo-deployment cd demo-deploy \u0026amp;\u0026amp; skaffold run -p prod install monitor sh ./install_monitor.sh setting data source 使用上面執行完的grafana url http://192.168.x.x:xxx 輸入帳號密碼：admin 選擇data source -\u0026gt; add data source -\u0026gt; prometheus url設定為http://prometheus:9090 -\u0026gt; 點擊save import grafana ui 點擊左上角回到首頁並選擇旁邊的dashboard -\u0026gt; import 到grafana/dashboard/複製dashboard.json貼到grafana並點擊load -\u0026gt; import ✅TODO 使用壓測pod去測試hpa 使用prometheus-adapter自定義指標 ","permalink":"https://sz9751210.github.io/posts/k8s-monitor/","summary":"\u003ch2 id=\"心得\"\u003e📔心得\u003c/h2\u003e\n\u003cp\u003e之前都介紹docker監控container，這次來點不一樣的，直接裝在k8s裡面去監控pod的一些指標。\u003c/p\u003e\n\u003cp\u003e基本的指標像是cpu, mem, pod數量, node數量等等，都能透過kube-state-metrics完成，而如果想要監控一些流量的指標，像是tcp連線數，tw數等，則是需要另外在服務的pod裡另外寫node-exporter的container，組成side-car的形式，讓exporter將指標送往prometheus。\u003c/p\u003e\n\u003cp\u003e在撰寫的過程，遇到比較大的難題是prometheus的config檔撰寫，一開始打算使用docker-compose的方式起monitor服務，然後去call k8s cluster取得相關指標，但常常call不到服務，可能是因為minikube的關係，在本地也跑docker，最後改成直接安裝在k8s裡面，另外建立一個namespace放監控相關的服務，有機會在測試kind以及k3s。\u003c/p\u003e\n\u003cp\u003edemo用的deploy使用skaffold這本地開發k8s的神器，搭配kustomize可讓我依據所需測試的環境下去做自動佈署，有機會再另外介紹這工具。\u003c/p\u003e\n\u003cp\u003e之後預計會再新增prometheus adapter，讓我的prometheus metrics可以成為我hpa的擴縮判斷，因為基本的hpa指標只有cpu以及mem，如果可以依照網路流量變大，幫我擴展pod，當流量變小時幫我縮pod，讓我能自定義指標，相信使用k8s的效益會更大。\u003c/p\u003e\n\u003cp\u003e🔗詳細專案位置 \u0026ndash;\u0026gt; \u003ca href=\"https://github.com/sz9751210/k8s-monitor\"\u003ehttps://github.com/sz9751210/k8s-monitor\u003c/a\u003e\u003c/p\u003e","title":"K8S-monitor"},{"content":"📚讀後心得 當初在研究Elastic Stack，ILM這部份還不熟時，剛好搜尋到喬叔的鐵人賽文章，閱讀時彷彿挖到了寶，對於Index的管理講解得非常透徹，從Index如何被建立，使用Template以及Alias，再到導入ILM以及搭配Rollover以及Shrink等方式達到索引、搜尋、儲存等最佳化，一步一步穩定順利的完成，真的很感動。\n之前使用Elastic Stack並沒有使用到ILM的配置，所以單個Index可能會超過官方建議的大小，並且使用的是以一天為單位，但實務上並非每個服務都是固定的大小，因此導入ILM對於整體的效能會有更好的幫助，並且使用三溫暖架構，讓最新的log都放在效能較好的機器上，較舊的log則隨著自定義的時間轉移到效能較差的機器上，讓搜尋能有更好的體驗。\n而Rollover的使用，當資料量達到設定的條件、或是時間過太久，將Index進行rotate，產生新的Index來接收新的資料，讓原先的Index依照ILM的設定進入下一個warm phase階段。\nForce Merge以及Shrink則是針對Segment Files數量以及Shards數量進行合併達到最佳化，Segment files的單檔愈大，總數愈少，空間使用率愈好，而已刪除的文件，會是透過「標示為刪除」的方式紀錄在新的Segment File，並且會等到merge時才真正的刪除，因此Force Merge將Shard中的Segment Files進行合併，可以釋放被標記要被刪除的文件在原先是read-only的Segment File所佔用的空間，藉此提升搜尋效率，；而Shrink則是減少Shards的數量，變少的規則是原先數值的因數，減少Shard的數量，增加Shard的大小，好處是可以提升搜尋的效率，儲存利用率也會較佳，壞處是如果Cluster rebalancing時成本較高，並且會限制資料被分散處理的能力，因此建議使用在較舊的資料上下去做優化處理。\n書中還有提到很多最佳化的技巧，例如Shards建議的大小、memory cache的建議大小、Indexing大量資料時的處理方式等等，各種神奇的優化技巧可以讓你針對自己的使用情境下去做測試以及改善，讓你的Elastic Stack頭好壯壯，最後也感謝喬叔的經驗分享，讓我在研究Elastic Stack上少走了很多彎路，底下會放上鐵人賽的連結。\n🔗【喬叔帶你上手Elastic Stack】總目錄 \u0026ndash;\u0026gt; https://ithelp.ithome.com.tw/users/20129543/ironman/3148\n","permalink":"https://sz9751210.github.io/posts/%E5%96%AC%E5%8F%94%E5%B8%B6%E4%BD%A0%E4%B8%8A%E6%89%8Belastic-stackelasticsearch%E7%9A%84%E6%9C%80%E4%BD%B3%E5%AF%A6%E8%B8%90%E8%88%87%E6%9C%80%E4%BD%B3%E5%8C%96%E6%8A%80%E5%B7%A7/","summary":"\u003ch2 id=\"讀後心得\"\u003e📚讀後心得\u003c/h2\u003e\n\u003cp\u003e當初在研究Elastic Stack，ILM這部份還不熟時，剛好搜尋到喬叔的鐵人賽文章，閱讀時彷彿挖到了寶，對於Index的管理講解得非常透徹，從Index如何被建立，使用Template以及Alias，再到導入ILM以及搭配Rollover以及Shrink等方式達到索引、搜尋、儲存等最佳化，一步一步穩定順利的完成，真的很感動。\u003c/p\u003e\n\u003cp\u003e之前使用Elastic Stack並沒有使用到ILM的配置，所以單個Index可能會超過官方建議的大小，並且使用的是以一天為單位，但實務上並非每個服務都是固定的大小，因此導入ILM對於整體的效能會有更好的幫助，並且使用三溫暖架構，讓最新的log都放在效能較好的機器上，較舊的log則隨著自定義的時間轉移到效能較差的機器上，讓搜尋能有更好的體驗。\u003c/p\u003e","title":"喬叔帶你上手Elastic Stack：Elasticsearch的最佳實踐與最佳化技巧"},{"content":"👀QUICK REVIEW The book in 3 Sentences 用三段話說明這本書的內容1\n像管理公司一樣管理自己，像享受遊戲一樣享受生活 硬實力決定起點，軟實力決定能走多快多遠 Learning, Doing, Learning and Teaching Purpose of the book 書的目的\n教導你如何成為全方位的軟體開發人員 期望給你各方面有用、實用又可用的忠告。 告訴你軟技能的重要性 My Top 3 Quotes 我最喜歡的 3 句 Quotes\n越努力將船駛向失敗，從相反方向吹來的成功之風就越強 唯有讓我參與其中，才是真正的學習 信念轉成思想 思想化作文字 文字觸發行動 行動成為習慣 習慣建立價值 價值決定命運 📚讀後心得 本書不教你寫程式，教導你程式以外的實用技能，讓你知道一名成功的軟體開發人員，不能只會寫code，還要有精彩的人生。\n書中作者很系統的歸納了程序員職業發展的方方面面，包括職業目標、公司選擇、如何學習、如何理財、健康和精神、自我認知等等，或許其中的一些觀點之前都零散的接觸過，這裡作者能結合自己的經驗，將這些話題一一展開，，並且引發了我更多的思考，而這些思考，將貫穿我整個職業生涯乃至人生。\n全文總共分為如下幾個方面：\n職業：職業的各個方面，包括面試，辭職，個人創業。把自己當成一家公司看待，不過我們這家公司只為一個客戶服務，就是我們工作的單位。 自我行銷：包括行銷重要性，一致性，網絡行銷等。 學習：十步學習法。尋找導師\u0026amp;\u0026amp;成為導師。 生產力：番茄鐘，定量執行法。也從科學的角度解釋瞭如何更有生產力。 理財：觀念大多數來自其他理財書籍。例如窮爸爸富爸爸。 健身：健身重要性。以及應該用上科技工具。 心靈：講述如何保持正面心態，擁抱失敗，跳脫舒適圈。 讀這本書最有感的地方是學習的篇章，作者提出的十步驟學習法讓我印象深刻，重點如下\n要先知道全貌，有初步的了解，然後決定想學習範圍，並把大主題拆成小主題，方便設定目標。 透過設定的目標，尋找相關的資源，並建立學習計劃。 對自己的目標學習最小量的知識，足以讓接下來的實作可完成。 實作當作是玩玩具，邊動手操作邊玩邊學，儘可能讓自己所設定的目標，學習計劃都使用上，做一個小小的專題，增加對自己所學的瞭解。 把自己所學到的知識，用自己的話講出來，化輸入為輸出。 另外還有生產力那個章節，番茄鐘的使用也讓我很有共鳴，利用番茄鐘工作法，可以知道自己的生產力落在哪個範圍，畢竟我們一天的專注力有限，如何分配事情的先後順序變得更為重要。\n","permalink":"https://sz9751210.github.io/posts/soft-skills-%E8%BB%9F%E5%AF%A6%E5%8A%9B%E8%BB%9F%E9%AB%94%E9%96%8B%E7%99%BC%E4%BA%BA%E5%93%A1%E7%9A%84%E7%94%9F%E5%AD%98%E6%89%8B%E5%86%8A/","summary":"\u003ch2 id=\"quick-review\"\u003e👀QUICK REVIEW\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003eThe book in 3 Sentences 用三段話說明這本書的內容1\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e像管理公司一樣管理自己，像享受遊戲一樣享受生活\u003c/li\u003e\n\u003cli\u003e硬實力決定起點，軟實力決定能走多快多遠\u003c/li\u003e\n\u003cli\u003eLearning, Doing, Learning and Teaching\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003ePurpose of the book 書的目的\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e教導你如何成為全方位的軟體開發人員\u003c/li\u003e\n\u003cli\u003e期望給你各方面有用、實用又可用的忠告。\u003c/li\u003e\n\u003cli\u003e告訴你軟技能的重要性\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eMy Top 3 Quotes 我最喜歡的 3 句 Quotes\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e越努力將船駛向失敗，從相反方向吹來的成功之風就越強\u003c/li\u003e\n\u003cli\u003e唯有讓我參與其中，才是真正的學習\u003c/li\u003e\n\u003cli\u003e信念轉成思想 思想化作文字 文字觸發行動 行動成為習慣 習慣建立價值 價值決定命運\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e","title":"Soft Skills 軟實力｜軟體開發人員的生存手冊"},{"content":"📔心得 上次使用docker建立起ELK-stack，最近剛好在研究ansible，所以也寫了一下使用playbook的方式建立起ELK-stack。\n撰寫的過程中，先從官方文件查看安裝流程，接著再去找ansible相對應的module，在目錄結構的劃分也學習到了不少，從一開始只有一個main.yml慢慢獨立出來有一個根目錄的yml再去include task，並學會如何使用template以及vars。\n在撰寫template時，使用到了jinja2語法，直接可以套用vars，讓我的template複製進去就都載入好我要的參數，並且可以依照我的inventory動態設定我的參數，真的有夠強大。\n最後要感謝凍仁大的ansible教程，許多學習資訊都是從凍仁大的ansible git book學到的，會把網址放在下面，有興趣的可以去參考一下，寫得很簡潔明瞭，讓新手也能很快上手，尤其是使用docker-compose就能練習ansible的部份，使用jupyter notebook下去跑ansible module有夠方便。\n🔗凍仁大ansible指南 \u0026ndash;\u0026gt; 現代 IT 人一定要知道的 Ansible 自動化組態技巧\n🔗Ansible-ELK repo \u0026ndash;\u0026gt; Ansible-ELK\n👨‍💻簡介 在gcp環境下使用ansible playbook 建立elk stack\nelasticsearch：主要會先需要先跑init master，接著再去跑seed host去加入master組成cluster架構，邏輯上還有可修改的地方，目前先以兩份yaml分開跑下去做建立，在跑完init master後會先建立iim以及index template logstash：直接將pipeline等設定都複製進去 📁資料夾結構 . ├── create_elasticsearch_master_instance.yaml ├── create_elasticsearch_slave_instance.yaml ├── create_filebeat_instance.yaml ├── create_kibana_instance.yaml ├── create_logstash_instance.yaml ├── files │ ├── elasticsearch │ │ ├── api.sh │ │ ├── certs │ │ └── elasticsearch.repo │ ├── kibana │ │ └── kibana.repo │ └── logstash │ ├── conf.d │ │ └── logstash.conf │ ├── logstash.repo │ ├── logstash.yml │ └── pipelines.yml ├── group_vars │ └── all │ ├── env.yml copy.example │ └── package.yml ├── inventory │ └── elk.test.node ├── inventory.instance.create.yml.example ├── README.md ├── roles │ ├── elasticsearch │ │ ├── tasks │ │ │ ├── create_disk.yml │ │ │ ├── install_elastic.yml │ │ │ ├── main.yml │ │ │ ├── setup_disk.yml │ │ │ ├── setup_elastic_master.yml │ │ │ └── setup_elastic_slave.yml │ │ └── templates │ │ └── elasticsearch.yml.j2 │ ├── instance │ │ └── tasks │ │ ├── create.yml │ │ └── setup.yml │ ├── kibana │ │ ├── tasks │ │ │ └── main.yml │ │ └── templates │ │ └── kibana.yml.j2 │ └── logstash │ └── tasks │ └── main.yml └── vars ├── elasticsearch │ ├── elasticsearch_var.yml │ └── elasticsearch_var.yml.example ├── instance │ ├── instance_var.yml │ └── instance_var.yml.example ├── kibana │ ├── kibana_var.yml │ └── kibana_var.yml.example └── logstash ├── logstash_var.yml └── logstash_var.yml.example 🔰基礎介紹 設定機器資訊：複製好inventory.instance.create.yml.example後，可參考inventory裡的設定，主要設定gcp的資訊，elasticsearch的node_role為data_role，可參考以下連結 Elasticsearch Multi-Tier Architecture | Hot, Warm, Cold \u0026amp; Frozen\n設定group_vars的env.yml，改成自己的gcp的專案以及要設定的region\n設定vars裡的相對yml，可參考範例\nelasticsearch：主要設定掛載的硬碟資訊 kibana,logstash：設定elasticsearch的host資訊 🎯setup elasticsearch_master -\u0026gt; elasticsearch_slave -\u0026gt; logstash -\u0026gt; kibana\n指令 ANSIBLE_HOST_KEY_CHECKING=False ansible-playbook -i inventory.instance.create.yml create_xxx_instance.yaml -v ✅TODO elasticsearch playbook 優化 添加filebeat role disk 修改建置資料夾 ","permalink":"https://sz9751210.github.io/posts/ansible-elk/","summary":"\u003ch2 id=\"心得\"\u003e📔心得\u003c/h2\u003e\n\u003cp\u003e上次使用docker建立起ELK-stack，最近剛好在研究ansible，所以也寫了一下使用playbook的方式建立起ELK-stack。\u003c/p\u003e\n\u003cp\u003e撰寫的過程中，先從官方文件查看安裝流程，接著再去找ansible相對應的module，在目錄結構的劃分也學習到了不少，從一開始只有一個main.yml慢慢獨立出來有一個根目錄的yml再去include task，並學會如何使用template以及vars。\u003c/p\u003e\n\u003cp\u003e在撰寫template時，使用到了jinja2語法，直接可以套用vars，讓我的template複製進去就都載入好我要的參數，並且可以依照我的inventory動態設定我的參數，真的有夠強大。\u003c/p\u003e\n\u003cp\u003e最後要感謝凍仁大的ansible教程，許多學習資訊都是從凍仁大的ansible git book學到的，會把網址放在下面，有興趣的可以去參考一下，寫得很簡潔明瞭，讓新手也能很快上手，尤其是使用docker-compose就能練習ansible的部份，使用jupyter notebook下去跑ansible module有夠方便。\u003c/p\u003e\n\u003cp\u003e🔗凍仁大ansible指南 \u0026ndash;\u0026gt; \u003ca href=\"https://chusiang.gitbooks.io/automate-with-ansible/content/\"\u003e現代 IT 人一定要知道的 Ansible 自動化組態技巧\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e🔗Ansible-ELK repo \u0026ndash;\u0026gt; \u003ca href=\"https://github.com/sz9751210/ansible-elk\"\u003eAnsible-ELK\u003c/a\u003e\u003c/p\u003e\n\u003ch2 id=\"簡介\"\u003e👨‍💻簡介\u003c/h2\u003e\n\u003cp\u003e在gcp環境下使用ansible playbook 建立elk stack\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eelasticsearch：主要會先需要先跑init master，接著再去跑seed host去加入master組成cluster架構，邏輯上還有可修改的地方，目前先以兩份yaml分開跑下去做建立，在跑完init master後會先建立iim以及index template\u003c/li\u003e\n\u003cli\u003elogstash：直接將pipeline等設定都複製進去\u003c/li\u003e\n\u003c/ul\u003e","title":"ANSIBLE-ELK"},{"content":"👀QUICK REVIEW The book in 3 Sentences 用三段話說明這本書的內容\n為了學習而寫 闡述是最有效的學習方法 簡要記述內容中提出的主要想法，而不是蒐集引文，並努力思考與其他不同內容的想法連結再一起 Purpose of the book 書的目的\n提供大腦一個外部記憶體去儲存細節與參考資料，讓大腦能專注在發揮創造力與深入的學習 透過原子性將多個重點的大筆記拆解成像是卡片一樣的小筆記 具有連結性，將各個小筆記的點透過關聯性連結成大筆記 My Top 3 Quotes 我最喜歡的 3 句 Quotes\n如果你無法清楚地說出來，你就無法真正的理解 人必須要找出想法的不同之處，掌握其中的差異，不管這些差異式很明顯可見，還是隱藏在概念裡 正確的學習代表的是理解，而理解是指用有意義的方式，連接到已知的知識 📚讀後心得 《 卡片盒筆記：最高效思考筆記術，德國教授超強秘技，促進寫作、學習與思考，使你洞見源源不斷，成為專家 》\n從以前做筆記都是使用資料夾的分類邏輯，接著會碰到如果一篇筆記有兩種以上的概念時，要如何去分類，這問題也是困擾了我很久，在網路上搜尋筆記法，剛好看到obsidian這套軟體，他裏面的反向連結功能真的太強大了，讓我能透過索引的方式去整理我的筆記，讓我的大腦可以更專注在眼前的任務上，也很感謝朱騏老師，在鐵人邦的obsidian系列文幫助了我很多，讓我做筆記有很多的改變，連結我會放在最下面。\n這本書讀完後，讓我對於卡片盒筆記法有更深入的瞭解，這本書不僅僅是教導做筆記的方法，而是一個完整的思考、工作流程和有效學習的方法。\n書中有提到蔡加尼克效應：還未完成的工作項目，會佔據我們的短期記憶，直到完成為止。\n要讓我們的大腦停止去想某件工作，不用等到那件工作做完，只要把他們記下來，並讓自己想像「我會去處理」，這樣大腦就會停止去想它了。\n因為大腦無法區別真正已做完以及未完成的事，如果把某件事記下來，就可以把它從大腦中清除掉。讓一個外部系統去儲存那些還沒做完的事情。\n現在做的筆記，觀眾是未來的自己，因為筆記做完不久，就會回到一無所知的狀態，要表達清楚給未來的自己，就需要真正的理解。\n而如何以有意義的方式，將某個訊息連接到其他訊息？\n第一步是思考某訊息，並把他寫出來，接著是思考這個訊息跟其他脈絡有甚麼關聯性。\n大腦與卡片盒的分工，負責細節與參考資料，確保資料保持客觀完整，讓大腦能夠專注在重要的事情上，而大腦負責自由發揮創造力，更深入的學習與整體性的規劃。\n而卡片盒的用意是，問這張卡片的意義為何？為何連接到某事？跟某事差異？它跟甚麼類似？\n只要連結合理，卡片就能彼此連結，所以卡片盒並不是根據主題分類。\n書中還提到過度井然有序會妨礙學習\n書中舉了教導學生認識不同的藝術風格，首先用傳統的方式，把屬於相同藝術風格的多幅繪畫展示給一組學生看，接著刻意打亂藝術風格給另一組學生看，結果反而是各種不同風格繪畫。\n混在一起的那一組學生，更快學會如何分辨不同的藝術風格。這顯示了與其用主題分類，不如表達清楚各種差異和相同之處，強化規類的能力以及創造合理的分類能力。\n本書搭配obsidian真的是一個完美的搭配，很感謝作者以身作則應用卡片盒筆記法的智慧結晶產出此書。\n🔗【Obsidian 使用教學】總目錄 \u0026ndash;\u0026gt; https://reurl.cc/NRZ9bx\n","permalink":"https://sz9751210.github.io/posts/%E5%8D%A1%E7%89%87%E7%9B%92%E7%AD%86%E8%A8%98%E6%9C%80%E9%AB%98%E6%95%88%E6%80%9D%E8%80%83%E7%AD%86%E8%A8%98%E8%A1%93%E5%BE%B7%E5%9C%8B%E6%95%99%E6%8E%88%E8%B6%85%E5%BC%B7%E7%A7%98%E6%8A%80%E4%BF%83%E9%80%B2%E5%AF%AB%E4%BD%9C%E5%AD%B8%E7%BF%92%E8%88%87%E6%80%9D%E8%80%83%E4%BD%BF%E4%BD%A0%E6%B4%9E%E8%A6%8B%E6%BA%90%E6%BA%90%E4%B8%8D%E6%96%B7%E6%88%90%E7%82%BA%E5%B0%88%E5%AE%B6/","summary":"\u003ch2 id=\"quick-review\"\u003e👀QUICK REVIEW\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003eThe book in 3 Sentences 用三段話說明這本書的內容\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e為了學習而寫\u003c/li\u003e\n\u003cli\u003e闡述是最有效的學習方法\u003c/li\u003e\n\u003cli\u003e簡要記述內容中提出的主要想法，而不是蒐集引文，並努力思考與其他不同內容的想法連結再一起\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003ePurpose of the book 書的目的\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e提供大腦一個外部記憶體去儲存細節與參考資料，讓大腦能專注在發揮創造力與深入的學習\u003c/li\u003e\n\u003cli\u003e透過原子性將多個重點的大筆記拆解成像是卡片一樣的小筆記\u003c/li\u003e\n\u003cli\u003e具有連結性，將各個小筆記的點透過關聯性連結成大筆記\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eMy Top 3 Quotes 我最喜歡的 3 句 Quotes\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e如果你無法清楚地說出來，你就無法真正的理解\u003c/li\u003e\n\u003cli\u003e人必須要找出想法的不同之處，掌握其中的差異，不管這些差異式很明顯可見，還是隱藏在概念裡\u003c/li\u003e\n\u003cli\u003e正確的學習代表的是理解，而理解是指用有意義的方式，連接到已知的知識\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e","title":"卡片盒筆記：最高效思考筆記術，德國教授超強秘技，促進寫作、學習與思考，使你洞見源源不斷，成為專家"},{"content":"📔心得 一直以來都在使用container下去跑測試環境，所以都是使用docker指令下去做除錯，最近因緣際會下找到這一款可以透過UI看全部的container狀態，真的覺得好用到爆炸，所以來介紹一下這款容器化管理神器。\n基本上能用docker指令做到的事情，portainer都能做到，像是docker ps，查看所有container，接著點擊某個container，就會顯示基本的container訊息。裡面能針對這個container查看logs，inspect，stat等等，功能非常齊全。 我自己最常使用的就是docker logs，透過UI可以直接點擊Logs查看，方便很多。\n依照類型也會分出stack，container，image，network，volume等等，都可各別下去做新增，查看與管理，有時候東西建了忘記刪，這邊會顯示unused，打勾後就能一鍵移除。\nportainer從拉image到deploy container都能透過ui完成，對於更新版本也是很有一套，可以透過設定pull latest並點擊recreate進行container的更新，對於常常使用container測試者真的是一大福音。\n👨‍💻簡介 portainer主要讓我們能有個UI介面管理我們的docker，對於初學docker指令不太熟的使用者能快速進入docker的世界，並且可從docker hub一鍵拉取image，設定network、volume等進行快速部署，都可藉由portainer完成。 🎯setup 透過docker-compose.yml建立portainer 建立docker-compose.yml # docker-compose.yml version: \u0026#34;3\u0026#34; services: portainer: image: portainer/portainer-ce volumes: - /var/run/docker.sock:/var/run/docker.sock - portainer_data:/data ports: - 9000:9000 container_name: portainer volumes: portainer_data: {} 執行docker-compose up -d\n設定系統管理員 finish 🔰基礎介紹(本地環境) 1. Dashboard 上面的Environment info為當前本地的系統環境基本資訊 6 core cpu 8.3 ram docker版本為20.10.17 URL為我掛載的docker.sock路徑 底下為當前所有的docker配置 2. Stacks 使用docker-compose起的就會形成一個stack，可顯示當前所跑的stack list，以及這個stack跑的container資訊 如果要自己新增stack可點擊Add stack把自己寫好的docker-compose.yml貼上去並按下Deploy the stack即可建立。 3. Containers 可針對container做啟動停止暫停刪除等等的基本操作，在list介面可顯示當前所有container的基礎資訊。Quick Actions從左到右分別為Logs、Inspect、Stats、Exec Console、Attach Console Logs：方便查看當前container log狀況 Inspect：跟docker inspect一樣，但可視程度較高，有轉成樹狀結構 Stats：可查看cpu、mem、network等使用率，以及顯示當前使用了哪些進程 Exec Console：一鍵進入容器內操作 新增container的方式也是很簡單，透過Add container之後設定image的基本設定即可成功建立container，底下也可設定volume、network等等。 4. Images 這邊最上面可直接輸入image name做pull image的動作，下面則是顯示當前本地所有的images，對於沒再使用的image這邊會顯示Unused真的方便許多，一鍵即可移除，點擊進去可看到image的基本資訊，並且能顯示image layers，對於自己撰寫dockerfile幫助很大。 如果要自己建立image可點擊Build a new image，將自己寫的dockerfile貼上去建立image。 ","permalink":"https://sz9751210.github.io/posts/portainer-intro/","summary":"\u003ch2 id=\"心得\"\u003e📔心得\u003c/h2\u003e\n\u003cp\u003e一直以來都在使用container下去跑測試環境，所以都是使用docker指令下去做除錯，最近因緣際會下找到這一款可以透過UI看全部的container狀態，真的覺得好用到爆炸，所以來介紹一下這款容器化管理神器。\u003c/p\u003e\n\u003cp\u003e基本上能用docker指令做到的事情，portainer都能做到，像是docker ps，查看所有container，接著點擊某個container，就會顯示基本的container訊息。裡面能針對這個container查看logs，inspect，stat等等，功能非常齊全。\n我自己最常使用的就是docker logs，透過UI可以直接點擊Logs查看，方便很多。\u003c/p\u003e\n\u003cp\u003e依照類型也會分出stack，container，image，network，volume等等，都可各別下去做新增，查看與管理，有時候東西建了忘記刪，這邊會顯示unused，打勾後就能一鍵移除。\u003c/p\u003e\n\u003cp\u003eportainer從拉image到deploy container都能透過ui完成，對於更新版本也是很有一套，可以透過設定pull latest並點擊recreate進行container的更新，對於常常使用container測試者真的是一大福音。\u003c/p\u003e\n\u003ch2 id=\"簡介\"\u003e👨‍💻簡介\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003eportainer主要讓我們能有個UI介面管理我們的docker，對於初學docker指令不太熟的使用者能快速進入docker的世界，並且可從docker hub一鍵拉取image，設定network、volume等進行快速部署，都可藉由portainer完成。\u003c/li\u003e\n\u003c/ul\u003e","title":"Portainer：一款圖形化容器管理工具"},{"content":"簡介 因常會在新機器跑container，藉此紀錄安裝過程，順便寫下腳本安裝懶人包 安裝docker 檢查系統中是否已經安裝了docker 執行：ps -ef |grep docker\n如上圖所示，說明系統中並沒有安裝docker\n添加docker-ce倉庫 安裝yum倉庫管理工具 sudo yum update -y sudo yum install -y yum-utils 配置docker yum源 sudo yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo\t安裝docker engine sudo yum install docker-ce docker-ce-cli containerd.io docker-compose-plugin 啟動docker \u0026amp;\u0026amp; 設置開機啟動docker sudo systemctl start docker.service sudo systemctl enable docker.service 安裝docker-compose Install Docker Compose CLI plugin | Docker Documentation\n透過curl下載docker-compose COMPOSE_VERSION=$(curl -s https://api.github.com/repos/docker/compose/releases/latest | grep \u0026#39;tag_name\u0026#39; | cut -d\\\u0026#34; -f4) sh -c \u0026#34;curl -L https://github.com/docker/compose/releases/download/${COMPOSE_VERSION}/docker-compose-`uname -s`-`uname -m` \u0026gt; /usr/local/bin/docker-compose\u0026#34; 將docker-compose變成可執行檔 chmod +x /usr/local/bin/docker-compose 建立連結 ln -s /usr/local/bin/docker-compose docker-compose 確認是否安裝成功 docker-compose -v 腳本自動化安裝docker \u0026amp;\u0026amp; docker-compose #!/bin/bash # ----- Install docker ----- # echo \u0026#34;install docker\u0026#34; sudo yum update -y sudo yum install -y yum-utils sudo yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo sudo yum install docker-ce docker-ce-cli containerd.io docker-compose-plugin # start \u0026amp; enable docker.service sudo systemctl start docker.service sudo systemctl enable docker.service # ----- Install docker-compose ----- # echo \u0026#34;install docker-compose\u0026#34; # get latest docker compose released tag COMPOSE_VERSION=$(curl -s https://api.github.com/repos/docker/compose/releases/latest | grep \u0026#39;tag_name\u0026#39; | cut -d\\\u0026#34; -f4) sudo curl -L \u0026#34;https://github.com/docker/compose/releases/download/${COMPOSE_VERSION}/docker-compose-$(uname -s)-$(uname -m)\u0026#34; -o /usr/local/bin/docker-compose sudo chmod +x /usr/local/bin/docker-compose sudo ln -s /usr/local/bin/docker-compose /usr/bin/docker-compose # Output compose version docker-compose --version exit 0 ","permalink":"https://sz9751210.github.io/posts/centos-%E5%AE%89%E8%A3%9Ddocker-%E5%92%8C-docker-compose/","summary":"\u003ch2 id=\"簡介\"\u003e簡介\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e因常會在新機器跑container，藉此紀錄安裝過程，順便寫下腳本安裝懶人包\u003c/li\u003e\n\u003c/ul\u003e","title":"CentOS 安裝docker 和 docker-compose"},{"content":"📔心得 因最近在研究elk-stack，藉此紀錄一下使用docker-compose建立起elk-stack的架構，在建立的過程中，比較多遇到的是記憶體使用率的配置不足，導致容器無法成功啟動，或是config檔權限的問題，因此在filebeat的部分會直接把config檔放進去並改成root權限。\n之後希望能再增加logstash的pipeline功能，在實務上可多個服務做篩選，以及elasticsearch的資料安全性配置SSL和叢集架構，並導入ILM做log的空間管理。\n監控的部分則是拿之前做的小專案直接套用並呈現，所以整體流程大致上差不多，多了個elasticsearch_exporter，可查看更多elasticsearch的整體狀況，例如index、shard的數量，資料大小，寫入速率等等。\n🔗詳細專案位置 \u0026ndash;\u0026gt; ELFK-stack-monitor\n👨‍💻簡介 🔰ELFK-stack：使用docker-compose建立起elk-stack的架構，主要先從alpine產生假資料並存到filebeat讀取的資料夾，接著filebeat將資料送往logstash，在實務上，會在logstash做filter的功能(未來會新增)，接著送到elasticsearch存起來，並透過kibana的ui下去做搜尋所需的log資料。\n🔰Monitor：使用cadvisor監控所有容器以及elasticsearch_exporter監控elasticsearch的狀態，並把資料送到prometheus儲存起來，最後透過grafana的ui呈現。\n🔰基礎介紹 ⚙️ELFK-stack : alpine+filebeat(送資料) -\u0026gt; logstash(filter) -\u0026gt; elasticsearch(db) -\u0026gt; kibana(ui)\n⚙️Monitor : cadvisor,elasticsearch_exporter(monitor) -\u0026gt; prometheus(db) -\u0026gt; grafana(ui)\n🎯setup 使用docker-compose啟動服務 sudo docker-compose up -d 進到localhost:5601按照以下圖示設定index pattern 可進到localhost:3000查看grafana dashboard，帳密都為admin container-dashboard ** elasticsearch-dashboard ✅TODO 新增log filter 添加ssl cluster架構的elastic ","permalink":"https://sz9751210.github.io/posts/elfk-stack-monitor/","summary":"\u003ch2 id=\"心得\"\u003e📔心得\u003c/h2\u003e\n\u003cp\u003e因最近在研究elk-stack，藉此紀錄一下使用docker-compose建立起elk-stack的架構，在建立的過程中，比較多遇到的是記憶體使用率的配置不足，導致容器無法成功啟動，或是config檔權限的問題，因此在filebeat的部分會直接把config檔放進去並改成root權限。\u003c/p\u003e\n\u003cp\u003e之後希望能再增加logstash的pipeline功能，在實務上可多個服務做篩選，以及elasticsearch的資料安全性配置SSL和叢集架構，並導入ILM做log的空間管理。\u003c/p\u003e\n\u003cp\u003e監控的部分則是拿之前做的小專案直接套用並呈現，所以整體流程大致上差不多，多了個elasticsearch_exporter，可查看更多elasticsearch的整體狀況，例如index、shard的數量，資料大小，寫入速率等等。\u003c/p\u003e\n\u003cp\u003e🔗詳細專案位置 \u0026ndash;\u0026gt; \u003ca href=\"https://github.com/sz9751210/ELFK-stack-monitor\"\u003eELFK-stack-monitor\u003c/a\u003e\u003c/p\u003e\n\u003ch2 id=\"簡介\"\u003e👨‍💻簡介\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e🔰ELFK-stack：使用docker-compose建立起elk-stack的架構，主要先從alpine產生假資料並存到filebeat讀取的資料夾，接著filebeat將資料送往logstash，在實務上，會在logstash做filter的功能(未來會新增)，接著送到elasticsearch存起來，並透過kibana的ui下去做搜尋所需的log資料。\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e🔰Monitor：使用cadvisor監控所有容器以及elasticsearch_exporter監控elasticsearch的狀態，並把資料送到prometheus儲存起來，最後透過grafana的ui呈現。\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e","title":"ELFK-stack-monitor"},{"content":"👨‍💻簡介 🔰ELFK-stack：使用docker-compose建立起tick-stack的架構，撈取的指標從config/telegraf.conf設定，並送往influxdb從起來，chronograf為ui介面，查看撈取的時間序列指標狀態，最後kapacitor則是處理告警的部分．\n流程 ⚙️TICK-stack : telrgraf(送資料) -\u0026gt; influxdb(存資料) -\u0026gt; chronograf(ui) -\u0026gt; kapacitor(alert) 環境建置 本篇github repo在此 -\u0026gt; TICK_Stack-tutorial\ntelegraf設定 使用telegraf.conf設定輸出資料庫\n[[outputs.influxdb]] urls = [\u0026#34;http://influxdb:8086\u0026#34;] database = \u0026#34;telegraf\u0026#34; # 要使用的資料庫 username = \u0026#34;admin\u0026#34; password = \u0026#34;admin\u0026#34; influxdb設定 使用configuration.env設定帳密以及資料庫\n# InfluxDB options INFLUXDB_DB=telegraf INFLUXDB_ADMIN_USER=admin INFLUXDB_ADMIN_PASSWORD=admin kapacitor設定 使用kapacitor.conf\n設定讀取的資料庫 [[influxdb]] enabled = true name = \u0026#34;telegraf\u0026#34; default = false urls = [\u0026#34;http://influxdb:8086\u0026#34;] username = \u0026#34;admin\u0026#34; password = \u0026#34;admin\u0026#34; 設定告警telegram [telegram] enabled = true url = \u0026#34;https://api.telegram.org/bot\u0026#34; token = \u0026#34;bot-token\u0026#34; 啟動環境 docker-compose up 接著去本地chronograf http://IP:8888 設定influxdb以及kapacitor\nhttp:// IP :8086 for influxdb http:// IP :9092 for kapacitor 告警設計 參考cpu_alert.tick.example\n使用告警 透過kapacitor cd /var/lib/kapacitor # cpu_alert為任務task_id # 定義任務 kapacitor define cpu_alert -tick cpu_alert.tick -type stream -dbrp telegraf.autogen # 啟動任務 kapacitor enable cpu_alert # 停止任務 kapacitor disable cpu_alert # 刪除任務 kapacitor delete tasks cpu_alert # 列出所有任務 kapacitor list tasks 透過chronograf 選到左邊的alerting -\u0026gt; write TICKscript 輸入task_id -\u0026gt; 把script貼上 -\u0026gt; 選擇類型為stream -\u0026gt; 選擇db -\u0026gt; 按下儲存後下方會判斷script是否正常 完成後可回到manage task管理當前task 可透過點擊enabled下方圓點一鍵啟動/停用任務 alert history可查看告警訊息\ngreen:OK white:INFO,WARN red:CRIT ============================\n查看alert寫回db訊息 參考資料 https://github.com/sz9751210/docker-telegraf-influx-grafana-stack https://www.influxdata.com/time-series-platform/kapacitor/ https://tanjiti.github.io/2018/12/18/%E5%BC%80%E6%BA%90kapacitor%E6%93%8D%E4%BD%9C%E6%89%8B%E5%86%8C/ ","permalink":"https://sz9751210.github.io/posts/tick-stack-tutorial/","summary":"\u003ch2 id=\"簡介\"\u003e👨‍💻簡介\u003c/h2\u003e\n\u003cp\u003e🔰ELFK-stack：使用docker-compose建立起tick-stack的架構，撈取的指標從config/telegraf.conf設定，並送往influxdb從起來，chronograf為ui介面，查看撈取的時間序列指標狀態，最後kapacitor則是處理告警的部分．\u003c/p\u003e\n\u003ch2 id=\"流程\"\u003e流程\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e⚙️TICK-stack : telrgraf(送資料) -\u0026gt; influxdb(存資料) -\u0026gt; chronograf(ui) -\u0026gt; kapacitor(alert)\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"環境建置\"\u003e環境建置\u003c/h2\u003e\n\u003cp\u003e本篇github repo在此 -\u0026gt;  \u003ca href=\"https://github.com/sz9751210/TICK_Stack-tutorial\"\u003eTICK_Stack-tutorial\u003c/a\u003e\u003c/p\u003e","title":"TICK-Stack-tutorial"},{"content":"Python 基本語法 python 語法的後綴名是以.py 結尾 python 執行方式 使用交互介面執行 使用 python test.py 命令執行 使用./test.py 執行 python 標示符 以單下劃線開頭的屬性，表示是類的私有屬性(包括方法，變量)。如:_foo表示不能直接訪問的類屬性。 以雙下劃線開頭的 __foo 代表類的私有成員； 以雙下劃線開頭和結尾的 __foo__ 代表 Python 里特殊方法專用的標識，如 __init__() 代表類的構造函數。 換行縮進 python 不使用{}來控制 code 範圍，而使用縮進來控制。一般都使用四個空格做縮進(PEP8規定)。 #!/usr/bin/python # -*- coding: UTF-8 -*- print \u0026#34;hello world\u0026#34;; if True: print(\u0026#34;Answer:\u0026#34;); print(\u0026#34;true\u0026#34;); else: print(\u0026#34;Answer:\u0026#34;); # 沒有嚴格縮進，在執行時會報錯 print(\u0026#34;false\u0026#34;); python 引號 Python 可以使用引號(')、雙引號(\u0026quot;)、三引號( ''' 或 \u0026quot;\u0026quot;\u0026quot; ) 來表示字符串。 三引號(\u0026quot;\u0026quot;\u0026quot;)可以由多行組成，是編寫多行文本的快捷語法，常用於文檔字符串。 # 單引號以及雙引號 \u0026#39;This is a string\u0026#39; \u0026#34;This is a string\u0026#34; # 引號包含引號 \u0026#34;We call it \u0026#39;Dog\u0026#39;...... \u0026#34; # 雙引號內可包含單引號 \u0026#39;We call it \u0026#34;Dog\u0026#34;...... \u0026#39; # 單引號內可包含雙引號 # 三雙引號可直接換行 \u0026#34;\u0026#34;\u0026#34;haha, this is a dog.\u0026#34;\u0026#34;\u0026#34; # 三單引號需要換行符 \u0026#39;\u0026#39;\u0026#39;haha, \\ this is a dog.\u0026#39;\u0026#39;\u0026#39; python 注釋 python 中單行註釋採用#開頭 python 中多行註釋使用三個單引號(''')或三個雙引號(\u0026quot;\u0026quot;\u0026quot;) 多行註釋通常用來為 Python 文件、模塊、類或者函數等添加版權或者功能描述信息。 # 單行 # 註釋內容 # 多行 \u0026#39;\u0026#39;\u0026#39;(\u0026#34;\u0026#34;\u0026#34;) 使用 3 個單引號分別作為註釋的開頭和結尾 可以一次性註釋多行內容 這裡面的內容全部是註釋內容 \u0026#39;\u0026#39;\u0026#39;(\u0026#34;\u0026#34;\u0026#34;) Python 空行 函數之間或 class 的方法之間用空行分隔，表示一段新的代碼的開始。class 和函數入口之間也用一行空行分隔，以突出函數入口的開始。 多個語句組成的代碼組 縮進相同的一組語句構成一個代碼塊，我們稱之代碼組。 子句: 像 if、while、def 和 class 這樣的複合語句，首行以關鍵字開始，以冒號( : )結束，該行之後的一行或多行代碼構成代碼組。 if expression: suite elif expression: suite else: suite python 變量類型 變量可以指定不同的數據類型，這些變量可以存儲整數，小數或字符。 python 變量賦值 變量賦值不需要聲明類型，變數的資料型別將根據分配給它的值的型別自動來定義。 每個變量在使用前必須賦值，變量賦值以後該變量才會被創建 不可以取保留字 只能由大小寫字母、數字、 _ 、 中文組成變數名稱 英文字母大小寫視為不同的變數名稱 counter = 100 # 賦值整型變量 miles = 1000.0 # 浮點型 name = \u0026#34;alan\u0026#34; # 字符串 print(count), print(miles), print(name); 多變量賦值，變數之間用，分隔 # 2 被分配給 x，4.124 被分配給 y，字串 Python 被分配給 z。 x, y, z = 2, 4.124, \u0026#34;Python\u0026#34; # 三個變數都是Blue x = y = z = \u0026#34;Blue\u0026#34; 刪除變數 del x python 資料型態 數值型態： int float bool 字串型態： str chr 容器型態： list dict tuple Python 基本的純量類型 整數（int） 浮點數（float） 文字（str） 布林（bool） None（NoneType） 整數和浮點數 整數與浮點數使用數學運算符號進行運算 會搭配運算符號進行運算 + 、 - 、 * 、 / ：加減乘除 ** ：次方 % ：回傳餘數 // ：回傳商數 字串 我們使用成雙的單引號 \u0026rsquo;\u0026rsquo; 或成對的雙引號 \u0026quot;\u0026quot; 來建立文字類型 如果建立的字串有包含不成對的引號，則需要使用跳脫字元\\來完成宣告 python 格式化字串 %-formatting print(\u0026#34;I am %s.%s\u0026#34;%(\u0026#34;Alan\u0026#34;,\u0026#34;wang\u0026#34;)) # output I am Alan.wang str.format()（Python 2.6+） # 基本使用 s = \u0026#39;I am {first_name} {middle_name}. {last_name}\u0026#39; print(s.format(first_name=\u0026#39;Monkey\u0026#39;, middle_name=\u0026#39;D\u0026#39;, last_name=\u0026#39;Luffy\u0026#39;)) # output I am Monkey D. Luffy # 調整輸出樣式：^(居中）、\u0026lt;（向左對齊）、\u0026gt;（向右對齊） print(\u0026#39;{:^10s}\u0026#39;.format(\u0026#39;a\u0026#39;)) # ^：居中對齊，10：寬度為10，s：以string輸出 # output a # 以 {:,} 的方式以逗號分隔數字 print(\u0026#39;{:,}\u0026#39;.format(100000000)) # output 100,000,000 f-string（Python 3.6+） # variables first_name = \u0026#34;Monkey\u0026#34; middle_name = \u0026#34;D\u0026#34; last_name = \u0026#34;Luffy\u0026#34; # f-string f\u0026#34;I am {first_name} {middle_name}. {last_name}\u0026#34; # Output: \u0026#34;I am Monkey D. Luffy\u0026#34; 布林 進行判斷條件或者資料篩選的時候會需要仰賴布林（bool），布林只有 True 與 False 這兩個值。 print(type(True)) print(type(False)) Python（或者絕大多數的程式語言）對於英文的大小寫是敏感的（case-sensitive），像是 True 會被識別為布林，但是 TRUE 或者 true 則會被視作物件名稱。 # recognized as bool print(type(True)) print(type(False)) # recognized as object names print(type(true)) print(type(TRUE)) print(type(false)) print(type(FALSE)) True 跟數值 1 相等； False 跟數值 0 相等。如果在數值運算中納入了布林不會產生任何問題。 print(True == 1) # output：True print(False == 0) # output：True print(1 + True) # output：2 print(1 + False) # output：1 判斷條件簡介 == 、 !=：等於以及不等於 \u0026gt; 、 \u0026gt;= 、 \u0026lt; 、 \u0026lt;=：大於、大於等於、小於以及小於等於 is 、 is not：是否為相同的值與類型 and 、 or：交集與聯集 not：非 in ：是否存在於 None None 是所謂的無值，或者可以用 NA 值（Not Available）或 NaN 值（Not a Number）去體會它 None 是無回傳值函數中的預設輸出值、也是搜索特徵函數找不到情況下的預設輸出值 # 宣告了一個只有 pass 保留字內容的 hello_world() 函數，這就是一個所謂的無回傳值函數 def hello_world(): pass print(hello_world()) # output：None print(type(hello_world())) # output：\u0026lt;class \u0026#39;NoneType\u0026#39;\u0026gt; 判斷純量類型的函數 使用 isinstance(x, classinfo) 函數判斷純量類型，其中 x 輸入物件名稱、 classinfo 輸入類型名稱。 # 判斷是否為整數 print(isinstance(87, int)) # output：True print(isinstance(\u0026#34;87\u0026#34;, int)) # output：False # 判斷是否為浮點數 print(isinstance(87.0, float)) # output：True print(isinstance(87, float)) # output：False # 判斷是否為文字 print(isinstance(\u0026#34;True\u0026#34;, str)) # output：True print(isinstance(True, str)) # output：False # 判斷是否為布林 print(isinstance(False, bool)) # output：True print(isinstance(\u0026#34;False\u0026#34;, bool)) # output：False # 判斷是否為 None print(isinstance(None, type(None))) # output：True print(isinstance(\u0026#34;None\u0026#34;, type(None))) # output：False 使用 type()函數回傳純量類型 my_int = 87 my_float = 8.7 my_str = \u0026#34;Hello Python\u0026#34; bool_true = True bool_false = False none_type = None print(type(my_int)) print(type(my_float)) print(type(my_str)) print(type(bool_true)) print(type(bool_false)) print(type(none_type)) # output ## \u0026lt;class \u0026#39;int\u0026#39;\u0026gt; ## \u0026lt;class \u0026#39;float\u0026#39;\u0026gt; ## \u0026lt;class \u0026#39;str\u0026#39;\u0026gt; ## \u0026lt;class \u0026#39;bool\u0026#39;\u0026gt; ## \u0026lt;class \u0026#39;bool\u0026#39;\u0026gt; ## \u0026lt;class \u0026#39;NoneType\u0026#39;\u0026gt; python 類型轉換 純量轉換 使用與目標轉換類型同名的函數轉換純量類型。\nint()：轉換純量為整數類型 float()：轉換純量為浮點數類型 bool()：轉換純量為布林類型，除了 0 以外的數字都是True str()：轉換純量為文字類型 # 轉換成整數 print(int(8.7)) print(int(True)) print(int(False)) print(int(\u0026#34;87\u0026#34;)) # output 8 1 0 87 # 轉換成浮點數 print(float(87)) print(float(True)) print(float(False)) print(float(\u0026#34;87\u0026#34;)) # output 87.0 1.0 0.0 87.0 # 轉換成布林 print(bool(0)) print(bool(0.0)) print(bool(1)) print(bool(1.0)) print(bool(8.7)) print(bool(-8.7)) # output False False True True True True # 轉換成字串 print(str(87)) print(str(87.0)) print(str(True)) print(str(False)) # output 87 87.0 True False python 運算符 算數運算符 x=5, y=2\n運算符 名稱 範例 + 加法 x + y = 7 - 減法 x - y = 3 * 乘法 x * y = 10 / 除法 x / y = 2.5 % 取餘數 x % y = 1 ** 指數 x ** y = 25 // 取整除 x // y = 2 + 與 * 也可用於字串 (string) ， + 用於字串相接， * 用於複製字串\na = \u0026#34;a\u0026#34; b = a + \u0026#34;b\u0026#34; # 字串連接， b 會等於 \u0026#34;ab\u0026#34; c = a * 3 # 字串重複三倍， c 會等於 \u0026#34;aaa\u0026#34; 賦值運算符 x = 5 = 0101 , 3 = 0011\n運算符 名稱 範例 解答 = 賦值 x = 5 x = 5 += 加法賦值 x += 3 \u0026mdash;\u0026gt; x = x + 3 x = 8 -= 減法賦值 x -= 3 \u0026mdash;\u0026gt; x = x - 3 x = 2 *= 乘法賦值 x * = 3 \u0026mdash;\u0026gt; x = x * 3 x = 15 /= 除法賦值 x /= 3 \u0026mdash;\u0026gt; x = x / 3 x = 1.666\u0026hellip; %= 取餘賦值 x %= 3 \u0026mdash;\u0026gt; x = x % 3 x = 2 //= 取整除賦值 x //= 3 \u0026mdash;\u0026gt; x = x // 3 x = 1 **= 指數賦值 x **= 3 \u0026mdash;\u0026gt; x = x ** 3 x = 125 \u0026amp;= AND 賦值 x \u0026amp;= 3 \u0026mdash;\u0026gt; x = x \u0026amp; 3 x = 1 = 0001 |= OR 賦值 x |= 3 \u0026mdash;\u0026gt; x = x | 3 x = 7 = 0111 ^= XOR 賦值 x ^= 3 \u0026mdash;\u0026gt; x = x ^ 3 x = 6 = 0110 \u0026raquo;= 右移賦值 x \u0026raquo;= 3 \u0026mdash;\u0026gt; x = x \u0026raquo; 3 x = 0 = 0000 = 5 * 1/2**3 = 5/8 \u0026laquo;= 左移賦值 x \u0026laquo;= 3 \u0026mdash;\u0026gt; x = x \u0026laquo; 3 x = 40 = 0010 1000 = 5 * 2**3 = 5 * 8 比較運算符 運算符 名稱 範例 == 相等 x == y != 不相等 x != y \u0026gt; 大於 x \u0026gt; y \u0026lt; 小於 x \u0026lt; y \u0026gt;= 大於等於 x \u0026gt;= y \u0026lt;= 小於等於 x \u0026lt;= y 邏輯(布林)運算符 x = 4\n運算符 名稱 範例 and 與運算 - 兩者為 True，返回 True x \u0026lt; 5 and x \u0026lt; 10 \u0026mdash;\u0026gt; True or 或運算 - 其中一者為 True，返回 True x \u0026lt; 5 or x \u0026lt; 4 \u0026mdash;\u0026gt; True not 非運算 - 兩者為 Faluse，返回 True not(x \u0026lt; 5 and x \u0026lt; 10) \u0026mdash;\u0026gt; False 身分運算符 運算符 描述 範例 is 如果兩個變量是同一個對象(具有相同的記憶體位置)，則返回 True x is y is not 如果兩個變量不是同一個對象(不是指向相同的記憶體位置)，則返回 True x is not y 成員運算符 運算符 描述 範例 in 當 in 前面的變數在後面的序列中時，結果為 True x in y not in 當 in 前面的變數不在後面的序列中時，結果為 True x not in y 位元運算符 a = 5\n運算符 名稱 範例 \u0026amp; AND(位與操作符) - 當兩側數字在該位上都是 1 的時候，結果該位也為 1，否則為 0 a \u0026amp; 2 = 0 = 0000 | OR(位或操作符) - 當兩側數字在該位上只要有一個是 1 的時候，結果該位為 1，否則為 0 a | 2 = 7 = 0111 ^ XOR(位異或操作符) - 當兩側數字對應位二進位制相異時(其中一位為 1，另一位為 0)，結果為 1 a ^ 2 = 7 = ~ NOT(位取反操作符) - 對運算元進行按位取反操作，1 變成 0，0 變成 1 ~a = -6 = -(0101 + 1) = -(0110) \u0026laquo; 左移操作符 - 將 \u0026laquo; 左側的數字左移若干位，右側補 0，左側高位數捨棄 a \u0026laquo; 2 = 20 = 0001 0100 \u0026raquo; 右移操作符 - 將 \u0026raquo; 左側的數字右移若干位，左側補齊 0 a \u0026raquo; 2 = 1 = 0001 python 條件語句與迴圈控制 條件語句：當程式流程在進行的過程，需要根據某個條件來決定是否執行接下來的動作時使用。 迴圈控制：處理資料時，若是想要重複執行某些相同的步驟時，就會使用到迴圈。 條件語句 if 若判斷條件成立，則執行底下縮排的敘述內容；反之，則不動作。 if condition: statement if-else 若condition 為真 (True)，則執行 statement1；反之，則執行statement2。 if condition: statement1 for True condition else: statement2 for False condition if-elif-else elif 的個數是沒有限制的，可以依照自己的需求而定。 if condition1: statement1 for True Condition1 elif condition2 : statement2 for True Condition2 elif condition3 : statement3 for True Condition3 else: statements for Each Condition False 巢狀if ID = input() year = int(ID[1:3]) if year \u0026lt; 4: print(\u0026#34;Graduated\u0026#34;) elif year \u0026lt;= 7 and year \u0026gt;= 4: if year == 7: print(\u0026#34;Freshman\u0026#34;) elif year == 6: print(\u0026#34;Sophomore\u0026#34;) elif year == 5: print(\u0026#34;Junior\u0026#34;) elif year == 4: print(\u0026#34;Senior\u0026#34;) else: print(\u0026#34;Not Registered Yet\u0026#34;) 迴圈控制 單層 for-loop 適用在「已知迴圈數」的問題 for和in中間放自訂變數，in後面可接一個序列(ex. list) 迴圈會依序從序列裡取得元素，將元素指派給前面的自訂變數，並執行迴圈裡的內容 通常會跟range()做一個搭配使用 range(起始值，終止值，遞增(減)值)\nfor x in sequence: # 放要執行的東西 # 迴圈搭配list依序印出內容 sequences = [0, 1,\u0026#39;jason\u0026#39;,2.5] for i in sequences: print(i) # output 0 1 jason 2.5 # 迴圈搭配range()使用 for i in range(3): print(i, end=\u0026#34; \u0026#34;) print() # 換行 for i in range(10,2,-2): print(i, end=\u0026#34; \u0026#34;) # output 0 1 2 10 8 6 4 巢狀 for-loop 迴圈裡面又包覆著其他的迴圈。 處理的問題具有重複執行某段敘述的特性，而且這些敘述受到兩個 (或兩個以上) 的變數來分別控制其變化 # 九九乘法表 for i in range(1, 10): for j in range(1, 10): if j == 9: print(\u0026#34;\\t\u0026#34;, i*j) # j == 9時，換行 else: print(\u0026#34;\\t\u0026#34;, i*j, end = \u0026#39;\u0026#39;) # j \u0026lt; 9時，不換行 while loops 適用在「無法預知迴圈數」的問題 while test_expression: Body of while # 產生1到10的序列 i = 1 while i \u0026lt;= 10: print(i, end=\u0026#34; \u0026#34;) i = i + 1 break 和 continue(迴圈不規則結束) break：中斷迴圈的執行並跳脫迴圈結構，繼續執行迴圈外的敘述。 continue：不中斷迴圈；只跳過迴圈內 continue 後面的剩餘敘述，接著繼續執行下一次的迴圈運作。 規則的結束方式是當迴圈的判斷條件不再符合時，迴圈自然結束；而不規則的迴圈結束則是在迴圈自然結束前，我們已經得到想要的運算結果，利用強制中斷的方式來結束迴圈。\nfor i in \u0026#34;Hey Alan\u0026#34;: if i == \u0026#34;l\u0026#34;: break print(i, end=\u0026#34; \u0026#34;) print() for i in \u0026#34;Hey Alan\u0026#34;: if i == \u0026#34;l\u0026#34;: continue print(i, end=\u0026#34; \u0026#34;) # output H e y A H e y A a n python保留字 定義：語言本身的編譯器中已經定義過的單詞，具有特定含義和用途，使用者不能再將這些單詞作為變數名或函數名、類名使用。 保留字 說明 and 邏輯與操作，用於表示式運算 as 用於轉換資料型別 assert 用於判斷變數或條件表示式的結果 async 用於啟用非同步操作 await 用於非同步操作中等待協程返回 break 中斷迴圈語句的執行 class 定義類 continue 繼續執行下一次迴圈 def 定義函數或方法 del 刪除變數或序列的值 elif 條件語句，與 if、else 結合使用 else 條件語句，與 if、else 結合使用；也可用於異常或迴圈語句 except 包含捕獲異常後的處理程式碼塊，與 try、finally 結合使用 False 含義為假的邏輯值 finally 包含捕獲異常後的始終要呼叫的程式碼塊，與 try、except 結合使用 for 迴圈語句 from 用於匯入模組，與 import 結合使用 global 用於在函數或其他區域性作用域中使用全域性變數 if 條件語句，與 elif、else 結合使用 import 匯入模組，與 from 結合使用 in 判斷變數是否在序列中 is 判斷變數是否為某個類的範例 lambda 定義匿名函數 None 表示一個空物件或是一個特殊的空值 nonlocal 用於在函數或其他作用域中使用外層（非全域性）變數 not 邏輯非操作，用於表示式運算 or 邏輯或操作，用於表示式運算 pass 空的類、方法或函數的預留位置 raise 用於丟擲異常 return 從函數返回計算結果 True 含義為真的邏輯值 try 測試執行可能出現異常的程式碼，與 except, finally 結合使用 while 迴圈語句 with 簡化 Python 的語句 yield 從函數依次返回值 ","permalink":"https://sz9751210.github.io/posts/python-%E5%9F%BA%E7%A4%8E/","summary":"\u003ch2 id=\"python-基本語法\"\u003ePython 基本語法\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003epython 語法的後綴名是以.py 結尾\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"python-執行方式\"\u003epython 執行方式\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e使用交互介面執行\u003c/li\u003e\n\u003cli\u003e使用 python test.py 命令執行\u003c/li\u003e\n\u003cli\u003e使用./test.py 執行\u003c/li\u003e\n\u003c/ul\u003e","title":"python 基礎"},{"content":"CentOS 7 安裝及設定Jenkins 介紹 開源且免費的CI工具，由Java編寫的，提供了持續構建以及部署的功能，是一個自動化的server\n環境 CentOS 7 安裝步驟 1. 添加Jenkins Repository [root@jenkins ~]# wget --no-check-certificate -O /etc/yum.repos.d/jenkins.repo http://pkg.jenkins.io/redhat-stable/jenkins.repo [root@jenkins ~]# rpm --import http://pkg.jenkins.io/redhat-stable/jenkins.io.key 2. 安裝Jenkins以及Java [root@jenkins ~]# yum install -y jenkins java-1.8.0-openjdk 3. 啟動並啟用Jenkins [root@jenkins ~]# systemctl start jenkins* [root@jenkins ~]# systemctl enable jenkins* 4. 在防火牆開啟80以及8080 的port [root@jenkins ~]# firewall-cmd --zone=public --add-port=8080/tcp --permanent success [root@jenkins ~]# firewall-cmd --zone=public --add-service=http --permanent success [root@jenkins ~]# firewall-cmd --reload success 5. 透過網頁打開Jenkins 存取URL：http://:8080\n管理員密碼創建並存儲在日誌文件 /var/log/jenkins/jenkins.log 中。接著透過以下指令取得初始密碼\n[root@localhost ~]# grep -A 5 password /var/log/jenkins/jenkins.log Jenkins initial setup is required. An admin user has been created and a password generated. Please use the following password to proceed to installation: Admin password This may also be found at: /var/lib/jenkins/secrets/initialAdminPassword 接著安裝插件，可直接選Install suggested plugins\n接著來建立管理者帳號\n到此所有設定都已完成，即可開始使用Jenkins\n參考資料 How to install and Configure Jenkins on CentOS 7 and RHEL 7 (linuxtechi.com)\n","permalink":"https://sz9751210.github.io/posts/jenkins-installation-centos/","summary":"\u003ch1 id=\"centos-7-安裝及設定jenkins\"\u003eCentOS 7 安裝及設定Jenkins\u003c/h1\u003e\n\u003ch2 id=\"介紹\"\u003e介紹\u003c/h2\u003e\n\u003cp\u003e開源且免費的CI工具，由Java編寫的，提供了持續構建以及部署的功能，是一個自動化的server\u003c/p\u003e","title":"Jenkins 安裝教學(CentOS)"},{"content":"👀QUICK REVIEW The book in 3 Sentences 用三段話說明這本書的內容\n從歷史帶到實戰的基礎書籍 由淺入深循序漸進的步調講解每個章節的主題 極度白話文的一本書 How the Book Changed Me? 這本書為我帶來什麼改變\n更了解自己對的區塊鏈與加密貨幣的意義 對於詐騙手法有更多的了解以及知名的案例 對於泡沫風險分析有更加的了解 My Top 3 Quotes 我最喜歡的 3 句 Quotes\nDYOR FOMO 量化交易 📚讀後心得 這本書是由知名youtuber 腦哥 所出的一本書，書中用極為白話的口語描述關於區塊鏈與加密貨幣的各種說明。此書主要分成四章，一開始先簡單講解甚麼是加密貨幣，區塊鏈等技術，比特幣的誕生，以及作者對於比特幣的未來看法，接著第二章實戰教學如何購買加密貨幣，交易所的介紹，以及作者看好的加密貨幣類型以及用途，還有幣圈的知識管道分享，以及NFT的簡單介紹，第三章主要先講解詐騙以及泡沫風險分析，諸如龐氏騙局，駭客事件，穩定幣危機，51攻擊等等，最後則是講解在幣圈有哪些獲利方式，從簡單的長期持有到高獲利的合約交易以及有玩樂性質的gamefi，對於新手來說是本極度易上手的書。\n","permalink":"https://sz9751210.github.io/posts/%E6%AF%94%E7%89%B9%E5%B9%A3%E6%8A%95%E8%B3%87%E9%87%91%E5%BE%8B%E5%8A%A0%E5%AF%86%E8%B2%A8%E5%B9%A3%E5%AF%A6%E6%88%B0%E6%95%99%E5%AD%B8%E8%88%87%E9%80%B2%E9%9A%8E%E7%8D%B2%E5%88%A9%E6%B3%95/","summary":"\u003ch2 id=\"quick-review\"\u003e👀QUICK REVIEW\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003eThe book in 3 Sentences 用三段話說明這本書的內容\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e從歷史帶到實戰的基礎書籍\u003c/li\u003e\n\u003cli\u003e由淺入深循序漸進的步調講解每個章節的主題\u003c/li\u003e\n\u003cli\u003e極度白話文的一本書\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eHow the Book Changed Me? 這本書為我帶來什麼改變\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e更了解自己對的區塊鏈與加密貨幣的意義\u003c/li\u003e\n\u003cli\u003e對於詐騙手法有更多的了解以及知名的案例\u003c/li\u003e\n\u003cli\u003e對於泡沫風險分析有更加的了解\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eMy Top 3 Quotes 我最喜歡的 3 句 Quotes\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eDYOR\u003c/li\u003e\n\u003cli\u003eFOMO\u003c/li\u003e\n\u003cli\u003e量化交易\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e","title":"比特幣投資金律：加密貨幣實戰教學與進階獲利法"},{"content":" 題目描述：給一個字串，依照題目給的表格，計算出字串對應的值並做加總\n思路：依照題目給的表格做一個字典，接著定義一個變數做加總，並依照題目所給的前一位的值小於當前的值時，做相對應的處理\nclass Solution: def romanToInt(self, s: str) -\u0026gt; int: numeral_map = {\u0026#34;I\u0026#34;:1, \u0026#34;V\u0026#34;:5, \u0026#34;X\u0026#34;:10, \u0026#34;L\u0026#34;:50, \u0026#34;C\u0026#34;:100, \u0026#34;D\u0026#34;:500, \u0026#34;M\u0026#34;:1000} result = 0 for i in range(len(s)): if i\u0026gt;0 and numeral_map[s[i]] \u0026gt; numeral_map[s[i-1]]: result += numeral_map[s[i]] - 2* numeral_map[s[i-1]] else: result += numeral_map[s[i]] return result ","permalink":"https://sz9751210.github.io/posts/leetcode-13/","summary":" 題目描述：給一個字串，依照題目給的表格，計算出字串對應的值並做加總\n思路：依照題目給的表格做一個字典，接著定義一個變數做加總，並依照題目所給的前一位的值小於當前的值時，做相對應的處理\nclass Solution: def romanToInt(self, s: str) -\u0026gt; int: numeral_map = {\u0026#34;I\u0026#34;:1, \u0026#34;V\u0026#34;:5, \u0026#34;X\u0026#34;:10, \u0026#34;L\u0026#34;:50, \u0026#34;C\u0026#34;:100, \u0026#34;D\u0026#34;:500, \u0026#34;M\u0026#34;:1000} result = 0 for i in range(len(s)): if i\u0026gt;0 and numeral_map[s[i]] \u0026gt; numeral_map[s[i-1]]: result += numeral_map[s[i]] - 2* numeral_map[s[i-1]] else: result += numeral_map[s[i]] return result ","title":"leetCode 13. Roman to Integer"},{"content":"👀QUICK REVIEW The book in 3 Sentences 用三段話說明這本書的內容\n天才並非真的存在，刻意練習才是真正通往專家的唯一途徑 練習的質與量勝過於單純的練習量 專注投入與信念至關重要 How the Book Changed Me? 這本書為我帶來什麼改變\n讓練習在你眼中成為一種投資，而不是耗費 沒有人可以不投注及大量的練習就發展出非凡技能 My Top 3 Quotes 我最喜歡的 3 句 Quotes\n人之所以停止學習、不再進步，不是因為到達天生能力的極限，而是因為某些原因不再練習，或者從未開始練習。 技能越高超，心智表徵越成熟，越了解這領域，代表自己更懂欠缺甚麼，也因此更能發揮刻意練習的效果，磨練技巧可以改善心智表徵，心智表徵又有助於技能進步 當你不再相信自己能達成目標時千萬別放棄，先和自己約定好，等到重回先前水準或突破高原期後再說，到時大概就會繼續下去了。 📚讀後心得 書的目的：教導如何使用刻意練習來達到學習技能並邁向專家的路\nCH1：有目標的練習 第一部分講解目標練習法，透過設定短期目標，並完成來達成整體效果，例如，提升打字速度，長期目標可能是一分鐘200字，目前卡關在一分鐘90字，短期目標可設定一分鐘連續100字三字，利用聚沙成塔的概念便是目標練習法的核心\n目標練習法需要意見回饋，可能像是打字，立即顯示一分鐘打幾個字，要認清自己的弱點，才能做適時的修正\n目標練習法必須跨出舒適圈，每次都有新的挑戰，例如目標一分鐘200字，達成後往250字，逼近自己的極限，成功就在增加字數，失敗就減少\n目標練習法的隱藏關鍵之一是設法克服障礙，例如打字一直卡關，可能是某個手指頭不夠靈活經常按錯，又或是對於鍵盤位置不夠熟悉，克服障礙最理想的做法，是透過尋找並嘗試不同方法來突破瓶頸\n目標練習法總結：設定清楚的目標和實現那些目標的計畫，並找出一個監測進步程度的方式，然後跨出舒適圈，專注地練習，並且要找出維持動機的方法\nCH2：駕馭大腦與身體的適應力 人類大腦會因為密集訓練而成長 改變，大腦的適應力在程度和種類上與身體的非常相似，可透過有意識的刻意練習形塑大腦\n長期訓練會導致與正在培養的技能相關的大腦部位產生變化\n刻意練習的目標卻不僅是發展潛能，還要打造潛能，做到以前做不到的事，恆定性受到挑戰，得離開舒適圈，迫使大腦或身體去適應，做到了，學習不再只是一個實踐某種遺傳命運的方式，而成了按照自己ˋ的選擇掌控個人命運與打造潛能的方法\nCH3：心智表徵 心智表徵，舉例像是打字，想像自己打某些字的指法\n刻意練習講求的正是發展出種種更高效率的心智表徵，讓你可以運用於你正在練習的任何活動中\n心智表徵的一項重要特色是 領域限定性，也就是只適用於正在培養的技能，例如，打字快可能無法運用在寫作上\n盡管短期記憶有其限制，人卻能運用心智表徵快速處理大量資訊，也就是建立心智圖，透過點與點之間的連結\n專家與凡人在心智表徵的差異在於質與量不同，例如可能要打其他比較難的字，會需要想出怎樣才會打得更快，寫程式也是，要考慮如何做出想要的樣子，如何優化，差別在於此\n而建立好的心智表徵，則是盡可能建立多個點，書中以狗為例子，建立了多摸牠們的毛，拍拍牠們的頭，多建立這些點並連成線\n在某個主題上投注的心力越多，心智表徵就越精細，理解 消化新資訊的能力也越強\n專家擁有優越的資訊組織能力\n監控並評估自身表現，必要時調整心智表徵以提升其效能\n本身察覺錯誤的能力高低也影響心智表徵的建立\nCH4：刻意練習的黃金法則 技能越高超，心智表徵越成熟，越了解這領域，代表自己更懂欠缺甚麼，也因此更能發揮刻意練習的效果，磨練技巧可以改善心智表徵，心智表徵又有助於技能進步\n當逼迫自己去做一件新的事，無論是培養新技能或是精進既有技能，同時也是在擴充、加強心智表徵，而這些心智表徵又反過來讓你有可能超越之前的極限。\n沒有人可以不投注及大量的練習就發展出非凡技能\n刻意練習與目標練習法有兩大差異\n該領域必須發展得相當成熟，佼佼者的表現水準和新手有極大差距 刻意練習需要有個老師提供可以幫助學生改善表現的練習活動 刻意練習等於是有方向和方法的目標練習法\n刻意練習特色\n刻意練習培養的技能已經有其他人知道該怎麼做，也已建立成效頗佳的訓練技巧。設計練習方式及負責監督的老師或教練應該熟悉頂尖專家的能力，並清楚該如何以最好的方法培養這些技能 跨出舒適圈後才能奏效，需要學生不斷嘗試去突破現階段的技能水準。這意味著幾乎得傾盡全力，所以往往不會太有樂趣 必須有定義清楚明確的目標，且往往涉及改進想要達到的表現得某個面向，而不能只設定模糊的整體改善目標。整體目標設定完成後，老師或教練會制定計畫，其中的一連串改善細項便會累積成向前邁進的一大步，改進想要達到的表現的某個面向，可以讓學生看見自身表現已經藉由訓練改善了 必須刻意進行，必須全神貫注，有意識地行動。光是遵從老師或教練的指導是不夠的，還得專注於自身練習的具體目標，才能適時調整，以掌控練習過程 刻意練習包含意見回饋，並根據該回饋調整努力方向。訓練初期得到的意見回括多來自老師或教練，他們會監控訓練過程並點出問題，提出解決之道。到後期學生也必須學會自我監督並察覺錯誤，隨之因應調整，而自我監督的本領則仰賴有效的心智表徵 刻意練習技能產生有效的心智表徵，也仰賴心智表徵運作。提升表現和改善心智表徵相輔相成，表現提升了，心智表徵就變得更精細有效，反之亦然，心智表徵有助於監控練習和實際上場時的狀況，讓人以正確的方式行動，也能察覺錯誤，並加以改正。 刻意練習幾乎等於加強或調整先前習得的技能，必須注重該技能的特定面向，努力改善，而隨著時間過去，每一步的改善最終會打造出專家級的表現。因為新技能以既有技能為基礎，老師必須在一開始就教導正確的基本功，這樣學生後來達到更高階的水準時，才不必從頭學習基本技能。 做法:先找出頂尖專家，弄清楚他們做了些甚麼才能如此成功，接著發展出讓自己可以做到那些事的訓練技巧\n有效的意見回饋不只是反應做得正確與否，更會討論過程\n這套方法是否能讓人離開舒適圈，嘗試帶有挑戰性的事務，能否讓人及時獲得與表現和可能的改善方式有關的意見回饋，建立這套方法的人有沒有在該領域找出頂尖專家，又是否了解專家與泛泛之輩的不同，其設計是否著眼於培養該領域專家具備的技能\n如何提升相關技能大於如何傳授相關知識，讓訓練著重於行動而非知識\nCH6：在日常生活中運用刻意練習原則 第一步，找個好老師：老師的重要任務之一，是協助學生發展個人的心智表徵，才能針對表現自我監控和修正，並視個人的改變更換老師，例如沒進步時 專注與投入至關重要：開始分心或覺得輕鬆好玩時，大概就代表沒有進步，想要從中獲得最大益處的關鍵，在於專注，有意識的發展技能並精益求精，學會以這種方式投入，便是提升練習效益最強大的方法。剛開始學著專注於練習的人無法維持數小時的注意力，因此一開始必須將練習時間設定得比較短，然後逐漸拉長。專注與投入至關重要，所以每回的訓練時間較短、但目標清楚，是更快速培養出新技能的最佳方法，在較短的時間內投入百分之百的努力，效果強過花了較長時間卻只投入百分之七十的努力，一旦發現自己無法專注，就結束這回合的訓練，並要確保睡眠充足，才能以最大的專注力進行訓練 沒有老師怎麼辦：有目標的練習或刻意練習的一項特色，在於挑戰做不到的事(離開舒適圈)，反覆練習，聚焦於自己的做法、自己的弱點，以及如何改善。富蘭克林實踐了夢想，是因為他針對寫作的不同面向設計出練習活動。好老師或好教練的主要貢獻之一，便是針對你正在努力培養的技能量身訂做類似的練習；若沒有老師，就得自己設計一套練習活動。漫不經心地重複同一件事毫無助益，重複的目的在發現自己的弱點，並聚焦於加強弱點，嘗試不同的方式改善，直到找出最佳策略為止，例如想加強英語理解能力或聽力，先觀看一步有字幕的影片，接著關掉字幕試著理解，接著打開對答案如此反覆，直到都成功，比起看好幾部片來得更有效率。想在沒有老師的情況下有效練習一項技能，建議記住三個重點：專注投入、意見回饋、解決問題。將技能分成可以有效重複練習和分析的幾個部分，確定弱點何在，並找出解決辦法。要建立有效的心智表徵，便得嘗試重現頂尖專家的成果，從失敗中認識自身弱點後再次嘗試，如此一再重複。心智表徵奏效與否，和採取行動密不可分。不能光憑思考，而是必須透過仿作加強練習，才能建立起自己所追求的心智表徵。 突破高原期，表現不再停滯不前：剛開始學習新事物時進步迅速很正常，不然也至少會穩定向前。一旦碰到停滯不前的狀況，自然會認為自己遭遇難以克服的障礙，因而往往不再試著向前邁進，反而認命地在高原徘徊。這就是各個領域的許多人不再進步的原因。突破瓶頸的最佳方式，就是以新的方法挑戰自己的大腦或身體，比平常更用力地逼迫自己，一點點就好，就像打字，卡在某個組合，就專注練習某個組合的打字節奏，如果要提升打字速度，就縮短一點時間打出平常的單字量，然後分析錯誤從何而來，找出速度快不起來的原因，設計一些練習來提升速度，而不只是再三重覆嘗試。突破高原期方法：先找出進步停滯的原因，犯了哪些錯，何時做錯的，迫使自己離開舒適圈，看哪個問題先顯露出來，設計改善這個問題的練習方法 找出持續不懈的動機：維持動機，可從兩點切入：持續的理由和停止的理由。會停止原本想做的事，是因為停止的理由終究強過於持續的理由，因此想維持動機，可以增強持續的理由或減弱停止的理由，而要讓動機發揮效用，通常必須兩者兼具。減弱停止的理由最有效的做法，撥出固定時間排除其他所有義務和令你分心的事，好好練習。在最佳狀況下要迫使自己練習可能就夠困難了，如果有其他是可以忙，往往會被引誘去做，而且會合理化地告訴自己那件事真的非做不可。經常如此，就會逐漸疏於練習，讓訓練計畫走進死胡同。可好好擬定練習時間，例如早晨，干擾因素最少，好的計畫有助於避開許多可能導致練習時間縮短的事情。找出可能干擾訓練的因素，並盡量減低影響。頂尖專家有兩個習慣，第一個是照顧身體：讓自己睡眠充足，不靠鬧鐘叫醒，並保持身體健康，第二個是將練習時間控制在大約一小時：人無法全神貫注超過一小時太多，訓練初期能集中注意力的時間可能更短，建議想將練習拉長至超過一小時的人每練一小時都休息片刻(番茄鐘)。增加持續的意願，在練習一陣子並看見成果後，技能本身就可能成為動機的一部份，讓你為自己的表現自豪，讓練習在你眼中成為一種投資，而不是耗費，另一個關鍵是相信自己能成功。想放棄可以，但至少先練習到恢復先前的水準，這時便會發現，持續進步的確有可能，之前只不過是一時的挫敗，信念的重要不容忽視。無論是因為退步或進入高原期，當你不再相信自己能達成目標時千萬別放棄，先和自己約定好，等到重回先前水準或突破高原期後再說，到時大概就會繼續下去了。最強而有力的外部動機之一是社會動機，最直接的就是得到他人的認可或欽佩。建立和維持社會動機最好的方法，就是讓自己身邊圍繞著你努力時會給予鼓勵、支持和挑戰的人，邀請興趣相同的人共組團體，或是加入現有的社團，將團體中的夥伴情誼和共同目標化為達成自身目標的額外動機。但本質上，刻意練習絕對是條寂寞的路。盡管可以和志同道合的人組成團體，彼此鼓勵，大多數的進步還是得靠獨自練習。將這條漫長的路分成一連串可達成的目標，一次聚焦一項。刻意練習是能通往實現夢想的路 CH7：邁向非凡的路線圖 專家的養成會經過四個不同的階段：產生興趣、變得認真、全心投入、開闢新路\n產生興趣：許多孩子一開始有動機探索或嘗試新事物，是出於與生俱來的好奇心或遊戲性，因此父母有機會以剛萌芽的興趣做為產開某項活動的跳板。讚美與獲得新技能的滿感會使孩子動力更強。手足間的競爭有激勵的作用。 變得認真：鼓勵，在培養技能和習慣的同時，也維持興趣與動機。協助孩子找到喜歡的相關活動，以維持長時間的動力，也就是培養心智表徵，培養音樂的表徵可以是找尋好聽的音樂，享受獨自在練習室演奏喜愛的曲子帶來的快樂。在這個階段的前半部，父母和老師的鼓勵與支持對孩子的進步至關重要，但等到孩子開始嘗到辛苦努力帶來的果實，就逐漸變得可以自我激勵。 全心投入：技能隨著年齡漸長而退步，多是因為訓練減少或中止。就算年齡增長，一定還是可以學會新技能 開闢新路：創造力其實和下苦功及長時間維持專注的能力相輔相成，這些正是一開始造就他們專家級能力的刻意練習的要素 非凡能力都是大量練習和訓練的結果，奇才或自閉學者無法證明特殊天賦的存在。人之所以停止學習、不再進步，不是因為到達天生能力的極限，而是因為某些原因不再練習，或者從未開始練習。\n刻意練習基本原則：將學習目標分解為一連串具體技能，並設計練習活動以正確的順序教導每一項技能，然後運用意見回饋監控進展。最後的勝利屬於更努力練習的人，而不屬於一開始靠智力或其他天賦佔上風者。\nCH8：如何解釋’’天賦’’這回事 老師在準備教案時，決定學生應該具備哪些能力，遠比決定應該具備那些知識有效，因為培養能力的過程中自然會獲得知識。先列出能力後，再化為一系列具體的學習目標，建立完善的心智表徵。\n設計一系列提點問題和學習任務，幫助他們達到老師訂定的學習目標。各個提點問題和任務的挑選標準是要能開啟討論，藉此鼓勵學生了解、應用正在學習的概念，進而運用這些概念回答問題和完成任務。設計問題另一個目的是激勵學生踏出舒適圈，讓學生思考，並在犯錯時讓學生能獲得即時的回應和改正建議。\nCH9：用刻意練習打造全新的世界 刻意練習原則路線圖：先確認學生應該學會的能力，目標在於技能，而非知識。找出學生學習某項技能應該使用的方式之後，了解專家的作法，尤其重要的是必須盡可能弄清楚專家運用的心智表徵。然後，將技能分解成幾個步驟，每個步驟都應該讓學生離開舒適圈，但又不至於遙不可及。接著開始充分反覆練習和提供意見回饋，也就是嘗試、失敗、意見回饋、再次嘗試，如此一再循環，學生便會在過程中建立起自己的心智表徵。\n協助學生培養某領域技能和心智表徵的最佳方法，便是提供可以模仿和學習的範例，並結合高品質的練習\n之所以不無聊，是因為總有新的跳站和契機\n可塑性與適應力極高的大腦並且搭配正確訓練\n學習變成一種創造能力的方法，而不是引導個人發揮固有能力，使人天生的潛能不具限制，我們醫生做的各式各樣的事情塑造而成，學習不是一種達到潛能的方法，而是發展潛能，創造出自己的潛能，此書將會介紹正確的練習方法(刻意練習)，以及如何應用\n任何領域裡最有效最有用的練習方式都是藉由掌控大腦與身體的適應力，一步步創造出之前不可能擁有的能力\n讀了這本書之後，讓我最有改觀的就是天才是靠努力得來的，並且有目標的大量練習，注重練習的質與量才是真正通往天才的唯一途徑，書中講述了許多被世人認為是天才，但經過自己深入暸解後並非是如此，並且舉例了天才背後不為人知的秘密，’’刻意練習’’，書中也說明了學習並不是引導個人發揮固有能力，而是讓學習變成一種創造能力的方法，學習不是一種達到潛能的方法，而是發展潛能，創造出自己的潛能，並且點破了’’一萬小時法則’’的迷思以及誤解， 讓練習在你眼中成為一種投資，而不是耗費，沒有人可以不投注大量的練習就發展出非凡技能，因此我也打算利用這個方法讓我在學習技能的道路上更有效率以及系統的大量練習，看是否也能讓我頭痛已久的能力也能成為我拿手的技能。\n","permalink":"https://sz9751210.github.io/posts/%E5%88%BB%E6%84%8F%E7%B7%B4%E7%BF%92/","summary":"\u003ch2 id=\"quick-review\"\u003e👀QUICK REVIEW\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003eThe book in 3 Sentences 用三段話說明這本書的內容\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e天才並非真的存在，刻意練習才是真正通往專家的唯一途徑\u003c/li\u003e\n\u003cli\u003e練習的質與量勝過於單純的練習量\u003c/li\u003e\n\u003cli\u003e專注投入與信念至關重要\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eHow the Book Changed Me? 這本書為我帶來什麼改變\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e讓練習在你眼中成為一種投資，而不是耗費\u003c/li\u003e\n\u003cli\u003e沒有人可以不投注及大量的練習就發展出非凡技能\u003c/li\u003e\n\u003cli\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eMy Top 3 Quotes 我最喜歡的 3 句 Quotes\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e人之所以停止學習、不再進步，不是因為到達天生能力的極限，而是因為某些原因不再練習，或者從未開始練習。\u003c/li\u003e\n\u003cli\u003e技能越高超，心智表徵越成熟，越了解這領域，代表自己更懂欠缺甚麼，也因此更能發揮刻意練習的效果，磨練技巧可以改善心智表徵，心智表徵又有助於技能進步\u003c/li\u003e\n\u003cli\u003e當你不再相信自己能達成目標時千萬別放棄，先和自己約定好，等到重回先前水準或突破高原期後再說，到時大概就會繼續下去了。\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e","title":"刻意練習：原創者全面解析, 比天賦更關鍵的學習法"},{"content":"📚讀後心得 讀完心流這本書後，心流對我的生活有很大的改觀，心流，就是我們在做某件事情時，全神貫注進入渾然忘我的狀態，讓我想起有時候在想一段程式，如何做優化，並且一步一步漸漸達成，接著看一下時間，突然就快要下班了，原來我也體驗過心流，那種感覺真的是很美好，整個人很享受當下那種慢慢擊破目標，達成目的的過程，裡面也有講到一段話我覺得很棒，成功，就像幸福一樣，不是追求而來的；它是一個人全心全意投入一件事，而忘卻自我的副產物。所以本書就是在教如何找到自己的心流所在，讓我們能夠變得更快樂，更幸福。\n心流的三個特徵，第一：全神貫注的忘我境界，拿我剛剛想程式碼的例子，從一開始的設計邏輯到實踐，整個過程我是全神貫注的狀態，第二：重建自我內在的秩序，我必須給自己信心，相信自己能夠實現出我所想的方法，第三：目標與即時的回饋，我透過一小段一小段慢慢實踐我所想的方法，並能夠立即知道結果，只要達成這三個，就有機會體驗心流，知道如何控制內在體驗的人們將有能力決定自己的人生品質。當我們進入心流體驗的時間越多，就越能提升自己本身的幸福感、加深對目標的堅持、擁有更積極的心態，讓我們面對未來種種挑戰也不會輕易受到外在的控制。自行作主的信念能使一個人能全心投入目標，行動完全受內在控制\n最後我整理了進入心流的五個步驟\n設定明確並且具有挑戰性的目標 具備一定程度的技能 拆解成階段性任務 屏除外界干擾專心投入 忘卻自我樂在當下 ","permalink":"https://sz9751210.github.io/posts/flow/","summary":"\u003ch2 id=\"讀後心得\"\u003e📚讀後心得\u003c/h2\u003e\n\u003cp\u003e讀完心流這本書後，心流對我的生活有很大的改觀，心流，就是我們在做某件事情時，全神貫注進入渾然忘我的狀態，讓我想起有時候在想一段程式，如何做優化，並且一步一步漸漸達成，接著看一下時間，突然就快要下班了，原來我也體驗過心流，那種感覺真的是很美好，整個人很享受當下那種慢慢擊破目標，達成目的的過程，裡面也有講到一段話我覺得很棒，成功，就像幸福一樣，不是追求而來的；它是一個人全心全意投入一件事，而忘卻自我的副產物。所以本書就是在教如何找到自己的心流所在，讓我們能夠變得更快樂，更幸福。\u003c/p\u003e","title":"心流：高手都在研究的最優體驗心理學"}]