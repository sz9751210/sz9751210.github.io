[{"content":"👨‍💻簡介 在當今的雲計算時代，容器化和微服務架構成為了重要趨勢。Kubernetes，作為領先的容器編排平台，提供了強大的功能來管理和部署應用程式。然而，隨著應用程式和用戶的增加，有效管理誰可以對 Kubernetes 集群執行何種操作變得至關重要。這裡，RBAC (Role-Based Access Control) 機制起到了關鍵作用。\n🔰基礎介紹 什麼是 RBAC： RBAC 可以根據角色對用戶進行細粒度的權限管理。它基於三個主要概念：角色（Role）、角色綁定（RoleBinding）和主體（Subjects）。\n角色 (Role) 和 ClusterRole：\n角色 (Role)：定義了一組權限，這些權限表示對特定 Kubernetes 資源的操作，如建立、讀取、更新和刪除。 ClusterRole：與 Role 類似，但它適用於整個集群範圍，而不是單個命名空間。ClusterRole 可以用來賦予對集群級資源的訪問權限，或者跨所有命名空間的特定資源。 角色綁定 (RoleBinding) 和 ClusterRoleBinding：\n角色綁定 (RoleBinding)：將角色的權限賦予給特定的主體。 ClusterRoleBinding：類似於 RoleBinding，但它將 ClusterRole 的權限賦予給整個集群的主體，而不是特定命名空間的主體。 主體 (Subjects)： 可以是用戶、群組或服務帳號。\n為什麼要在 Kubernetes 中使用 RBAC？ 在 Kubernetes 中，RBAC 使得管理大型、多用戶的集群變得更為安全和方便。它確保了只有合適的用戶和服務能夠訪問關鍵的 Kubernetes 資源，從而降低了安全風險。\n如何使用 RBAC 要開始使用 RBAC，首先要在 Kubernetes 集群中建立角色。例如，你可能有一個角色，只允許對 Pod 資源進行讀取操作。\nkind: Role apiVersion: rbac.authorization.k8s.io/v1 metadata: namespace: default name: pod-reader rules: - apiGroups: [\u0026#34;\u0026#34;] resources: [\u0026#34;pods\u0026#34;] verbs: [\u0026#34;get\u0026#34;, \u0026#34;list\u0026#34;, \u0026#34;watch\u0026#34;] --- kind: RoleBinding apiVersion: rbac.authorization.k8s.io/v1 metadata: name: read-pods namespace: default subjects: - kind: User name: alan apiGroup: rbac.authorization.k8s.io roleRef: kind: Role name: pod-reader apiGroup: rbac.authorization.k8s.io 在這個例子中，用戶 alan 獲得了在默認命名空間中讀取 Pod 的權限。\n同樣，ClusterRole 和 ClusterRoleBinding 也可以被定義以授予對集群範圍資源的訪問權限。以下是 ClusterRole 的一個範例，它允許對集群中所有命名空間的服務進行監視：\nkind: ClusterRole apiVersion: rbac.authorization.k8s.io/v1 metadata: # \u0026#34;name\u0026#34; is the name of the ClusterRole name: service-watcher rules: - apiGroups: [\u0026#34;\u0026#34;] resources: [\u0026#34;services\u0026#34;] verbs: [\u0026#34;get\u0026#34;, \u0026#34;list\u0026#34;, \u0026#34;watch\u0026#34;] 詳解 Resources 和 Verbs： 在 Kubernetes 的 RBAC 中，resources 和 verbs 是設定角色權限時的關鍵要素。\nResources： 指的是在 Kubernetes 中可以操作的各種資源類型，如 pods, services, deployments 等。每種資源都有特定的屬性和相關操作。\nVerbs： 定義了對這些資源可以執行的操作。常見的 verbs 包括：\nget：獲取單個資源的詳細訊息。 list：列出所有資源或某個集合的資源。 create：建立新的資源。 update：更新現有資源。 patch：更新部分資源。 watch：監聽資源的變化。 delete：刪除資源。 deletecollection：刪除資源集合。 理解這些 resources 和 verbs 對於建立符合特定需求的角色至關重要。例如，如果想建立一個只能查看 Pod 訊息但不能修改的角色，將需要選擇相應的 resources 和 verbs 組合。\n最佳實踐：\n最小權限原則： 僅賦予必要的最小權限，避免過度授權。 定期審核： 定期檢查和審核角色和角色綁定，確保它們符合當前的安全政策。 命名空間層級的管理： 利用命名空間對權限進行隔離和細分，確保不同團隊或應用之間的權限界限清晰。 集群範圍的權限控制： 使用 ClusterRole 和 ClusterRoleBinding 來管理跨命名空間或集群級資源的訪問。 📚Reference Using RBAC Authorization | Kubernetes Role Based Access Control Good Practices | Kubernetes ","permalink":"https://sz9751210.github.io/posts/k8s-rbac/","summary":"👨‍💻簡介 在當今的雲計算時代，容器化和微服務架構成為了重要趨勢。Kubernetes，作為領先的容器編排平台，提供了強大的功能來管理和部署應用程式。然而，隨著應用程式和用戶的增加，有效管理誰可以對 Kubernetes 集群執行何種操作變得至關重要。這裡，RBAC (Role-Based Access Control) 機制起到了關鍵作用。\n🔰基礎介紹 什麼是 RBAC： RBAC 可以根據角色對用戶進行細粒度的權限管理。它基於三個主要概念：角色（Role）、角色綁定（RoleBinding）和主體（Subjects）。\n角色 (Role) 和 ClusterRole：\n角色 (Role)：定義了一組權限，這些權限表示對特定 Kubernetes 資源的操作，如建立、讀取、更新和刪除。 ClusterRole：與 Role 類似，但它適用於整個集群範圍，而不是單個命名空間。ClusterRole 可以用來賦予對集群級資源的訪問權限，或者跨所有命名空間的特定資源。 角色綁定 (RoleBinding) 和 ClusterRoleBinding：\n角色綁定 (RoleBinding)：將角色的權限賦予給特定的主體。 ClusterRoleBinding：類似於 RoleBinding，但它將 ClusterRole 的權限賦予給整個集群的主體，而不是特定命名空間的主體。 主體 (Subjects)： 可以是用戶、群組或服務帳號。\n為什麼要在 Kubernetes 中使用 RBAC？ 在 Kubernetes 中，RBAC 使得管理大型、多用戶的集群變得更為安全和方便。它確保了只有合適的用戶和服務能夠訪問關鍵的 Kubernetes 資源，從而降低了安全風險。\n如何使用 RBAC 要開始使用 RBAC，首先要在 Kubernetes 集群中建立角色。例如，你可能有一個角色，只允許對 Pod 資源進行讀取操作。\nkind: Role apiVersion: rbac.authorization.k8s.io/v1 metadata: namespace: default name: pod-reader rules: - apiGroups: [\u0026#34;\u0026#34;] resources: [\u0026#34;pods\u0026#34;] verbs: [\u0026#34;get\u0026#34;, \u0026#34;list\u0026#34;, \u0026#34;watch\u0026#34;] --- kind: RoleBinding apiVersion: rbac.","title":"Kubernetes RBAC Overview：賦予安全與彈性的管理"},{"content":"👨‍💻簡介 terraform在每次執行terraform plan或terraform apply時，是如何知道應該要管理哪些資源？\n其實就是透過在每次執行terraform時，將建立或要變更的資源都記錄在terraform.state這份狀態檔，預設檔案使用JSON格式。\n假設建立一個google cloud storage的resource，tf設定檔如下：\nresource \u0026#34;google_storage_bucket\u0026#34; \u0026#34;bucket\u0026#34; { name = \u0026#34;terraform-alan-test-bucket\u0026#34; location = \u0026#34;ASIA-EAST1\u0026#34; storage_class = \u0026#34;STANDARD\u0026#34; public_access_prevention = \u0026#34;enforced\u0026#34; force_destroy = true uniform_bucket_level_access = true } 建立後的terraform.tfstate的一小部分如下：\n{ \u0026#34;version\u0026#34;: 4, \u0026#34;terraform_version\u0026#34;: \u0026#34;1.5.7\u0026#34;, \u0026#34;serial\u0026#34;: 3, \u0026#34;lineage\u0026#34;: \u0026#34;abda0fda-b807-b8b3-0a36-8b0c2f92e3f5\u0026#34;, \u0026#34;outputs\u0026#34;: {}, \u0026#34;resources\u0026#34;: [ { \u0026#34;module\u0026#34;: \u0026#34;module.base-bucket\u0026#34;, \u0026#34;mode\u0026#34;: \u0026#34;managed\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;google_storage_bucket\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;bucket\u0026#34;, \u0026#34;provider\u0026#34;: \u0026#34;module.base-bucket.provider[\\\u0026#34;registry.terraform.io/hashicorp/google\\\u0026#34;]\u0026#34;, \u0026#34;instances\u0026#34;: [ { \u0026#34;schema_version\u0026#34;: 1, \u0026#34;attributes\u0026#34;: { \u0026#34;autoclass\u0026#34;: [], \u0026#34;cors\u0026#34;: [], \u0026#34;custom_placement_config\u0026#34;: [], \u0026#34;default_event_based_hold\u0026#34;: false, \u0026#34;effective_labels\u0026#34;: {}, \u0026#34;encryption\u0026#34;: [], \u0026#34;force_destroy\u0026#34;: true, \u0026#34;id\u0026#34;: \u0026#34;terraform-alan-test-bucket\u0026#34;, \u0026#34;labels\u0026#34;: null, \u0026#34;lifecycle_rule\u0026#34;: [], \u0026#34;location\u0026#34;: \u0026#34;ASIA-EAST1\u0026#34;, \u0026#34;logging\u0026#34;: [], \u0026#34;name\u0026#34;: \u0026#34;terraform-alan-test-bucket\u0026#34;, } } ] } ] } 可以看到id的屬性，當每次執行plan或是apply時，terraform就是拿這個屬性從本地terraform設定檔與雲上資源做比對。\n如果你的terraform用在個人專案，則將狀態檔存在本機即可；不過如果是一個團隊要使用terraform，則可能會遇到幾個問題：\n狀態檔需要共用：需要確保團隊成員都能正常存取相同的terraform狀態檔。 鎖定狀態檔：需要確保團隊成員使用terraform進行操作時，只有一人能對狀態檔做修改，否則可能會因為多個terraform進程對狀態檔做併發更新，導致資料丟失或是狀態檔損壞。 要解決上述問題，常見的做法是將狀態檔進行版本控制(git)，但因為某些原因，將狀態檔進行版控並不是一個好想法。有底下幾個原因：\n手動操作錯誤：有時候可能在操作terraform時，忘記拉取最新狀態檔，或是在執行完terraform後，忘記將狀態檔更新到版控。可能團隊成員使用到舊的狀態檔導致資源回滾。 鎖定問題：多數的版本控制系統沒提供任何形式的鎖定，防止兩個團隊成員同時對同一份狀態檔執行操作。 加密：terraform狀態檔的資料預設都是以明文形式儲存。但某些資源需要儲存敏感資料，像是資料庫創建時需要建立初始化使用者以及密碼，這些資料不應該以明文的形式儲存在版本控制。 因為以上原因，terraform官方推出 remote backend的支援，可以將狀態檔儲存在所使用的雲平台，而不是使用版本控制，而remote backend解決了剛才列出的三個問題：\n手動操作錯誤：terraform每次運行時會自動從 remote backend 載入狀態檔，並且每次運行後都會自動將狀態檔儲存在 remote backend，解決了手動操作錯誤。 鎖定問題：大多數 remote backend 都支援鎖定。運行terraform時會自動將檔案進行上鎖，確保只會有一人進行操作。 加密：大多數 remote backend 都支援狀態檔的傳輸中加密和靜態加密。 使用gcp平台推薦使用 google cloud storage，整理的原因如下：\n這是託管服務，不需部署和管理額外基礎設施即可使用。 gcs旨在實現99.99%的持久性和年度耐用性。 数据可用性和耐用性 | Cloud Storage | Google Cloud\ngcs支援加密，預設使用server side encrypt，另外也可使用ckms服務 数据加密选项 | Cloud Storage | Google Cloud\n支援版本控制 使用对象版本控制 | Cloud Storage | Google Cloud\n費用便宜，使用免費額度即可滿足需求。 价格 | Cloud Storage | Google Cloud\nGCP GCS作為terraform remote backend 要使用 Google cloud stroage作為 terraform remote backend，首先是先建立 gcs bucket。 在新資料夾中建立一個provider.tf檔案\nterraform { required_providers { google = { source = \u0026#34;hashicorp/google\u0026#34; version = \u0026#34;\u0026gt;=4.0\u0026#34; } } } provider \u0026#34;google\u0026#34; { region =\u0026#34;asia-east1\u0026#34; } 接著再建立一個名為bucket.tf檔案，使用 google_storage_bucket resource 建立 gcs bucket。\nresource \u0026#34;google_storage_bucket\u0026#34; \u0026#34;bucket\u0026#34; { name = \u0026#34;terraform-alan-test-bucket\u0026#34; location = \u0026#34;ASIA-EAST1\u0026#34; storage_class = \u0026#34;STANDARD\u0026#34; public_access_prevention = \u0026#34;enforced\u0026#34; force_destroy = false uniform_bucket_level_access = true } 參數說明如下：\nname：定義 gcs bucket 名稱 location：指定 bucket 儲存位置 storage_class：指定 bucket 儲存類型 public_access_prevention：設定公開存取防止策略，enforce表示不允許公開訪問 force_destroy：設定是否可強制刪除 uniform_bucket_level_access：設定是否啟用統一訪問控制 當執行完terraform init以及 terraform apply部署完後，就會看到gcs已經建立完成。但目前狀態檔還是儲存在本地。要將狀態檔儲存到 gcs bucket，需要再額外設定 remote backend，語法如下：\nterraform { backend \u0026#34;\u0026lt;BACKEND_NAME\u0026gt;\u0026#34; { [CONFIG...] } } 其中 BACKEND_NAME是要使用的資源，CONFIG是對這個後端的參數設定。以下是 gcs bucket的後端設定：\nterraform { backend \u0026#34;gcs\u0026#34; { bucket = \u0026#34;terraform-alan-test-bucket\u0026#34; prefix = \u0026#34;bucket-state\u0026#34; } } 參數說明如下：\nbucket：要使用的bucket name，這邊填入剛剛建立的 bucket prefix：定義狀態檔的路徑和名稱，以上述為例，狀態檔會被存放在 bucket-state資料夾 要將狀態檔儲存到 gcs ，只需要重新執行 terraform init 指令。該指令不僅可以下載 provider code，還可以設定 terraform backend。此外，init的指令是冪等的，多次執行可以確保每次都是預期的行為。\n\u0026gt; terraform init Initializing the backend... Do you want to copy existing state to the new backend? Pre-existing state was found while migrating the previous \u0026#34;local\u0026#34; backend to the newly configured \u0026#34;gcs\u0026#34; backend. No existing state was found in the newly configured \u0026#34;gcs\u0026#34; backend. Do you want to copy this state to the new \u0026#34;gcs\u0026#34; backend? Enter \u0026#34;yes\u0026#34; to copy and \u0026#34;no\u0026#34; to start with an empty state. Enter a value: 執行後terraform會自動檢查本地已有的狀態檔，並跳出提示說要將狀態檔複製到 gcs backend。如果輸入 yes，則會看到以下內容：\nSuccessfully configured the backend \u0026#34;gcs\u0026#34;! Terraform will automatically use this backend unless the backend configuration changes. Initializing modules... Initializing provider plugins... - Reusing previous version of hashicorp/google from the dependency lock file - Using previously-installed hashicorp/google v5.3.0 Terraform has been successfully initialized! 執行完畢後可以到 gcs查看狀態檔是否已經儲存上去。\n如果之後有資源使用一樣的backend，terraform執行時就會自動從這個 gcs拉取最新的狀態，並且執行後會自動將最新狀態推送到這個 gcs。\n當有兩人同時執行時，則第二個人會出現以下訊息：\n\u0026gt; terraform plan Acquiring state lock. This may take a few moments... ╷ │ Error: Error acquiring the state lock │ │ Error message: writing │ \u0026#34;gs://terraform-alan-test-bucket/bucket-state/default.tflock\u0026#34; failed: │ googleapi: Error 412: At least one of the pre-conditions you specified did not │ hold., conditionNotMet │ Lock Info: │ ID: 1698225515771180 │ Path: gs://terraform-alan-test-bucket/bucket-state/default.tflock │ Operation: OperationTypeApply │ Who: alan_wang │ Version: 1.5.7 │ Created: 2023-10-25 09:18:35.490893 +0000 UTC │ Info: │ │ │ Terraform acquires a state lock to protect the state from being written │ by multiple users at the same time. Please resolve the issue above and try │ again. For most commands, you can disable locking with the \u0026#34;-lock=false\u0026#34; │ flag, but this is not recommended. 這也確保了執行只會有一人，其他人要操作都會被擋下來。\nAWS S3作為terraform remote backend 依照慣例先來個 provider.tf起手式\nterraform { required_providers { aws = { source = \u0026#34;hashicorp/aws\u0026#34; version = \u0026#34;5.22.0\u0026#34; } } } provider \u0026#34;aws\u0026#34; { alias = \u0026#34;ap-east-1\u0026#34; region = \u0026#34;ap-east-1\u0026#34; } 接著建立一個名為bucket.tf檔案\nresource \u0026#34;aws_s3_bucket\u0026#34; \u0026#34;terraform_state\u0026#34; { bucket = \u0026#34;terraform-alan-test-bucket\u0026#34; provider = aws.ap-east-1 force_destroy = false # Prevent accidental deletion of this S3 bucket lifecycle { prevent_destroy = true } } 參數說明如下：\nbucket：定義 s3 bucket 名稱 provider：指定 bucket 儲存位置 force_destroy：設定是否可強制刪除 prevent_destroy：任何嘗試刪除該資源的操作都將導致terraform退出並顯示錯誤。 接下來要替s3增加一些額外的保護\n首先新增版本控制，使用aws_s3_bucket_versioning resource開啟版本控制，確保每次更新都會創建新版。當出現問題時也能恢復成舊版：\nresource \u0026#34;aws_s3_bucket_versioning\u0026#34; \u0026#34;enabled\u0026#34; { bucket = aws_s3_bucket.terraform_state.id versioning_configuration { status = \u0026#34;Enabled\u0026#34; } } 參數說明如下：\nbucket：要啟用版本控制的 S3 bucket 的 ID versioning_configuration： status：可用選項為Enabled、Disabled與Suspended，設為 \u0026ldquo;Enabled\u0026rdquo; 表示啟用版本控制 接著開啟加密設定，使用 aws_s3_bucket_server_side_encryption_configuration，開啟後寫入到這個 S3 的所有資料都會啟用 server 端的加密。確保狀態檔以及任何存在 S3 的敏感資料都在硬碟上加密：\nresource \u0026#34;aws_s3_bucket_server_side_encryption_configuration\u0026#34; \u0026#34;server_side_encryption\u0026#34; { bucket = aws_s3_bucket.terraform_state.id rule { apply_server_side_encryption_by_default { sse_algorithm = \u0026#34;AES256\u0026#34; } } } 參數說明如下：\nbucket：要啟用版本控制的 S3 bucket 的 ID apply_server_side_encryption_by_default：指定預設的 server 端加密設定。 sse_algorithm：設定 server 端加密算法，這裡使用的是 \u0026ldquo;AES256\u0026rdquo;。 補充一下其他可用選項\nAES256 (SSE-S3): 描述：使用 Amazon S3 托管的密鑰（SSE-S3）進行加密。 算法：AES-256。 密鑰管理：由 Amazon S3 自動處理。 aws:kms (SSE-KMS): 描述：使用 AWS Key Management Service (KMS) 托管的 CMK（客戶主密鑰）進行加密。 算法：通常是 AES-256，但具體取決於 KMS。 密鑰管理：由 AWS KMS 處理，允許更細緻的控制和審計跟踪。 aws:kms:dsse (SSE-KMS with Double-Wrap): 描述：這是一種特殊的 KMS 加密方法，其中數據首先使用一個隨機數據加密密鑰 (DEK) 進行加密，然後 DEK 本身使用 KMS CMK 進行加密，從而實現雙重加密。 密鑰管理：由 AWS KMS 處理。 區別:\n密鑰管理：AES256 由 S3 自動管理，aws:kms 和 aws:kms:dsse 允許更多的控制和稽核，由 AWS KMS 處理。 加密強度：aws:kms:dsse 提供雙重加密，可提供更高的安全性。 推薦:\n對於大多數使用者，AES256 是一個簡單且安全的選擇。 如果需要更細緻的密鑰管理、審計或控制，則推薦使用 aws:kms。 如果需要更高的安全性和加密強度，則可以考慮使用 aws:kms:dsse，但請注意，這可能會增加一些複雜性和成本。 如果開啟 aws:kms 時，推薦也需要設定 bucket_key_enabled，可減少對 kms請求，降低成本。 當使用SSE-KMS進行 server 端加密時，每次S3對象操作都會導致KMS請求，這可能會增加成本。使用S3 Bucket Keys，可以減少這些請求，從而減少成本。\n第三個設定是存取權的控制，阻止對 S3 bucket 的所有公開存取。\nresource \u0026#34;aws_s3_bucket_public_access_block\u0026#34; \u0026#34;public_access\u0026#34; { bucket = aws_s3_bucket.bucket.id block_public_acls = true block_public_policy = true ignore_public_acls = true restrict_public_buckets = true } 參數說明如下：\nbucket：要設定公開存取阻止的 S3 bucket ID。 block_public_acls：設定為 true 阻止公開 ACL。 block_public_policy：設定為 true 阻止公開策略。 ignore_public_acls：設定為 true 忽略公開 ACL。 restrict_public_buckets：設定為 true 限制公開 bucket。 最後一個要設定的是用來當作鎖的 DynamoDB table，使用 aws_dynamodb_table 的強一制性讀取和條件寫入，達到分散式鎖系統。\nresource \u0026#34;aws_dynamodb_table\u0026#34; \u0026#34;terraform_locks\u0026#34; { name = var.dynamodb_table_name billing_mode = \u0026#34;PAY_PER_REQUEST\u0026#34; hash_key = \u0026#34;LockID\u0026#34; attribute { name = \u0026#34;LockID\u0026#34; type = \u0026#34;S\u0026#34; } } 參數說明如下：\nname：這是 DynamoDB 表的名稱。 billing_mode：這指定了計費模式，能使用的值有PROVISIONED與PAY_PER_REQUEST，這裡使用\u0026quot;PAY_PER_REQUEST\u0026quot;，依照需請求計費。另一種則是確定有固定的讀寫，則可以設定讀寫量。 BillingModeSummary - Amazon DynamoDB\nhash_key：這是表的主鍵名稱。 attribute： name：這是屬性的名稱，這裡是 \u0026ldquo;LockID\u0026rdquo; type：這是屬性的類型，可以用的類型有S(字串)、N(數字)、B(二進制) 依照上面的設定，即可完成s3以及dynamodb的建立，一樣下 terraform init terraform apply完成建置。接著來設定 remote backend\nterraform { backend \u0026#34;s3\u0026#34; { bucket = \u0026#34;terraform-alan-test-bucket\u0026#34; key = \u0026#34;bucket-state/terraform.tfstate\u0026#34; region = \u0026#34;ap-east-1\u0026#34; dynamodb_table = \u0026#34;terraform-locks\u0026#34; encrypt = true } } 參數說明如下：\nbucket：要使用的bucket name，這邊填入剛剛建立的 bucket key：要建立在 s3 的路徑和名稱 region：指定 s3 的區域 dynamodb_table：用來儲存狀態檔的鎖定，防止多人同時使用 terraform 操作同一份檔案，可防止同時修改，避免數據不一致 encrypt：決定是否加密 terraform state 檔案，設定為 true 將使用 s3 的 sse 進行加密 prefix：定義狀態檔的路徑和名稱，以上述為例，狀態檔會被存放在 bucket-state資料夾 一樣重下 terraform init 重設 backend\n\u0026gt; terraform init Initializing the backend... Do you want to copy existing state to the new backend? Pre-existing state was found while migrating the previous \u0026#34;local\u0026#34; backend to the newly configured \u0026#34;s3\u0026#34; backend. No existing state was found in the newly configured \u0026#34;s3\u0026#34; backend. Do you want to copy this state to the new \u0026#34;s3\u0026#34; backend? Enter \u0026#34;yes\u0026#34; to copy and \u0026#34;no\u0026#34; to start with an empty state. Enter a value: 執行後terraform會自動檢查本地已有的狀態檔，並跳出提示說要將狀態檔複製到 gcs backend。如果輸入 yes，則會看到以下內容：\nSuccessfully configured the backend \u0026#34;s3\u0026#34;! Terraform will automatically use this backend unless the backend configuration changes. Initializing modules... Initializing provider plugins... - Reusing previous version of hashicorp/aws from the dependency lock file - Using previously-installed hashicorp/aws v5.22.0 Terraform has been successfully initialized! 一樣執行完畢後上去 s3 看一下狀態檔是否已經儲存上去\n當有兩人同時執行時，則第二個人會出現以下訊息：\n\u0026gt; terraform apply Acquiring state lock. This may take a few moments... ╷ │ Error: Error acquiring the state lock │ │ Error message: ConditionalCheckFailedException: The conditional request failed │ Lock Info: │ ID: 46f562fd-ab59-a657-6984-5e164ec4bf │ Path: terraform-alan-test-bucket/bucket-state/terraform.tfstate │ Operation: OperationTypeApply │ Who: alan_wang@Alan-wangdeMacBook-Pro.local │ Version: 1.5.7 │ Created: 2023-10-26 09:33:34.15838 +0000 UTC │ Info: │ │ │ Terraform acquires a state lock to protect the state from being written │ by multiple users at the same time. Please resolve the issue above and try │ again. For most commands, you can disable locking with the \u0026#34;-lock=false\u0026#34; │ flag, but this is not recommended. ╵ 📚Reference How To Setup a Terraform Remote Backend in Google Cloud | by Żimuzo Obiechina | Medium How to Manage Terraform S3 Backend - Best Practices (spacelift.io) ","permalink":"https://sz9751210.github.io/posts/terraform-backend/","summary":"👨‍💻簡介 terraform在每次執行terraform plan或terraform apply時，是如何知道應該要管理哪些資源？\n其實就是透過在每次執行terraform時，將建立或要變更的資源都記錄在terraform.state這份狀態檔，預設檔案使用JSON格式。\n假設建立一個google cloud storage的resource，tf設定檔如下：\nresource \u0026#34;google_storage_bucket\u0026#34; \u0026#34;bucket\u0026#34; { name = \u0026#34;terraform-alan-test-bucket\u0026#34; location = \u0026#34;ASIA-EAST1\u0026#34; storage_class = \u0026#34;STANDARD\u0026#34; public_access_prevention = \u0026#34;enforced\u0026#34; force_destroy = true uniform_bucket_level_access = true } 建立後的terraform.tfstate的一小部分如下：\n{ \u0026#34;version\u0026#34;: 4, \u0026#34;terraform_version\u0026#34;: \u0026#34;1.5.7\u0026#34;, \u0026#34;serial\u0026#34;: 3, \u0026#34;lineage\u0026#34;: \u0026#34;abda0fda-b807-b8b3-0a36-8b0c2f92e3f5\u0026#34;, \u0026#34;outputs\u0026#34;: {}, \u0026#34;resources\u0026#34;: [ { \u0026#34;module\u0026#34;: \u0026#34;module.base-bucket\u0026#34;, \u0026#34;mode\u0026#34;: \u0026#34;managed\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;google_storage_bucket\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;bucket\u0026#34;, \u0026#34;provider\u0026#34;: \u0026#34;module.base-bucket.provider[\\\u0026#34;registry.terraform.io/hashicorp/google\\\u0026#34;]\u0026#34;, \u0026#34;instances\u0026#34;: [ { \u0026#34;schema_version\u0026#34;: 1, \u0026#34;attributes\u0026#34;: { \u0026#34;autoclass\u0026#34;: [], \u0026#34;cors\u0026#34;: [], \u0026#34;custom_placement_config\u0026#34;: [], \u0026#34;default_event_based_hold\u0026#34;: false, \u0026#34;effective_labels\u0026#34;: {}, \u0026#34;encryption\u0026#34;: [], \u0026#34;force_destroy\u0026#34;: true, \u0026#34;id\u0026#34;: \u0026#34;terraform-alan-test-bucket\u0026#34;, \u0026#34;labels\u0026#34;: null, \u0026#34;lifecycle_rule\u0026#34;: [], \u0026#34;location\u0026#34;: \u0026#34;ASIA-EAST1\u0026#34;, \u0026#34;logging\u0026#34;: [], \u0026#34;name\u0026#34;: \u0026#34;terraform-alan-test-bucket\u0026#34;, } } ] } ] } 可以看到id的屬性，當每次執行plan或是apply時，terraform就是拿這個屬性從本地terraform設定檔與雲上資源做比對。","title":"如何在GCP以及AWS設定 remote backend 管理 terraform 狀態檔"},{"content":"👨‍💻 簡介 最近想要透過小實作來撰寫筆記，達到做中學的效果，因此就來實作個小爬蟲順便結合前面學到的package做一個小複習。\n建立HTTP Client Go的net/http package 提供了一個HTTP Client，用來發送各種HTTP請求。\nhttp.Get：發送GET請求。 http.Post：發送POST請求。 http.NewRequest：建立一個新的HTTP請求。 語法如下：\n// 發送GET請求 func http.Get(url string) (resp *http.Response, err error) // 發送POST請求 func http.Post(url, contentType string, body io.Reader) (resp *http.Response, err error) // 建立一個新的HTTP請求 func http.NewRequest(method, url string, body io.Reader) (*http.Request, error) 常見的Response可以使用以下欄位\ntype Response struct { Status string // e.g. \u0026#34;200 OK\u0026#34; StatusCode int // e.g. 200 Proto string // e.g. \u0026#34;HTTP/1.0\u0026#34; Header Header Body io.ReadCloser ... } 接著看一下io.ReadCloser\ntype ReadCloser interface { Reader Closer } 可以看到ReadCloser是 interface，接著來看一下Reader\ntype Reader interface { Read(p []byte) (n int, err error) } Reader也是一個interface，裡面有定義了Read方法，因此可以推測出resp.Body（作為一個 io.ReadCloser）也實現了 io.Reader interface。\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;io\u0026#34; \u0026#34;net/http\u0026#34; ) func main() { // 使用 http.Get 發送GET請求 resp, err := http.Get(\u0026#34;https://www.example.com\u0026#34;) if err != nil { fmt.Println(\u0026#34;Error:\u0026#34;, err) return } // 拿到Body最後要確保有關閉連線 defer resp.Body.Close() // 語法為func ReadAll(r io.Reader) ([]byte, error) // 會回傳[]byte，要透過string package轉為string body, _ := io.ReadAll(resp.Body) fmt.Println(\u0026#34;status code: \u0026#34;, resp.StatusCode) fmt.Println(\u0026#34;body: \u0026#34;) fmt.Println(string(body)) } 在上面的範例中，簡單的使用http.Get取得網頁的相關資訊。接下來試著寫一個簡單的爬蟲，來爬取ptt。\n爬取PTT八卦版標題 1. 建立http client以及自定義請求 client := \u0026amp;http.Client{} req, err := http.NewRequest(\u0026#34;GET\u0026#34;, \u0026#34;https://www.ptt.cc/bbs/Gossiping/index.html\u0026#34;, nil) if err != nil { log.Fatal(err) } 因為八卦版會有詢問是否年滿18，因此會需要設定cookie，而要設定cookie則必須使用自定義請求的方式，使用自定義請求則必須自己建立client進行請求的發送。\n2. 設定cookie 先去網站上看cookie的name跟value為多少 接著設定對應的參數\n// 設定cookie，可 req.AddCookie(\u0026amp;http.Cookie{Name: \u0026#34;over18\u0026#34;, Value: \u0026#34;1\u0026#34;}) 3. 發送請求 resp, err := client.Do(req) if err != nil { log.Fatal(err) } defer resp.Body.Close() 使用剛剛建立的client放入自定義請求就可以完成請求的發送並取得回傳。\n4. 解析回傳資訊 在進行這一步之前需要先安裝一個 go package，github.com/PuerkitoBio/goquery，主要用來解析html的標籤屬性。\ngo get github.com/PuerkitoBio/goquery 等一下會用到的方法為\nfunc NewDocumentFromReader(r io.Reader) (*Document, error) 而Document是一個struct\ntype Document struct { *Selection } 要根據css selector下去找資料，可以使用Find方法，而當找到匹配的元素時，對這個元素接著使用Each方法取得相關屬性，像是Text或是Attr等\nfunc (s *Selection) Find(selector string) *Selection func (s *Selection) Each(f func(int, *Selection)) *Selection 接著依照ptt的網站結構查看title的標籤為div，class為title，而裡面還有一層包著超連結，因此要爬取的路徑就可以依照下面的格式撰寫\ndoc, err := goquery.NewDocumentFromReader(resp.Body) if err != nil { log.Fatal(err) } // 提取文章標題 doc.Find(\u0026#34;div.title a\u0026#34;).Each(func(index int, item *goquery.Selection) { title := item.Text() fmt.Println(title) }) 以下為完整程式碼\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;log\u0026#34; \u0026#34;net/http\u0026#34; \u0026#34;github.com/PuerkitoBio/goquery\u0026#34; ) func main() { client := \u0026amp;http.Client{} req, err := http.NewRequest(\u0026#34;GET\u0026#34;, \u0026#34;https://www.ptt.cc/bbs/Gossiping/index.html\u0026#34;, nil) if err != nil { log.Fatal(err) } // 設定cookie模擬已滿18歲的使用者 req.AddCookie(\u0026amp;http.Cookie{Name: \u0026#34;over18\u0026#34;, Value: \u0026#34;1\u0026#34;}) resp, err := client.Do(req) if err != nil { log.Fatal(err) } defer resp.Body.Close() doc, err := goquery.NewDocumentFromReader(resp.Body) if err != nil { log.Fatal(err) } // 提取文章標題 doc.Find(\u0026#34;div.title a\u0026#34;).Each(func(index int, item *goquery.Selection) { title := item.Text() fmt.Println(title) }) } 📚Reference net/http package - http - Go Packages http — HTTP Client和服務器 · Go語言標准庫 (studygolang.com) [pkg] net/http | PJCHENder 未整理筆記 ","permalink":"https://sz9751210.github.io/posts/go-ptt-crawler/","summary":"👨‍💻 簡介 最近想要透過小實作來撰寫筆記，達到做中學的效果，因此就來實作個小爬蟲順便結合前面學到的package做一個小複習。\n建立HTTP Client Go的net/http package 提供了一個HTTP Client，用來發送各種HTTP請求。\nhttp.Get：發送GET請求。 http.Post：發送POST請求。 http.NewRequest：建立一個新的HTTP請求。 語法如下：\n// 發送GET請求 func http.Get(url string) (resp *http.Response, err error) // 發送POST請求 func http.Post(url, contentType string, body io.Reader) (resp *http.Response, err error) // 建立一個新的HTTP請求 func http.NewRequest(method, url string, body io.Reader) (*http.Request, error) 常見的Response可以使用以下欄位\ntype Response struct { Status string // e.g. \u0026#34;200 OK\u0026#34; StatusCode int // e.g. 200 Proto string // e.g. \u0026#34;HTTP/1.0\u0026#34; Header Header Body io.ReadCloser ... } 接著看一下io.","title":"如何用 Go 實作一個簡單的 PTT 爬蟲"},{"content":"👨‍💻簡介 今天來介紹一個自己開發後端蠻常用的一個 package，promptui，拿來做menu真的很方便，promptui有兩個主要的輸入模式：\nPrompt：跳出單行使用者輸入。 Select：提供一個選項列表供使用者選擇。 Prompt prompt是一個struct，當執行Run時會返回輸入的結果\ntype Prompt struct { // Label is the value displayed on the command line prompt. // // The value for Label can be a simple string or a struct that will need to be accessed by dot notation // inside the templates. For example, `{{ .Name }}` will display the name property of a struct. Label interface{} // Default is the initial value for the prompt. This value will be displayed next to the prompt\u0026#39;s label // and the user will be able to view or change it depending on the options. Default string // AllowEdit lets the user edit the default value. If false, any key press // other than \u0026lt;Enter\u0026gt; automatically clears the default value. AllowEdit bool // Validate is an optional function that fill be used against the entered value in the prompt to validate it. Validate ValidateFunc // Mask is an optional rune that sets which character to display instead of the entered characters. This // allows hiding private information like passwords. Mask rune // HideEntered sets whether to hide the text after the user has pressed enter. HideEntered bool // Templates can be used to customize the prompt output. If nil is passed, the // default templates are used. See the PromptTemplates docs for more info. Templates *PromptTemplates // IsConfirm makes the prompt ask for a yes or no ([Y/N]) question rather than request an input. When set, // most properties related to input will be ignored. IsConfirm bool // IsVimMode enables vi-like movements (hjkl) and editing. IsVimMode bool // the Pointer defines how to render the cursor. Pointer Pointer Stdin io.ReadCloser Stdout io.WriteCloser } 語法如下：\nfunc (*promptui.Prompt).Run() (string, error) package main import ( \u0026#34;fmt\u0026#34; \u0026#34;github.com/manifoldco/promptui\u0026#34; ) func main() { prompt := promptui.Prompt{ Label: \u0026#34;Anything\u0026#34;, } result, err := prompt.Run() if err != nil { fmt.Printf(\u0026#34;Prompt failed %v\\n\u0026#34;, err) return } fmt.Printf(\u0026#34;You type %q\\n\u0026#34;, result) } 確認（Confirm） 建立一個確認提示，使用者可以選擇是或否。\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;github.com/manifoldco/promptui\u0026#34; ) func main() { prompt := promptui.Prompt{ Label: \u0026#34;Delete all resources\u0026#34;, IsConfirm: true, } _, err := prompt.Run() if err != nil { fmt.Printf(\u0026#34;Prompt failed %v\\n\u0026#34;, err) return } fmt.Printf(\u0026#34;Resources deleted\u0026#34;) } 自定義提示（Custom Prompt） 這個功能是讓使用者可以自己定義提示的外觀和行為。例如，你可以更改提示的顏色，標籤和其他設定。\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;errors\u0026#34; \u0026#34;github.com/manifoldco/promptui\u0026#34; ) func main() { prompt := promptui.Prompt{ Label: \u0026#34;Enter your name\u0026#34;, Validate: func(input string) error { if len(input) \u0026lt; 3 { return errors.New(\u0026#34;Name must have more than 3 characters\u0026#34;) } return nil }, } result, err := prompt.Run() if err != nil { fmt.Printf(\u0026#34;Prompt failed %v\\n\u0026#34;, err) return } fmt.Printf(\u0026#34;Hello %q\\n\u0026#34;, result) } 提示預設值（Prompt Default） Promptui 支援設定提示的預設值。\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;github.com/manifoldco/promptui\u0026#34; ) func main() { prompt := promptui.Prompt{ Label: \u0026#34;Enter your name\u0026#34;, Default: \u0026#34;Alan\u0026#34;, } result, err := prompt.Run() if err != nil { fmt.Printf(\u0026#34;Prompt failed %v\\n\u0026#34;, err) return } fmt.Printf(\u0026#34;Hello %q\\n\u0026#34;, result) } 密碼提示（Password Prompt） Promptui 可以用來建立一個密碼提示，其中使用者輸入的文本將被掩蓋。\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;github.com/manifoldco/promptui\u0026#34; ) func main() { prompt := promptui.Prompt{ Label: \u0026#34;Enter Password\u0026#34;, Mask: \u0026#39;*\u0026#39;, } result, err := prompt.Run() if err != nil { fmt.Printf(\u0026#34;Prompt failed %v\\n\u0026#34;, err) return } fmt.Printf(\u0026#34;Password entered: %q\\n\u0026#34;, result) } Select Select也是一個struct，與Prompt不同的是當執行Run時會返回index以及選中的結果\ntype Select struct { // Label is the text displayed on top of the list to direct input. The IconInitial value \u0026#34;?\u0026#34; will be // appended automatically to the label so it does not need to be added. // // The value for Label can be a simple string or a struct that will need to be accessed by dot notation // inside the templates. For example, `{{ .Name }}` will display the name property of a struct. Label interface{} // Items are the items to display inside the list. It expect a slice of any kind of values, including strings. // // If using a slice of strings, promptui will use those strings directly into its base templates or the // provided templates. If using any other type in the slice, it will attempt to transform it into a string // before giving it to its templates. Custom templates will override this behavior if using the dot notation // inside the templates. // // For example, `{{ .Name }}` will display the name property of a struct. Items interface{} // Size is the number of items that should appear on the select before scrolling is necessary. Defaults to 5. Size int // CursorPos is the initial position of the cursor. CursorPos int // IsVimMode sets whether to use vim mode when using readline in the command prompt. Look at // https://godoc.org/github.com/chzyer/readline#Config for more information on readline. IsVimMode bool // HideHelp sets whether to hide help information. HideHelp bool // HideSelected sets whether to hide the text displayed after an item is successfully selected. HideSelected bool // Templates can be used to customize the select output. If nil is passed, the // default templates are used. See the SelectTemplates docs for more info. Templates *SelectTemplates // Keys is the set of keys used in select mode to control the command line interface. See the SelectKeys docs for // more info. Keys *SelectKeys // Searcher is a function that can be implemented to refine the base searching algorithm in selects. // // Search is a function that will receive the searched term and the item\u0026#39;s index and should return a boolean // for whether or not the terms are alike. It is unimplemented by default and search will not work unless // it is implemented. Searcher list.Searcher // StartInSearchMode sets whether or not the select mode should start in search mode or selection mode. // For search mode to work, the Search property must be implemented. StartInSearchMode bool list *list.List // A function that determines how to render the cursor Pointer Pointer Stdin io.ReadCloser Stdout io.WriteCloser } 語法如下：\nfunc (*promptui.Select).Run() (int, string, error) func (*promptui.Select).RunCursorAt(cursorPos int, scroll int) (int, string, error) func (*promptui.Select).ScrollPosition() int package main import ( \u0026#34;fmt\u0026#34; \u0026#34;github.com/manifoldco/promptui\u0026#34; ) func main() { prompt := promptui.Select{ Label: \u0026#34;Select Day\u0026#34;, Items: []string{\u0026#34;Monday\u0026#34;, \u0026#34;Tuesday\u0026#34;, \u0026#34;Wednesday\u0026#34;, \u0026#34;Thursday\u0026#34;, \u0026#34;Friday\u0026#34;, \u0026#34;Saturday\u0026#34;, \u0026#34;Sunday\u0026#34;}, } _, result, err := prompt.Run() if err != nil { fmt.Printf(\u0026#34;Prompt failed %v\\n\u0026#34;, err) return } fmt.Printf(\u0026#34;You choose %q\\n\u0026#34;, result) } 自定義選擇（Custom Select） 除了基本的選擇提示外，Promptui 還允許使用者自定義選擇列表的外觀和行為。\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;github.com/manifoldco/promptui\u0026#34; ) func main() { prompt := promptui.Select{ Label: \u0026#34;Choose Color\u0026#34;, Items: []string{\u0026#34;Red\u0026#34;, \u0026#34;Blue\u0026#34;, \u0026#34;Green\u0026#34;}, Templates: \u0026amp;promptui.SelectTemplates{ Label: \u0026#34;{{ . }}?\u0026#34;, Active: \u0026#34;\\U0001F336 {{ . | red }}\u0026#34;, Inactive: \u0026#34; {{ . | cyan }}\u0026#34;, Selected: \u0026#34;\\U0001F336 {{ . | red | cyan }}\u0026#34;, }, } _, result, err := prompt.Run() if err != nil { fmt.Printf(\u0026#34;Prompt failed %v\\n\u0026#34;, err) return } fmt.Printf(\u0026#34;You choose %q\\n\u0026#34;, result) } 選擇添加（Select Add） Promptui 還允許使用者在選擇提示中添加新的選項。\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;github.com/manifoldco/promptui\u0026#34; ) func main() { items := []string{\u0026#34;Monday\u0026#34;, \u0026#34;Tuesday\u0026#34;, \u0026#34;Wednesday\u0026#34;, \u0026#34;Thursday\u0026#34;, \u0026#34;Friday\u0026#34;} prompt := promptui.SelectWithAdd{ Label: \u0026#34;What day is it?\u0026#34;, Items: items, AddLabel: \u0026#34;Other\u0026#34;, } idx, result, err := prompt.Run() if err != nil { fmt.Printf(\u0026#34;Prompt failed %v\\n\u0026#34;, err) return } if idx == len(items) { fmt.Printf(\u0026#34;You chose to add %q\\n\u0026#34;, result) } else { fmt.Printf(\u0026#34;You chose %q\\n\u0026#34;, result) } } 📚Reference manifoldco/promptui: Interactive prompt for command-line applications (github.com) promptui package - github.com/manifoldco/promptui - Go Packages ","permalink":"https://sz9751210.github.io/posts/go-promptui/","summary":"👨‍💻簡介 今天來介紹一個自己開發後端蠻常用的一個 package，promptui，拿來做menu真的很方便，promptui有兩個主要的輸入模式：\nPrompt：跳出單行使用者輸入。 Select：提供一個選項列表供使用者選擇。 Prompt prompt是一個struct，當執行Run時會返回輸入的結果\ntype Prompt struct { // Label is the value displayed on the command line prompt. // // The value for Label can be a simple string or a struct that will need to be accessed by dot notation // inside the templates. For example, `{{ .Name }}` will display the name property of a struct. Label interface{} // Default is the initial value for the prompt.","title":"Promptui教學：快速建立 Go 語言的交互式介面"},{"content":"👨‍💻 簡介 在處理string時，正則表達式是一個非常有用的工具。Go語言的regexp package 可以使用正則表達式，用來執行如檢查string是否匹配某個模式、提取匹配的subString等操作。\n匹配功能 regexp.MatchString：檢查一個string是否匹配某個模式。 regexp.Compile：編譯一個正則表達式。 語法如下：\n// 檢查一個string是否匹配某個模式。 func regexp.MatchString(pattern string, s string) (matched bool, err error) // 編譯一個正則表達式。 func regexp.Compile(expr string) (*Regexp, error) package main import ( \u0026#34;fmt\u0026#34; \u0026#34;regexp\u0026#34; ) func main() { // 檢查string是否匹配模式 matched, err := regexp.MatchString(\u0026#34;Go\u0026#34;, \u0026#34;Hello, Go!\u0026#34;) if err != nil { fmt.Println(err) } fmt.Println(\u0026#34;Matched:\u0026#34;, matched) // true } 提取功能 regexp.FindString：找到第一個匹配的subString。 regexp.FindAllString：找到所有匹配的subString。 語法如下：\n// 找到第一個匹配的subString。 func (re *Regexp) FindString(s string) string // 找到所有匹配的subString。 func (re *Regexp) FindAllString(s string, n int) []string package main import ( \u0026#34;fmt\u0026#34; \u0026#34;regexp\u0026#34; ) func main() { re, err := regexp.Compile(\u0026#34;Go\u0026#34;) if err != nil { fmt.Println(err) } // 找到第一個匹配的subString firstMatch := re.FindString(\u0026#34;Hello, Go! Go is awesome!\u0026#34;) fmt.Println(\u0026#34;First Match:\u0026#34;, firstMatch) // \u0026#34;Go\u0026#34; // 找到所有匹配的subString allMatches := re.FindAllString(\u0026#34;Hello, Go! Go is awesome!\u0026#34;, -1) fmt.Println(\u0026#34;All Matches:\u0026#34;, allMatches) // [\u0026#34;Go\u0026#34; \u0026#34;Go\u0026#34;] } 替換功能 regexp.ReplaceAllString：替換匹配的subString。 語法如下：\n// 替換匹配的subString。 func (re *Regexp) ReplaceAllString(src, repl string) string package main import ( \u0026#34;fmt\u0026#34; \u0026#34;regexp\u0026#34; ) func main() { re, err := regexp.Compile(\u0026#34;Go\u0026#34;) if err != nil { fmt.Println(err) } // 替換匹配的subString replaced := re.ReplaceAllString(\u0026#34;Hello, Go! Go is awesome!\u0026#34;, \u0026#34;Golang\u0026#34;) fmt.Println(replaced) // \u0026#34;Hello, Golang! Golang is awesome!\u0026#34; } 其他功能 regexp.Split：按照正則表達式分割string。 語法如下：\n// 按照正則表達式分割string。 func (re *Regexp) Split(s string, n int) []string package main import ( \u0026#34;fmt\u0026#34; \u0026#34;regexp\u0026#34; ) func main() { re, err := regexp.Compile(\u0026#34; \u0026#34;) if err != nil { fmt.Println(err) } // 按照正則表達式分割string parts := re.Split(\u0026#34;Hello, Go! Go is awesome!\u0026#34;, -1) fmt.Println(parts) // [\u0026#34;Hello,\u0026#34;, \u0026#34;Go!\u0026#34;, \u0026#34;Go\u0026#34;, \u0026#34;is\u0026#34;, \u0026#34;awesome!\u0026#34;] } 📚Reference regexp package - regexp - Go Packages Regular Expression :: Go 的 Regexp 實例 (openhome.cc) ","permalink":"https://sz9751210.github.io/posts/go-regexp/","summary":"👨‍💻 簡介 在處理string時，正則表達式是一個非常有用的工具。Go語言的regexp package 可以使用正則表達式，用來執行如檢查string是否匹配某個模式、提取匹配的subString等操作。\n匹配功能 regexp.MatchString：檢查一個string是否匹配某個模式。 regexp.Compile：編譯一個正則表達式。 語法如下：\n// 檢查一個string是否匹配某個模式。 func regexp.MatchString(pattern string, s string) (matched bool, err error) // 編譯一個正則表達式。 func regexp.Compile(expr string) (*Regexp, error) package main import ( \u0026#34;fmt\u0026#34; \u0026#34;regexp\u0026#34; ) func main() { // 檢查string是否匹配模式 matched, err := regexp.MatchString(\u0026#34;Go\u0026#34;, \u0026#34;Hello, Go!\u0026#34;) if err != nil { fmt.Println(err) } fmt.Println(\u0026#34;Matched:\u0026#34;, matched) // true } 提取功能 regexp.FindString：找到第一個匹配的subString。 regexp.FindAllString：找到所有匹配的subString。 語法如下：\n// 找到第一個匹配的subString。 func (re *Regexp) FindString(s string) string // 找到所有匹配的subString。 func (re *Regexp) FindAllString(s string, n int) []string package main import ( \u0026#34;fmt\u0026#34; \u0026#34;regexp\u0026#34; ) func main() { re, err := regexp.","title":"如何在Go中使用正則表達式"},{"content":"👨‍💻 簡介 一開始介紹基本資料型別時有稍微提到一點string的處理，今天介紹string的一些操作，像是檢查的功能、修改的功能、比較的功能等等。\n檢查功能 strings.Contains：檢查一個string是否包含另一個string。 strings.ContainsAny：檢查一個string是否包含任何指定的Unicode字元。 strings.Count：計算subString在目標string中出現的次數。 strings.ContainsRune：檢查一個string是否包含指定的Unicode字元。 語法如下：\n// 檢查一個string是否包含另一個string。 func strings.Contains(s, substr string) bool // 檢查一個string是否包含任何指定的Unicode字元。 func strings.ContainsAny(s, chars string) bool // 計算subString在目標string中出現的次數。 func strings.Count(s, substr string) int // 檢查一個string是否包含指定的Unicode字元。 func strings.ContainsRune(s string, r rune) bool package main import ( \u0026#34;fmt\u0026#34; \u0026#34;strings\u0026#34; ) func main() { text := \u0026#34;Hello, world! Hello, universe!\u0026#34; // 檢查string是否包含另一個string containsHello := strings.Contains(text, \u0026#34;Hello\u0026#34;) fmt.Println(\u0026#34;Contains \u0026#39;Hello\u0026#39;:\u0026#34;, containsHello) // true // 檢查string是否包含指定的Unicode字元 containsAny := strings.ContainsAny(text, \u0026#34;aeiou\u0026#34;) fmt.Println(\u0026#34;Contains any vowel:\u0026#34;, containsAny) // true // 計算subString在目標string中出現的次數 countHello := strings.Count(text, \u0026#34;Hello\u0026#34;) fmt.Println(\u0026#34;Count \u0026#39;Hello\u0026#39;:\u0026#34;, countHello) // 2 // 檢查string是否包含指定的Unicode字元 containsRune := strings.ContainsRune(text, \u0026#39;H\u0026#39;) fmt.Println(\u0026#34;Contains \u0026#39;H\u0026#39;:\u0026#34;, containsRune) // true } 修改功能 strings.Join：將多個string連接成一個新的string，並使用指定的分隔符分隔它們。 strings.Repeat：將一個string重複多次。 strings.Replace：替換string中的特定subString。 strings.ReplaceAll：替換string中的所有匹配subString。 strings.ToLower：將string轉換為小寫。 strings.ToUpper：將string轉換為大寫。 strings.Title：將string中的每個單字的首字母轉換為大寫。 strings.Trim：刪除string開頭和結尾的指定字符集合。 strings.TrimSpace：刪除string開頭和結尾的空格字符。 strings.TrimPrefix：刪除string開頭的指定前綴。 strings.TrimSuffix：刪除string結尾的指定後綴。 strings.TrimLeft：刪除string開頭的指定字符集合。 strings.TrimRight：刪除string結尾的指定字符集合。 strings.TrimFunc：使用自定義函數刪除string開頭和結尾的字符。 語法如下：\n// 將多個string連接成一個新的string，並使用指定的分隔符分隔它們。 func strings.Join(strs []string, sep string) string // 將一個string重複多次。 func strings.Repeat(s string, count int) string // 替換string中的特定subString。 func strings.Replace(s, old, new string, n int) string // 替換string中的所有匹配subString。 func strings.ReplaceAll(s, old, new string) string // 將string轉換為小寫。 func strings.ToLower(s string) string // 將string轉換為大寫。 func strings.ToUpper(s string) string // 將string中的每個單字的首字母轉換為大寫。 func strings.Title(s string) string // 刪除string開頭和結尾的指定字符集合。 func strings.Trim(s string, cutset string) string // 刪除string開頭和結尾的空格字符。 func strings.TrimSpace(s string) string // 刪除string開頭的指定前綴。 func strings.TrimPrefix(s, prefix string) string // 刪除string結尾的指定後綴。 func strings.TrimSuffix(s, suffix string) string // 刪除string開頭的指定字符集合。 func strings.TrimLeft(s string, cutset string) string // 刪除string結尾的指定字符集合。 func strings.TrimRight(s string, cutset string) string // 使用自定義函數刪除string開頭和結尾的字符。 func strings.TrimFunc(s string, f func(rune) bool) string package main import ( \u0026#34;fmt\u0026#34; \u0026#34;strings\u0026#34; ) func main() { // string連接 words := []string{\u0026#34;apple\u0026#34;, \u0026#34;banana\u0026#34;, \u0026#34;cherry\u0026#34;} joined := strings.Join(words, \u0026#34;, \u0026#34;) fmt.Println(joined) // \u0026#34;apple, banana, cherry\u0026#34; // string重複 text := \u0026#34;Go\u0026#34; repeated := strings.Repeat(text, 3) fmt.Println(repeated) // \u0026#34;GoGoGo\u0026#34; // string替換 text = \u0026#34;Hello, world! Hello, universe!\u0026#34; // 替換第一個匹配 replaced := strings.Replace(text, \u0026#34;Hello\u0026#34;, \u0026#34;Hi\u0026#34;, 1) fmt.Println(replaced) // \u0026#34;Hi, world! Hello, universe!\u0026#34; // 替換所有匹配 replacedAll := strings.ReplaceAll(text, \u0026#34;Hello\u0026#34;, \u0026#34;Hi\u0026#34;) fmt.Println(replacedAll) // \u0026#34;Hi, world! Hi, universe!\u0026#34; // string大小寫轉換 text = \u0026#34;Hello, World!\u0026#34; lowerCase := strings.ToLower(text) upperCase := strings.ToUpper(text) fmt.Println(lowerCase) // \u0026#34;hello, world!\u0026#34; fmt.Println(upperCase) // \u0026#34;HELLO, WORLD!\u0026#34; // string前綴和後綴刪除 text = \u0026#34; Go is awesome! \u0026#34; // 刪除string開頭和結尾的空格 trimmedText := strings.Trim(text, \u0026#34; \u0026#34;) fmt.Printf(\u0026#34;[%s]\\n\u0026#34;, trimmedText) // \u0026#34;[Go is awesome!]\u0026#34; // 刪除string開頭的空格 trimmedLeftText := strings.TrimLeft(text, \u0026#34; \u0026#34;) fmt.Printf(\u0026#34;[%s]\\n\u0026#34;, trimmedLeftText) // \u0026#34;[Go is awesome! ]\u0026#34; // 刪除string結尾的空格 trimmedRightText := strings.TrimRight(text, \u0026#34; \u0026#34;) fmt.Printf(\u0026#34;[%s]\\n\u0026#34;, trimmedRightText) // \u0026#34;[ Go is awesome!]\u0026#34; // string前綴和後綴替換 prefixedText := \u0026#34;prefix: Hello, World!\u0026#34; trimmedPrefixText := strings.TrimPrefix(prefixedText, \u0026#34;prefix: \u0026#34;) fmt.Println(trimmedPrefixText) // \u0026#34;Hello, World!\u0026#34; suffixedText := \u0026#34;Hello, World! -suffix\u0026#34; trimmedSuffixText := strings.TrimSuffix(suffixedText, \u0026#34; -suffix\u0026#34;) fmt.Println(trimmedSuffixText) // \u0026#34;Hello, World!\u0026#34; // 使用自定義函數刪除string trimFuncText := \u0026#34;###TrimMe###\u0026#34; trimmedFuncText := strings.TrimFunc(trimFuncText, func(r rune) bool { return r == \u0026#39;#\u0026#39; }) fmt.Println(trimmedFuncText) // \u0026#34;TrimMe\u0026#34; } 比較功能 strings.Compare：比較兩個string是否相等，不過直接使用==或是!=更直覺。 語法如下：\n// 比較兩個string，返回比較結果的整數值。 func strings.Compare(a, b string) int package main import ( \u0026#34;fmt\u0026#34; \u0026#34;strings\u0026#34; ) func main() { str1 := \u0026#34;apple\u0026#34; str2 := \u0026#34;banana\u0026#34; // 使用 strings.Compare 比較string result := strings.Compare(str1, str2) switch { case result \u0026lt; 0: fmt.Printf(\u0026#34;%s 小於 %s\\n\u0026#34;, str1, str2) case result \u0026gt; 0: fmt.Printf(\u0026#34;%s 大於 %s\\n\u0026#34;, str1, str2) default: fmt.Printf(\u0026#34;%s 等於 %s\\n\u0026#34;, str1, str2) } } 切割功能 strings.Split：將string按照指定的分隔符分割成subString。 strings.SplitAfter：在指定的分隔符之後切割string。 語法如下：\n// 將string按照指定的分隔符分割成subString。 func strings.Split(s, sep string) []string // 在指定的分隔符之後切割string。 func strings.SplitAfter(s, sep string) []string package main import ( \u0026#34;fmt\u0026#34; \u0026#34;strings\u0026#34; ) func main() { // 使用 strings.Split 函數按照逗號分割string s1 := \u0026#34;apple,banana,cherry\u0026#34; words1 := strings.Split(s1, \u0026#34;,\u0026#34;) fmt.Printf(\u0026#34;使用 Split 函數分割的結果：%v\\n\u0026#34;, words1) // 使用 strings.SplitAfter 函數在逗號之後分割string s2 := \u0026#34;apple,banana,cherry\u0026#34; words2 := strings.SplitAfter(s2, \u0026#34;,\u0026#34;) fmt.Printf(\u0026#34;使用 SplitAfter 函數分割的結果：%v\\n\u0026#34;, words2) } 其他功能 strings.Index：找到一個subString在目標string中的第一次出現的索引位置。 strings.LastIndex：找到一個subString在目標string中的最後一次出現的索引位置。 strings.Fields：將string拆分為slice的subString，使用空格作為分隔符。 語法如下：\n// 找到一個subString在目標string中的第一次出現的索引位置。 func strings.Index(s, substr string) int // 找到一個subString在目標string中的最後一次出現的索引位置。 func strings.LastIndex(s, substr string) int // 將string拆分為slice的subString，使用空格作為分隔符。 func strings.Fields(s string) []string package main import ( \u0026#34;fmt\u0026#34; \u0026#34;strings\u0026#34; ) func main() { s := \u0026#34;Hello, world! Welcome to the world of Go. Hello, Go world.\u0026#34; // 找到一個subString在目標string中的第一次出現的索引位置。 substr := \u0026#34;world\u0026#34; index := strings.Index(s, substr) if index != -1 { fmt.Printf(\u0026#34;\u0026#39;%s\u0026#39; 第一次出現的索引位置：%d\\n\u0026#34;, substr, index) } else { fmt.Printf(\u0026#34;\u0026#39;%s\u0026#39; 未在string中找到\\n\u0026#34;, substr) } // 找到一個subString在目標string中的最後一次出現的索引位置。 lastIndex := strings.LastIndex(s, substr) if lastIndex != -1 { fmt.Printf(\u0026#34;\u0026#39;%s\u0026#39; 最後一次出現的索引位置：%d\\n\u0026#34;, substr, lastIndex) } else { fmt.Printf(\u0026#34;\u0026#39;%s\u0026#39; 未在string中找到\\n\u0026#34;, substr) } // 將string拆分為slice的subString，使用空格作為分隔符。 text := \u0026#34;This is a sample sentence.\u0026#34; fields := strings.Fields(text) fmt.Println(\u0026#34;拆分後的subString slice：\u0026#34;) for _, field := range fields { fmt.Println(field) } } 📚Reference strings package - strings - Go Packages strings — 字符串操作 · Go语言标准库 (studygolang.com) [pkg] strings | PJCHENder 未整理筆記 ","permalink":"https://sz9751210.github.io/posts/go-strings/","summary":"👨‍💻 簡介 一開始介紹基本資料型別時有稍微提到一點string的處理，今天介紹string的一些操作，像是檢查的功能、修改的功能、比較的功能等等。\n檢查功能 strings.Contains：檢查一個string是否包含另一個string。 strings.ContainsAny：檢查一個string是否包含任何指定的Unicode字元。 strings.Count：計算subString在目標string中出現的次數。 strings.ContainsRune：檢查一個string是否包含指定的Unicode字元。 語法如下：\n// 檢查一個string是否包含另一個string。 func strings.Contains(s, substr string) bool // 檢查一個string是否包含任何指定的Unicode字元。 func strings.ContainsAny(s, chars string) bool // 計算subString在目標string中出現的次數。 func strings.Count(s, substr string) int // 檢查一個string是否包含指定的Unicode字元。 func strings.ContainsRune(s string, r rune) bool package main import ( \u0026#34;fmt\u0026#34; \u0026#34;strings\u0026#34; ) func main() { text := \u0026#34;Hello, world! Hello, universe!\u0026#34; // 檢查string是否包含另一個string containsHello := strings.Contains(text, \u0026#34;Hello\u0026#34;) fmt.Println(\u0026#34;Contains \u0026#39;Hello\u0026#39;:\u0026#34;, containsHello) // true // 檢查string是否包含指定的Unicode字元 containsAny := strings.ContainsAny(text, \u0026#34;aeiou\u0026#34;) fmt.","title":"如何在 Go 中處理 String"},{"content":"👨‍💻 簡介 昨天講到 os package，今天繼續補充 os package底下的 exec package，這個package主要用來執行外部指令和處理指令的輸入和輸出，包括如何設定指令、執行指令以及處理輸出等等。\n設定指令 要執行外部指令，首先需要設定要執行的主要指令：\nexec.Command：接受一個指令名稱和多個參數，並返回一個 Cmd 對象。 語法如下：\nfunc exec.Command(name string, arg ...string) *exec.Cmd 第一個參數是放要執行的命令名稱，第二個則是放參數。 接著來看看exec.Cmd是甚麼東西：\ntype Cmd struct { Path string // the path of the command to run Args []string // holds command line arguments Env []string // the environment of the process Dir string // the working directory of the command. Stdin io.Reader // the process\u0026#39;s standard input. Stdout io.Writer // the process\u0026#39;s standard output and error. Stderr io.Writer .... } 可以看到exec.Command會回傳一個Cmd的struct。\n以下是一個設定指令的簡單範例：\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;os/exec\u0026#34; ) func main() { cmd := exec.Command(\u0026#34;ls\u0026#34;, \u0026#34;-al\u0026#34;) err := cmd.Run() if err != nil { fmt.Printf(\u0026#34;failed to call cmd.Run(): %v\u0026#34;, err) } } 執行完沒有任何輸出是正常的，因為這個範例並沒有將標準輸出印出。如果要印出執行結果將cmd.Run改為cmd.Output即可：\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;os/exec\u0026#34; ) func main() { cmd := exec.Command(\u0026#34;ls\u0026#34;, \u0026#34;-al\u0026#34;) output, err := cmd.Output() if err != nil { fmt.Printf(\u0026#34;failed to call cmd.Output(): %v\u0026#34;, err) return } fmt.Println(\u0026#34;Command Output:\u0026#34;) fmt.Println(string(output)) } 接著來快速介紹Cmd struct常用的欄位：\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;os\u0026#34; \u0026#34;os/exec\u0026#34; ) func main() { cmd := exec.Command(\u0026#34;ls\u0026#34;, \u0026#34;-l\u0026#34;) // 設定執行位置 cmd.Dir = \u0026#34;/\u0026#34; // 將標準輸出和標準錯誤輸出到終端機 cmd.Stdout = os.Stdout cmd.Stderr = os.Stderr // 執行並等待其完成 err := cmd.Run() if err != nil { fmt.Println(err) return } } 執行指令 cmd.Run：執行指令並會等待指令完成，是cmd.Start和cmd.Wait的結合。 cmd.Start：執行指令但不會等待指令完成。 cmd.Wait：等待已經執行的指令，會阻塞程式，職到指令執行完畢。 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;os\u0026#34; \u0026#34;os/exec\u0026#34; ) func main() { cmd := exec.Command(\u0026#34;ls\u0026#34;, \u0026#34;-l\u0026#34;) // 執行指令 err := cmd.Start() if err != nil { fmt.Println(err) return } // 等待指令完成 err = cmd.Wait() if err != nil { log.Fatal(err) } } 處理輸出 cmd.Output：取得執行的標準輸出。 cmd.CombinedOutput：取得執行的標準輸出和標準錯誤的合併結果。 取得標準輸出 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;os/exec\u0026#34; ) func main() { cmd := exec.Command(\u0026#34;echo\u0026#34;, \u0026#34;Hello, World!\u0026#34;) // 取得執行的標準輸出 output, err := cmd.Output() if err != nil { fmt.Println(\u0026#34;failed to call cmd.Output(): %v\u0026#34;, err) return } fmt.Println(\u0026#34;Command Output:\u0026#34;) fmt.Println(string(output)) } 取得標準輸出和標準錯誤的合併結果 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;os/exec\u0026#34; ) func main() { cmd := exec.Command(\u0026#34;ls\u0026#34;, \u0026#34;non-existent-directory\u0026#34;) // 取得執行的標準輸出和標準錯誤的合併結果 output, err := cmd.CombinedOutput() if err != nil { fmt.Println(\u0026#34;Error:\u0026#34;, err) return } fmt.Println(\u0026#34;Command Output:\u0026#34;) fmt.Println(string(output)) } 輸出的多種方式 因為cmd 的struct包含以下三個欄位，分別代表執行的標準輸入，標準輸出以及標準錯誤輸出，而io.Reader以及io.Writer皆為interface，因此只要滿足interface method的struct，即可完成讀取跟寫入\ntype Cmd struct { Stdin io.Reader // the process\u0026#39;s standard input. Stdout io.Writer // the process\u0026#39;s standard output and error. Stderr io.Writer .... } 寫入檔案 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;os\u0026#34; \u0026#34;os/exec\u0026#34; ) func main() { // 建立一個檔案，用於存儲標準輸出 outFile, err := os.Create(\u0026#34;output.txt\u0026#34;) if err != nil { fmt.Println(err) return } defer outFile.Close() // 建立一個檔案，用於存儲標準錯誤 errFile, err := os.Create(\u0026#34;error.txt\u0026#34;) if err != nil { fmt.Println(err) return } defer errFile.Close() // 設定執行指令，將標準輸出和標準錯誤重定向到檔案 cmd := exec.Command(\u0026#34;ls\u0026#34;, \u0026#34;-l\u0026#34;) cmd.Stdout = outFile cmd.Stderr = errFile // 執行並等待其完成 err = cmd.Run() if err != nil { fmt.Println(err) return } } 寫到終端 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;os\u0026#34; \u0026#34;os/exec\u0026#34; ) func main() { cmd := exec.Command(\u0026#34;ls\u0026#34;, \u0026#34;-l\u0026#34;) // 將標準輸出和標準錯誤輸出到終端機 cmd.Stdout = os.Stdout cmd.Stderr = os.Stderr // 執行指令 err := cmd.Start() if err != nil { fmt.Println(err) return } // 等待指令完成 err = cmd.Wait() if err != nil { log.Fatal(err) } } 因os.Create、os.Stdout和os.Stderr都會返回一個File struct，而該struct有滿足io.Writer的method -\u0026gt; Write，因此可以將標準輸出以及標準錯誤輸出給寫入檔案或是終端裡。\n處理輸入 透過wc指令讀取main.go檔案，並計算總共多少行。\npackage main import ( \u0026#34;log\u0026#34; \u0026#34;os\u0026#34; \u0026#34;os/exec\u0026#34; ) func main() { stdin, err := os.Open(\u0026#34;main.go\u0026#34;) if err != nil { log.Fatalf(\u0026#34;failed to open file: %v\u0026#34;, err) } cmd := exec.Command(\u0026#34;wc\u0026#34;, \u0026#34;-l\u0026#34;) cmd.Stdin = stdin cmd.Stdout = os.Stdout cmd.Stderr = os.Stderr err = cmd.Run() if err != nil { log.Fatalf(\u0026#34;failed to call cmd.Run(): %v\u0026#34;, err) } } Pipeline操作 cmd.StderrPipe：返回一個連接到執行的標準錯誤的pipeline。 cmd.StdinPipe：返回一個連接到執行的標準輸入的pipeline。 cmd.StdoutPipe：返回一個連接到執行的標準輸出的pipeline。 package main import ( \u0026#34;log\u0026#34; \u0026#34;os\u0026#34; \u0026#34;os/exec\u0026#34; ) func main() { cmdCat := exec.Command(\u0026#34;cat\u0026#34;, \u0026#34;main.go\u0026#34;) cmdWC := exec.Command(\u0026#34;wc\u0026#34;, \u0026#34;-l\u0026#34;) // 建立一個pipeline，將 cat main.go 的輸出內容存放到 catout catout, err := cmdCat.StdoutPipe() if err != nil { log.Fatalf(\u0026#34;failed to get StdoutPipe of cat: %v\u0026#34;, err) } cmdWC.Stdin = catout // 將 catout 當作 wc -l 的輸入 cmdWC.Stdout = os.Stdout // 將 wc -l 的結果印到終端機上 err = cmdCat.Start() if err != nil { log.Fatalf(\u0026#34;failed to call cmdCat.Start():%v\u0026#34;, err) } err = cmdWC.Start() if err != nil { log.Fatalf(\u0026#34;failed to call cmdWC.Start():%v\u0026#34;, err) } cmdCat.Wait() cmdWC.Wait() } 通用pipeline方法 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;os/exec\u0026#34; ) func main() { cmdCat := exec.Command(\u0026#34;cat\u0026#34;, \u0026#34;main.go\u0026#34;) cmdWC := exec.Command(\u0026#34;wc\u0026#34;, \u0026#34;-l\u0026#34;) data, err := pipeCommands(cmdCat, cmdWC) if err != nil { fmt.Printf(\u0026#34;failed to call pipeCommands(): %v\u0026#34;, err) } fmt.Printf(\u0026#34;output: %s\u0026#34;, data) } func pipeCommands(commands ...*exec.Cmd) ([]byte, error) { for i, command := range commands[:len(commands)-1] { out, err := command.StdoutPipe() if err != nil { return nil, err } command.Start() commands[i+1].Stdin = out } final, err := commands[len(commands)-1].Output() if err != nil { return nil, err } return final, nil } bash pipeline cmd := exec.Command(\u0026#34;bash\u0026#34;, \u0026#34;-c\u0026#34;, \u0026#34;cat main.go| wc -l\u0026#34;) data, err := cmd.CombinedOutput() if err != nil { log.Fatalf(\u0026#34;failed to call pipeCommands(): %v\u0026#34;, err) } log.Printf(\u0026#34;output: %s\u0026#34;, data) 📚 參考資料 os/exec package - exec - Go packages Go os.exec 執行外部指令 - Gary Liao - Medium go os/exec 简明教程 (colobu.com) ","permalink":"https://sz9751210.github.io/posts/go-os-exec/","summary":"👨‍💻 簡介 昨天講到 os package，今天繼續補充 os package底下的 exec package，這個package主要用來執行外部指令和處理指令的輸入和輸出，包括如何設定指令、執行指令以及處理輸出等等。\n設定指令 要執行外部指令，首先需要設定要執行的主要指令：\nexec.Command：接受一個指令名稱和多個參數，並返回一個 Cmd 對象。 語法如下：\nfunc exec.Command(name string, arg ...string) *exec.Cmd 第一個參數是放要執行的命令名稱，第二個則是放參數。 接著來看看exec.Cmd是甚麼東西：\ntype Cmd struct { Path string // the path of the command to run Args []string // holds command line arguments Env []string // the environment of the process Dir string // the working directory of the command. Stdin io.Reader // the process\u0026#39;s standard input. Stdout io.Writer // the process\u0026#39;s standard output and error.","title":"如何在 Go 中操作系統"},{"content":"👨‍💻 簡介 今天快速介紹一下對檔案的操作所使用的package os，包括檔案和資料夾操作等。\n檔案和資料夾操作 os package 可以執行各種檔案和資料夾操作，如建立、讀取、寫入、刪除檔案，以及取得資料夾內容等。\n建立相關操作 os.Create：建立一個新檔案。 os.Mkdir：建立一個新資料夾。 os.MkdirAll：建立資料夾，包括必要的父層資料夾。 語法如下：\nfunc os.Create(name string) (*os.File, error) func os.Mkdir(name string, perm fs.FileMode) error func os.MkdirAll(path string, perm fs.FileMode) error package main import ( \u0026#34;fmt\u0026#34; \u0026#34;os\u0026#34; \u0026#34;io\u0026#34; ) func main() { // 建立資料夾，指定權限為755 err := os.Mkdir(\u0026#34;mydir\u0026#34;, 0755) if err != nil { fmt.Println(\u0026#34;Error creating directory:\u0026#34;, err) } else { fmt.Println(\u0026#34;Directory created successfully.\u0026#34;) } // 建立一個新檔案並寫入內容 file, err := os.Create(\u0026#34;example.txt\u0026#34;) if err != nil { fmt.Println(err) return } defer file.Close() file.WriteString(\u0026#34;Hello, World!\u0026#34;) } 讀寫相關操作 os.Open：打開一個檔案進行讀取操作。 os.OpenFile：打開一個檔案，可以指定更多的選項，如讀寫模式和權限。 os.Getwd：取得當前路徑 os.Stat：取得檔案或資料夾訊息。 os.IsNotExist：檢查檔案或資料夾是否存在。 os.Rename：重命名檔案或資料夾 語法如下：\nfunc os.Open(name string) (*os.File, error) func OpenFile(name string, flag int, perm FileMode) (*File, error) func os.Getwd() (dir string, err error) func os.Stat(name string) (fs.FileInfo, error) func os.IsNotExist(err error) bool OpenFile的細項介紹：\n第一個參數為檔名，第二個為要對檔案使用的選項，第三個則為檔案權限的設定。\n常見的選項有以下幾種：\nO_RDONLY：以只讀模式打開檔案，不允許寫入。 O_WRONLY：以只寫模式打開檔案，不允許讀取。 O_APPEND：以附加模式打開檔案，新內容將附加到檔案末尾。 O_TRUNC：如果檔案存在，則清空檔案內容。 O_EXCL：與 O_CREATE 一起使用時，只有在檔案不存在時才建立檔案，用於防止檔案競爭。 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;os\u0026#34; ) func main() { // 打開檔案並讀取內容 readFile, err := os.Open(\u0026#34;example.txt\u0026#34;) if err != nil { fmt.Println(err) return } defer readFile.Close() // 打開一個檔案以進行讀寫操作 file, err := os.OpenFile(\u0026#34;example.txt\u0026#34;, os.O_RDWR|os.O_CREATE, 0755) if err != nil { fmt.Println(\u0026#34;Error opening file:\u0026#34;, err) return } defer file.Close() // 取得當前工作資料夾 wd, err := os.Getwd() if err != nil { fmt.Println(\u0026#34;Error:\u0026#34;, err) return } fmt.Println(\u0026#34;Current Working Directory:\u0026#34;, wd) } 這邊另外介紹一下Stat，\nStat會回傳一個FileInfo的interface\ntype FileInfo interface { Name() string // base name of the file Size() int64 // length in bytes for regular files; system-dependent for others Mode() FileMode // file mode bits ModTime() time.Time // modification time IsDir() bool // abbreviation for Mode().IsDir() Sys() any // underlying data source (can return nil) } package main import ( \u0026#34;fmt\u0026#34; \u0026#34;os\u0026#34; ) func main() { fileInfo, err := os.Stat(\u0026#34;example.txt\u0026#34;) if err == nil { fmt.Println(\u0026#34;File exists.\u0026#34;) } else if os.IsNotExist(err) { fmt.Println(\u0026#34;File does not exist.\u0026#34;) } else { fmt.Println(\u0026#34;Error:\u0026#34;, err) } // 取得檔案資訊 fmt.Println(fileInfo.Name()) fmt.Println(fileInfo.IsDir()) fmt.Println(fileInfo.Size()) fmt.Println(fileInfo.ModTime()) fmt.Println(fileInfo.Mode()) } 要寫入檔案則需要先取得os.File物件，可透過Openfile取得。 先來看一下WriteString語法\nfunc (*os.File).WriteString(s string) (n int, err error) 其中s為要寫入的內容，n為寫入的字節數\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;os\u0026#34; ) func main() { // 打開一個檔案以進行寫入操作 file, err := os.OpenFile(\u0026#34;example.txt\u0026#34;, os.O_WRONLY|os.O_CREATE|os.O_APPEND, 0644) if err != nil { fmt.Println(\u0026#34;Error opening file:\u0026#34;, err) return } defer file.Close() // 寫入內容到檔案 _, err = file.WriteString(\u0026#34;Hello, Appended Content!\u0026#34;) if err != nil { fmt.Println(\u0026#34;Error writing to file:\u0026#34;, err) return } fmt.Println(\u0026#34;File opened and written in append mode successfully.\u0026#34;) } 最後介紹一下Rename，語法如下：\nfunc os.Rename(oldpath string, newpath string) error package main import ( \u0026#34;fmt\u0026#34; \u0026#34;os\u0026#34; ) func main() { // 重命名檔案 err := os.Rename(\u0026#34;oldfile.txt\u0026#34;, \u0026#34;newfile.txt\u0026#34;) if err != nil { fmt.Println(\u0026#34;Error:\u0026#34;, err) return } // 重命名資料夾 err = os.Rename(\u0026#34;olddir\u0026#34;, \u0026#34;newdir\u0026#34;) if err != nil { fmt.Println(\u0026#34;Error:\u0026#34;, err) return } } 刪除相關操作 os.Remove：刪除檔案和資料夾，如果資料夾不為空會報錯。 os.RemoveAll：刪除檔案和資料夾。 兩種使用方法都很類似，語法為\nfunc os.Remove(name string) error func os.RemoveAll(path string) error package main import ( \u0026#34;fmt\u0026#34; \u0026#34;os\u0026#34; ) func main() { file, err := os.Create(\u0026#34;example.txt\u0026#34;) if err != nil { fmt.Println(err) return } defer file.Close() err := os.Remove(\u0026#34;example.txt\u0026#34;) if err != nil { fmt.Println(\u0026#34;Error deleting file:\u0026#34;, err) } else { fmt.Println(\u0026#34;File deleted successfully.\u0026#34;) } testDir := \u0026#34;d1/d2/d3\u0026#34; // Create Recursive dir err := os.MkdirAll(testDir, os.ModePerm) if err != nil { fmt.Println(\u0026#34;Error creating directory:\u0026#34;, err) } // 使用 os.RemoveAll() 刪除資料夾 err = os.RemoveAll(\u0026#34;d1\u0026#34;) // err = os.Remove(\u0026#34;d1\u0026#34;) // 因資料夾不為空，因此會噴directory not empty錯誤 if err != nil { fmt.Println(\u0026#34;Error deleting directory:\u0026#34;, err) } else { fmt.Println(\u0026#34;Directory deleted successfully.\u0026#34;) } } 📚 參考資料 os package - os - Go packages Go Standard Library - os Go file - working with files in Golang (zetcode.com) ","permalink":"https://sz9751210.github.io/posts/go-os-file/","summary":"👨‍💻 簡介 今天快速介紹一下對檔案的操作所使用的package os，包括檔案和資料夾操作等。\n檔案和資料夾操作 os package 可以執行各種檔案和資料夾操作，如建立、讀取、寫入、刪除檔案，以及取得資料夾內容等。\n建立相關操作 os.Create：建立一個新檔案。 os.Mkdir：建立一個新資料夾。 os.MkdirAll：建立資料夾，包括必要的父層資料夾。 語法如下：\nfunc os.Create(name string) (*os.File, error) func os.Mkdir(name string, perm fs.FileMode) error func os.MkdirAll(path string, perm fs.FileMode) error package main import ( \u0026#34;fmt\u0026#34; \u0026#34;os\u0026#34; \u0026#34;io\u0026#34; ) func main() { // 建立資料夾，指定權限為755 err := os.Mkdir(\u0026#34;mydir\u0026#34;, 0755) if err != nil { fmt.Println(\u0026#34;Error creating directory:\u0026#34;, err) } else { fmt.Println(\u0026#34;Directory created successfully.\u0026#34;) } // 建立一個新檔案並寫入內容 file, err := os.Create(\u0026#34;example.txt\u0026#34;) if err !","title":"如何在 Go 中操作檔案"},{"content":"👨‍💻 簡介 今天的encoding/json package是我日常在開發web時很常用到的package之一，主要是用來將Go struct和 JSON 之間進行轉換。主要功能為資料序列化（marshalling）和反序列化（unmarshalling）。\n主要功能 encoding/json package 主要用來將 Go struct轉換為 JSON 格式（marshalling）以及將 JSON 資料轉換為 Go struct（unmarshalling）。以下是一些主要功能：\n將 Go struct轉換為 JSON 使用 json.Marshal 函數可以將 Go struct轉換為 JSON 格式的資料。\npackage main import ( \u0026#34;encoding/json\u0026#34; \u0026#34;fmt\u0026#34; ) type Person struct { Name string `json:\u0026#34;name\u0026#34;` Age int `json:\u0026#34;age\u0026#34;` } func main() { person := Person{Name: \u0026#34;Alan\u0026#34;, Age: 25} jsonData, err := json.Marshal(person) if err != nil { fmt.Println(\u0026#34;JSON 編碼失敗:\u0026#34;, err) return } fmt.Println(string(jsonData)) // 輸出: {\u0026#34;name\u0026#34;:\u0026#34;Alan\u0026#34;,\u0026#34;age\u0026#34;:25} } 在上面的範例中，我們先定義了一個 Person struct，然後使用 json.Marshal 函數將 Person 轉換為 JSON 資料。\n將 JSON 資料轉換為 Go struct 使用 json.Unmarshal 函數可以將 JSON 資料轉換為 Go struct。\npackage main import ( \u0026#34;encoding/json\u0026#34; \u0026#34;fmt\u0026#34; ) type Person struct { Name string `json:\u0026#34;name\u0026#34;` Age int `json:\u0026#34;age\u0026#34;` } func main() { jsonData := []byte(`{\u0026#34;name\u0026#34;:\u0026#34;Bob\u0026#34;,\u0026#34;age\u0026#34;:30}`) var person Person err := json.Unmarshal(jsonData, \u0026amp;person) if err != nil { fmt.Println(\u0026#34;JSON 解碼失敗:\u0026#34;, err) return } fmt.Println(\u0026#34;姓名:\u0026#34;, person.Name) fmt.Println(\u0026#34;年齡:\u0026#34;, person.Age) // 輸出: // 姓名: Bob // 年齡: 30 } 反轉則是使用 json.Unmarshal 函數將 JSON 資料轉換為 Person 的struct。\n自定義 JSON 鍵名 當需要API顯示自定義 JSON 欄位鍵名時，可以在 Go struct的欄位上使用 json 標籤來自定義 JSON 鍵名，方便與外部 API 或其他系統的格式相同。\npackage main import ( \u0026#34;encoding/json\u0026#34; \u0026#34;fmt\u0026#34; ) type Person struct { FullName string `json:\u0026#34;full_name\u0026#34;` Age int `json:\u0026#34;age\u0026#34;` } func main() { person := Person{FullName: \u0026#34;Charlie Brown\u0026#34;, Age: 10} jsonData, err := json.Marshal(person) if err != nil { fmt.Println(\u0026#34;JSON 編碼失敗:\u0026#34;, err) return } fmt.Println(string(jsonData)) // 輸出: {\u0026#34;full_name\u0026#34;:\u0026#34;Charlie Brown\u0026#34;,\u0026#34;age\u0026#34;:10} } 在這個範例中，我們使用 json 標籤來指定 FullName 欄位在 JSON 中的名稱為 \u0026ldquo;full_name\u0026rdquo;。\n常見用法 解析複雜的 JSON 資料 encoding/json package 可以處理複雜的 JSON 資料，包括嵌套struct和陣列。\npackage main import ( \u0026#34;encoding/json\u0026#34; \u0026#34;fmt\u0026#34; ) type Address struct { City string `json:\u0026#34;city\u0026#34;` Country string `json:\u0026#34;country\u0026#34;` } type Person struct { Name string `json:\u0026#34;name\u0026#34;` Age int `json:\u0026#34;age\u0026#34;` Address Address `json:\u0026#34;address\u0026#34;` } func main() { jsonData := []byte(`{ \u0026#34;name\u0026#34;: \u0026#34;Alan\u0026#34;, \u0026#34;age\u0026#34;: 25, \u0026#34;address\u0026#34;: { \u0026#34;city\u0026#34;: \u0026#34;Taichung\u0026#34;, \u0026#34;country\u0026#34;: \u0026#34;Taiwan\u0026#34; } }`) var person Person err := json.Unmarshal(jsonData, \u0026amp;person) if err != nil { fmt.Println(\u0026#34;JSON 解碼失敗:\u0026#34;, err) return } fmt.Println(\u0026#34;姓名:\u0026#34;, person.Name) fmt.Println(\u0026#34;年齡:\u0026#34;, person.Age) fmt.Println(\u0026#34;地址:\u0026#34;, person.Address.Country，person.Address.City ) // 輸出: // 姓名: Alan // 年齡: 25 // 地址: Taiwan Taichung } 在這個範例中，我們定義了 Address 和 Person 兩個struct，其中 Person 包含一個嵌套的 Address struct。我們使用 json.Unmarshal 函數解析嵌套struct的 JSON 資料。\n處理 JSON 陣列 encoding/json package 也能夠處理 JSON 陣列。\npackage main import ( \u0026#34;encoding/json\u0026#34; \u0026#34;fmt\u0026#34; ) type Item struct { ID int `json:\u0026#34;id\u0026#34;` Name string `json:\u0026#34;name\u0026#34;` } func main() { jsonData := []byte(`[ {\u0026#34;id\u0026#34;: 1, \u0026#34;name\u0026#34;: \u0026#34;Item 1\u0026#34;}, {\u0026#34;id\u0026#34;: 2, \u0026#34;name\u0026#34;: \u0026#34;Item 2\u0026#34;}, {\u0026#34;id\u0026#34;: 3, \u0026#34;name\u0026#34;: \u0026#34;Item 3\u0026#34;} ]`) var items []Item err := json.Unmarshal(jsonData, \u0026amp;items) if err != nil { fmt.Println(\u0026#34;JSON 解碼失敗:\u0026#34;, err) return } for _, item := range items { fmt.Printf(\u0026#34;ID: %d, 名稱: %s\\n\u0026#34;, item.ID, item.Name) } // 輸出: // ID: 1, 名稱: Item 1 // ID: 2, 名稱: Item 2 // ID: 3, 名稱: Item 3 } 可以看到，我們定義了 Item struct，然後使用 json.Unmarshal 函數解析包含 JSON 陣列的 JSON 資料。\n📚 參考資料 encoding/json package - json - Go packages The Go Blog - JSON and Go ","permalink":"https://sz9751210.github.io/posts/go-json/","summary":"👨‍💻 簡介 今天的encoding/json package是我日常在開發web時很常用到的package之一，主要是用來將Go struct和 JSON 之間進行轉換。主要功能為資料序列化（marshalling）和反序列化（unmarshalling）。\n主要功能 encoding/json package 主要用來將 Go struct轉換為 JSON 格式（marshalling）以及將 JSON 資料轉換為 Go struct（unmarshalling）。以下是一些主要功能：\n將 Go struct轉換為 JSON 使用 json.Marshal 函數可以將 Go struct轉換為 JSON 格式的資料。\npackage main import ( \u0026#34;encoding/json\u0026#34; \u0026#34;fmt\u0026#34; ) type Person struct { Name string `json:\u0026#34;name\u0026#34;` Age int `json:\u0026#34;age\u0026#34;` } func main() { person := Person{Name: \u0026#34;Alan\u0026#34;, Age: 25} jsonData, err := json.Marshal(person) if err != nil { fmt.Println(\u0026#34;JSON 編碼失敗:\u0026#34;, err) return } fmt.","title":"如何在 Go 中處理 JSON"},{"content":"👨‍💻簡介 在 Go 語言中，reflect package是用來檢查和操作變數的type、value和struct。常見用法有檢察 type、調用方法，以及修改變數的value。今天簡單介紹 reflect package的主要功能、使用方法和常見用法。\n主要功能 reflect package 主要用來在運行時檢查和操作變數的type訊息。這對於需要在不確定type的情況下處理資料的情況非常有用。要使用reflect package，首先需要import它：\nimport \u0026#34;reflect\u0026#34; reflect package的主要功能包括：\nType reflect reflect 可以讓你取得變數的type訊息，方便我們在運行時進行type比較，檢查變數的type。下面是一些基本的type reflect操作：\nreflect.TypeOf：取得變數的type。 reflect.ValueOf：取得變數的value。 reflect.Zero：建立一個zero value。 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;reflect\u0026#34; ) func main() { var num int typ := reflect.TypeOf(num) val := reflect.ValueOf(num) zeroVal := reflect.Zero(typ) fmt.Printf(\u0026#34;Type: %v\\n\u0026#34;, typ) // Type: int fmt.Printf(\u0026#34;Value: %v\\n\u0026#34;, val) // Value: 0 fmt.Printf(\u0026#34;Zero Value: %v\\n\u0026#34;, zeroVal) // Zero Value: 0 } Struct reflect reflect 可以讓你取得struct欄位的訊息，訪問struct欄位的value，以及修改struct欄位的value。\nreflect.Value.Field：取得struct欄位的value。 reflect.Value.FieldByName：根據欄位名稱取得struct欄位的value。 reflect.Value.FieldByIndex：根據欄位索引取得struct欄位的value。 reflect.Value.FieldByNameFunc：使用自定義函數查找欄位。 reflect.Value.Set：設定變數的value。 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;reflect\u0026#34; ) type Person struct { Name string Age int } func main() { person := Person{Name: \u0026#34;Alan\u0026#34;, Age: 30} val := reflect.ValueOf(person) nameField := val.FieldByName(\u0026#34;Name\u0026#34;) fmt.Printf(\u0026#34;Name: %v\\n\u0026#34;, nameField) // Name: \u0026#34;Alan\u0026#34; ageField := val.FieldByName(\u0026#34;Age\u0026#34;) fmt.Printf(\u0026#34;Age: %v\\n\u0026#34;, ageField) // Age: 30 val.FieldByName(\u0026#34;Age\u0026#34;).SetInt(31) fmt.Printf(\u0026#34;Updated Age: %v\\n\u0026#34;, person.Age) // Updated Age: 31 } 方法 reflect reflect 也可以調用struct的方法。\nreflect.Value.Method：取得struct方法。 reflect.Value.MethodByName：根據方法名取得struct方法。 reflect.Value.Call：調用方法。 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;reflect\u0026#34; ) type Calculator struct{} func (c Calculator) Add(a, b int) int { return a + b } func main() { calculator := Calculator{} // 使用 reflect.ValueOf 取得計算器物件的reflect value val := reflect.ValueOf(calculator) // 使用 MethodByName 方法取得名為 \u0026#34;Add\u0026#34; 的方法的reflect value method := val.MethodByName(\u0026#34;Add\u0026#34;) // 準備方法的參數 args := []reflect.Value{reflect.ValueOf(5), reflect.ValueOf(3)} // 調用方法並取得結果，然後轉換為整數型別 result := method.Call(args)[0].Interface().(int) fmt.Printf(\u0026#34;Result: %d\\n\u0026#34;, result) // Result: 8 } 建立新的value reflect 也可以用來建立一個新的變數，並設定它的value。先建立變數的類型，然後使用 reflect.New 方法來建立，最後使用 Elem 方法取得可設定value的對象：\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;reflect\u0026#34; ) func main() { // 取得整數類型的 reflect.Type intType := reflect.TypeOf(0) // 建立一個新的整數變數 newInt := reflect.New(intType).Elem() // 設定變數的value newInt.SetInt(42) // 取得變數的value fmt.Println(\u0026#34;New Integer Value:\u0026#34;, newInt.Int()) // 42 } 修改變數的value 要使用 reflect 修改變數的value，有以下步驟：\n使用 reflect.ValueOf 函數取得變數的 reflect.Value。 使用 .Elem() 方法取得可寫的value（如果原始value是pointer或interface）。 使用 CanSet 方法確保value可寫。 使用 SetXXX 方法設定新的value，其中 XXX 是所需的資料type。 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;reflect\u0026#34; ) func main() { // 創建一個整數變數 var num int = 42 // 使用 reflect.ValueOf 取得 reflect.Value valueOfNum := reflect.ValueOf(\u0026amp;num).Elem() // 使用 Elem() 取得可寫的value if valueOfNum.CanSet() { // 使用 SetInt 設定新的整數value valueOfNum.SetInt(99) } fmt.Println(\u0026#34;Updated Value:\u0026#34;, num) // 99 } 在上面的範例中，我們首先使用 reflect.ValueOf 取得整數變數 num 的 reflect.Value，然後使用 .Elem() 方法取得可寫的value。最後，我們使用 SetInt 方法設定新的整數value。請注意，只有在可寫的value上才能使用 SetXXX 方法，使用前記得使用 CanSet 方法來確保value是可寫的。\n檢查是否有效和是否為空 reflect package 還提供了 IsValid 和 IsNil 方法，用來檢查 reflect value是否有效（不為zero value）和是否為nil pointer。這在處理 reflect value時非常有用，可以避免意外的錯誤。\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;reflect\u0026#34; ) func main() { var num int = 42 value := reflect.ValueOf(num) if value.IsValid() { fmt.Println(\u0026#34;Value is valid\u0026#34;) } var ptr *int ptrValue := reflect.ValueOf(ptr) if ptrValue.IsValid() { fmt.Println(\u0026#34;Pointer Value is valid\u0026#34;) } else if ptrValue.IsNil() { fmt.Println(\u0026#34;Pointer Value is nil\u0026#34;) } } 常見用法 檢查Interface的動態type package main import ( \u0026#34;fmt\u0026#34; \u0026#34;reflect\u0026#34; ) func main() { var x interface{} = 42 val := reflect.ValueOf(x) if val.Type() == reflect.TypeOf(0) { fmt.Printf(\u0026#34;Value is an integer: %d\\n\u0026#34;, val.Int()) } else { fmt.Printf(\u0026#34;Value is not an integer\\n\u0026#34;) } } 遍歷struct的欄位 reflect package 可以用來遍歷struct的欄位，這在某些情況下很有用，例如序列化或檢查struct的欄位屬性：\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;reflect\u0026#34; ) type Person struct { Name string Age int Address string } func main() { p := Person{\u0026#34;Alan\u0026#34;, 30, \u0026#34;123 Main St\u0026#34;} valueOfP := reflect.ValueOf(p) for i := 0; i \u0026lt; valueOfP.NumField(); i++ { field := valueOfP.Field(i) fmt.Printf(\u0026#34;Field Name: %s, Field Value: %v\\n\u0026#34;, valueOfP.Type().Field(i).Name, field.Interface()) } } 檢查方法是否存在 你可以使用reflect package 檢查struct是否實現了某個方法：\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;reflect\u0026#34; ) type Person struct { Name string Age int } func (p Person) SayHello() { fmt.Println(\u0026#34;Hello, my name is\u0026#34;, p.Name) } func main() { p := Person{\u0026#34;Alan\u0026#34;, 30} valueOfP := reflect.ValueOf(p) method := valueOfP.MethodByName(\u0026#34;SayHello\u0026#34;) if method.IsValid() { fmt.Println(\u0026#34;SayHello method exists\u0026#34;) } else { fmt.Println(\u0026#34;SayHello method does not exist\u0026#34;) } } 操作切片和映射 reflect package 可以用來動態操作切片和映射的元素：\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;reflect\u0026#34; ) func main() { slice := []int{1, 2, 3} mapVal := map[string]int{\u0026#34;a\u0026#34;: 1, \u0026#34;b\u0026#34;: 2} sliceValue := reflect.ValueOf(slice) mapValue := reflect.ValueOf(mapVal) // 修改切片和映射的元素 sliceValue.Index(0).SetInt(42) mapValue.SetMapIndex(reflect.ValueOf(\u0026#34;b\u0026#34;), reflect.ValueOf(99)) fmt.Println(slice) // [42 2 3] fmt.Println(mapVal) // map[a:1 b:99] } 📚參考資料 reflect package - reflect - Go packages The Laws of Reflection ","permalink":"https://sz9751210.github.io/posts/go-reflect/","summary":"👨‍💻簡介 在 Go 語言中，reflect package是用來檢查和操作變數的type、value和struct。常見用法有檢察 type、調用方法，以及修改變數的value。今天簡單介紹 reflect package的主要功能、使用方法和常見用法。\n主要功能 reflect package 主要用來在運行時檢查和操作變數的type訊息。這對於需要在不確定type的情況下處理資料的情況非常有用。要使用reflect package，首先需要import它：\nimport \u0026#34;reflect\u0026#34; reflect package的主要功能包括：\nType reflect reflect 可以讓你取得變數的type訊息，方便我們在運行時進行type比較，檢查變數的type。下面是一些基本的type reflect操作：\nreflect.TypeOf：取得變數的type。 reflect.ValueOf：取得變數的value。 reflect.Zero：建立一個zero value。 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;reflect\u0026#34; ) func main() { var num int typ := reflect.TypeOf(num) val := reflect.ValueOf(num) zeroVal := reflect.Zero(typ) fmt.Printf(\u0026#34;Type: %v\\n\u0026#34;, typ) // Type: int fmt.Printf(\u0026#34;Value: %v\\n\u0026#34;, val) // Value: 0 fmt.Printf(\u0026#34;Zero Value: %v\\n\u0026#34;, zeroVal) // Zero Value: 0 } Struct reflect reflect 可以讓你取得struct欄位的訊息，訪問struct欄位的value，以及修改struct欄位的value。","title":"Reflect：Go 語言的鏡子"},{"content":"👨‍💻簡介 要處理日期和時間，就必須知道這個Package -\u0026gt; time，Go提供了內建的timePackage。 今天主要介紹time的功能，包括時間操作、格式化等等，以及常見用法。\n主要功能 timePackage的主要功能是處理時間和日期的操作，包括時間的表示、創建、格式化和計算。在Go中，時間通常以time.Time type表示，這個type包含了日期和時間的資訊。\n導入Package import \u0026#34;time\u0026#34; 創建時間 使用time.Now()函數來獲取當前的時間。\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;time\u0026#34; ) func main() { currentTime := time.Now() fmt.Println(\u0026#34;Current Time:\u0026#34;, currentTime) } 你還可以使用time.Date()函數來創建一個特定日期和時間的time.Time 物件。\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;time\u0026#34; ) func main() { specificTime := time.Date(2023, time.September, 15, 12, 0, 0, 0, time.UTC) fmt.Println(\u0026#34;Specific Time:\u0026#34;, specificTime) } 時間格式化 timePackage有提供許多方法來格式化時間為字串。可以使用Format方法和指定的時間格式來實現。\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;time\u0026#34; ) func main() { currentTime := time.Now() fmt.Println(\u0026#34;Default Format:\u0026#34;, currentTime) fmt.Println(\u0026#34;Custom Format:\u0026#34;, currentTime.Format(\u0026#34;2006-01-02 15:04:05\u0026#34;)) } 時間操作 對時間進行增減，如計算兩個時間的差距、增加時間、減少時間等。\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;time\u0026#34; ) func main() { now := time.Now() oneHourLater := now.Add(time.Hour) fmt.Println(\u0026#34;One Hour Later:\u0026#34;, oneHourLater) tenMinutesAgo := now.Add(-10 * time.Minute) fmt.Println(\u0026#34;Ten Minutes Ago:\u0026#34;, tenMinutesAgo) duration := oneHourLater.Sub(now) fmt.Println(\u0026#34;Time Difference:\u0026#34;, duration) } 定時器 timePackage還提供了定時器的功能，可以用來執行定時任務。\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;time\u0026#34; ) func main() { ticker := time.NewTicker(2 * time.Second) defer ticker.Stop() for { select { case \u0026lt;-ticker.C: fmt.Println(\u0026#34;Tick at\u0026#34;, time.Now()) } } } Sleep 要讓程式暫停執行一段時間，可以使用time.Sleep函數。\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;time\u0026#34; ) func main() { fmt.Println(\u0026#34;Start\u0026#34;) time.Sleep(3 * time.Second) fmt.Println(\u0026#34;End after 3 seconds\u0026#34;) } 常見用法 時間比較 使用Before、After和Equal方法來比較兩個時間差。\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;time\u0026#34; ) func main() { now := time.Now() future := now.Add(time.Hour) if future.After(now) { fmt.Println(\u0026#34;Future time is after current time\u0026#34;) } past := now.Add(-time.Hour) if past.Before(now) { fmt.Println(\u0026#34;Past time is before current time\u0026#34;) } sameTime := now if sameTime.Equal(now) { fmt.Println(\u0026#34;Same time as current time\u0026#34;) } } 計算時間間隔 使用Sub方法計算兩個時間之間的時間間隔。\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;time\u0026#34; ) func main() { start := time.Now() time.Sleep(2 * time.Second) end := time.Now() duration := end.Sub(start) fmt.Println(\u0026#34;Time elapsed:\u0026#34;, duration) } 時間格式化與解析 將時間格式化為字串，也可以從字串解析出時間。\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;time\u0026#34; ) func main() { // 格式化時間為字串 currentTime := time.Now() fmt.Println(\u0026#34;Default Format:\u0026#34;, currentTime) fmt.Println(\u0026#34;Custom Format:\u0026#34;, currentTime.Format(\u0026#34;2006-01-02 15:04:05\u0026#34;)) // 從字串解析時間 timeStr := \u0026#34;2023-09-15 14:30:00\u0026#34; parsedTime, _ := time.Parse(\u0026#34;2006-01-02 15:04:05\u0026#34;, timeStr) fmt.Println(\u0026#34;Parsed Time:\u0026#34;, parsedTime) } 定義自定義時區 使用time.LoadLocation來定義自定義的時區。\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;time\u0026#34; ) func main() { // 定義自定義時區 taipei, _ := time.LoadLocation(\u0026#34;Asia/Taipei\u0026#34;) // 在指定時區下獲取時間 twTime := time.Now().In(taipei) fmt.Println(\u0026#34;Taiwai Time:\u0026#34;, twTime) } 定時任務 使用time.Timer來執行定時任務，通常用來定時執行程式中的某些操作。\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;time\u0026#34; ) func main() { timer1 := time.NewTimer(2 * time.Second) \u0026lt;-timer1.C fmt.Println(\u0026#34;Timer 1 fired\u0026#34;) timer2 := time.NewTimer(time.Second) go func() { \u0026lt;-timer2.C fmt.Println(\u0026#34;Timer 2 fired\u0026#34;) }() stop2 := timer2.Stop() if stop2 { fmt.Println(\u0026#34;Timer 2 stopped\u0026#34;) } } 📚參考資料 time package - time - Go Packages Go by Example: Time [pkg] time | PJCHENder 未整理筆記 ","permalink":"https://sz9751210.github.io/posts/go-time/","summary":"👨‍💻簡介 要處理日期和時間，就必須知道這個Package -\u0026gt; time，Go提供了內建的timePackage。 今天主要介紹time的功能，包括時間操作、格式化等等，以及常見用法。\n主要功能 timePackage的主要功能是處理時間和日期的操作，包括時間的表示、創建、格式化和計算。在Go中，時間通常以time.Time type表示，這個type包含了日期和時間的資訊。\n導入Package import \u0026#34;time\u0026#34; 創建時間 使用time.Now()函數來獲取當前的時間。\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;time\u0026#34; ) func main() { currentTime := time.Now() fmt.Println(\u0026#34;Current Time:\u0026#34;, currentTime) } 你還可以使用time.Date()函數來創建一個特定日期和時間的time.Time 物件。\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;time\u0026#34; ) func main() { specificTime := time.Date(2023, time.September, 15, 12, 0, 0, 0, time.UTC) fmt.Println(\u0026#34;Specific Time:\u0026#34;, specificTime) } 時間格式化 timePackage有提供許多方法來格式化時間為字串。可以使用Format方法和指定的時間格式來實現。\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;time\u0026#34; ) func main() { currentTime := time.","title":"Time：Go語言的時間處理利器"},{"content":"👨‍💻簡介 要印出Hello World，就會碰到這個Package -\u0026gt; fmt，今天來簡單整理一下fmt的作用、格式化的控制與常見用法。\n主要功能 fmt 套件的主要功能是處理格式化的輸出和輸入，包括資料格式處理、字串解析和數值轉換等功能。通常用來記錄訊息、檔案處理等等。fmt 套件中的函數可以主要分為兩大類：Print 和 Scan。\n導入Package import \u0026#34;fmt\u0026#34; Print 函數系列 fmt.Print：將資料印到終端機。 fmt.Println：將資料印到終端機，並換行。 fmt.Printf：根據格式化參數將資料印到終端機。 fmt.Sprintf：格式化成字串，通常用在需要以字串形式處理格式化時會用到 fmt.Fprintf：格式化到文件，通常用來寫檔會用到 Print與Printf相比，差在不能印格式化輸出\nPrint與Println相比，差在ln多了一個換行\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;os\u0026#34; ) func main() { name := \u0026#34;Alan\u0026#34; age := 30 fmt.Print(\u0026#34;Name: \u0026#34;, name, \u0026#34; Age: \u0026#34;, age) // 沒有換行 fmt.Println(\u0026#34;Name:\u0026#34;, name, \u0026#34;Age:\u0026#34;, age) // 有換行 fmt.Printf(\u0026#34;Name: %s Age: %d\\n\u0026#34;, name, age) // 格式化印出 formatted := fmt.Sprintf(\u0026#34;Name: %s, Age: %d\u0026#34;, name, age) fmt.Println(formatted) // 輸出格式化後的字串 file, _ := os.Create(\u0026#34;output.txt\u0026#34;) defer file.Close() fmt.Fprintf(file, \u0026#34;Name: %s, Age: %d\u0026#34;, name, age) // 將格式化後的內容寫入檔案 } Scan 函數系列 fmt.Scan：讀取一個或多個空格分隔的值。 fmt.Scanf：格式化讀取。 fmt.Scanln：讀取一行內容。 fmt.Fscanf：從文件中格式化讀取 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;os\u0026#34; ) func main() { // 使用 fmt.Scan 讀取一個或多個空格分隔的值 var name string var age int fmt.Print(\u0026#34;Enter your name and age (space-separated): \u0026#34;) fmt.Scan(\u0026amp;name, \u0026amp;age) fmt.Printf(\u0026#34;Name: %s Age: %d\\n\u0026#34;, name, age) // 使用 fmt.Scanf 進行格式化讀取 var height float64 fmt.Print(\u0026#34;Enter your height in meters: \u0026#34;) fmt.Scanf(\u0026#34;%f\u0026#34;, \u0026amp;height) fmt.Printf(\u0026#34;Height: %.2f meters\\n\u0026#34;, height) // 使用 fmt.Scanln 讀取一行內容 var city string var country string fmt.Print(\u0026#34;Enter your city and country: \u0026#34;) fmt.Scanln(\u0026amp;city, \u0026amp;country) fmt.Printf(\u0026#34;City: %s Country: %s\\n\u0026#34;, city, country) // 使用 fmt.Fscanf 從文件中格式化讀取 file, _ := os.Open(\u0026#34;input.txt\u0026#34;) defer file.Close() var code int var message string fmt.Fscanf(file, \u0026#34;%d %s\u0026#34;, \u0026amp;code, \u0026amp;message) fmt.Printf(\u0026#34;Code: %d Message: %s\\n\u0026#34;, code, message) } 格式化控制 常見的格式化參數 在Go的fmtPackage中，常見的格式化參數用來指定印出的格式。這邊列舉一些常見的格式化參數：\n%s：string (字串) %c：char (字元) %d：digit (10進位的數字) %f：float (浮點數) %t：bool (布林值) %v: value (值) package main import \u0026#34;fmt\u0026#34; func main() { name := \u0026#34;Alan\u0026#34; age := 30 firstChar := \u0026#39;A\u0026#39; height := 5.8 isStudent := true fmt.Printf(\u0026#34;Name: %s\\n\u0026#34;, name) // Name: Alan fmt.Printf(\u0026#34;Age: %d\\n\u0026#34;, age) // Age: 30 fmt.Printf(\u0026#34;First Char: %c\\n\u0026#34;, firstChar) // First Char: A fmt.Printf(\u0026#34;Height: %.2f\\n\u0026#34;, height) // Height: 5.8 fmt.Printf(\u0026#34;Is Student: %t\\n\u0026#34;, isStudent) // Is Student: true } %v還能夠顯示更詳細的資訊\n%+v: value (以詳細格式輸出，印出 struct 時，會多欄位名稱) %#v: value (以Go語言語法輸出，印出 struct 時，會多 struct 名稱與欄位名稱) type Person struct { FirstName string LastName string Age int } func main() { person := Person{ FirstName: \u0026#34;Alan\u0026#34;, LastName: \u0026#34;Wang\u0026#34;, Age: 30, } fmt.Printf(\u0026#34;%+v\\n\u0026#34;, person) // {FirstName:John LastName:Doe Age:30} fmt.Printf(\u0026#34;%#v\\n\u0026#34;, person) // main.Person{FirstName:\u0026#34;John\u0026#34;, LastName:\u0026#34;Doe\u0026#34;, Age:30} } 寬度和精度 在格式化字符串中，我們可以使用寬度（Width）和精度（Precision）來調整印出的長度和小數點位數。例如，%8.2f表示印出浮點數佔8個字符的寬度，並保留2位小數。\npackage main import \u0026#34;fmt\u0026#34; func main() { num := 123.456789 fmt.Printf(\u0026#34;Default: %f\\n\u0026#34;, num) fmt.Printf(\u0026#34;Width 16: %16f\\n\u0026#34;, num) fmt.Printf(\u0026#34;Width 8, Precision 2: %8.2f\\n\u0026#34;, num) } 格式化選項 格式化選項可以讓我們設定對齊方式、填充字符等。例如，%-8s代表向左對齊，並在不足8個字符時使用空格進行填充。\npackage main import \u0026#34;fmt\u0026#34; func main() { name := \u0026#34;Alan\u0026#34; fmt.Printf(\u0026#34;Name: %-8s|\\n\u0026#34;, name) fmt.Printf(\u0026#34;Name: %8s|\\n\u0026#34;, name) fmt.Printf(\u0026#34;Name: %.8s|\\n\u0026#34;, name) } 常見用法 字串格式化 package main import \u0026#34;fmt\u0026#34; func main() { name := \u0026#34;Alan\u0026#34; greeting := fmt.Sprintf(\u0026#34;Hello, %s!\u0026#34;, name) fmt.Println(greeting) } 數值格式化 package main import \u0026#34;fmt\u0026#34; func main() { num := 42 fmt.Printf(\u0026#34;Decimal: %d\\n\u0026#34;, num) fmt.Printf(\u0026#34;Hexadecimal: %x\\n\u0026#34;, num) fmt.Printf(\u0026#34;Binary: %b\\n\u0026#34;, num) } 時間格式化 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;time\u0026#34; ) func main() { now := time.Now() fmt.Printf(\u0026#34;Current time: %s\\n\u0026#34;, now.Format(\u0026#34;2006-01-02 15:04:05\u0026#34;)) } JSON 讀取和印出 package main import ( \u0026#34;encoding/json\u0026#34; \u0026#34;fmt\u0026#34; ) type Person struct { Name string `json:\u0026#34;name\u0026#34;` Age int `json:\u0026#34;age\u0026#34;` } func main() { // 將Struct轉換為JSON person := Person{Name: \u0026#34;Alan\u0026#34;, Age: 30} jsonBytes, _ := json.Marshal(person) fmt.Println(string(jsonBytes)) // 從JSON解析Struct jsonStr := `{\u0026#34;name\u0026#34;:\u0026#34;Bob\u0026#34;,\u0026#34;age\u0026#34;:25}` var anotherPerson Person json.Unmarshal([]byte(jsonStr), \u0026amp;anotherPerson) fmt.Printf(\u0026#34;Name: %s Age: %d\\n\u0026#34;, anotherPerson.Name, anotherPerson.Age) } 📚Reference fmt package - fmt - Go Packages [pkg] fmt | PJCHENder 未整理筆記 ","permalink":"https://sz9751210.github.io/posts/go-fmt/","summary":"👨‍💻簡介 要印出Hello World，就會碰到這個Package -\u0026gt; fmt，今天來簡單整理一下fmt的作用、格式化的控制與常見用法。\n主要功能 fmt 套件的主要功能是處理格式化的輸出和輸入，包括資料格式處理、字串解析和數值轉換等功能。通常用來記錄訊息、檔案處理等等。fmt 套件中的函數可以主要分為兩大類：Print 和 Scan。\n導入Package import \u0026#34;fmt\u0026#34; Print 函數系列 fmt.Print：將資料印到終端機。 fmt.Println：將資料印到終端機，並換行。 fmt.Printf：根據格式化參數將資料印到終端機。 fmt.Sprintf：格式化成字串，通常用在需要以字串形式處理格式化時會用到 fmt.Fprintf：格式化到文件，通常用來寫檔會用到 Print與Printf相比，差在不能印格式化輸出\nPrint與Println相比，差在ln多了一個換行\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;os\u0026#34; ) func main() { name := \u0026#34;Alan\u0026#34; age := 30 fmt.Print(\u0026#34;Name: \u0026#34;, name, \u0026#34; Age: \u0026#34;, age) // 沒有換行 fmt.Println(\u0026#34;Name:\u0026#34;, name, \u0026#34;Age:\u0026#34;, age) // 有換行 fmt.Printf(\u0026#34;Name: %s Age: %d\\n\u0026#34;, name, age) // 格式化印出 formatted := fmt.Sprintf(\u0026#34;Name: %s, Age: %d\u0026#34;, name, age) fmt.","title":"Fmt：資料處理的好幫手"},{"content":"👨‍💻簡介 昨天講到Goroutine的橋梁aka傳話筒 - Channel，那要怎麼知道對方有收到訊息，我的紙條有送到對方手上呢? 今天就是要來介紹幾種Goroutine的確定完成工作的幾種方式。\nGoroutine 的等待方式 在Go語言中，等待Goroutine完成的方式有多種。\nsync.WaitGroup sync.WaitGroup是Go語言中常見的一種等待方式，它允許我們等待一組Goroutine完成。\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;sync\u0026#34; ) func worker(id int, wg *sync.WaitGroup) { defer wg.Done() // 表示Goroutine完成工作，減少WaitGroup計數 fmt.Printf(\u0026#34;Worker %d 正在工作\\n\u0026#34;, id) } func main() { var wg sync.WaitGroup for i := 1; i \u0026lt;= 3; i++ { wg.Add(1) // 增加WaitGroup數量 go worker(i, \u0026amp;wg) // 啟動Goroutine，並將WaitGroup的指針傳遞給它 } wg.Wait() // 將主程式阻塞，直到所有Goroutines完成工作。 fmt.Println(\u0026#34;所有工作完成\u0026#34;) } 在上面的範例中，我們先創建了一個sync.WaitGroup的變數wg，並使用for循環去執行我們的goroutine，每次執行前都先將等待goroutine的數量+1，總共等待三個Goroutine完成工作。 接著使用 wg.Wait()將main函數先暫停一下，等所有goroutine都完成工作，wg的計數器為0，在繼續執行程式。 在 worker函數裡，會接收 wg的pointer，並在開頭使用defer wg.Done()在程式執行結束就將等待的goroutine數量-1，來確保goroutine會完成\nChannel Channel是Go語言中用於通信的機制，也可以用於等待Goroutine完成。\npackage main import ( \u0026#34;fmt\u0026#34; ) func worker(id int, ch chan bool) { fmt.Printf(\u0026#34;Worker %d 正在工作\\n\u0026#34;, id) ch \u0026lt;- true } func main() { ch := make(chan bool) for i := 1; i \u0026lt;= 3; i++ { go worker(i, ch) } for i := 1; i \u0026lt;= 3; i++ { \u0026lt;-ch } fmt.Println(\u0026#34;所有工作完成\u0026#34;) } Channel的特性就是有方向性，在這段程式碼中，創建了三個Goroutines，每個Goroutine在執行時都印出一條訊息，然後將一個布林值傳送到Channel中，最後等三個Channel都接收到操作完成後，印出 \u0026ldquo;所有工作完成\u0026rdquo;。\nselect 使用select語句可以等待多個Goroutine中的任何一個完成。\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;time\u0026#34; ) func worker(id int, ch chan bool) { fmt.Printf(\u0026#34;Worker %d 正在工作\\n\u0026#34;, id) time.Sleep(time.Second * time.Duration(id)) ch \u0026lt;- true } func main() { ch1 := make(chan bool) ch2 := make(chan bool) go worker(1, ch1) go worker(2, ch2) select { case \u0026lt;-ch1: fmt.Println(\u0026#34;Worker 1 完成\u0026#34;) case \u0026lt;-ch2: fmt.Println(\u0026#34;Worker 2 完成\u0026#34;) } fmt.Println(\u0026#34;工作完成\u0026#34;) } 在這個範例中，我們啟動了兩個Goroutines（worker(1, ch1) 和 worker(2, ch2)），它們各自執行一些工作並將布林值寫入Channel。接著，我們使用 select 來等待哪個Channel中的值會先到達，即哪個Goroutine先完成工作。\n因select的特性， 只會選擇其中一個 case，如果兩個Goroutines都完成，只會選擇一個來處理，而不會等待所有Goroutines完成。這也使得 select 非常適合用來需要競爭的情況，可以根據需要增加更多的 case 來等待多個Goroutines。\ntime.Sleep time.Sleep也是一種簡單的等待方式，但它只是預測多久完成，而且會阻塞整個執行緒，不推。\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;time\u0026#34; ) func worker(id int) { fmt.Printf(\u0026#34;Worker %d 正在工作\\n\u0026#34;, id) time.Sleep(time.Second * time.Duration(id)) fmt.Printf(\u0026#34;Worker %d 完成\\n\u0026#34;, id) } func main() { go worker(1) go worker(2) // 等待一段時間以確保工作完成 time.Sleep(time.Second * 3) fmt.Println(\u0026#34;所有工作完成\u0026#34;) } Goroutine 等待方式的比較 不同的等待方式有各自的使用場景和優缺點。sync.WaitGroup是最常用的方式，因為它簡單且高效。Channel等待方式在需要更多控制時很有用，而select則適用於等待多個Goroutine中的某一個。請根據您的需求選擇最適合的方式。\n當你在Go語言中使用Goroutines並需要等待它們完成時，有幾種不同的等待方式可供選擇。以下是這些等待方式的比較：\nsync.WaitGroup：\n優點：\n簡單易用 效率高：等待期間不會浪費CPU資源。 可用於任意數量的Goroutines。 限制：\n需要額外的記憶體：每個等待的Goroutine都需要一個WaitGroup。 只能等待固定數量的Goroutines。 Channel（Channel）等待：\n優點：\n可以靈活控制等待：你可以在Goroutine完成時向Channel發送信號。 可以用於不定數量的Goroutines。 可以用於任何需要自定義等待邏輯的情況。 限制：\n需要額外的程式碼來處理Channel。 可能需要額外的同步以確保所有Channel操作正確。 select 多Channel選擇：\n優點：\n可以等待多個Goroutines中的任何一個完成。 適用於需要競爭的情況。 限制：\n複雜性：當你有多個Channel時，可能需要更多的程式碼和邏輯。 只能等待一個完成，無法等待多個Goroutines全部完成。 time.Sleep：\n優點：\n簡單明瞭，容易理解。 限制：\n不是一種有效的等待方式，因為會阻塞整個函數，浪費CPU資源。 無法確保Goroutines何時完成。 不推薦在正式環境中使用。 這樣看下來，最常見且推薦的方式就是使用sync.WaitGroup，因為簡單而且高效。但根據不同情況，你可能需要使用其他方式。使用Channel等待和select適用於需要更多控制和競爭的情況，而time.Sleep只應該在測試或學習目的中使用。選擇適合你需求的等待方式，才能確保Goroutines的並發能夠在你的應用中正確運作。\n小結 前兩篇介紹了Goroutine、Channel，最後就來介紹一下如何確保你的工作有完成，紙條有成功送到對方手上。了解如何等待它們完成是開發高效併發應用的重要一環。介紹了多種等待Goroutine的方式，每種方式都有他的優勢和限制。可以根據需求，選擇適合的方式來讓你程式碼能夠充分利用Goroutine的優點。\n📚Reference Go by Example: WaitGroups Golang 教學系列 - 何謂 WaitGroup? 等待 Goroutine 的好幫手！ | Kenny\u0026rsquo;s Blog (kennycoder.io) ","permalink":"https://sz9751210.github.io/posts/go-waitgroup/","summary":"👨‍💻簡介 昨天講到Goroutine的橋梁aka傳話筒 - Channel，那要怎麼知道對方有收到訊息，我的紙條有送到對方手上呢? 今天就是要來介紹幾種Goroutine的確定完成工作的幾種方式。\nGoroutine 的等待方式 在Go語言中，等待Goroutine完成的方式有多種。\nsync.WaitGroup sync.WaitGroup是Go語言中常見的一種等待方式，它允許我們等待一組Goroutine完成。\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;sync\u0026#34; ) func worker(id int, wg *sync.WaitGroup) { defer wg.Done() // 表示Goroutine完成工作，減少WaitGroup計數 fmt.Printf(\u0026#34;Worker %d 正在工作\\n\u0026#34;, id) } func main() { var wg sync.WaitGroup for i := 1; i \u0026lt;= 3; i++ { wg.Add(1) // 增加WaitGroup數量 go worker(i, \u0026amp;wg) // 啟動Goroutine，並將WaitGroup的指針傳遞給它 } wg.Wait() // 將主程式阻塞，直到所有Goroutines完成工作。 fmt.Println(\u0026#34;所有工作完成\u0026#34;) } 在上面的範例中，我們先創建了一個sync.WaitGroup的變數wg，並使用for循環去執行我們的goroutine，每次執行前都先將等待goroutine的數量+1，總共等待三個Goroutine完成工作。 接著使用 wg.Wait()將main函數先暫停一下，等所有goroutine都完成工作，wg的計數器為0，在繼續執行程式。 在 worker函數裡，會接收 wg的pointer，並在開頭使用defer wg.Done()在程式執行結束就將等待的goroutine數量-1，來確保goroutine會完成\nChannel Channel是Go語言中用於通信的機制，也可以用於等待Goroutine完成。","title":"Go語言中Goroutine的等待方式"},{"content":"👨‍💻簡介 昨天講到Goroutine有稍微簡單介紹Channel，Channel是Go語言中極為重要的併發通訊機制，它就像是不同goroutines之間的話筒，允許它們安全地傳遞資料和信息。這個強大的工具使得Go語言在處理併發任務時非常優雅和高效。通過Channel，可以協調goroutines的操作，防止競爭條件，並實現高效的併發程式設計。\n什麼是Channel？ Channel是Go語言中一個強大的併發原語言功能，用於在不同的goroutine之間傳遞資料。它們提供了一種通訊的機制，可以讓goroutines之間安全地交換信息，而不需要額外的互斥鎖或信號量。\n可以把channel比喻成傳紙條，傳紙條可以是單向，也可以是雙向，單向可以想像類似以前傳紙條的中間人，他只接收和傳遞，紙條也有大小的限制，寫滿了就不能再繼續寫，並且需要等待對方將紙條進行回覆後你才能繼續。\n建立和使用Channel 在Go中，可以使用內建的make函數來建立一個新的Channel。以下是使用 make函數建立整數類型的Channel\nch := make(chan int) 建立完後，就可以將資料發送到Channel中，然後在其他goroutine中接收它們。以下是一個簡單的發送和接收資料的例子：\nfunc main() { ch := make(chan int) go func() { ch \u0026lt;- 42 // 發送資料到Channel }() value := \u0026lt;-ch // 從Channel接收資料 fmt.Println(value) // 輸出：42 } 這個例子中，我們建立了一個goroutine，它將數字42發送到Channel，然後主goroutine，也就是main函數，接收到這個數字。\n關閉Channel 紙條用完會丟掉，Channel用完也是要關掉，您可能需要關閉Channel，以通知接收方不再有新的資料可用。要關閉Channel，可以使用close函數，如下所示：\nclose(ch) 接收方可以使用特殊的語法來檢查Channel是否已關閉：\nvalue, ok := \u0026lt;-ch if !ok { // Channel已經關閉 } 這可以防止接收方在Channel已關閉的情況下繼續等待。 並且已經關閉的Channel依然可以進行接收的操作，但不能再進行發送。\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;time\u0026#34; ) func main() { ch := make(chan int) go func() { for i := 0; i \u0026lt; 5; i++ { time.Sleep(1 * time.Second) ch \u0026lt;- i // 向Channel發送資料 } close(ch) // 關閉Channel }() // 接收資料直到Channel被關閉 for val := range ch { fmt.Println(val) } } 範例中首先創建了一個整數型的Channel ch，並在一個獨立的goroutine中向該Channel發送一系列數字。一旦所有資料都被發送完畢，我們通過close(ch)關閉了Channel。\n主goroutine使用for num := range ch的方式來從Channel中接收資料，這是一種常見的接收方式。當Channel被關閉後，range迴圈會自動退出，從而避免了無限等待。\nChannel的方向 傳紙條有方向，Channel肯定也有方向，Channel的方向主要用來限制操作方向，增加程式的安全性。Channel可以是雙向的（可以用來發送和接收），也可以是單向的（只能用來發送或接收）。\n1. 雙向Channel（Bidirectional Channels） 雙向Channel是最常見的類型，它允許進行發送和接收操作。\n建立方式：ch := make(chan T)，其中T是所需的資料類型。\n雙向Channel可以在函數參數中以普通形式使用，進行發送和接收操作。\n範例：\nch := make(chan int) go func() { ch \u0026lt;- 42 // 向Channel發送資料 fmt.Println(\u0026lt;-ch) // 從Channel接收資料 }() 2. 單向Channel（Unidirectional Channels） 單向Channel只允許發送或接收操作，以增加程式的安全性和可讀性。它們可以分為兩種類型：\na. 單向發送Channel（Send-Only Channel） 只允許發送操作，不允許接收操作。\n建立方式：ch := make(chan\u0026lt;- T)，其中T是所需的資料類型。\n用來向其他goroutines發送資料，提高安全性。\n範例：\nfunc sendData(ch chan\u0026lt;- int, data int) { ch \u0026lt;- data } func main() { ch := make(chan\u0026lt;- int) go sendData(ch, 42) // 向單向發送Channel發送資料 // 這行程式碼無法編譯，因為我們無法從單向發送Channel接收資料 value := \u0026lt;-ch // 編譯錯誤 } b. 單向接收Channel（Receive-Only Channel） 只允許接收操作，不允許發送操作。\n建立方式：ch := make(\u0026lt;-chan T)，其中T是所需的資料類型。\n用來限制goroutines只能從Channel接收資料，提高程式的可讀性。\n範例：\nfunc receiveData(ch \u0026lt;-chan int) { data := \u0026lt;-ch fmt.Println(data) } func main() { ch := make(\u0026lt;-chan int) go receiveData(ch) // 從單向接收Channel接收資料 // 這行程式碼無法編譯，因為我們無法向單向接收Channel發送資料 ch \u0026lt;- 42 // 編譯錯誤 } Channel的特性、限制與常見用法 特性 通訊機制：Channel是用於goroutines之間通訊的機制。它們允許goroutines安全地傳遞資料，確保同步和協調。 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;time\u0026#34; ) func main() { ch := make(chan string) // 启动一个goroutine发送消息到Channel go func() { ch \u0026lt;- \u0026#34;Hello from goroutine!\u0026#34; }() // 主goroutine接收消息 msg := \u0026lt;-ch fmt.Println(msg) // 输出：Hello from goroutine! } 在這個例子中，我們建立了一個String類型的Channel ch，然後在一個goroutine中將消息發送到該Channel，主goroutine接收並打印消息。\n阻塞操作：Channel的發送（send）和接收（receive）操作都是阻塞的。如果發送方沒有goroutine準備好接收資料，或者接收方沒有資料可用，操作將被阻塞，直到滿足條件為止。 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;time\u0026#34; ) func main() { ch := make(chan int) go func() { time.Sleep(2 * time.Second) ch \u0026lt;- 42 // 將資料42發送到Channel }() select { case value := \u0026lt;-ch: fmt.Printf(\u0026#34;接收到資料：%d\\n\u0026#34;, value) case \u0026lt;-time.After(1 * time.Second): fmt.Println(\u0026#34;超時：未能接收到資料\u0026#34;) } } 在範例中，我們先建立了一個Channel ch，然後啟動一個goroutine，該goroutine將在2秒後向Channel發送數字42。接著，我們使用select語句來等待Channel的資料接收操作，但我們設置了一個1秒的超時。\n這裡可能發生以下情況：\n如果在2秒內，goroutine成功向Channel發送了數字42，則我們會在case value := \u0026lt;-ch分支處接收到資料，並輸出「接收到資料：42」。\n如果在1秒內無法接收到資料，則超時發生，我們會進入case \u0026lt;-time.After(1 * time.Second)分支，並輸出「超時：未能接收到資料」。\n這個範例展示了Channel的阻塞操作特性，無論是成功接收資料還是超時，都取決於Channel中是否有可用的資料以及操作是否阻塞。這種阻塞操作使得在併發程式設計中能夠安全地等待資料的到來，而不需要使用額外的等待或輪詢機制。\n具有方向性：Channel可以是單向或雙向的。單向Channel只允許發送或接收操作，而雙向Channel則沒有這限制。\n緩衝Channel：可以使用make函數的第二個參數來建立緩衝Channel。緩衝Channel允許一定數量的資料在不阻塞的情況下進行發送，直到緩衝區滿為止。\npackage main import \u0026#34;fmt\u0026#34; func main() { ch := make(chan int, 2) // 建立一個容量為2的緩衝Channel ch \u0026lt;- 1 // 發送第一個數字，不會阻塞 ch \u0026lt;- 2 // 發送第二個數字，不會阻塞 // ch \u0026lt;- 3 // 如果再嘗試發送第三個數字，將會阻塞，因為緩衝區已滿 fmt.Println(\u0026lt;-ch) // 從Channel接收第一個數字 fmt.Println(\u0026lt;-ch) // 從Channel接收第二個數字 } 在這個範例中，我們建立了一個容量為2的緩衝Channel。我們可以連續發送兩個數字，而不會阻塞，但如果想再發送第三個數字，則會阻塞，直到有goroutine接收。\n限制 只能傳遞相同類型的資料：就像紙條只講一件事，可能英文課上傳紙條會寫英文，數學課上傳紙條會寫數學；Channel也一樣，每個Channel只允許傳遞相同類型的資料。例如，如果建立了一個整數型的Channel，則只能發送和接收整數。 package main import \u0026#34;fmt\u0026#34; func main() { ch := make(chan int) // 以下程式碼將導致編譯錯誤 ch \u0026lt;- \u0026#34;Hello\u0026#34; // 嘗試向整數Channel發送String } 在這個例子中，我們想要在整數型的Channel ch 傳遞一個String，這就會讓編譯器看不懂，進而報錯，因為它們不是相同類型的資料。\n不可擴展：一樣在拿紙條來舉例，當你撕下一張紙作為紙條，就不能再決定紙條大小了；Channel也是，建立完後，容量就不能動態擴展。如果需要更多容量，就必須重新建立一個新的Channel。 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;time\u0026#34; ) func main() { // 建立一個整數型的Channel，容量為2 ch := make(chan int, 2) // 向Channel發送兩個數字 ch \u0026lt;- 1 ch \u0026lt;- 2 // 嘗試再次向Channel發送，但此時容量已滿，將導致死鎖 // ch \u0026lt;- 3 // 這行會導致程式死鎖 // 讀取Channel中的數字 fmt.Println(\u0026lt;-ch) fmt.Println(\u0026lt;-ch) // 關閉Channel close(ch) // 再次嘗試讀取Channel中的數字，將得到零值並不會造成死鎖 fmt.Println(\u0026lt;-ch) // 輸出：0 } 常見用法 併發控制：可以使用Channel來協調多個goroutines的執行順序，確保它們按照所需的順序執行。\n資料共享：多個goroutines可以通過Channel共享資料，而無需使用額外的同步機制，從而避免競爭條件和死鎖。\n事件通知：Channel可以用於通知goroutines發生的事件，例如某個條件已滿足或某個任務已完成。\n異步處理：可以使用Channel來啟動異步任務，然後等待它們完成，而不會阻塞主線程。\n小結 Goroutine就像是講電話的我們，Channel就像是話筒，能穩穩地傳達我要的訊息，在goroutines之間安全地傳遞資料和協調操作，也避免了競爭條件和死鎖等問題。\n📚Reference Go by Example: Channels [Golang] goroutines, channels, and concurrency | PJCHENder 未整理筆記 使用 Go Channel 及 Goroutine 時機 | Go 技术论坛 (learnku.com) ","permalink":"https://sz9751210.github.io/posts/go-channel/","summary":"👨‍💻簡介 昨天講到Goroutine有稍微簡單介紹Channel，Channel是Go語言中極為重要的併發通訊機制，它就像是不同goroutines之間的話筒，允許它們安全地傳遞資料和信息。這個強大的工具使得Go語言在處理併發任務時非常優雅和高效。通過Channel，可以協調goroutines的操作，防止競爭條件，並實現高效的併發程式設計。\n什麼是Channel？ Channel是Go語言中一個強大的併發原語言功能，用於在不同的goroutine之間傳遞資料。它們提供了一種通訊的機制，可以讓goroutines之間安全地交換信息，而不需要額外的互斥鎖或信號量。\n可以把channel比喻成傳紙條，傳紙條可以是單向，也可以是雙向，單向可以想像類似以前傳紙條的中間人，他只接收和傳遞，紙條也有大小的限制，寫滿了就不能再繼續寫，並且需要等待對方將紙條進行回覆後你才能繼續。\n建立和使用Channel 在Go中，可以使用內建的make函數來建立一個新的Channel。以下是使用 make函數建立整數類型的Channel\nch := make(chan int) 建立完後，就可以將資料發送到Channel中，然後在其他goroutine中接收它們。以下是一個簡單的發送和接收資料的例子：\nfunc main() { ch := make(chan int) go func() { ch \u0026lt;- 42 // 發送資料到Channel }() value := \u0026lt;-ch // 從Channel接收資料 fmt.Println(value) // 輸出：42 } 這個例子中，我們建立了一個goroutine，它將數字42發送到Channel，然後主goroutine，也就是main函數，接收到這個數字。\n關閉Channel 紙條用完會丟掉，Channel用完也是要關掉，您可能需要關閉Channel，以通知接收方不再有新的資料可用。要關閉Channel，可以使用close函數，如下所示：\nclose(ch) 接收方可以使用特殊的語法來檢查Channel是否已關閉：\nvalue, ok := \u0026lt;-ch if !ok { // Channel已經關閉 } 這可以防止接收方在Channel已關閉的情況下繼續等待。 並且已經關閉的Channel依然可以進行接收的操作，但不能再進行發送。\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;time\u0026#34; ) func main() { ch := make(chan int) go func() { for i := 0; i \u0026lt; 5; i++ { time.","title":"Channel：Go語言建立併發通訊的橋樑"},{"content":"👨‍💻簡介 在日常生活中，如果能同時做很多事情，效率肯定大大提升，那麼在Go語言中，該如何做到呢，答案就是今天的主角Goroutine了，在Go語言中，讓併發變得簡單的強大工具，今天就是來給他一個快速介紹。\n什麼是Goroutine？ 首先，讓我們以一個簡單的方式來解釋什麼是Goroutine。Goroutine是Go語言的一個特別的功能，它就像是小型的工作任務，可以讓我們同時處理很多事情，而不需要浪費太多電腦資源。可以把它想像成比傳統方式更聰明的方式來處理多項工作，而不會讓電腦變得超級忙碌。這種功能讓Go語言在處理大量同時執行的工作時變得非常強大。\n如何創建和啟動Goroutine 要使用Goroutine很簡單，只需要創建一個函數，然後使用go關鍵字在要使用goroutine的函數前面就完成了。可以看以下範例：\npackage main import ( \u0026#34;fmt\u0026#34; ) func main() { go sayHello() // 主程式不會等待Goroutine完成 } func sayHello() { fmt.Println(\u0026#34;Hello, Goroutine!\u0026#34;) } 在這個例子中，我們使用go關鍵字啟動一個新的Goroutine，Goroutine執行了sayHello函數。但須注意，主程式main不會等待Goroutine完成，所以可能不會看到有印出任何東西來。\n可以稍微讓main主程式睡一下，就可以看到輸出了\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;time\u0026#34; ) func main() { go sayHello() time.Sleep(1) } func sayHello() { fmt.Println(\u0026#34;Hello, Goroutine!\u0026#34;) } Goroutine的執行過程 下面提供了一個簡單的小程式，在主程式裡有兩個goroutine，試著執行一下程式可以發現輸出是一段一段的，會是0跟1交錯印出，代表兩邊的goroutine會搶著印出，呈現競爭狀態\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;time\u0026#34; ) func main() { go print1() go print2() time.Sleep(time.Second) } func print1() { for i := 0; i \u0026lt; 100; i++ { fmt.Print(\u0026#34;0\u0026#34;) } } func print2() { for i := 0; i \u0026lt; 100; i++ { fmt.Print(\u0026#34;1\u0026#34;) } } Goroutine之間的通信 併發往往涉及到多個任務之間的通信。這就是通道（Channel）的用武之地。通道是一種特殊的資料結構，用於在不同的Goroutine之間傳遞資料：\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;time\u0026#34; ) func main() { ch := make(chan string) go sendData(ch) go receiveData(ch) time.Sleep(2 * time.Second) // 等待Goroutines完成 } func sendData(ch chan string) { ch \u0026lt;- \u0026#34;Hello from Goroutine!\u0026#34; } func receiveData(ch chan string) { msg := \u0026lt;-ch fmt.Println(msg) } 在這個例子中，我們先創建了一個通道ch，然後使用通道在兩個Goroutine之間傳遞消息。 通道的溝通可以看到範例，\u0026lt;- chan 代表將資料從channel中取出，而chan \u0026lt;- 則代表將資料放進channel\nGoroutine同步與等待 通常情況下，我們希望主程式能夠等待所有的Goroutine完成，以確保結果的完整性。這就是WaitGroup的作用：\nsync.WaitGroup 這個函數的主要功能是讓主程式等待所有的Goroutine完成，然後再繼續執行接下來的程式，主要有以下幾種方法\nAdd(delta int)：用來增加計數器的值，表示有多少個Goroutine需要等待。\nDone()：用來減少計數器的值，表示一個Goroutine已經完成。通常在Goroutine執行完後使用 Done。\nWait()：用來將計數器歸零。當計數器的值為零時，Wait 函數會返回，並允許主程式繼續執行。\n接著讓我們來看一下範例：\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;sync\u0026#34; ) func main() { // 創建一個WaitGroup var wg sync.WaitGroup // 啟動5個Goroutine for i := 0; i \u0026lt; 5; i++ { wg.Add(1) // 增加計數器 go worker(i, \u0026amp;wg) } wg.Wait() // 等待所有Goroutines完成 fmt.Println(\u0026#34;All Goroutines have finished.\u0026#34;) } func worker(id int, wg *sync.WaitGroup) { defer wg.Done() // 減少計數器 fmt.Printf(\u0026#34;Worker %d is done\\n\u0026#34;, id) } 可以看到，我們使用WaitGroup來等待所有的Goroutine完成，確保我的主程式可以完整執行而不會提前退出。\nGoroutine 的特性與限制 特性 資源消耗極低：Goroutine 的創建相對輕量，主要消耗少量stack空間。這意味著你可以創建大量的 goroutine 而不必擔心資源耗盡的問題。\n有效的線程管理：當一個 goroutine 被阻塞時，相應的管理線程將被擱置，但運行時會將其他 goroutine 分配給這個線程，使其繼續執行其他工作。這種機制確保了線程的高效使用，避免了資源浪費。\n最大線程數限制：你可以透過設定 $GOMAXPROCS 來限制系統中的線程數量，確保它們不會無節制地增加。這有助於避免系統資源的過度消耗。\n限制 Goroutine 數量限制：理論上，Go 語言可以創建極多的 Goroutine，但實際上，系統的可用資源（記憶體和 CPU）是有限的。因此，你需要謹慎控制 Goroutine 的數量，以避免過多的併發造成資源耗盡或性能下降。\n競爭條件和死鎖：Goroutine 的併發操作需要謹慎處理共享資源，否則可能出現競爭條件（race condition）和死鎖（deadlock）。這不是直接的限制，但是在 Goroutine 的設計和使用中需要特別注意，以確保程式的正確性。\n小結 相信學習Go語言的各位，也是被Goroutine強大的併發能力所吸引，Goroutine還有許多細節，今天這篇只是簡單介紹Goroutine，之後會再慢慢深入探討Goroutine的奧妙之處。\n📚Reference A Tour of Go(goroutine) Golang 教學系列 - 何謂 Goroutine | Kenny\u0026rsquo;s Blog (kennycoder.io) 關於 Goroutine的二三事. 近期因個人因素，開始查詢… | by Lykoi Zhang | Medium [Golang] goroutines, channels, and concurrency | PJCHENder 未整理筆記 ","permalink":"https://sz9751210.github.io/posts/go-goroutine/","summary":"👨‍💻簡介 在日常生活中，如果能同時做很多事情，效率肯定大大提升，那麼在Go語言中，該如何做到呢，答案就是今天的主角Goroutine了，在Go語言中，讓併發變得簡單的強大工具，今天就是來給他一個快速介紹。\n什麼是Goroutine？ 首先，讓我們以一個簡單的方式來解釋什麼是Goroutine。Goroutine是Go語言的一個特別的功能，它就像是小型的工作任務，可以讓我們同時處理很多事情，而不需要浪費太多電腦資源。可以把它想像成比傳統方式更聰明的方式來處理多項工作，而不會讓電腦變得超級忙碌。這種功能讓Go語言在處理大量同時執行的工作時變得非常強大。\n如何創建和啟動Goroutine 要使用Goroutine很簡單，只需要創建一個函數，然後使用go關鍵字在要使用goroutine的函數前面就完成了。可以看以下範例：\npackage main import ( \u0026#34;fmt\u0026#34; ) func main() { go sayHello() // 主程式不會等待Goroutine完成 } func sayHello() { fmt.Println(\u0026#34;Hello, Goroutine!\u0026#34;) } 在這個例子中，我們使用go關鍵字啟動一個新的Goroutine，Goroutine執行了sayHello函數。但須注意，主程式main不會等待Goroutine完成，所以可能不會看到有印出任何東西來。\n可以稍微讓main主程式睡一下，就可以看到輸出了\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;time\u0026#34; ) func main() { go sayHello() time.Sleep(1) } func sayHello() { fmt.Println(\u0026#34;Hello, Goroutine!\u0026#34;) } Goroutine的執行過程 下面提供了一個簡單的小程式，在主程式裡有兩個goroutine，試著執行一下程式可以發現輸出是一段一段的，會是0跟1交錯印出，代表兩邊的goroutine會搶著印出，呈現競爭狀態\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;time\u0026#34; ) func main() { go print1() go print2() time.Sleep(time.Second) } func print1() { for i := 0; i \u0026lt; 100; i++ { fmt.","title":"探索Goroutine：Go語言的併發魔法"},{"content":"👨‍💻簡介 當我們在宣告變數時，電腦會為該變數在記憶體中分配一個位置，然後將這個變數值儲存在這個位置上，需要讀取或修改這個變數值時，電腦是透過記憶體位置來存取這個值。 今天來簡單介紹一下go的Pointer，他的特性以及常見用法。\n什麼是Pointer？ Pointer是一種資料類型，用來儲存變數的記憶體地址。在Go中，我們可以通過使用 * 符號來宣告和操作Pointer。這允許我們直接訪問和修改變數的內容，而不僅僅是讀取或複製它們的值。\nPointer的特性、限制與常見用法 特性 Pointer的值和地址 每個變數都有一個記憶體地址，我們可以使用Pointer變數來儲存這個地址。讓我們看一個範例：\npackage main import \u0026#34;fmt\u0026#34; func main() { x := 42 var p *int // 宣告一個整數Pointer p = \u0026amp;x // 將p指向x的地址 fmt.Println(\u0026#34;x =\u0026#34;, x) fmt.Println(\u0026#34;p =\u0026#34;, p) } 在這個例子中，我們創建了一個整數變數 x，並宣告了一個整數Pointer p，然後將 p 設為 x 的地址。現在，p 裡面存放的就是 x 的地址。\nPointer的初始化 Go中的Pointer可以通過 new 函數來初始化，這將為指定的類型分配記憶體並返回其地址。範例：\npackage main import \u0026#34;fmt\u0026#34; func main() { var p *int p = new(int) // 初始化一個整數Pointer *p = 123 // 將Pointer所指向的記憶體設置為123 fmt.Println(\u0026#34;*p =\u0026#34;, *p) } 可以看到，我們創建了一個整數Pointer p，並使用 new(int) 初始化它，然後將 p 所指向的記憶體設置為 123。\nPointer的解引用 通過Pointer，我們可以訪問和修改變數的值，這稱為Pointer的解引用。\npackage main import \u0026#34;fmt\u0026#34; func main() { x := 42 p := \u0026amp;x // 將p設為x的地址，使用\u0026amp; fmt.Println(\u0026#34;x =\u0026#34;, x) fmt.Println(\u0026#34;\u0026amp;x =\u0026#34;, \u0026amp;x) fmt.Println(\u0026#34;*p =\u0026#34;, *p) // 解引用Pointer，獲得x的值，使用* *p = 99 // 通過Pointer修改x的值 fmt.Println(\u0026#34;x =\u0026#34;, x) // x的值已被修改 fmt.Println(\u0026#34;\u0026amp;x =\u0026#34;, \u0026amp;x) fmt.Println(\u0026#34;*p =\u0026#34;, *p) } 在這個例子中，我們使用Pointer p 解引用，並修改了變數 x 的值。也可以觀察到修改值並不會改變記憶體位置。\n限制 空Pointer風險：未初始化的Pointer可能為nil，試圖解引用nil Pointer會導致運行時錯誤（panic）。\n記憶體管理：Go中的垃圾回收器會管理記憶體，但Pointer仍然需要謹慎使用，以避免記憶體錯誤。\n競爭條件：多線程環境中，共享的Pointer可能導致競爭條件，需要使用互斥鎖等技術來保護共享資源。\n常見用法 節省記憶體 當需要處理大型資料結構時，使用Pointer可以節省記憶體，因為它們只儲存變數的地址，而不是整個資料。\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;unsafe\u0026#34; ) // 定義一個名為 Person 的結構（struct） type Person struct { Name string // 名稱 Age int // 年齡 } func main() { // 創建一個 Person 變數，名稱為 Alice，年齡為 30 歲 alice := Person{Name: \u0026#34;Alice\u0026#34;, Age: 30} // 計算 Person 變數 alice 的大小 personSize := unsafe.Sizeof(alice) // 創建一個指向 Person 變數的Pointer，名稱為 Bob，年齡為 24 歲 bob := \u0026amp;Person{Name: \u0026#34;Bob\u0026#34;, Age: 24} // 計算指向 Person 變數 bob 的Pointer的大小 pointerSize := unsafe.Sizeof(bob) fmt.Printf(\u0026#34;alice -\u0026gt; Person 變數的大小： %d 個位元組\\n\u0026#34;, personSize) fmt.Printf(\u0026#34;bob -\u0026gt; 指向 Person 變數的Pointer的大小： %d 個位元組\\n\u0026#34;, pointerSize) fmt.Println(\u0026amp;alice) // 列印 alice 變數的記憶體位置 fmt.Println(\u0026amp;bob) // 列印 bob 變數（Pointer）的記憶體位置 } 在上面的範例中，我們透過兩種方式創建person，但可以觀察到使用Pointer的方式創建，使用的大小較小，達到節省記憶體的作用。\n改變資料的原始值 想要在函數中修改變數的值，而不只是副本時，Pointer變得非常有用。\npackage main import \u0026#34;fmt\u0026#34; func modifyValue(x *int) { *x = 100 } func main() { y := 10 modifyValue(\u0026amp;y) // 通過Pointer修改y的值 fmt.Println(\u0026#34;y =\u0026#34;, y) } 效能優勢 在某些情況下，使用Pointer可以提高性能，因為它們允許直接訪問和修改記憶體，而不需要額外的記憶體複製操作。\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;time\u0026#34; ) const N = 1000000 // 陣列大小 // 使用值傳遞的函數，不使用指標 func sumValues(arr [N]int) int { sum := 0 for _, v := range arr { sum += v } return sum } // 使用指標傳遞的函數，避免陣列複製 func sumPointers(arr *[N]int) int { sum := 0 for _, v := range arr { sum += v } return sum } func main() { // 創建一個包含大量資料的整數陣列 var arr [N]int for i := 0; i \u0026lt; N; i++ { arr[i] = i } // 測試不使用指標的情況，複製陣列 startTime := time.Now() result1 := sumValues(arr) duration1 := time.Since(startTime) // 測試使用指標的情況，避免複製陣列 startTime = time.Now() result2 := sumPointers(\u0026amp;arr) duration2 := time.Since(startTime) fmt.Printf(\u0026#34;不使用指標的結果：%d，執行時間：%v\\n\u0026#34;, result1, duration1) fmt.Printf(\u0026#34;使用指標的結果：%d，執行時間：%v\\n\u0026#34;, result2, duration2) } 可以看到，我們創建了一個包含大量資料的整數陣列，並寫了兩個函數來計算陣列中所有元素的總和。一個函數 sumValues 使用值傳遞陣列，另一個函數 sumPointers 使用指標傳遞陣列。\n在 main 函數中，測試了這兩個函數的效能。結果顯示，使用指標傳遞陣列可以明顯提高效能，因為它少了陣列的複製，節省了大量的時間和記憶體。\n小結 Pointer是程式語言中的重要概念，它允許我們直接訪問和修改變數的內容，並在許多情況下提供性能優勢和節省記憶體的機會。但還是要小心使用Pointer，確保程式碼的穩定性和安全性。\n📚Reference A Tour of Go(pointer) [Golang] 指標 Pointers | PJCHENder 未整理筆記 Go 指针与引用：值传递和址传递-腾讯云开发者社区-腾讯云 (tencent.com) ","permalink":"https://sz9751210.github.io/posts/go-pointer/","summary":"👨‍💻簡介 當我們在宣告變數時，電腦會為該變數在記憶體中分配一個位置，然後將這個變數值儲存在這個位置上，需要讀取或修改這個變數值時，電腦是透過記憶體位置來存取這個值。 今天來簡單介紹一下go的Pointer，他的特性以及常見用法。\n什麼是Pointer？ Pointer是一種資料類型，用來儲存變數的記憶體地址。在Go中，我們可以通過使用 * 符號來宣告和操作Pointer。這允許我們直接訪問和修改變數的內容，而不僅僅是讀取或複製它們的值。\nPointer的特性、限制與常見用法 特性 Pointer的值和地址 每個變數都有一個記憶體地址，我們可以使用Pointer變數來儲存這個地址。讓我們看一個範例：\npackage main import \u0026#34;fmt\u0026#34; func main() { x := 42 var p *int // 宣告一個整數Pointer p = \u0026amp;x // 將p指向x的地址 fmt.Println(\u0026#34;x =\u0026#34;, x) fmt.Println(\u0026#34;p =\u0026#34;, p) } 在這個例子中，我們創建了一個整數變數 x，並宣告了一個整數Pointer p，然後將 p 設為 x 的地址。現在，p 裡面存放的就是 x 的地址。\nPointer的初始化 Go中的Pointer可以通過 new 函數來初始化，這將為指定的類型分配記憶體並返回其地址。範例：\npackage main import \u0026#34;fmt\u0026#34; func main() { var p *int p = new(int) // 初始化一個整數Pointer *p = 123 // 將Pointer所指向的記憶體設置為123 fmt.","title":"淺談Go中的Pointer和記憶體管理"},{"content":"👨‍💻簡介 在軟體開發中，錯誤無所不在。無論是網路請求失敗、檔案不存在，還是數學計算錯誤，處理錯誤是任何開發者的日常工作，系統的穩定度基本取決於對於錯誤處理是否全面，好的錯誤處理也可以產生適當的錯誤訊息，讓 Debug 更加容易。在Go語言中，有一些獨特的功能在處理錯誤和資源管理方面非常有用。，其中包括error、panic和recover。今天就來介紹這三個關鍵字與錯誤處理的簡單用法。\nError 什麼是Error? 在Go中，Error是一個擁有error interface的類型，可以看到他只有一個方法，該方法主要用來描述一個錯誤的字串。\ntype error interface { Error() string } 如何產生錯誤訊息 errors.New() 使用方式很簡單，在裡面放入要顯示的錯誤訊息 package main import ( \u0026#34;errors\u0026#34; \u0026#34;fmt\u0026#34; ) func main() { err := errors.New(\u0026#34;This is a custom error message\u0026#34;) fmt.Println(err.Error()) // output：This is a custom error message } fmt.Errorf() 主要用在格式化錯誤訊息的情況下 package main import ( \u0026#34;fmt\u0026#34; ) func main() { name := \u0026#34;John\u0026#34; err := fmt.Errorf(\u0026#34;Hello, %s! This is a custom error message\u0026#34;, name) fmt.Println(err.Error()) // output：Hello, John! This is a custom error message } Error用途 我們通常將Error用來當作函數的返回值，方便我們在調用函數時檢查錯誤：\nfunc divide(x, y int) (int, error) { if y == 0 { return 0, errors.New(\u0026#34;division by zero\u0026#34;) } return x / y, nil } 在範例中，我們透過errors.New創建一個新的Error實例，以表示除以零的錯誤情況。\npanic與recover 什麼是panic？ 在Go中，panic是一個內建函數，用於引發運行時異常或嚴重錯誤。通常情況下，我們應該避免使用panic，除非出現不可恢復的錯誤。\nPanic是Go語言中的一種異常情況，表示程式遇到了一個無法處理的錯誤。當Panic發生時，程式會立即停止執行並打印Panic訊息，然後退出。Panic通常用於表示嚴重的錯誤，如空指標引用或陣列越界。\n什麼是recover？ recover是Go語言中的一個內建函數，用於在發生panic時恢復程序的正常執行流程。它用於捕獲panic引發的錯誤，並允許程序繼續運行而不崩潰。\n如何處理panic 為了處理panic，我們會使用recover。底下簡單使用兩者當作範例：\npackage main import \u0026#34;fmt\u0026#34; func main() { defer handlePanic() doSomething() } func doSomething() { panic(\u0026#34;發生了一個嚴重錯誤\u0026#34;) } func handlePanic() { if r := recover(); r != nil { fmt.Println(\u0026#34;恢復了panic:\u0026#34;, r) } } 可以看到，doSomething函數引發了一個panic，但由於我們在main函數中使用了defer和recover，程序不會崩潰，而是執行了handlePanic函數，並輸出了錯誤訊息。需要注意的是，recover只能在defer中執行\n常見用法 函數返回錯誤 當函數執行過程中遇到錯誤時，通常會將一個 error 類型的值作為返回值，以便呼叫方可以檢查和處理錯誤。\nfunc Divide(a, b float64) (float64, error) { if b == 0 { return 0, errors.New(\u0026#34;division by zero\u0026#34;) } return a / b, nil } 錯誤處理 在呼叫函數時，通常會檢查返回的 error 是否為 nil，以判斷是否發生了錯誤。如果錯誤不為 nil，則需要採取適當的措施來處理錯誤，比如記錄錯誤日誌、返回錯誤訊息給使用者等。\nresult, err := Divide(10.0, 0.0) if err != nil { log.Println(\u0026#34;Error:\u0026#34;, err) // 進一步處理錯誤，如返回錯誤響應給使用者 } 自定義錯誤類型 因為Error是一個 interface，所以我們也可以實作自己的 error struct，有時會需要自定義錯誤類型，方便我們更好描述特定類型的錯誤\n// 自定義 error type type MyError struct { Code int Message string } // 實現 error interface的 Error 方法 func (e *MyError) Error() string { return fmt.Sprintf(\u0026#34;Error %d: %s\u0026#34;, e.Code, e.Message) } func main() { // 簡單建立自己的error err := \u0026amp;MyError{ Code: 404, Message: \u0026#34;Page not found\u0026#34;, } // 調用自己的error 方法 fmt.Println(\u0026#34;Error:\u0026#34;, err.Error()) } 錯誤類型判斷 還有一種常見的做法是將error搭配 type assertion進行錯誤類型判斷\npackage main import ( \u0026#34;errors\u0026#34; \u0026#34;fmt\u0026#34; ) // 自定義 error type type MyError struct { Code int Message string } func (e *MyError) Error() string { return fmt.Sprintf(\u0026#34;Error %d: %s\u0026#34;, e.Code, e.Message) } func main() { err := processRequest(0) switch e := err.(type) { case nil: fmt.Println(\u0026#34;Request processed successfully.\u0026#34;) case *MyError: fmt.Printf(\u0026#34;Custom Error: %v\\n\u0026#34;, e) // 處理自定義錯誤 case error: fmt.Printf(\u0026#34;Generic Error: %v\\n\u0026#34;, e) // 處理其他錯誤 default: fmt.Println(\u0026#34;Unknown error.\u0026#34;) } } func processRequest(param int) error { if param == 0 { return \u0026amp;MyError{Code: 500, Message: \u0026#34;Internal Server Error\u0026#34;} } else if param \u0026lt; 0 { return errors.New(\u0026#34;Negative parameter value\u0026#34;) } return nil } 實際應用 1. 檔案操作 場景：讀取檔案時檔案不存在的情況。 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;os\u0026#34; ) func main() { _, err := os.Open(\u0026#34;non_existent_file.txt\u0026#34;) if err != nil { if os.IsNotExist(err) { fmt.Println(\u0026#34;檔案不存在。\u0026#34;) } else { fmt.Println(\u0026#34;錯誤:\u0026#34;, err) } } } 2. 網路通訊 場景：嘗試建立網路連線時timeout的情況。 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;net\u0026#34; \u0026#34;time\u0026#34; ) func main() { _, err := net.DialTimeout(\u0026#34;tcp\u0026#34;, \u0026#34;example.com:8080\u0026#34;, time.Second) if err != nil { fmt.Println(\u0026#34;錯誤:\u0026#34;, err) } } 3. 資料庫操作 場景：執行 SQL 查詢時發生語法錯誤的情況。 package main import ( \u0026#34;database/sql\u0026#34; \u0026#34;fmt\u0026#34; _ \u0026#34;github.com/go-sql-driver/mysql\u0026#34; ) func main() { db, _ := sql.Open(\u0026#34;mysql\u0026#34;, \u0026#34;user:password@tcp(localhost:3306)/database\u0026#34;) _, err := db.Exec(\u0026#34;SELECT * FROM non_existent_table\u0026#34;) if err != nil { fmt.Println(\u0026#34;錯誤:\u0026#34;, err) } } 4. 使用者輸入驗證 場景：驗證使用者輸入是否為數字。 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;strconv\u0026#34; ) func main() { userInput := \u0026#34;abc\u0026#34; _, err := strconv.Atoi(userInput) if err != nil { fmt.Println(\u0026#34;無效的輸入:\u0026#34;, err) } } 5. 異常情況處理 場景：處理不可預見的系統錯誤。 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;os\u0026#34; ) func main() { file, err := os.Open(\u0026#34;/dev/zero\u0026#34;) if err != nil { panic(err) } defer file.Close() fmt.Println(\u0026#34;File opened successfully.\u0026#34;) } 小結 錯誤處理三劍客，error、panic和recover是強大的工具，它能讓你的程式碼更容易讀懂、容易維護，同時也能確保資源被妥善釋放，處理錯誤也更加方便。\n📚Reference Error handling and Go - The Go Programming Language Effective Error Handling in Golang - Earthly Blog [Golang] 錯誤處理 error handling | PJCHENder 未整理筆記 Error handling in Go: Best practices - LogRocket Blog ","permalink":"https://sz9751210.github.io/posts/go-error/","summary":"👨‍💻簡介 在軟體開發中，錯誤無所不在。無論是網路請求失敗、檔案不存在，還是數學計算錯誤，處理錯誤是任何開發者的日常工作，系統的穩定度基本取決於對於錯誤處理是否全面，好的錯誤處理也可以產生適當的錯誤訊息，讓 Debug 更加容易。在Go語言中，有一些獨特的功能在處理錯誤和資源管理方面非常有用。，其中包括error、panic和recover。今天就來介紹這三個關鍵字與錯誤處理的簡單用法。\nError 什麼是Error? 在Go中，Error是一個擁有error interface的類型，可以看到他只有一個方法，該方法主要用來描述一個錯誤的字串。\ntype error interface { Error() string } 如何產生錯誤訊息 errors.New() 使用方式很簡單，在裡面放入要顯示的錯誤訊息 package main import ( \u0026#34;errors\u0026#34; \u0026#34;fmt\u0026#34; ) func main() { err := errors.New(\u0026#34;This is a custom error message\u0026#34;) fmt.Println(err.Error()) // output：This is a custom error message } fmt.Errorf() 主要用在格式化錯誤訊息的情況下 package main import ( \u0026#34;fmt\u0026#34; ) func main() { name := \u0026#34;John\u0026#34; err := fmt.Errorf(\u0026#34;Hello, %s! This is a custom error message\u0026#34;, name) fmt.","title":"錯誤處理的精髓：快速了解Go語言的 error、panic和recover"},{"content":"👨‍💻簡介 當我們在寫程式時，有時候會需要在程式結束時關閉某些資源，而defer這個關鍵字，可以讓你輕鬆的實現，下面來簡單介紹一下defer以及常用的範例。，它為程式設計師提供了一種簡單而強大的工具，用於管理資源和確保程式的正確執行。在本篇文章中，我們將深入探討Go語言中的defer，並提供一些實際的程式碼範例，以幫助你理解它的工作原理以及如何運用它來提高程式的可讀性和可維護性。\n什麼是defer？ defer是一個關鍵字，用來延遲函數的執行，直到包含它的函數執行完畢。這代表你可以在函數中的任何位置使用defer來安排某個操作，並確保它將在函數返回之前執行。defer通常用於執行一些清理或資源回收的操作。\npackage main import \u0026#34;fmt\u0026#34; func main() { defer fmt.Println(\u0026#34;World\u0026#34;) fmt.Print(\u0026#34;Hello, \u0026#34;) } 使用方式也很簡單，在要執行的函數前面加上defer就完成了，所以上面的範例會印出 Hello World\nDefer的特性 延遲執行：defer 語句允許你安排一段程式碼，使它在包含它的函數返回之前執行，無論函數是否正常返回或出現錯誤。\n堆疊特性：多個 defer 語句按照後進先出（LIFO）的順序執行，這意味著最後一個被延遲的語句會最先執行。\npackage main import \u0026#34;fmt\u0026#34; func main() { fmt.Println(\u0026#34;Start\u0026#34;) defer fmt.Println(\u0026#34;Deferred 1\u0026#34;) defer fmt.Println(\u0026#34;Deferred 2\u0026#34;) fmt.Println(\u0026#34;End\u0026#34;) } 根據defer特性的後進先出，輸出會是下面這個樣子\nStart End Deferred 2 Deferred 1 Defer的限制 延遲的函數必須是無參數函數：你只能延遲無參數的函數調用，因為 defer 不允許傳遞參數。\n順序性：defer 語句的效果在函數內是有限定範圍的，它只在包含它的函數範圍內有效，無法跨函數使用。\n常見用法 資源清理 最常見的用途之一是在函數返回前關閉文件、釋放鎖、關閉資料庫連接等，以確保資源被正確釋放。\nfunc readFile(filename string) (string, error) { file, err := os.Open(filename) if err != nil { return \u0026#34;\u0026#34;, err } defer file.Close() // 讀取文件內容 // ... return content, nil } 在上述範例中，defer 用於確保文件在函數返回之前被正確關閉。\n記錄錯誤 **：defer 可以用於處理錯誤，例如記錄錯誤訊息或回滾交易，並確保它們不會被遺漏。\nfunc doSomething() error { err := performOperation() if err != nil { defer logError(err) } // 其他操作 return nil } func logError(err error) { fmt.Println(\u0026#34;Error:\u0026#34;, err) } 在上述範例中，defer 用於記錄錯誤，無論函數是否正常返回。\n小結 defer是Go語言中一個強大的功能，通常在撰寫對db的連接時我都會在下一行使用defer進行db的關閉連接，確保這些操作在函數返回之前執行。這使得程式更容易閱讀和維護，並有助於避免資源洩漏等問題，它可用於資源管理、錯誤處理和性能優化等多種情況下，提高程式的可讀性和可維護性。\n📚Reference A Tour of Go(defer) [Golang] Defer, Panic 和 Recovery | PJCHENder 未整理筆記 ","permalink":"https://sz9751210.github.io/posts/go-defer/","summary":"👨‍💻簡介 當我們在寫程式時，有時候會需要在程式結束時關閉某些資源，而defer這個關鍵字，可以讓你輕鬆的實現，下面來簡單介紹一下defer以及常用的範例。，它為程式設計師提供了一種簡單而強大的工具，用於管理資源和確保程式的正確執行。在本篇文章中，我們將深入探討Go語言中的defer，並提供一些實際的程式碼範例，以幫助你理解它的工作原理以及如何運用它來提高程式的可讀性和可維護性。\n什麼是defer？ defer是一個關鍵字，用來延遲函數的執行，直到包含它的函數執行完畢。這代表你可以在函數中的任何位置使用defer來安排某個操作，並確保它將在函數返回之前執行。defer通常用於執行一些清理或資源回收的操作。\npackage main import \u0026#34;fmt\u0026#34; func main() { defer fmt.Println(\u0026#34;World\u0026#34;) fmt.Print(\u0026#34;Hello, \u0026#34;) } 使用方式也很簡單，在要執行的函數前面加上defer就完成了，所以上面的範例會印出 Hello World\nDefer的特性 延遲執行：defer 語句允許你安排一段程式碼，使它在包含它的函數返回之前執行，無論函數是否正常返回或出現錯誤。\n堆疊特性：多個 defer 語句按照後進先出（LIFO）的順序執行，這意味著最後一個被延遲的語句會最先執行。\npackage main import \u0026#34;fmt\u0026#34; func main() { fmt.Println(\u0026#34;Start\u0026#34;) defer fmt.Println(\u0026#34;Deferred 1\u0026#34;) defer fmt.Println(\u0026#34;Deferred 2\u0026#34;) fmt.Println(\u0026#34;End\u0026#34;) } 根據defer特性的後進先出，輸出會是下面這個樣子\nStart End Deferred 2 Deferred 1 Defer的限制 延遲的函數必須是無參數函數：你只能延遲無參數的函數調用，因為 defer 不允許傳遞參數。\n順序性：defer 語句的效果在函數內是有限定範圍的，它只在包含它的函數範圍內有效，無法跨函數使用。\n常見用法 資源清理 最常見的用途之一是在函數返回前關閉文件、釋放鎖、關閉資料庫連接等，以確保資源被正確釋放。\nfunc readFile(filename string) (string, error) { file, err := os.Open(filename) if err != nil { return \u0026#34;\u0026#34;, err } defer file.","title":"Go語言的defer：確保後置操作的執行"},{"content":"👨‍💻簡介 在Go中，假如我要判斷一個資料類型是甚麼，該怎麼做呢? Golang有一個功能叫做Type Assertions（類型斷言），它的作用就是能夠在運行時檢查我的資料類型，讓我在傳遞類型時能確保資料類型是正確的。\nType Assertions 的基本概念 在Go中，Type Assertions的主要目的是在運行時將 interface 型別的值轉換為特定的實際型別。interface 是一種特殊的類型，它可以保存任何值的實例，但在運行時，我們可能需要確定該值的實際類型以執行相應的操作，以確保我們能夠安全地操作資料，這就是Type Assertions的作用。\nType Assertions的基本語法如下：\nvalue, ok := someInterface.(T) 這個表達式意思為將someInterface轉換為類型T。如果成功，它將value設置為轉換後的值，並將ok設置為true。如果轉換失敗，則value將是零值，而ok將是false。\nType Assertions的用途 Type Assertions 的主要用途包括：\n資料型別的轉換 當我們處理interface型別的資料時，可能需要將其轉換為具體的型別，以便進行特定操作。\nfunc process(someInterface interface{}) { if str, ok := someInterface.(string); ok { // 將interfacce轉換為string類型並進行操作 fmt.Printf(\u0026#34;Length of string: %d\\n\u0026#34;, len(str)) } else { fmt.Println(\u0026#34;Not a string\u0026#34;) } } 確保型別的正確性 使用 Type Assertions，我們可以在執行特定操作之前，確保資料的型別是我們期望的。這有助於防止因型別錯誤而引發的執行時錯誤。\nif val, ok := someInterface.(int); ok { // someInterface 是一個int類型 fmt.Printf(\u0026#34;Value is an int: %d\\n\u0026#34;, val) } else { // someInterface 不是一個int類型 fmt.Println(\u0026#34;Value is not an int\u0026#34;) } 在接口值中存儲額外信息 Type Assertions還可用於在interface中儲存額外的資料，這些資料只在特定類型時才可用。 以下程式碼使用Type Assertions 和 switch 來處理不同的struct\ntype Circle struct { Radius float64 } type Square struct { SideLength float64 } func printArea(shape interface{}) { switch val := shape.(type) { case Circle: area := 3.14159265359 * val.Radius * val.Radius fmt.Printf(\u0026#34;Area of the circle: %f\\n\u0026#34;, area) case Square: area := val.SideLength * val.SideLength fmt.Printf(\u0026#34;Area of the square: %f\\n\u0026#34;, area) default: fmt.Println(\u0026#34;Unknown shape\u0026#34;) } } Type Assertions 的實際應用 以下簡單介紹實際應用情況：\nJSON 解碼：當解碼 JSON 資料時，通常會解碼為 map[string]interface{} 或 []interface{}，這些 interface 型別可以讓我們能夠動態處理資料，但有時我們需要將它們轉換為具體的 struct，以便更方便地使用。 package main import ( \u0026#34;encoding/json\u0026#34; \u0026#34;fmt\u0026#34; ) type Person struct { Name string Age int } func main() { jsonData := `{\u0026#34;Name\u0026#34;: \u0026#34;Alice\u0026#34;, \u0026#34;Age\u0026#34;: 30}` var data interface{} err := json.Unmarshal([]byte(jsonData), \u0026amp;data) if err != nil { fmt.Println(\u0026#34;JSON 解碼失敗:\u0026#34;, err) return } // 使用 Type Assertions 將介面型別轉換為結構體型別 if person, ok := data.(map[string]interface{}); ok { name := person[\u0026#34;Name\u0026#34;].(string) age := int(person[\u0026#34;Age\u0026#34;].(float64)) fmt.Printf(\u0026#34;Name: %s, Age: %d\\n\u0026#34;, name, age) } else { fmt.Println(\u0026#34;資料型別不是預期的 map[string]interface{}\u0026#34;) } } 可以看到，我們首先解碼了一個 JSON 字串，並儲存在一個 interface 型別的變數 data 中。然後，我們使用 Type Assertions 將 data 斷言為 map[string]interface{} 型別，讓我們能夠訪問其中的字段。\n反射（Reflection）： reflect 通常用於檢查和操作變數、struct 和 interface 型別的訊息。 在某些情況下，Type Assertions 在reflect 過程中經常派上用場，用於確認 interface 型別的實際內容。 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;reflect\u0026#34; ) func main() { var x interface{} = 42 // 使用 Type Assertions 檢查實際型別 if val, ok := x.(int); ok { fmt.Printf(\u0026#34;x 是一個整數，值為：%d\\n\u0026#34;, val) } else { fmt.Println(\u0026#34;x 不是一個整數\u0026#34;) } // 使用 reflect 獲取型別信息 t := reflect.TypeOf(x) fmt.Printf(\u0026#34;x 的實際型別是：%s\\n\u0026#34;, t) } 在這個範例中，我們首先使用 Type Assertions 檢查 x 的實際型別，然後使用 reflect 獲取型別信息。Type Assertions 確保了我們在確定型別後才能安全地訪問 val 變數。\nType Assertions 使用時的注意事項 在使用 Type Assertions 時，有些注意事項有助於確保程式碼如預期運作，並減少潛在的執行時錯誤。\n始終檢查 ok 值：當進行 Type Assertions 時，無論如何都應該始終檢查 ok 值。這是確保轉換成功的關鍵。如果 ok 的值為 false，代表斷言失敗，你應該採取適當的錯誤處理措施，而不是假設轉換已成功。\n使用 switch 語句：當處理多種可能的資料型別時，最好使用 switch 語句來進行 Type Assertions。這樣做的好處是，它使你的程式碼更具可讀性，並且更容易擴展。每個 case 子句可以處理一種特定的型別，讓程式邏輯清晰明瞭。\n避免過多的 Type Assertions：過多的 Type Assertions 可能是程式設計上的警號，可能表示你的設計存在問題。儘量避免在程式碼中過多使用 Type Assertions，而是考慮使用 interface 和多態性來實現更優雅的設計。正確的 interface 設計可以減少對 Type Assertions 的需求，使程式碼更加簡潔且易於維護。\n小結 Go 語言的 Type Assertions 讓我們能夠更好地處理不同資料型別的情況，同時保持程式的可讀性和安全性。無論是在處理 JSON 數據、實現 reflect 功能，Type Assertions 都是一個不可或缺的功能，有助於 Go 語言的應用程式開發更加靈活和強大。\n📚Reference A Tour of Go(Type Assertions) Type Assertions in Golang - GeeksforGeeks Golang 筆記 — Type Assertion | Kalan\u0026rsquo;s Blog ","permalink":"https://sz9751210.github.io/posts/go-type-assertion/","summary":"👨‍💻簡介 在Go中，假如我要判斷一個資料類型是甚麼，該怎麼做呢? Golang有一個功能叫做Type Assertions（類型斷言），它的作用就是能夠在運行時檢查我的資料類型，讓我在傳遞類型時能確保資料類型是正確的。\nType Assertions 的基本概念 在Go中，Type Assertions的主要目的是在運行時將 interface 型別的值轉換為特定的實際型別。interface 是一種特殊的類型，它可以保存任何值的實例，但在運行時，我們可能需要確定該值的實際類型以執行相應的操作，以確保我們能夠安全地操作資料，這就是Type Assertions的作用。\nType Assertions的基本語法如下：\nvalue, ok := someInterface.(T) 這個表達式意思為將someInterface轉換為類型T。如果成功，它將value設置為轉換後的值，並將ok設置為true。如果轉換失敗，則value將是零值，而ok將是false。\nType Assertions的用途 Type Assertions 的主要用途包括：\n資料型別的轉換 當我們處理interface型別的資料時，可能需要將其轉換為具體的型別，以便進行特定操作。\nfunc process(someInterface interface{}) { if str, ok := someInterface.(string); ok { // 將interfacce轉換為string類型並進行操作 fmt.Printf(\u0026#34;Length of string: %d\\n\u0026#34;, len(str)) } else { fmt.Println(\u0026#34;Not a string\u0026#34;) } } 確保型別的正確性 使用 Type Assertions，我們可以在執行特定操作之前，確保資料的型別是我們期望的。這有助於防止因型別錯誤而引發的執行時錯誤。\nif val, ok := someInterface.(int); ok { // someInterface 是一個int類型 fmt.Printf(\u0026#34;Value is an int: %d\\n\u0026#34;, val) } else { // someInterface 不是一個int類型 fmt.","title":"保證型別安全：使用Go的Type Assertions避免型別錯誤"},{"content":"👨‍💻簡介 make函數在slice、map和之後會介紹到的channel的初始化中扮演著關鍵的角色。本文將會簡單介紹make函數的用法，以及在初始化不同資料結構時的差異，讓你更好地理解和利用make函數。\nmake函數基本概念 首先，讓我們來了解一下make函數的基本概念。在Go中，make函數用於動態分配記憶體並初始化slice、map和channel。\n// 創建一個切片，長度為5，容量為10 mySlice := make([]int, 5, 10) 在上面的範例中，我們使用make函數創建了一個整數切片（slice），其長度為5，容量為10。這意味著切片可以容納5個元素，但它的底層陣列的容量是10，這為後續的操作提供了一定的靈活性。\nmake函數的語法 make函數的語法相對簡單。它的一般形式是：\nmake(類型, 長度, 容量) 類型：指定要創建的資料類型，可以是切片、map或通道。 長度：表示資料結構的初始長度。 容量：只適用於切片和通道，表示底層陣列的容量。 使用make初始化切片 接下來，讓我們看看如何使用make函數初始化切片。\n// 創建一個整數切片，長度為3，容量為5 mySlice := make([]int, 3, 5) mySlice[0] = 1 mySlice[1] = 2 mySlice[2] = 3 在這個例子中，我們首先使用make函數創建了一個長度為3、容量為5的整數切片。然後，我們分配了三個整數值到切片中。\n使用make初始化Map 現在，讓我們看看如何使用make函數初始化Map。map是一種鍵值對的資料結構，非常適合用於存儲關聯性資料。\n// 創建一個字符串到整數的map myMap := make(map[string]int) myMap[\u0026#34;apple\u0026#34;] = 1 myMap[\u0026#34;banana\u0026#34;] = 2 myMap[\u0026#34;cherry\u0026#34;] = 3 在這個範例中，我們使用make函數創建了一個空的字符串到整數的map，然後添加了三個鍵值對。\nmake 函數在 Go 語言中常見用法包括初始化切片、map和通道。然而，它的使用也受到一些限制和約束。以下是 make 函數的常見用法以及相關的使用限制：\n使用make初始化通道 最後，我們來看看如何使用make函數初始化通道。通道是Go語言中用於並發通信的重要機制。\n// 創建一個通道，用於傳輸字符串資料 myChannel := make(chan string) go func() { myChannel \u0026lt;- \u0026#34;Hello\u0026#34; myChannel \u0026lt;- \u0026#34;World\u0026#34; }() 在這個例子中，我們使用make函數創建了一個通道，它可以傳輸字符串資料。然後，我們使用Go協程向通道發送了兩個字符串。\n使用限制 只能用於切片、map和通道：make 函數只能用於初始化切片、map和通道，不能用於其他資料類型或自定義類型的初始化。\n切片容量必須大於等於長度：在使用 make 初始化切片時，切片的容量必須大於等於長度。否則，會導致運行時錯誤。\n// 正確的範例 mySlice := make([]int, 5, 10) // 錯誤的範例，容量小於長度 mySlice := make([]int, 10, 5) // 這會導致運行時錯誤 Map無需指定容量：與切片不同，map的容量無需顯示指定，因為map會根據需要動態擴展。\nmyMap := make(map[string]int) // 正確的初始化map，無需指定容量 通道的容量是可選的：通道的容量是可選的，你可以選擇在創建通道時指定容量，也可以不指定。\nmyChannel := make(chan int) // 創建一個無緩衝通道 myBufferedChannel := make(chan int, 10) // 創建一個有緩衝容量為 10 的通道 通道需要關閉：如果你使用 make 創建的通道，需要負責在適當的時候關閉通道，以避免死鎖。\nclose(myChannel) make 函數是 Go 語言中用於初始化切片、map和通道的重要工具，但它有一些使用限制，需要按照上述規則使用，以確保程序的正確性和性能。\nmake函數的注意事項 在使用make函數時，有一些注意事項。首先，要確保選擇適當的長度和容量，以避免不必要的記憶體浪費。其次，根據你的需求，選擇切片、map或通道來存儲和處理資料。最後，記得釋放不再使用的資料結構，以避免記憶體洩漏。\n📚Reference A Tour of Go(make) Golang Make Function - Initializing Slices, Maps, and Channels (Size and Capacity) (sohamkamani.com) ","permalink":"https://sz9751210.github.io/posts/go-make/","summary":"👨‍💻簡介 make函數在slice、map和之後會介紹到的channel的初始化中扮演著關鍵的角色。本文將會簡單介紹make函數的用法，以及在初始化不同資料結構時的差異，讓你更好地理解和利用make函數。\nmake函數基本概念 首先，讓我們來了解一下make函數的基本概念。在Go中，make函數用於動態分配記憶體並初始化slice、map和channel。\n// 創建一個切片，長度為5，容量為10 mySlice := make([]int, 5, 10) 在上面的範例中，我們使用make函數創建了一個整數切片（slice），其長度為5，容量為10。這意味著切片可以容納5個元素，但它的底層陣列的容量是10，這為後續的操作提供了一定的靈活性。\nmake函數的語法 make函數的語法相對簡單。它的一般形式是：\nmake(類型, 長度, 容量) 類型：指定要創建的資料類型，可以是切片、map或通道。 長度：表示資料結構的初始長度。 容量：只適用於切片和通道，表示底層陣列的容量。 使用make初始化切片 接下來，讓我們看看如何使用make函數初始化切片。\n// 創建一個整數切片，長度為3，容量為5 mySlice := make([]int, 3, 5) mySlice[0] = 1 mySlice[1] = 2 mySlice[2] = 3 在這個例子中，我們首先使用make函數創建了一個長度為3、容量為5的整數切片。然後，我們分配了三個整數值到切片中。\n使用make初始化Map 現在，讓我們看看如何使用make函數初始化Map。map是一種鍵值對的資料結構，非常適合用於存儲關聯性資料。\n// 創建一個字符串到整數的map myMap := make(map[string]int) myMap[\u0026#34;apple\u0026#34;] = 1 myMap[\u0026#34;banana\u0026#34;] = 2 myMap[\u0026#34;cherry\u0026#34;] = 3 在這個範例中，我們使用make函數創建了一個空的字符串到整數的map，然後添加了三個鍵值對。\nmake 函數在 Go 語言中常見用法包括初始化切片、map和通道。然而，它的使用也受到一些限制和約束。以下是 make 函數的常見用法以及相關的使用限制：\n使用make初始化通道 最後，我們來看看如何使用make函數初始化通道。通道是Go語言中用於並發通信的重要機制。\n// 創建一個通道，用於傳輸字符串資料 myChannel := make(chan string) go func() { myChannel \u0026lt;- \u0026#34;Hello\u0026#34; myChannel \u0026lt;- \u0026#34;World\u0026#34; }() 在這個例子中，我們使用make函數創建了一個通道，它可以傳輸字符串資料。然後，我們使用Go協程向通道發送了兩個字符串。","title":"從零開始：使用make函數創建資料結構"},{"content":"👨‍💻簡介 套件（Package）在Golang中扮演著組織和管理程式碼的重要角色。\npackage就像工具箱一樣，裡面裝滿各種不同的工具，每個工具都有特定的功能。這些工具能夠幫助你完成不同的任務，從修理家具到蓋小屋，樣樣都行。\n今天這篇文章將快速瞭解 Golang 的package，學習如何建立package、匯入package以及一些使用技巧。\n什麼是 Package？ 在 Golang 中，Package 是一種組織程式碼的方式，它將相關的函式、變數和資源放在一個目錄中。這不僅有助於保持程式碼的整潔，還能讓我們更容易地重複使用程式碼。\nPackage 名稱與資料夾名稱的一致性 通常建議在建立package時，將package名稱與所在資料夾名稱保持一致，這樣有助於提高程式碼的可讀性和一致性。Golang 的匯入機制是基於package的 import 路徑來識別package，而 import 路徑通常會反映package的資料夾結構。這種一致性可以讓其他開發人員更容易理解你的程式碼，並且不需要額外的查找工作，因為package的名稱與資料夾名稱一致。\n舉例來說，假設你的資料夾結構如下：\nproject/ |-- greetings/ | |-- greetings.go | |-- main/ | |-- main.go 如果我們建立的package名稱為 greetings，我們可以在 greetings.go 中這樣定義：\n// greetings.go package greetings func Hello(name string) string { return \u0026#34;Hello, \u0026#34; + name } 然後在 main.go 中使用這個package：\n// main.go package main import ( \u0026#34;fmt\u0026#34; \u0026#34;your/project/path/greetings\u0026#34; ) func main() { message := greetings.Hello(\u0026#34;Alan\u0026#34;) fmt.Println(message) } 在這個例子中，我們建立的package名稱 greetings 與所在資料夾名稱相同，確保匯入的時候路徑是一致的。\n建立 Package 建立一個 Package之前，首先，我們需要創建一個目錄，我們取名叫 greetings：\n在你的工作目錄底下創建一個新資料夾：greetings 在 greetings 資料夾中，創建一個名為 greetings.go 的檔案 // greetings/greetings.go package greetings import \u0026#34;fmt\u0026#34; func SayHello(name string) { fmt.Println(\u0026#34;Hello, \u0026#34; + name + \u0026#34;!\u0026#34;) } 可以看到，我們在 greetings 中建立了一個 SayHello 函式，讓我們可以打個招呼。\n使用 Package 現在我們已經建立完 Package，讓我們來看看如何使用它：\n使用 go mod init xxx 初始化專案以設定路徑，假設這邊是叫demo 創建一個名為 main.go 的檔案，放在與 greetings 資料夾不同的目錄下。 編寫以下程式碼： // main.go package main import \u0026#34;demo/greetings\u0026#34; func main() { greetings.SayHello(\u0026#34;Alan\u0026#34;) } 在main.go直接使用 greetings.SayHello 函式來印出hello到終端。\n最後，我們可以在終端中執行我們的程式：\ngo run main.go 你應該會在終端看到輸出的問候訊息：「Hello, Alan」\n到這裡已經成功地創建了一個 Golang 的 Package，並在自己的程式中使用它。\npackage的可見性 Golang 中的package成員有可導出（Exported）和不可導出（Unexported）之分。首字母大寫的成員是可導出的，其他package可以存取它們；而首字母小寫的成員則是不可導出的，僅在同一package內可見。以下是一個示例：\n// greetings/greetings.go package greetings func sayHi(name string) { fmt.Println(\u0026#34;Hi, \u0026#34; + name + \u0026#34;!\u0026#34;) } 在這個範例中，sayHi 是不可導出的，無法在其他package中使用。\n匯入package 匯入多個package 你可以使用括號匯入多個package，以提高程式碼的可讀性：\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;your/project/path/greetings\u0026#34; \u0026#34;your/project/path/utils\u0026#34; ) func main() { greetings.SayHello(\u0026#34;Alan\u0026#34;) fmt.Println(\u0026#34;Cube of 3:\u0026#34;, utils.Cube(3)) } package別名 當我們引入一個package時，我們可以為該package指定一個別名。這對於解決名稱衝突或縮短package名稱都很有用。\nimport mygreetings \u0026#34;your/project/path/greetings\u0026#34; 使用方式也很簡單，在package前面加上別名即可\n接著調用函式如下\nfunc main() { mygreetings.SayHello(\u0026#34;Alan\u0026#34;) } 這樣，你就可以使用 mygreetings 作為 greetings package的別名，以更簡潔的方式訪問package中的函式。\n這個方式尤其在當你的專案中有多個package需要引入時很有用，因為它可以幫助你更好地管理package的命名空間。\n匿名package 假設你的 greetings package路徑仍然是 your/project/path/greetings，你可以引入它並使用匿名package，如下所示：\nimport _ \u0026#34;your/project/path/greetings\u0026#34; 可以看到，我們使用 _ 作為匿名package的名稱，這表示我們不打算在程式碼中直接使用 greetings package的名稱，但我們希望它執行package初始化的工作。\n在這種情況下，你不需要在後續的程式碼中使用 greetings package的名稱，而package初始化的工作仍然會執行，如果 greetings package具有初始化邏輯（init 函式），那麼它將在引入時運行。\n在某些情況下，你可能希望引入一個package，但你不打算在你的程式碼中直接使用該package中的函式或資源。相反，你只對package的一些「副作用」或初始化操作感興趣。這些初始化操作可能包括設置全局變數、執行某些初始化函式或設定package的配置。\n使用匿名package的方式，你可以引入package，使它執行初始化操作，但你不需要在你的程式碼中使用它的功能。這就是「只關心副作用」的意思。你不需要直接與package的功能交互，只是希望package在你的程式啟動時執行某些操作，然後你的程式可以繼續運行。\n舉個例子，假設你有一個package，它在初始化時設置了一個全局的日誌記錄器，但你的主程式不需要直接使用這個日誌記錄器。你可以使用匿名package的方式引入這個package，這樣它會在程式啟動時設置日誌記錄器，而你的程式可以繼續執行自己的邏輯，而不必直接與日誌package交互。\npackage的版本控制 管理package的版本是非常重要的。你可以使用 go get 命令安裝package並更新版本：\ngo get -u your/project/path/greetings package的佈署與分享 如果你想分享你的package給其他人，你可以將package的原始碼上傳至版本控制系統，如 GitHub。其他人可以透過 go get 命令來安裝並使用你的package。\n小結 package在 Golang 中扮演著組織程式碼、重複使用程式碼的重要角色。透過本文，我們學習了建立package、匯入package以及一些使用技巧，希望能幫助你更深入地理解 Golang 的package世界！\n📚Reference Packages — An Introduction to Programming in Go | Go Resources (golang-book.com) Managing dependencies - The Go Programming Language Go Packages (With Examples) (programiz.com) [Golang] Modules and Packages | PJCHENder 未整理筆記 ","permalink":"https://sz9751210.github.io/posts/go-package/","summary":"👨‍💻簡介 套件（Package）在Golang中扮演著組織和管理程式碼的重要角色。\npackage就像工具箱一樣，裡面裝滿各種不同的工具，每個工具都有特定的功能。這些工具能夠幫助你完成不同的任務，從修理家具到蓋小屋，樣樣都行。\n今天這篇文章將快速瞭解 Golang 的package，學習如何建立package、匯入package以及一些使用技巧。\n什麼是 Package？ 在 Golang 中，Package 是一種組織程式碼的方式，它將相關的函式、變數和資源放在一個目錄中。這不僅有助於保持程式碼的整潔，還能讓我們更容易地重複使用程式碼。\nPackage 名稱與資料夾名稱的一致性 通常建議在建立package時，將package名稱與所在資料夾名稱保持一致，這樣有助於提高程式碼的可讀性和一致性。Golang 的匯入機制是基於package的 import 路徑來識別package，而 import 路徑通常會反映package的資料夾結構。這種一致性可以讓其他開發人員更容易理解你的程式碼，並且不需要額外的查找工作，因為package的名稱與資料夾名稱一致。\n舉例來說，假設你的資料夾結構如下：\nproject/ |-- greetings/ | |-- greetings.go | |-- main/ | |-- main.go 如果我們建立的package名稱為 greetings，我們可以在 greetings.go 中這樣定義：\n// greetings.go package greetings func Hello(name string) string { return \u0026#34;Hello, \u0026#34; + name } 然後在 main.go 中使用這個package：\n// main.go package main import ( \u0026#34;fmt\u0026#34; \u0026#34;your/project/path/greetings\u0026#34; ) func main() { message := greetings.Hello(\u0026#34;Alan\u0026#34;) fmt.","title":"Package：Golang 專案的組織策略"},{"content":"👨‍💻簡介 在Go語言中，Interface 是一個重要且強大的概念。Interface提供了一種方式來定義對象之間的契約，讓你可以設計更具有靈活性和可擴展性的程式碼。 你可以把Interface想像成是一種約定，讓不同的東西彼此溝通的方式變得特別靈活和好擴充，告訴程式裡的各個元件彼此要怎麼合作。\n什麼是Interface 在 Go 語言中，Interface是一種關鍵的概念，用於定義方法的契約，而不關心具體的實現。它是一種抽象的型別，描述了物件應該具備的方法。Interface在實現多態性、抽象和模組化設計等方面扮演著重要角色。\nInterface是一種抽象的類型，它定義了一組方法簽名（method signatures），但不包含方法的實際實現。這些方法簽名定義了對象應該支援的操作，從而允許不同類型的對象實現同一個Interface並進行交互。\n一聽可能有點高深，但其實它就像是一份約定，不管實際怎麼做，只要能遵循這份約定就行。\n就好像你和朋友約好要出去玩，你們約定好一起出門、一起玩，但具體怎麼玩，是不是吃火鍋還是去唱歌，那就隨你們。這些約定就是你們的「Interface」，告訴大家「我們一起要做這些事情！」。\n當然，這在程式碼裡的作用更大。透過這個「Interface」，你可以讓不同種類的東西，像是車、狗、電腦，都能夠用一樣的方式進行互動。不管是車、狗、還是電腦，只要符合了這個「Interface」約定的方法，你就可以放心地拿來用了。\nInterface的基本使用 透過Interface，我們可以在不關心具體類型的情況下，對對象進行操作。這種多態性的概念讓程式碼更具彈性，能夠適應不同的實現。\n// 定義一個Interface Shape，它具有一個 Area 方法 type Shape Interface { Area() float64 } // 定義一個 Circle 結構體，實現了 Shape Interface的 Area 方法 type Circle struct { Radius float64 } func (c Circle) Area() float64 { return 3.14 * c.Radius * c.Radius } // 定義一個 Rectangle 結構體，實現了 Shape Interface的 Area 方法 type Rectangle struct { Width, Height float64 } func (r Rectangle) Area() float64 { return r.Width * r.Height } func PrintArea(s Shape) { fmt.Println(\u0026#34;Area:\u0026#34;, s.Area()) } func main() { circle := Circle{Radius: 3} rectangle := Rectangle{Width: 4, Height: 5} PrintArea(circle) // 輸出：Area: 28.26 PrintArea(rectangle) // 輸出：Area: 20 } 類型斷言（Type Assertion） 在Interface中，使用類型斷言可以將Interface值轉換為具體型別，以便使用該型別的方法。\nfunc PrintSpecificArea(s Shape) { if circle, ok := s.(Circle); ok { fmt.Println(\u0026#34;Circle Area:\u0026#34;, circle.Area()) } else if rectangle, ok := s.(Rectangle); ok { fmt.Println(\u0026#34;Rectangle Area:\u0026#34;, rectangle.Area()) } } func main() { circle := Circle{Radius: 3} rectangle := Rectangle{Width: 4, Height: 5} PrintSpecificArea(circle) // 輸出：Circle Area: 28.26 PrintSpecificArea(rectangle) // 輸出：Rectangle Area: 20 } 空Interface 什麼是空Interface？ 在 Go 語言中，空Interface是一個不包含任何方法簽名的Interface，因此它可以表示任意型別的值。由於空Interface不包含方法，所以任何型別都可以隱式地滿足空Interface。這種特性使得空Interface在需要處理多種型別的場景中非常有用。\n空Interface是一個不包含任何方法的Interface，因此可以代表任何類型的值。透過類型斷言，我們可以將空Interface轉換為特定類型並進行操作。\n空Interface的定義和使用 // 定義一個空Interface type EmptyInterface Interface{} func main() { // 空Interface可以存儲任何型別的值 var val1 EmptyInterface = 42 var val2 EmptyInterface = \u0026#34;Hello, Go!\u0026#34; var val3 EmptyInterface = []int{1, 2, 3} fmt.Println(val1) // 輸出：42 fmt.Println(val2) // 輸出：Hello, Go! fmt.Println(val3) // 輸出：[1 2 3] } 空Interface的類型斷言 由於空Interface可以存儲任意型別的值，我們在需要使用這些值時通常需要進行類型斷言。\nfunc PrintTypeAndValue(val EmptyInterface) { switch v := val.(type) { case int: fmt.Println(\u0026#34;Type: int, Value:\u0026#34;, v) case string: fmt.Println(\u0026#34;Type: string, Value:\u0026#34;, v) case []int: fmt.Println(\u0026#34;Type: []int, Value:\u0026#34;, v) default: fmt.Println(\u0026#34;Unknown Type\u0026#34;) } } func main() { val1 := 42 val2 := \u0026#34;Hello, Go!\u0026#34; val3 := []int{1, 2, 3} PrintTypeAndValue(val1) // 輸出：Type: int, Value: 42 PrintTypeAndValue(val2) // 輸出：Type: string, Value: Hello, Go! PrintTypeAndValue(val3) // 輸出：Type: []int, Value: [1 2 3] } 在這個範例中，我們定義了一個函式 PrintTypeAndValue，並且使用了類型斷言來檢查空Interface中存儲的值的實際型別，並根據不同的型別進行不同的處理。\nInterface的內嵌與組合 在Go中，你可以將一個或多個Interface內嵌在另一個Interface中，這種方式可以實現更強大的Interface組合。\ntype ReadWrite Interface { Reader Writer } type Reader Interface { Read(data []byte) (int, error) } type Writer Interface { Write(data []byte) (int, error) } 實際案例分析 透過Interface，我們可以實現不同資料庫驅動，讓程式碼能夠適應不同的資料庫引擎。\ntype Database Interface { Connect() Query(query string) []byte Disconnect() } type MySQL struct { // ... } func (m MySQL) Connect() { // ... } func main() { db := MySQL{} db.Connect() defer db.Disconnect() data := db.Query(\u0026#34;SELECT * FROM users\u0026#34;) fmt.Println(\u0026#34;Data:\u0026#34;, string(data)) } Interface的特性與應用場景 Interface的特性 方法集合： Interface定義了一組方法，描述了物件的操作。 隱式實現： 符合方法集合的型別被視為該Interface的實現。 多重實現： 一個型別可以實現多個Interface。 類型轉換： 可以將實現了Interface的型別存儲在該Interface類型的變數中。 動態分派： 使用動態分派實現多態性。 空Interface： 空Interface Interface{} 可表示任意型別的值。 可嵌入的Interface： Interface可嵌入在另一個Interface中，實現方法的合併。 Interface的應用場景 多態性操作： Interface允許不同型別實現相同方法，從而以統一的方式處理多種型別的資料。 package main import ( \u0026#34;fmt\u0026#34; ) type Shape Interface { Area() float64 } type Circle struct { Radius float64 } func (c Circle) Area() float64 { return 3.14 * c.Radius * c.Radius } type Rectangle struct { Width, Height float64 } func (r Rectangle) Area() float64 { return r.Width * r.Height } func PrintArea(s Shape) { fmt.Println(\u0026#34;Area:\u0026#34;, s.Area()) } func main() { circle := Circle{Radius: 3} rectangle := Rectangle{Width: 4, Height: 5} PrintArea(circle) // 輸出：Area: 28.26 PrintArea(rectangle) // 輸出：Area: 20 } 抽象和模組化設計： Interface可以定義模組間的契約，實現模組化和解耦合的程式設計。 package main import ( \u0026#34;fmt\u0026#34; ) type PaymentGateway Interface { Pay(amount float64) bool } type CreditCard struct { CardNumber string Expiration string CVV string } func (c CreditCard) Pay(amount float64) bool { fmt.Println(\u0026#34;Paying with credit card:\u0026#34;, amount) return true } type PayPal struct { Username string Password string } func (p PayPal) Pay(amount float64) bool { fmt.Println(\u0026#34;Paying with PayPal:\u0026#34;, amount) return true } func ProcessPayment(pg PaymentGateway, amount float64) { pg.Pay(amount) } func main() { creditCard := CreditCard{} payPal := PayPal{} ProcessPayment(creditCard, 100.0) // 使用信用卡支付 ProcessPayment(payPal, 50.0) // 使用 PayPal 支付 } 測試和模擬： 使用Interface可以更容易進行測試，因為可以創建模擬的實現來模擬不同的情況。這有助於單元測試和集成測試，從而提高代碼的質量。 package main import ( \u0026#34;fmt\u0026#34; ) type Database Interface { Query(query string) string } type MySQL struct { // ... } func (m MySQL) Query(query string) string { return \u0026#34;MySQL: \u0026#34; + query } type MockDatabase struct { Response string } func (m MockDatabase) Query(query string) string { return m.Response } func GetData(db Database, query string) string { return db.Query(query) } func main() { mysql := MySQL{} mockDB := MockDatabase{Response: \u0026#34;Mock Data\u0026#34;} fmt.Println(GetData(mysql, \u0026#34;SELECT * FROM table\u0026#34;)) // 使用 MySQL 取得資料 fmt.Println(GetData(mockDB, \u0026#34;SELECT * FROM table\u0026#34;)) // 使用模擬資料取得資料 } 常見錯誤與疑難排解 Interface未實現的錯誤：確保所有Interface方法都在結構中得到實現。 型別斷言導致的執行時錯誤：使用型別斷言前，應確保類型匹配，可以使用型別斷言的「comma, ok」慣用法。 複雜Interface結構帶來的困難與解決策略：保持Interface結構的簡單性，避免過度複雜的組合。 📚Reference A Tour of Go(Interface) Go by Example: Interfaces [Golang] Interfaces | PJCHENder 未整理筆記 Golang - 深入理解 Interface 常見用法 | Kenny\u0026rsquo;s Blog (kennycoder.io) ","permalink":"https://sz9751210.github.io/posts/go-interface/","summary":"👨‍💻簡介 在Go語言中，Interface 是一個重要且強大的概念。Interface提供了一種方式來定義對象之間的契約，讓你可以設計更具有靈活性和可擴展性的程式碼。 你可以把Interface想像成是一種約定，讓不同的東西彼此溝通的方式變得特別靈活和好擴充，告訴程式裡的各個元件彼此要怎麼合作。\n什麼是Interface 在 Go 語言中，Interface是一種關鍵的概念，用於定義方法的契約，而不關心具體的實現。它是一種抽象的型別，描述了物件應該具備的方法。Interface在實現多態性、抽象和模組化設計等方面扮演著重要角色。\nInterface是一種抽象的類型，它定義了一組方法簽名（method signatures），但不包含方法的實際實現。這些方法簽名定義了對象應該支援的操作，從而允許不同類型的對象實現同一個Interface並進行交互。\n一聽可能有點高深，但其實它就像是一份約定，不管實際怎麼做，只要能遵循這份約定就行。\n就好像你和朋友約好要出去玩，你們約定好一起出門、一起玩，但具體怎麼玩，是不是吃火鍋還是去唱歌，那就隨你們。這些約定就是你們的「Interface」，告訴大家「我們一起要做這些事情！」。\n當然，這在程式碼裡的作用更大。透過這個「Interface」，你可以讓不同種類的東西，像是車、狗、電腦，都能夠用一樣的方式進行互動。不管是車、狗、還是電腦，只要符合了這個「Interface」約定的方法，你就可以放心地拿來用了。\nInterface的基本使用 透過Interface，我們可以在不關心具體類型的情況下，對對象進行操作。這種多態性的概念讓程式碼更具彈性，能夠適應不同的實現。\n// 定義一個Interface Shape，它具有一個 Area 方法 type Shape Interface { Area() float64 } // 定義一個 Circle 結構體，實現了 Shape Interface的 Area 方法 type Circle struct { Radius float64 } func (c Circle) Area() float64 { return 3.14 * c.Radius * c.Radius } // 定義一個 Rectangle 結構體，實現了 Shape Interface的 Area 方法 type Rectangle struct { Width, Height float64 } func (r Rectangle) Area() float64 { return r.","title":"Interface：Go 語言中的抽象關鍵"},{"content":"👨‍💻簡介 在程式開發的世界中，我們經常需要處理各式各樣的資料，可能是一個人的個人資訊，也可能是一個商品的詳細訊息。當我們面對這麼多的資料時，如何將它們有系統地整理起來，讓我們能夠輕鬆地找到所需，便成了一個重要的課題。這時，結構體的概念就像是一道曙光，為我們提供了一個非常有力的工具。\n結構體基礎 結構體，就像是一張設計圖，讓我們畫下我們腦袋裡的想法，就像是一個多功能的工具箱，結構體讓我們能夠以組織化的方式來儲存各種資料片段，就像是將資料拼湊成了一個個獨特的拼圖。今天，我們將深入探討 Golang 中結構體的神奇之處，以及如何通過結構體來更有效地組織和處理複雜資料。\n首先，我們來看看如何定義和使用結構體。結構體是一個自定義的資料類型，它允許我們組織不同類型的資料在一個單一的單位中。\ntype Person struct { FirstName string LastName string Age int } 以一個人的資訊為例，我們可以創建一個名為 Person 的結構體，其中包含了 FirstName、LastName 和 Age 這三個基本資料。這些資料如同載體，讓我們能夠更方便地一次性儲存和訪問它們。 現在，我們可以創建一個 Person 的實例，並訪問其字段：\nfunc main() { person := Person{ FirstName: \u0026#34;John\u0026#34;, LastName: \u0026#34;Doe\u0026#34;, Age: 30, } fmt.Println(\u0026#34;First Name:\u0026#34;, person.FirstName) fmt.Println(\u0026#34;Last Name:\u0026#34;, person.LastName) fmt.Println(\u0026#34;Age:\u0026#34;, person.Age) } 複雜資料的嵌套組織 但有時候，我們還需要更複雜的資料結構，例如住址。這時，結構體的嵌套就派上用場了，我們可以在 Person 結構體中嵌套另一個結構體，用來表示住址的相關資訊，如 Street、City 和 Country。\ntype Address struct { Street string City string Country string } type Person struct { FirstName string LastName string Age int Address Address } 也可以直接寫在裡面\ntype Person struct { FirstName string LastName string Age int Address struct { Street string City string Country string } } 在這個例子中，我們定義了一個 Address 結構體，然後在 Person 結構體中嵌套了一個 Address。\nfunc main() { person := Person{ FirstName: \u0026#34;Jane\u0026#34;, LastName: \u0026#34;Smith\u0026#34;, Age: 25, Address: Address{ Street: \u0026#34;123 Main St\u0026#34;, City: \u0026#34;New York\u0026#34;, Country: \u0026#34;USA\u0026#34;, }, } fmt.Println(\u0026#34;First Name:\u0026#34;, person.FirstName) fmt.Println(\u0026#34;Address:\u0026#34;, person.Address) } 這讓我們可以更有組織地儲存和查看複雜的資料。\n結構體方法的優雅處理 結構體不僅僅可以儲存資料，還可以有關聯的方法。這些方法可以在結構體上執行操作，從而實現更好的程式組織。讓結構體不僅僅是一個儲存數據的容器，還能夠具備處理數據的能力。 例如，我們可以為 Circle 結構體添加一個計算面積的方法 Area，讓計算變得更加優雅和集中。\ntype Circle struct { Radius float64 } func (c Circle) Area() float64 { return math.Pi * c.Radius * c.Radius } 這種方式，就好像是遊戲的技能，讓它們能夠有更多的功能，而不僅僅只是一個角色。\nfunc main() { circle := Circle{Radius: 5} fmt.Println(\u0026#34;Circle Area:\u0026#34;, circle.Area()) } 通過結構體方法，我們可以更加優雅地處理資料操作，讓程式碼看起來更加清晰。\n維護可讀性：使用命名結構體 為了提高程式的可讀性，我們應該給結構體和字段取有意義的名稱。\ntype Product struct { Name string Price float64 } 在這個例子中，我們定義了一個 Product 結構體，它有兩個字段：Name 和 Price。這樣的命名讓程式更加直觀，我們一眼就能理解這個結構體的用途。\n建立動態資料結構：使用切片和映射 當我們需要處理一組相關的結構體時，可以使用切片來創建動態的資料結構。\ntype Task struct { ID int Title string Status string } func main() { tasks := []Task{ {ID: 1, Title: \u0026#34;Read\u0026#34;, Status: \u0026#34;Pending\u0026#34;}, {ID: 2, Title: \u0026#34;Write article\u0026#34;, Status: \u0026#34;In Progress\u0026#34;}, } for _, task := range tasks { fmt.Println(\u0026#34;Task:\u0026#34;, task.Title, \u0026#34;| Status:\u0026#34;, task.Status) } } 在這個例子中，我們使用切片創建了多個 Task 結構體的實例，並遍歷切片印出任務的標題和狀態。\n重用性與模組化：匿名結構體和結構體嵌入 有時候，我們可以使用匿名結構體來快速創建臨時的資料結構。\nfunc main() { data := struct { Name string Value int }{ Name: \u0026#34;example\u0026#34;, Value: 42, } fmt.Println(\u0026#34;Name:\u0026#34;, data.Name, \u0026#34;| Value:\u0026#34;, data.Value) } 在這個例子中，我們直接在變數初始化時創建了一個匿名結構體。\n進一步來說，結構體嵌入可以幫助我們實現程式的重用。通過將一個結構體嵌入到另一個結構體中，我們可以在不破壞程式的情況下擴展功能。\n結論 結構體是 Golang 中一個非常強大的特性，它讓我們能夠更加有效地處理複雜的數據情境。 無論是單純的數據儲存，還是充滿了邏輯的數據操作，結構體都能幫助我們完成任務，讓我們的程式碼更有條理、更易讀，同時也更具可擴展性。\n📚Reference Go by Example: Structs A Tour of Go(struct) [Golang] 程式設計教學：使用結構 (Struct) | 開源技術教學網 (opensourcedoc.com) [Golang] Struct | PJCHENder 未整理筆記 ","permalink":"https://sz9751210.github.io/posts/go-struct/","summary":"👨‍💻簡介 在程式開發的世界中，我們經常需要處理各式各樣的資料，可能是一個人的個人資訊，也可能是一個商品的詳細訊息。當我們面對這麼多的資料時，如何將它們有系統地整理起來，讓我們能夠輕鬆地找到所需，便成了一個重要的課題。這時，結構體的概念就像是一道曙光，為我們提供了一個非常有力的工具。\n結構體基礎 結構體，就像是一張設計圖，讓我們畫下我們腦袋裡的想法，就像是一個多功能的工具箱，結構體讓我們能夠以組織化的方式來儲存各種資料片段，就像是將資料拼湊成了一個個獨特的拼圖。今天，我們將深入探討 Golang 中結構體的神奇之處，以及如何通過結構體來更有效地組織和處理複雜資料。\n首先，我們來看看如何定義和使用結構體。結構體是一個自定義的資料類型，它允許我們組織不同類型的資料在一個單一的單位中。\ntype Person struct { FirstName string LastName string Age int } 以一個人的資訊為例，我們可以創建一個名為 Person 的結構體，其中包含了 FirstName、LastName 和 Age 這三個基本資料。這些資料如同載體，讓我們能夠更方便地一次性儲存和訪問它們。 現在，我們可以創建一個 Person 的實例，並訪問其字段：\nfunc main() { person := Person{ FirstName: \u0026#34;John\u0026#34;, LastName: \u0026#34;Doe\u0026#34;, Age: 30, } fmt.Println(\u0026#34;First Name:\u0026#34;, person.FirstName) fmt.Println(\u0026#34;Last Name:\u0026#34;, person.LastName) fmt.Println(\u0026#34;Age:\u0026#34;, person.Age) } 複雜資料的嵌套組織 但有時候，我們還需要更複雜的資料結構，例如住址。這時，結構體的嵌套就派上用場了，我們可以在 Person 結構體中嵌套另一個結構體，用來表示住址的相關資訊，如 Street、City 和 Country。\ntype Address struct { Street string City string Country string } type Person struct { FirstName string LastName string Age int Address Address } 也可以直接寫在裡面","title":"探索 Golang 中的結構體：如何有效地組織複雜資料"},{"content":"👨‍💻簡介 在 Go 語言中，函數（Function）是一個強大且重要的概念，就像食譜一樣，告訴你應該如何處理食材，最後得到一道美味的料理。經過哪些程序讓程式更有組織性和可讀性。函數可幫助你將程式碼區塊組織成可重複使用的元件，進而執行特定的任務。本文要帶你一探究竟，深入了解 Golang 裡的函數有哪些不同的方面。從基本的概念開始，一路講到更高級的技巧，我們會告訴你怎麼樣用函數來處理各種不同的情況。\n函數基本概念 函數在 Golang 中是一組程式語句的組合，用於執行特定的任務。它們接受輸入（參數）並返回輸出（返回值），從高層次來看，就像是黑盒子，你提供輸入，它交付結果。在每個 Golang 程式中，最常見的函數是 main()，它是程式的入口點。\n函數名稱與命名規則 在 Golang 中，函數名稱的命名規則如下：\n名稱必須以字母開始，後面可以是任意數量的字母和數字。 函數名稱不能以數字開頭。 函數名稱不能包含空格。 如果函數名稱以大寫字母開頭，則可以被其他套件引用。如果以小寫字母開頭，則不能被其他套件引用，但可以在同一套件內部使用。 如果名稱由多個單詞組成，從第二個單詞開始的每個單詞首字母應大寫，例如 empName、EmpAddress 等。 函數名稱區分大小寫，即 car、Car 和 CAR 是三個不同的變數。 創建函數 在 Golang 中，創建函數的基本語法如下：\nfunc 函數名稱(參數1 型別1, 參數2 型別2, ...) 返回型別 { // 函數程式碼 return 返回值 } 首先，用 func 關鍵字開始函數宣告，然後是你想要給函數的名稱，一對括號 ()，然後是一個包含函數程式碼的區塊。\n以下是一個簡單的範例，它不接受任何參數，也不返回任何值。\npackage main import \u0026#34;fmt\u0026#34; // SimpleFunction 印出一個訊息 func SimpleFunction() { fmt.Println(\u0026#34;Hello World\u0026#34;) } func main() { SimpleFunction() // 呼叫 SimpleFunction 函數 } 接受參數的函數 如果要將資訊傳遞給函數，可以通過參數來實現。參數就像變數一樣。\n在函數名稱後面的括號內指定參數。你可以添加任意多的參數，只需用逗號分隔。\n以下是一個帶有兩個整數參數的範例。當呼叫 add() 函數時，我們傳遞了兩個整數值（例如 20 和 30）。\npackage main import \u0026#34;fmt\u0026#34; // 接受參數的函數 func add(x int, y int) { total := 0 total = x + y fmt.Println(total) } func main() { // 傳遞參數 add(20, 30) } 在 Golang 中，函數名稱首字母大寫的話，可以被其他套件引用（export）使用。如果函數名稱首字母小寫，則不能被其他套件引用，但在同一套件內部可以呼叫該函數。\n返回值的函數 如果要在函數中返回值，可以在函數中指定返回類型。以下是一個計算兩個整數之和並返回結果的範例：\npackage main import \u0026#34;fmt\u0026#34; // 函數返回 int 型別的值 func add(x int, y int) int { total := x + y return total } func main() { // 接收返回值並存入變數 sum := add(20, 30) fmt.Println(sum) } 命名返回值的函數 在 Golang 中，函數的返回值可以命名。這意味著你可以在函數中指定返回值的名稱，並在函數內部直接使用這些名稱。\n以下是一個計算矩形面積和周長的範例：\npackage main import \u0026#34;fmt\u0026#34; func rectangle(l int, b int) (area int) { parameter := 2 * (l + b) fmt.Println(\u0026#34;周長：\u0026#34;, parameter) area = l * b return// 省略返回值變數，使用命名的返回 } func main() { fmt.Println(\u0026#34;面積：\u0026#34;, rectangle(20, 30)) } 返回多個值的函數 函數還可以返回多個值，這在處理多個相關的值時非常方便。以下是一個返回矩形面積和周長的範例：\npackage main import \u0026#34;fmt\u0026#34; // rectangle 是一個計算矩形面積和周長的函數，返回兩個值 func rectangle(length int, breadth int) (area int, perimeter int) { perimeter = 2 * (length + breadth) area = length * breadth return // 省略返回值變數，使用命名的返回 } func main() { a, p := rectangle(10, 5) // 呼叫 rectangle 函數並接收返回值 fmt.Println(\u0026#34;面積：\u0026#34;, a) fmt.Println(\u0026#34;周長：\u0026#34;, p) } 將位址傳遞給函數進行值更新 在 Golang 中，你還可以將變數的位址傳遞給函數，並且在函數內部透過解引用的方式來修改變數的值。以下範例將展示這種通過位址更新變數值的情境：\npackage main import \u0026#34;fmt\u0026#34; func update(a *int, t *string) { *a = *a + 5 // 透過解引用位址修改變數值 *t = *t + \u0026#34; Doe\u0026#34; // 透過解引用位址修改變數值 return } func main() { var age = 20 var text = \u0026#34;John\u0026#34; fmt.Println(\u0026#34;修改前：\u0026#34;, text, age) update(\u0026amp;age, \u0026amp;text) fmt.Println(\u0026#34;修改後：\u0026#34;, text, age) } 匿名函數：更靈活的處理 在 Golang 中，還可以使用匿名函數。匿名函數是一種無需命名識別符即可宣告的函數。匿名函數可以接受輸入並返回輸出，就像普通函數一樣。以下是一個將函數指派給變數並使用匿名函數：\npackage main import \u0026#34;fmt\u0026#34; var ( area = func(l int, b int) int { return l * b } ) func main() { fmt.Println(area(20, 30)) } 你還可以將參數傳遞給匿名函數：\npackage main import \u0026#34;fmt\u0026#34; func main() { func(l int, b int) { fmt.Println(l * b) }(20, 30) } 匿名函數也可以接受參數並返回值：\npackage main import \u0026#34;fmt\u0026#34; func main() { fmt.Printf( \u0026#34;100 (°F) = %.2f (°C)\\n\u0026#34;, func(f float64) float64 { return (f - 32.0) * (5.0 / 9.0) }(100), ) } 閉包：捕獲外部變數 在 Golang 中，閉包是匿名函數的一種特殊情形。閉包是可以存取在函數外部定義的變數的匿名函數。\n以下是一個使用閉包的範例，其中匿名函數可以訪問在函數外部定義的變數：\npackage main import \u0026#34;fmt\u0026#34; func main() { l := 20 b := 30 func() { var area int area = l * b fmt.Println(area) }() } 另一個範例是，在函數內的迴圈迭代過程中，匿名函數可以訪問變數的值：\npackage main import \u0026#34;fmt\u0026#34; func main() { for i := 10.0; i \u0026lt; 100; i += 10.0 { rad := func() float64 { return i * 39.370 }() fmt.Printf(\u0026#34;%.2f 公尺 = %.2f 英吋\\n\u0026#34;, i, rad) } } 高階函數：函數作為參數和返回值 在 Golang 中，函數可以作為參數傳遞給其他函數，也可以作為函數的返回值。這種功能稱為高階函數（Higher-Order Functions），能夠提供更靈活且模組化的程式設計方式。以下範例演示如何創建一個高階函數，將一個函數套用到切片的每個元素：\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;strings\u0026#34; ) // mapString 將 f 函數套用到每個字串元素並返回新的切片 func mapString(arr []string, f func(string) string) []string { result := make([]string, len(arr)) for i, v := range arr { result[i] = f(v) } return result } func main() { words := []string{\u0026#34;apple\u0026#34;, \u0026#34;banana\u0026#34;, \u0026#34;cherry\u0026#34;} toUpper := func(s string) string { return strings.ToUpper(s) } upperWords := mapString(words, toUpper) fmt.Println(upperWords) // 輸出：[APPLE BANANA CHERRY] } 函數作為參數傳遞給其他函數 以下是一個將函數作為參數傳遞給高階函數的範例：\npackage main import \u0026#34;fmt\u0026#34; func sum(x, y int) int { return x + y } func partialSum(x int) func(int) int { return func(y int) int { return sum(x, y) } } func main() { partial := partialSum(3) fmt.Println(partial(7)) } 將函數作為結果返回的高階函數 你還可以將函數作為結果返回，這被稱為返回函數的高階函數。以下是一個範例，該範例返回一個函數，該函數在其內部使用嵌套的匿名函數：\npackage main import \u0026#34;fmt\u0026#34; func squareSum(x int) func(int) func(int) int { return func(y int) func(int) int { return func(z int) int { return x*x + y*y + z*z } } } func main() { resultFunc := squareSum(5) // 返回一個函數 subResultFunc := resultFunc(6) // 返回一個嵌套函數 finalResult := subResultFunc(7) // 呼叫最內層的函數獲取結果 fmt.Println(finalResult) // 印出最終計算結果 fmt.Println(squareSum(5)(6)(7)) } 自定義函數類型 在 Golang 中，你可以使用 type 關鍵字定義自己的函數類型。這就像是為函數創建了一個別名，使得該函數類型能夠被用作變數的型別。自定義函數類型能夠讓你更好地組織程式碼，以及在特定情境下使代碼更具表達性。\n以下是一個使用自定義函數類型的範例，我們將創建一個函數類型 First，並進一步使用 Second 函數類型。這些自定義的函數類型可以用於創建一個執行特定計算的函數：\npackage main import \u0026#34;fmt\u0026#34; // 定義 First 函數類型 type First func(int) int // 定義 Second 函數類型 type Second func(int) First // squareSum 返回一個 Second 函數 func squareSum(x int) Second { return func(y int) First { return func(z int) int { return x*x + y*y + z*z } } } func main() { // 使用自定義函數類型的範例 result := squareSum(5)(6)(7) fmt.Println(\u0026#34;計算結果：\u0026#34;, result) // 輸出：110 } 函數的特性、限制與使用場景 函數是程式設計中的重要組成部分，它們能夠將程式碼模組化、重複使用，使程式更具可讀性和可維護性。然而，函數也有其特性、限制以及適用的使用場景，讓我們來一起深入了解。\n函數的特性 模組化： 函數能夠將程式碼分成小的模組，使得程式邏輯更加清晰，也更容易進行測試和修改。\n重複使用： 定義一次函數後，你可以在程式中多次調用它，避免了重複編寫相同的程式碼。\n參數和返回值： 函數可以接受參數，這些參數提供了執行函數所需的資訊。同時，函數可以返回值，使得結果能夠被其他程式碼使用。\n封裝： 函數能夠封裝實現細節，隱藏程式碼的複雜性，使得外部使用者只需關心函數的功能。\n遞迴： 函數可以呼叫自己，這種稱為遞迴的特性在處理某些問題時非常有用。\n函數的限制 可讀性： 過多的函數調用可能導致程式難以閱讀和理解，因此需要適當的拆分和命名函數。\n效能考慮： 過於頻繁的函數調用可能會影響程式的效能，因為每次函數呼叫都會有一定的開銷。\n記憶體使用： 函數的呼叫需要保留堆疊帧等相關資訊，這可能會佔用一些記憶體空間。\n可變性： 在某些程式語言中，函數可能會更改其外部範疇的變數，這可能導致程式難以理解和調試。\n函數的使用場景 程式模組化： 將相關的程式碼封裝為函數，可以使程式更具結構，更容易維護。\n代碼重用： 如果你在多個地方需要執行相同或類似的操作，可以將這些操作封裝成函數，方便重複使用。\n抽象化： 函數可以將複雜的實現細節隱藏起來，只暴露必要的介面，使外部程式碼更易於理解。\n遞迴問題： 某些問題的解決方案適合使用遞迴，例如數學中的遞迴定義和分治算法。\n事件處理： 在事件驅動的程式中，函數可以用於處理不同的事件類型，使程式具有彈性。\n資料轉換： 函數可以用於將一種資料類型轉換為另一種，例如日期格式轉換、單位轉換等。\n處理業務邏輯： 在軟體應用中，函數可以用於實現業務邏輯，如處理訂單、用戶驗證等。\n演算法實現： 函數是實現演算法的基本元素，能夠將複雜的演算法分解成可管理的部分。\n函數的常見用法 1. 計算數值的平方和 package main import \u0026#34;fmt\u0026#34; func squareSum(numbers ...int) int { sum := 0 for _, num := range numbers { sum += num * num } return sum } func main() { result := squareSum(2, 3, 4) fmt.Println(\u0026#34;平方和:\u0026#34;, result) } 2. 找出切片中的最大值 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;math\u0026#34; ) func findMax(numbers ...float64) float64 { max := math.Inf(-1) for _, num := range numbers { if num \u0026gt; max { max = num } } return max } func main() { result := findMax(2.3, 5.7, 1.2, 9.8) fmt.Println(\u0026#34;最大值:\u0026#34;, result) } 3. 檢查字串是否為回文 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;strings\u0026#34; ) func isPalindrome(s string) bool { s = strings.ToLower(s) for i := 0; i \u0026lt; len(s)/2; i++ { if s[i] != s[len(s)-1-i] { return false } } return true } func main() { result := isPalindrome(\u0026#34;racecar\u0026#34;) fmt.Println(\u0026#34;是否為回文:\u0026#34;, result) } 4. 計算 Fibonacci 數列 package main import \u0026#34;fmt\u0026#34; func fibonacci(n int) int { if n \u0026lt;= 0 { return 0 } else if n == 1 { return 1 } return fibonacci(n-1) + fibonacci(n-2) } func main() { result := fibonacci(6) fmt.Println(\u0026#34;第 6 個 Fibonacci 數:\u0026#34;, result) } 5. 判斷是否為質數 package main import \u0026#34;fmt\u0026#34; func isPrime(n int) bool { if n \u0026lt;= 1 { return false } for i := 2; i*i \u0026lt;= n; i++ { if n%i == 0 { return false } } return true } func main() { result := isPrime(17) fmt.Println(\u0026#34;17 是否為質數:\u0026#34;, result) } 小結 函數是 Golang 程式設計的基石之一，讓你能夠組織程式碼、提高重用性，並以更模組化的方式處理不同情境的需求。無論是創建簡單的函數、使用閉包捕獲變數，還是運用高階函數進行模組化設計，函數都在 Golang 中扮演著關鍵角色。\n📚Reference A Tour of Go - Function types The Go Programming Language Specification - Function types ","permalink":"https://sz9751210.github.io/posts/go-func/","summary":"👨‍💻簡介 在 Go 語言中，函數（Function）是一個強大且重要的概念，就像食譜一樣，告訴你應該如何處理食材，最後得到一道美味的料理。經過哪些程序讓程式更有組織性和可讀性。函數可幫助你將程式碼區塊組織成可重複使用的元件，進而執行特定的任務。本文要帶你一探究竟，深入了解 Golang 裡的函數有哪些不同的方面。從基本的概念開始，一路講到更高級的技巧，我們會告訴你怎麼樣用函數來處理各種不同的情況。\n函數基本概念 函數在 Golang 中是一組程式語句的組合，用於執行特定的任務。它們接受輸入（參數）並返回輸出（返回值），從高層次來看，就像是黑盒子，你提供輸入，它交付結果。在每個 Golang 程式中，最常見的函數是 main()，它是程式的入口點。\n函數名稱與命名規則 在 Golang 中，函數名稱的命名規則如下：\n名稱必須以字母開始，後面可以是任意數量的字母和數字。 函數名稱不能以數字開頭。 函數名稱不能包含空格。 如果函數名稱以大寫字母開頭，則可以被其他套件引用。如果以小寫字母開頭，則不能被其他套件引用，但可以在同一套件內部使用。 如果名稱由多個單詞組成，從第二個單詞開始的每個單詞首字母應大寫，例如 empName、EmpAddress 等。 函數名稱區分大小寫，即 car、Car 和 CAR 是三個不同的變數。 創建函數 在 Golang 中，創建函數的基本語法如下：\nfunc 函數名稱(參數1 型別1, 參數2 型別2, ...) 返回型別 { // 函數程式碼 return 返回值 } 首先，用 func 關鍵字開始函數宣告，然後是你想要給函數的名稱，一對括號 ()，然後是一個包含函數程式碼的區塊。\n以下是一個簡單的範例，它不接受任何參數，也不返回任何值。\npackage main import \u0026#34;fmt\u0026#34; // SimpleFunction 印出一個訊息 func SimpleFunction() { fmt.Println(\u0026#34;Hello World\u0026#34;) } func main() { SimpleFunction() // 呼叫 SimpleFunction 函數 } 接受參數的函數 如果要將資訊傳遞給函數，可以通過參數來實現。參數就像變數一樣。","title":"🚀 Golang 函數：從入門到精通"},{"content":"👨‍💻簡介 在 Go 語言中，有著一個強大又便捷的工具，可以讓你以鍵-值（Key-Value）的形式儲存和查詢資料，它就是「Map」。Map 在 Go 語言中扮演了重要的角色，簡化了許多資料處理的任務，現在讓我們一起來深入了解這個有趣的資料型別。\nMap的基本概念 Map 是 Go 語言中的一種內建資料型別，用來存儲鍵值對。簡單來說，你可以將 Map 想像成一個無序的集合，每個元素都有一個唯一的鍵和相應的值。這讓你可以根據鍵來快速查詢和存取對應的值，就像是字典一樣。\n宣告和初始化 Map 在 Go 中，宣告 Map 可使用以下語法：\nm1 := make(map[string]int) // 創建一個儲存字串為鍵，整數為值的 Map m2 := map[int]string{1: \u0026#34;A\u0026#34;, 2: \u0026#34;B\u0026#34;} // 創建一個包含鍵值對的映射 var m3 map[string]int // 創建一個鍵為字串、值為整數的空映射 而宣告時順便初始化可以使用以下方式：\nmyMap := map[string]int{ \u0026#34;apple\u0026#34;: 3, \u0026#34;banana\u0026#34;: 5, } var myMap map[string]int myMap = map[string]int{ \u0026#34;apple\u0026#34;: 3, \u0026#34;banana\u0026#34;: 5, } Map的基本操作 Map 的操作非常簡單直觀。你可以使用鍵來存取對應的值，也可以使用鍵來新增、修改或刪除元素。\n新增或修改元素 myMap[\u0026#34;apple\u0026#34;] = 3 // 新增一個元素，鍵是 \u0026#34;apple\u0026#34;，值是 3 myMap[\u0026#34;banana\u0026#34;] = 5 // 新增一個元素，鍵是 \u0026#34;banana\u0026#34;，值是 5 myMap[\u0026#34;apple\u0026#34;] = 10 // 修改鍵為 \u0026#34;apple\u0026#34; 的元素的值為 10 查詢元素 value := myMap[\u0026#34;banana\u0026#34;] // 根據鍵 \u0026#34;banana\u0026#34; 查詢對應的值 刪除元素 delete(myMap, \u0026#34;apple\u0026#34;) // 刪除鍵為 \u0026#34;apple\u0026#34; 的元素 遍歷 Map 要遍歷一個 Map 中的所有元素，通常會使用 for range 迴圈：\nfor key, value := range myMap { fmt.Println(\u0026#34;Key:\u0026#34;, key, \u0026#34;Value:\u0026#34;, value) } Map 的特性、限制與使用場景 Map 的特性與限制 雖然 Map 是極其方便的資料結構，但也有一些需要注意的地方：\n無序性： Map 中的元素是無序的，不像陣列或切片那樣有明確的順序。 鍵的唯一性： 每個鍵在 Map 中只能出現一次，這確保了每個鍵都對應唯一的值。 零值返回： 若查詢不存在的鍵，會返回值型別的零值，例如整數型別返回 0，字串型別返回空字串。 內存消耗： Map 是引用型別，存儲的是指向實際數據的指針，這可能導致內存消耗增加。 並發安全： Map 在多執行緒環境下需要特殊處理，可以使用 sync 包中的相關函式進行安全操作。 Map 的使用場景 Map 在很多場景中都非常有用，例如：\n字典： 想像一下你有一本字典，你查找一個單詞時，你會找到它的解釋。在程式裡，你可以用 Map 來建立這種關聯，每個單詞對應到它的解釋。\n計數器： 如果你想知道一段文字中每個單詞出現的次數，你可以使用 Map。你從文字中抓取每個單詞，然後在 Map 中記錄它出現的次數。\n快速查詢： 想像你有一張表格，裡面寫著每個用戶的姓名和他們的聯繫方式。你想通過姓名來找到聯繫方式，這就像在程式中使用 Map，透過用戶名找到相對應的資訊。\n紀錄狀態： 舉個例子，你在一個遊戲中，想要記錄每個玩家的生命值。你可以使用 Map 來將每個玩家的名字對應到他們的生命值。\n暫存資料： 想像你做了一個複雜的計算，但你不想每次都重新計算。你可以使用 Map 把計算結果儲存在裡面，以後需要時直接取出。\n設定管理： 如果你的程式需要一些設定，像是遊戲的難度或網站的外觀，你可以使用 Map 儲存這些設定，方便管理和調整。\n關聯數據： 想像你有一個應用程式，需要儲存每位用戶的個人資料。使用 Map 可以將每個用戶的ID對應到他們的資料，就像是在虛擬的表格中。\n事件管理： 如果你有很多不同的事件，每個事件都需要不同的處理方式，你可以使用 Map 把事件類型與對應的處理方法關聯起來。\n角色權限： 在一個應用程式中，不同的用戶可能有不同的權限。你可以使用 Map 把每個用戶的角色對應到他們的權限，以便進行訪問控制。\n常見用法 字典建立： 創建一個字典，將單字對應到它們的解釋。 package main import \u0026#34;fmt\u0026#34; func main() { dictionary := map[string]string{ \u0026#34;apple\u0026#34;: \u0026#34;a fruit\u0026#34;, \u0026#34;banana\u0026#34;: \u0026#34;a yellow fruit\u0026#34;, \u0026#34;cherry\u0026#34;: \u0026#34;a red fruit\u0026#34;, } fmt.Println(dictionary[\u0026#34;apple\u0026#34;]) fmt.Println(dictionary[\u0026#34;banana\u0026#34;]) fmt.Println(dictionary[\u0026#34;cherry\u0026#34;]) } 計數器： 統計文字中每個單字的出現次數。 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;strings\u0026#34; ) func main() { text := \u0026#34;apple banana apple cherry banana apple\u0026#34; words := strings.Fields(text) wordCount := make(map[string]int) for _, word := range words { wordCount[word]++ } fmt.Println(wordCount) } 快速查詢： 儲存用戶名對應的用戶資訊。 package main import \u0026#34;fmt\u0026#34; func main() { userMap := map[string]string{ \u0026#34;alice\u0026#34;: \u0026#34;Alice Johnson\u0026#34;, \u0026#34;bob\u0026#34;: \u0026#34;Bob Smith\u0026#34;, \u0026#34;charlie\u0026#34;: \u0026#34;Charlie Brown\u0026#34;, } fmt.Println(userMap[\u0026#34;alice\u0026#34;]) fmt.Println(userMap[\u0026#34;bob\u0026#34;]) } 狀態存儲： 儲存玩家名字和對應的生命值。 package main import \u0026#34;fmt\u0026#34; func main() { playerStatus := map[string]int{ \u0026#34;alice\u0026#34;: 100, \u0026#34;bob\u0026#34;: 75, \u0026#34;charlie\u0026#34;: 90, } fmt.Println(playerStatus[\u0026#34;alice\u0026#34;]) fmt.Println(playerStatus[\u0026#34;bob\u0026#34;]) } 小結 Map 是一種讓你能夠以鍵-值對的方式來組織和存儲資料的方式，它在 Go 語言中扮演著重要的角色。記住 Map 的基本概念、操作方法和限制，這將有助於你在寫程式時選擇適合的資料結構。\n📚Reference Effective Go - The Go Programming Language [Golang] maps | PJCHENder 未整理筆記 ","permalink":"https://sz9751210.github.io/posts/go-map/","summary":"👨‍💻簡介 在 Go 語言中，有著一個強大又便捷的工具，可以讓你以鍵-值（Key-Value）的形式儲存和查詢資料，它就是「Map」。Map 在 Go 語言中扮演了重要的角色，簡化了許多資料處理的任務，現在讓我們一起來深入了解這個有趣的資料型別。\nMap的基本概念 Map 是 Go 語言中的一種內建資料型別，用來存儲鍵值對。簡單來說，你可以將 Map 想像成一個無序的集合，每個元素都有一個唯一的鍵和相應的值。這讓你可以根據鍵來快速查詢和存取對應的值，就像是字典一樣。\n宣告和初始化 Map 在 Go 中，宣告 Map 可使用以下語法：\nm1 := make(map[string]int) // 創建一個儲存字串為鍵，整數為值的 Map m2 := map[int]string{1: \u0026#34;A\u0026#34;, 2: \u0026#34;B\u0026#34;} // 創建一個包含鍵值對的映射 var m3 map[string]int // 創建一個鍵為字串、值為整數的空映射 而宣告時順便初始化可以使用以下方式：\nmyMap := map[string]int{ \u0026#34;apple\u0026#34;: 3, \u0026#34;banana\u0026#34;: 5, } var myMap map[string]int myMap = map[string]int{ \u0026#34;apple\u0026#34;: 3, \u0026#34;banana\u0026#34;: 5, } Map的基本操作 Map 的操作非常簡單直觀。你可以使用鍵來存取對應的值，也可以使用鍵來新增、修改或刪除元素。\n新增或修改元素 myMap[\u0026#34;apple\u0026#34;] = 3 // 新增一個元素，鍵是 \u0026#34;apple\u0026#34;，值是 3 myMap[\u0026#34;banana\u0026#34;] = 5 // 新增一個元素，鍵是 \u0026#34;banana\u0026#34;，值是 5 myMap[\u0026#34;apple\u0026#34;] = 10 // 修改鍵為 \u0026#34;apple\u0026#34; 的元素的值為 10 查詢元素 value := myMap[\u0026#34;banana\u0026#34;] // 根據鍵 \u0026#34;banana\u0026#34; 查詢對應的值 刪除元素 delete(myMap, \u0026#34;apple\u0026#34;) // 刪除鍵為 \u0026#34;apple\u0026#34; 的元素 遍歷 Map 要遍歷一個 Map 中的所有元素，通常會使用 for range 迴圈：","title":"淺談 Go 語言中的 Map - 快速查詢與狀態儲存的利器"},{"content":"👨‍💻簡介 在 Go 語言中，切片（Slice）是一種動態序列的資料結構，能夠方便地存儲和操作多個相同類型的元素。切片相比於陣列，更具有彈性，因為它的大小是可變的，可以根據需要動態增長或縮小。切片在處理集合型資料時非常實用，讓你能夠輕鬆地新增、刪除、修改和操作元素，同時避免了固定大小的限制。\n切片的基本概念 切片是由一個指向陣列的指針、切片長度和切片容量組成的。切片的長度指的是切片中實際包含的元素個數，而切片的容量則是從切片開始的底層陣列中能夠訪問的元素個數。切片的容量可以大於或等於切片的長度。\n宣告和初始化切片 在 Go 中，宣告和初始化切片可以使用以下的語法：\nvar slice1 []int // 創建一個整數切片，大小和容量都是 0 slice2 := []string{\u0026#34;A\u0026#34;, \u0026#34;B\u0026#34;, \u0026#34;C\u0026#34;} // 創建一個包含三個字串元素的切片 slice3 := make([]int, 5) // 創建一個整數切片，大小為 5，容量也為 5 slice4 := make([]int, 3, 5) // 創建一個整數切片，大小為 3，容量為 5 切片的基本操作 新增元素到切片 Go語言中有個內件函式append()，可以用來新增元素到切片中，這使得切片能夠根據需求動態增長。\nnumbers := []int{10, 20, 30} numbers = append(numbers, 40, 50) // 新增兩個元素到切片 需要注意的是，如果切片的容量不足以容納新增的元素，append() 函式會創建一個新的切片，並將舊的元素和新的元素一同複製到新的切片中。\n查詢和修改切片元素 切片的元素可以通過索引來存取，索引從 0 開始計數。\nnumbers := []int{10, 20, 30, 40, 50} firstNumber := numbers[0] // 存取第一個元素，值為 10 secondNumber := numbers[1] // 存取第二個元素，值為 20 numbers[2] = 35 // 修改切片中的元素，將第三個元素改為 35 切割和遍歷切片 可以使用切片的切割操作來獲取部分切片，這可以通過指定切片的起始索引和結束索引來實現：\nnumbers := []int{10, 20, 30, 40, 50} subSlice := numbers[1:4] // 從第二個元素到第四個元素的子切片，值為 [20 30 40] [:]：使用 [:] 語法可以獲得完整的切片，即包含所有元素的切片。 [x:]：這種語法表示從索引 x 開始，提取所有直到切片結尾的元素。 [:x]：這種語法表示提取從開頭到索引 x-1 的元素，不包含索引 x 的元素。 切片的遍歷可以使用傳統的索引方式，或者使用 range 來簡化遍歷過程。\nnumbers := []int{10, 20, 30, 40, 50} // 使用傳統的索引方式遍歷切片 for i := 0; i \u0026lt; len(numbers); i++ { fmt.Println(numbers[i]) } // 使用 range 遍歷切片 for index, value := range numbers { fmt.Printf(\u0026#34;索引：%d，值：%d\\n\u0026#34;, index, value) } for i := range numbers { fmt.Println(numbers[i]) } 刪除切片元素 雖然切片沒有內建的刪除方法，不過可以使用切片的切割操作，將不需要的元素排除在外。\nslice := []int{10, 20, 30, 40, 50} indexToDelete := 2 slice = append(slice[:indexToDelete], slice[indexToDelete+1:]...) // 刪除索引 2 的元素 切片的容量 切片的容量就是指，你從切片開始的位置能夠往後訪問到的元素數量。當你在切片上進行新增元素的操作時，如果新加進來的元素數量超過了切片目前的容量，Go 語言會做一些事情：它會重新搞一個更大的陣列，然後把舊的元素都複製到這個新陣列中。這個過程會花一些時間，也就是所謂的性能開銷。\npackage main import \u0026#34;fmt\u0026#34; func main() { numbers := []int{1, 2, 3} fmt.Println(\u0026#34;長度：\u0026#34;, len(numbers)) // 輸出：長度：3 fmt.Println(\u0026#34;容量：\u0026#34;, cap(numbers)) // 輸出：容量：3 slice := numbers[1:2] fmt.Println(\u0026#34;切片：\u0026#34;, slice) // 輸出：切片：[2] fmt.Println(\u0026#34;切片長度：\u0026#34;, len(slice)) // 輸出：切片長度：1 fmt.Println(\u0026#34;切片容量：\u0026#34;, cap(slice)) // 輸出：切片容量：2 // 切片的容量是從切片的起始索引開始計算，一直到底層陣列的末尾索引。因此容量為2 // 新增元素超過切片容量時，會自動擴容並分配更大的底層陣列 slice = append(numbers, 4) // 新切片為 [1, 2, 3, 4] fmt.Println(\u0026#34;切片：\u0026#34;, slice) // 輸出：切片：[1 2 3 4] fmt.Println(\u0026#34;切片長度：\u0026#34;, len(slice)) // 輸出：切片長度：4 fmt.Println(\u0026#34;切片容量：\u0026#34;, cap(slice)) // 輸出：切片容量：6 } 切片的特性、限制與使用場景 切片的特性 切片的大小是動態的，可以隨時進行增長或縮小。 切片可以方便地從現有的陣列或切片中創建，不需要顯式地指定容量。 切片的新增、刪除、修改操作都非常方便，讓你能夠輕鬆地操作集合型資料。 切片的背後通常使用動態陣列來實現，因此在內存佈局上更具彈性，不受固定大小的限制。 切片是引用類型，這意味著它們引用底層的陣列，而不是複製數據。當你將一個切片賦值給另一個切片，它們實際上共享同一份數據。因此，對其中一個切片所做的修改將影響到另一個切片。 以下是一個實際案例： slice1 := []int{1, 2, 3} slice2 := slice1 slice2[0] = 3 fmt.Println(slice1, slice2) // 輸出：[3 2 3] [3 2 3] 在這裡，修改 slice2 的值同樣影響了 slice1，因為它們引用同一份底層數據。這是切片和陣列之間的一個重要區別。\n切片的限制 記憶體配置： 切片的內部實現中使用了底層的陣列，因此切片所佔用的記憶體空間可能比實際所需大。當切片的元素數量增加時，Go 語言可能會重新配置更大的陣列，導致一些性能開銷。 不適用於大型資料： 對於大型資料集合，切片可能不是最佳選擇。大型切片可能導致記憶體占用過多，影響程式的效能。 不支援多維切片： 切片僅支援一維結構，如果需要處理多維資料，可能需要自行實現多維切片的概念。 使用場景 動態資料集合： 切片的大小是可變的，使其非常適用於處理動態資料集合，無需事先知道集合的大小。 API 請求和回應： 在處理 API 請求和回應時，切片可用於儲存和解析不確定數量的請求參數或回應資料。 資料過濾和轉換： 使用 range 遍歷切片，可以輕鬆地過濾或轉換切片中的元素，進行處理和計算。 傳遞函式參數： 切片的引用類型特性使其適用於傳遞函式參數，避免不必要的資料複製。 檔案讀寫： 切片可用於讀取大量數據，進行處理後再寫回檔案。 實現堆疊和佇列： 使用切片可以實現簡單的堆疊（後進先出）和佇列（先進先出）結構。 排序和搜尋： 切片在排序和搜尋資料時非常有用，可以利用 sort 套件進行排序，並使用二分搜尋等技術進行搜尋。 常見用法 資料過濾和轉換 // 將切片中的所有元素乘以 2 numbers := []int{1, 2, 3, 4, 5} for i := range numbers { numbers[i] *= 2 } // 過濾出大於 3 的元素 filteredNumbers := []int{} for _, num := range numbers { if num \u0026gt; 3 { filteredNumbers = append(filteredNumbers, num) } } 傳遞函式參數 func modifySlice(slice []int) { slice[0] = 100 } numbers := []int{1, 2, 3} modifySlice(numbers) 小結 切片是 Go 語言中非常實用的資料結構，它解決了陣列大小固定的限制，讓你能夠輕鬆地處理動態大小的集合型資料。切片的操作包括取得、修改、新增、刪除等，讓你可以靈活地處理資料集合。\n在遍歷切片時，range 很方便地提供了索引和值，讓你能夠輕鬆地訪問切片中的元素。切片的特性和優勢使得它在處理動態數據集合時成為 Go 程式設計中的一個重要工具。\n📚Reference A Tour of Go(slice) [Golang] Slice and Array | PJCHENder 未整理筆記 ","permalink":"https://sz9751210.github.io/posts/go-slice/","summary":"👨‍💻簡介 在 Go 語言中，切片（Slice）是一種動態序列的資料結構，能夠方便地存儲和操作多個相同類型的元素。切片相比於陣列，更具有彈性，因為它的大小是可變的，可以根據需要動態增長或縮小。切片在處理集合型資料時非常實用，讓你能夠輕鬆地新增、刪除、修改和操作元素，同時避免了固定大小的限制。\n切片的基本概念 切片是由一個指向陣列的指針、切片長度和切片容量組成的。切片的長度指的是切片中實際包含的元素個數，而切片的容量則是從切片開始的底層陣列中能夠訪問的元素個數。切片的容量可以大於或等於切片的長度。\n宣告和初始化切片 在 Go 中，宣告和初始化切片可以使用以下的語法：\nvar slice1 []int // 創建一個整數切片，大小和容量都是 0 slice2 := []string{\u0026#34;A\u0026#34;, \u0026#34;B\u0026#34;, \u0026#34;C\u0026#34;} // 創建一個包含三個字串元素的切片 slice3 := make([]int, 5) // 創建一個整數切片，大小為 5，容量也為 5 slice4 := make([]int, 3, 5) // 創建一個整數切片，大小為 3，容量為 5 切片的基本操作 新增元素到切片 Go語言中有個內件函式append()，可以用來新增元素到切片中，這使得切片能夠根據需求動態增長。\nnumbers := []int{10, 20, 30} numbers = append(numbers, 40, 50) // 新增兩個元素到切片 需要注意的是，如果切片的容量不足以容納新增的元素，append() 函式會創建一個新的切片，並將舊的元素和新的元素一同複製到新的切片中。\n查詢和修改切片元素 切片的元素可以通過索引來存取，索引從 0 開始計數。\nnumbers := []int{10, 20, 30, 40, 50} firstNumber := numbers[0] // 存取第一個元素，值為 10 secondNumber := numbers[1] // 存取第二個元素，值為 20 numbers[2] = 35 // 修改切片中的元素，將第三個元素改為 35 切割和遍歷切片 可以使用切片的切割操作來獲取部分切片，這可以通過指定切片的起始索引和結束索引來實現：","title":"Go 語言中的動態陣列：深入解析切片"},{"content":"👨‍💻簡介 陣列就像是一個儲存相同類型資料的容器，你可以想像成裝滿了一樣東西的盒子，每個東西都叫做陣列元素。這種類型可以是基本的，像是整數或字串，也可以是你自己定義的型別。不過陣列有個限制，就是大小一旦確定就無法改變。在Go語言裡，陣列的長度也是型別的一部分。舉例來說，[5]int和[10]int就是不同的型別。雖然它們都是整數陣列，但因為長度不同，所以視為不同的資料型別，不能直接互相給值或操作。這麼做是為了在長度上更加嚴謹，不會混淆不同大小的陣列，增加了資料的安全性。\n另一個類似的東西是切片（Slice），這東西可以想像成動態的序列，可以根據需要自由地增加或減少。不過，為了更好地理解切片，我們先學學陣列的使用。\n陣列的基本概念 陣列是由一組元素所組成的固定大小的資料結構，每個元素都有一個相應的索引。陣列的大小在宣告時就需要確定，並且在後續操作中無法改變。\n宣告和初始化陣列 在 Go 中，宣告和初始化陣列可以使用以下的語法：\nvar arr1 [3]int // 創建一個整數陣列，大小為 3 arr2 := [4]string{\u0026#34;A\u0026#34;, \u0026#34;B\u0026#34;} // 創建一個包含 4 個字串元素的陣列 arr3 := [...]int{1, 2, 3} // 自動推斷陣列大小為 3 你也可以在宣告陣列的同時，使用指定索引的方式來初始化陣列：\narr := [...]int{1: 10, 3: 30} // 陣列的值為 [0 10 0 30] 陣列的基本操作 取得陣列元素 陣列的元素可以通過索引來存取，索引從 0 開始計數。\nnumbers := [5]int{10, 20, 30, 40, 50} firstNumber := numbers[0] // 存取第一個元素，值為 10 secondNumber := numbers[1] // 存取第二個元素，值為 20 假設我們有一個陣列 arr := [5]int{1, 2, 3, 4, 5}。\narr[:] 表示整個陣列： arr := [5]int{1, 2, 3, 4, 5} arr_new := arr[:] fmt.Println(arr_new) // 輸出：[1 2 3 4 5] arr[i:] 表示從索引 i 到陣列末尾的陣列： arr := [5]int{1, 2, 3, 4, 5} startIndex := 2 arr_new := arr[startIndex:] fmt.Println(arr_new) // 輸出：[3 4 5] arr[:i] 表示從陣列開頭到索引 i-1 的切片： arr := [5]int{1, 2, 3, 4, 5} endIndex := 3 arr_new := arr[:endIndex] fmt.Println(arr_new) // 輸出：[1 2 3] 修改陣列元素 我們可以修改陣列中的元素，例如：\nvar arr = [...]int{1, 2, 3} arr[0] = 5 fmt.Println(arr) // 輸出：[5 2 3] 遍歷陣列 可以使用傳統的索引方式或 range 來遍歷陣列中的元素：\nnumbers := [5]int{10, 20, 30, 40, 50} // 使用傳統的索引方式遍歷陣列 for i := 0; i \u0026lt; len(numbers); i++ { fmt.Println(numbers[i]) } // 使用 range 遍歷陣列 for _, num := range numbers { fmt.Println(num) } for i := range numbers { fmt.Println(numbers[i]) } range 是一個內建函式，用於遍歷陣列、切片、映射等集合型資料。在這個範例中，我們使用 range 來遍歷 numbers 陣列中的每個元素，並將每個元素的值賦值給 num 變數。\n陣列的特性、限制與使用場景 陣列的特性 固定大小： 陣列在宣告時需要確定大小，且大小不可改變。這意味著一旦陣列被創建，其大小將保持不變。 相同類型元素： 陣列內的元素必須是相同的類型，可以是內建的基本數據類型（如整數、浮點數）或自定義的結構體。 連續儲存： 陣列中的元素在記憶體中是連續儲存的，這有助於提高存取效率，因為 CPU 可以預取接下來的元素。 值類型： 陣列是值類型，當陣列被賦值給另一個陣列時，實際上是對數據的複製，而不是引用。 陣列是值類型，這意味著當你賦值或傳遞陣列時，實際上是複製整個陣列的內容。因此，對副本的修改不會影響原始陣列的值：\nvar array1 = [...]int{1, 2, 3} array2 := array1 array2[0] = 3 fmt.Println(array1, array2) // 輸出：[1 2 3] [3 2 3] 這上面的代碼展示了陣列的值類型特性。改變array2的值並不會影響array1的值。\n陣列的限制 固定大小： 陣列在宣告時需要指定固定的大小，且無法在運行時動態改變。這意味著陣列的容量是固定的，可能會限制資料集合的彈性。 資源浪費： 如果分配了比實際使用更大的陣列，可能會浪費記憶體。而若分配比需求小的陣列，可能會限制數據的存儲。 不適合動態資料： 由於固定大小，陣列不太適合儲存動態增減的資料集合，這方面切片（Slice）更適合。 使用場景 固定大小需求： 當你確定資料集合的大小是固定的，且不會變動時，陣列是一個不錯的選擇，如一週的天數、一個月的天數等。 簡單的資料儲存： 如果你僅需要儲存一些數值，且不需要動態調整大小，陣列可以很好地滿足需求。 記憶體效能要求： 陣列在記憶體中是連續儲存的，這可以提供更好的存取效能，特別是當資料量較小時。 多維資料： 陣列可以用於建立多維資料結構，例如矩陣，如果資料的結構相對固定，陣列是一個不錯的選擇。 資料安全性： 陣列的大小固定，這可以防止意外的資料溢位，有助於維護資料的安全性。 常見用法 取得陣列長度 使用內建函式len()即可取得陣列長度 var a[10]int fmt.Println(len(a)) 計算陣列元素總和 numbers := [5]int{10, 20, 30, 40, 50} var sum int for _, num := range numbers { sum += num } fmt.Println(\u0026#34;總和：\u0026#34;, sum) // 輸出總和：150 計算陣列元素平均值 numbers := [5]float64{98, 93, 77, 82, 83} var sum float64 for _, num := range numbers { sum += num } average := sum / float64(len(numbers)) fmt.Printf(\u0026#34;平均值：%.2f\\n\u0026#34;, average) // 輸出平均值：86.60 尋找最大和最小值 numbers := [5]int{10, 20, 30, 40, 50} max := numbers[0] min := numbers[0] for _, num := range numbers { if num \u0026gt; max { max = num } if num \u0026lt; min { min = num } } fmt.Println(\u0026#34;最大值：\u0026#34;, max) // 輸出最大值：50 fmt.Println(\u0026#34;最小值：\u0026#34;, min) // 輸出最小值：10 陣列反轉 numbers := [5]int{10, 20, 30, 40, 50} reversedNumbers := [5]int{} for i, j := 0, len(numbers)-1; i \u0026lt; len(numbers); i, j = i+1, j-1 { reversedNumbers[j] = numbers[i] } fmt.Println(\u0026#34;反轉陣列：\u0026#34;, reversedNumbers) // 輸出反轉陣列：[50 40 30 20 10] 小結 陣列在Go語言中是一個基本的資料結構，用來固定儲存相同類型的元素。雖然使用受限，但在需要保持順序和固定大小的資料集合時非常實用。它在儲存資料、計算總和、平均值等方面扮演重要角色。陣列能透過索引初始化，特定位置賦值，其他位置保留預設值。無論使用索引或range，都能輕鬆迭代陣列元素，進行各種操作。陣列值需相同類型，且在記憶體中連續儲存，存取效率高。但記住，陣列大小固定，儲存可變數量元素可考慮使用切片。\n📚Reference Effective Go - The Go Programming Language [Golang] Slice and Array | PJCHENder 未整理筆記 ","permalink":"https://sz9751210.github.io/posts/go-array/","summary":"👨‍💻簡介 陣列就像是一個儲存相同類型資料的容器，你可以想像成裝滿了一樣東西的盒子，每個東西都叫做陣列元素。這種類型可以是基本的，像是整數或字串，也可以是你自己定義的型別。不過陣列有個限制，就是大小一旦確定就無法改變。在Go語言裡，陣列的長度也是型別的一部分。舉例來說，[5]int和[10]int就是不同的型別。雖然它們都是整數陣列，但因為長度不同，所以視為不同的資料型別，不能直接互相給值或操作。這麼做是為了在長度上更加嚴謹，不會混淆不同大小的陣列，增加了資料的安全性。\n另一個類似的東西是切片（Slice），這東西可以想像成動態的序列，可以根據需要自由地增加或減少。不過，為了更好地理解切片，我們先學學陣列的使用。\n陣列的基本概念 陣列是由一組元素所組成的固定大小的資料結構，每個元素都有一個相應的索引。陣列的大小在宣告時就需要確定，並且在後續操作中無法改變。\n宣告和初始化陣列 在 Go 中，宣告和初始化陣列可以使用以下的語法：\nvar arr1 [3]int // 創建一個整數陣列，大小為 3 arr2 := [4]string{\u0026#34;A\u0026#34;, \u0026#34;B\u0026#34;} // 創建一個包含 4 個字串元素的陣列 arr3 := [...]int{1, 2, 3} // 自動推斷陣列大小為 3 你也可以在宣告陣列的同時，使用指定索引的方式來初始化陣列：\narr := [...]int{1: 10, 3: 30} // 陣列的值為 [0 10 0 30] 陣列的基本操作 取得陣列元素 陣列的元素可以通過索引來存取，索引從 0 開始計數。\nnumbers := [5]int{10, 20, 30, 40, 50} firstNumber := numbers[0] // 存取第一個元素，值為 10 secondNumber := numbers[1] // 存取第二個元素，值為 20 假設我們有一個陣列 arr := [5]int{1, 2, 3, 4, 5}。","title":"陣列：Go語言中的數據小倉庫"},{"content":"👨‍💻簡介 本文簡單介紹了 Go 語言的流程控制概念，涵蓋了從條件語句到迴圈，再到 range 遍歷數據結構，以及 goto 與標籤 label 的應用。主要知識點為如何使用 if 語句進行條件判斷，以及在不同情況下運用 switch 語句。此外，還探討了 for 迴圈和 range 的運用，以及在特定情境下使用 goto 與 label。\n條件語句 在 Go 語言中，我們可以使用條件語句來根據不同的條件執行不同的程式碼塊。常見的條件語句包括：\nif 語句 if 語句用來檢查一個條件是否成立，如果條件為真，就執行相關的程式碼塊。例如：\nage := 18 if age \u0026gt;= 18 { fmt.Println(\u0026#34;你已成年\u0026#34;) } else { fmt.Println(\u0026#34;你還未成年\u0026#34;) } 我們也可以使用 else if 分支處理多種情況：\nage := 25 if age \u0026lt; 18 { fmt.Println(\u0026#34;你還未成年\u0026#34;) } else if age \u0026gt;= 18 \u0026amp;\u0026amp; age \u0026lt; 60 { fmt.Println(\u0026#34;你已成年，但尚未退休\u0026#34;) } else { fmt.Println(\u0026#34;你已退休\u0026#34;) } 我們甚至可以在 if 語句中宣告並初始化一個變數，然後根據條件進行判斷：\nif num2 := 10; num2 \u0026gt;= 10 { fmt.Println(\u0026#34;變數 num2 大於等於 10\u0026#34;) } switch 語句 switch 語句用來根據不同的值進行不同的處理。我們可以使用 switch 來避免多個 if 判斷。例如：\nday := \u0026#34;Sunday\u0026#34; switch day { case \u0026#34;Monday\u0026#34;: fmt.Println(\u0026#34;星期一\u0026#34;) case \u0026#34;Tuesday\u0026#34;: fmt.Println(\u0026#34;星期二\u0026#34;) case \u0026#34;Sunday\u0026#34;: fmt.Println(\u0026#34;星期天\u0026#34;) default: fmt.Println(\u0026#34;其他天\u0026#34;) } 我們也可以在 switch 語句中宣告並初始化一個變數，然後根據其值進行判斷：\nswitch day := \u0026#34;Sunday\u0026#34;; day { case \u0026#34;Monday\u0026#34;: fmt.Println(\u0026#34;星期一\u0026#34;) case \u0026#34;Tuesday\u0026#34;: fmt.Println(\u0026#34;星期二\u0026#34;) case \u0026#34;Sunday\u0026#34;: fmt.Println(\u0026#34;星期天\u0026#34;) default: fmt.Println(\u0026#34;其他天\u0026#34;) } 我們甚至可以在 case 中處理多個值，共用相同的程式碼塊，例如：\nday := \u0026#34;Saturday\u0026#34; switch day { case \u0026#34;Monday\u0026#34;, \u0026#34;Tuesday\u0026#34;, \u0026#34;Wednesday\u0026#34;, \u0026#34;Thursday\u0026#34;, \u0026#34;Friday\u0026#34;: fmt.Println(\u0026#34;工作日\u0026#34;) case \u0026#34;Saturday\u0026#34;, \u0026#34;Sunday\u0026#34;: fmt.Println(\u0026#34;週末\u0026#34;) default: fmt.Println(\u0026#34;其他\u0026#34;) } 迴圈 迴圈是一種重複執行程式碼塊的結構。Go 語言提供了幾種迴圈方式：\nfor 迴圈 for 迴圈用來重複執行一段程式碼塊，可以指定初始值、條件和遞增方式。例如：\nfor i := 0; i \u0026lt; 5; i++ { fmt.Println(i) } while 迴圈 Go 語言中沒有 while 關鍵字，但我們可以使用 for 迴圈來實現類似的功能：\nnum := 0 for num \u0026lt; 5 { fmt.Println(num) num++ } 無限迴圈 我們可以使用 for 迴圈來創建無限迴圈，例如：\nfor { fmt.Println(\u0026#34;無限迴圈\u0026#34;) } 使用 range 遍歷數據結構 除了上述的迴圈方式外，我們還可以使用 range 關鍵字來遍歷數組、切片、字串、映射等數據結構。例如：\nnumbers := []int{1, 2, 3, 4, 5} for index, value := range numbers { fmt.Printf(\u0026#34;索引 %d 的值為 %d\\n\u0026#34;, index, value) } word := \u0026#34;Hello\u0026#34; for index, char := range word { fmt.Printf(\u0026#34;索引 %d 的字符為 %c\\n\u0026#34;, index, char) } 跳出與繼續 在迴圈中，我們可以使用 break 來提前結束迴圈，使用 continue 來跳過本次迭代，繼續下一次迭代。\nfor i := 0; i \u0026lt; 5; i++ { if i == 2 { continue // 跳過本次迭代，繼續下一次迭代 } if i == 4 { break // 提前結束迴圈 } fmt.Println(i) } 跳轉語句 goto 在某些情況下，我們可能需要使用 goto 來直接跳轉到程式碼中的指定標籤位置。然而，goto 往往會讓程式碼變得複雜且難以理解，因此在實際開發中應謹慎使用。\nfunc main() { i := 0 Loop: fmt.Println(i) i++ if i \u0026lt; 5 { goto Loop } } 標籤 label label 是一種用於標記程式碼位置的方式，通常與 goto 一起使用。較少使用 label 和 goto 的程式碼更容易閱讀和維護。以下是一個使用 label 和 goto 的範例：\nfunc main() { outer := 0 LoopOuter: for outer \u0026lt; 3 { inner := 0 LoopInner: for inner \u0026lt; 3 { fmt.Printf(\u0026#34;外部迴圈：%d，內部迴圈：%d\\n\u0026#34;, outer, inner) inner++ goto LoopInner } outer++ goto LoopOuter } } 注意事項 在使用條件語句時，確保清楚地理解不同分支的執行情況，避免邏輯錯誤。 在使用迴圈時，謹記設定適當的終止條件，以免陷入無限迴圈。 📚Reference Effective Go - The Go Programming Language [Golang] 流程控制 Control Flow | PJCHENder 未整理筆記 ","permalink":"https://sz9751210.github.io/posts/go-control-flow/","summary":"👨‍💻簡介 本文簡單介紹了 Go 語言的流程控制概念，涵蓋了從條件語句到迴圈，再到 range 遍歷數據結構，以及 goto 與標籤 label 的應用。主要知識點為如何使用 if 語句進行條件判斷，以及在不同情況下運用 switch 語句。此外，還探討了 for 迴圈和 range 的運用，以及在特定情境下使用 goto 與 label。\n條件語句 在 Go 語言中，我們可以使用條件語句來根據不同的條件執行不同的程式碼塊。常見的條件語句包括：\nif 語句 if 語句用來檢查一個條件是否成立，如果條件為真，就執行相關的程式碼塊。例如：\nage := 18 if age \u0026gt;= 18 { fmt.Println(\u0026#34;你已成年\u0026#34;) } else { fmt.Println(\u0026#34;你還未成年\u0026#34;) } 我們也可以使用 else if 分支處理多種情況：\nage := 25 if age \u0026lt; 18 { fmt.Println(\u0026#34;你還未成年\u0026#34;) } else if age \u0026gt;= 18 \u0026amp;\u0026amp; age \u0026lt; 60 { fmt.Println(\u0026#34;你已成年，但尚未退休\u0026#34;) } else { fmt.","title":"探索 Go 語言的流程控制"},{"content":"👨‍💻簡介 本文快速介紹了 Go 語言中的各種運算符，從數學計算到邏輯判斷，包括自增自減、賦值、比較和位運算。透過實例和清晰的解釋，快速掌握如何在程式中運用這些運算符。\n算術運算符 在 Go 語言中，我們可以使用各種算術運算符來執行基本的數學運算。以下是一些常用的算術運算符：\n+：加法運算，用來將兩個數相加。 -：減法運算，用來從一個數中減去另一個數。 *：乘法運算，用來將兩個數相乘。 /：除法運算，用來將一個數除以另一個數。 %：求餘運算，用來得到兩個數相除的餘數。 例如：\na := 5 b := 3 c := a + b // c 的值是 8 d := a * b // d 的值是 15 此外，我們還有自增和自減運算符，它們用來讓變數的值增加或減少 1：\n++：自增運算符，將變數的值增加 1。 --：自減運算符，將變數的值減少 1。 舉個例子：\nx := 10 x++ // x 的值變成了 11 y := 5 y-- // y 的值變成了 4 賦值運算符 賦值運算符用來將一個值賦給一個變數。我們常見的賦值運算符有：\n=：將右邊的值賦給左邊的變數。 +=：先將右邊的值加到左邊的變數上，然後再將結果賦給左邊的變數。 -=：先從左邊的變數中減去右邊的值，然後再將結果賦給左邊的變數。 *=：先將左邊的變數乘以右邊的值，然後再將結果賦給左邊的變數。 /=：先將左邊的變數除以右邊的值，然後再將結果賦給左邊的變數。 %=：先將左邊的變數除以右邊的值取餘數，然後再將結果賦給左邊的變數。 簡單範例如下：\na := 10 b := 5 // = a = 20 // a 的值變成了 20 // += a += b // 等同於 a = a + b，所以 a 的值變成了 25 // -= a -= b // 等同於 a = a - b，所以 a 的值變成了 20 // *= a *= b // 等同於 a = a * b，所以 a 的值變成了 100 // /= a /= b // 等同於 a = a / b，所以 a 的值變成了 20 // %= a %= b // 等同於 a = a % b，所以 a 的值變成了 0 比較運算符 比較運算符用來比較兩個值的大小或者是否相等。我們常用的比較運算符有：\n==：判斷兩個值是否相等。 !=：判斷兩個值是否不相等。 \u0026lt;：判斷左邊的值是否小於右邊的值。 \u0026gt;：判斷左邊的值是否大於右邊的值。 \u0026lt;=：判斷左邊的值是否小於等於右邊的值。 \u0026gt;=：判斷左邊的值是否大於等於右邊的值。 以下為使用範例：\nx := 10 y := 5 isEqual := x == y // false，因為 x 不等於 y isNotEqual := x != y // true，因為 x 不等於 y isLess := x \u0026lt; y // false，因為 x 不小於 y isGreater := x \u0026gt; y // true，因為 x 大於 y isLessOrEqual := x \u0026lt;= y // false，因為 x 不小於等於 y isGreaterOrEqual := x \u0026gt;= y // true，因為 x 大於等於 y 邏輯運算符 邏輯運算符用來執行邏輯操作。我們常用的邏輯運算符有：\n\u0026amp;\u0026amp;：邏輯與，用來判斷多個條件是否同時滿足。 ||：邏輯或，用來判斷多個條件是否至少有一個滿足。 !：邏輯非，用來取反一個條件的結果。 以下為使用範例：\np := true q := false andResult := p \u0026amp;\u0026amp; q // false，因為 p 和 q 不都為 true orResult := p || q // true，因為 p 或 q 至少有一個為 true notResult := !p // false，因為 p 為 true，取反後為 false 位運算符 位運算符用來在二進制位級別執行操作。我們常用的位運算符有：\n\u0026amp;：按位與，對每一位進行與操作。 |：按位或，對每一位進行或操作。 ^：按位異或，對每一位進行異或操作。 \u0026lt;\u0026lt;：左移，將二進制位向左移動指定的位數。 \u0026gt;\u0026gt;：右移，將二進制位向右移動指定的位數。 以下為使用範例：\na := 5 // 二進制表示：0101 b := 3 // 二進制表示：0011 andResult := a \u0026amp; b // 二進制表示：0001，十進制表示：1 orResult := a | b // 二進制表示：0111，十進制表示：7 xorResult := a ^ b // 二進制表示：0110，十進制表示：6 leftShiftResult := a \u0026lt;\u0026lt; 1 // 二進制表示：1010，十進制表示：10 rightShiftResult := a \u0026gt;\u0026gt; 1 // 二進制表示：0010，十進制表示：2 其他運算符 其他運算符用來執行一些特定的操作。我們常用的其他運算符有：\n\u0026amp;：取地址，用來獲取變數的內存地址。 *：指針，用來聲明指針變數。 \u0026lt;-：通道操作符，用來發送和接收通道消息。 以下為使用範例：\nvar num int = 42 ptr := \u0026amp;num // ptr 現在包含 num 的內存地址 var value int = *ptr // value 現在包含 ptr 所指向的內存中的值 ch := make(chan int) // 創建一個整數通道 ch \u0026lt;- 10 // 將值 10 發送到通道 ch 中 receivedValue := \u0026lt;-ch // 從通道 ch 接收值並存儲在 receivedValue 中 📚Reference The Go Programming Language Specification - The Go Programming Language Go Operators - GeeksforGeeks ","permalink":"https://sz9751210.github.io/posts/go-operator/","summary":"👨‍💻簡介 本文快速介紹了 Go 語言中的各種運算符，從數學計算到邏輯判斷，包括自增自減、賦值、比較和位運算。透過實例和清晰的解釋，快速掌握如何在程式中運用這些運算符。\n算術運算符 在 Go 語言中，我們可以使用各種算術運算符來執行基本的數學運算。以下是一些常用的算術運算符：\n+：加法運算，用來將兩個數相加。 -：減法運算，用來從一個數中減去另一個數。 *：乘法運算，用來將兩個數相乘。 /：除法運算，用來將一個數除以另一個數。 %：求餘運算，用來得到兩個數相除的餘數。 例如：\na := 5 b := 3 c := a + b // c 的值是 8 d := a * b // d 的值是 15 此外，我們還有自增和自減運算符，它們用來讓變數的值增加或減少 1：\n++：自增運算符，將變數的值增加 1。 --：自減運算符，將變數的值減少 1。 舉個例子：\nx := 10 x++ // x 的值變成了 11 y := 5 y-- // y 的值變成了 4 賦值運算符 賦值運算符用來將一個值賦給一個變數。我們常見的賦值運算符有：\n=：將右邊的值賦給左邊的變數。 +=：先將右邊的值加到左邊的變數上，然後再將結果賦給左邊的變數。 -=：先從左邊的變數中減去右邊的值，然後再將結果賦給左邊的變數。 *=：先將左邊的變數乘以右邊的值，然後再將結果賦給左邊的變數。 /=：先將左邊的變數除以右邊的值，然後再將結果賦給左邊的變數。 %=：先將左邊的變數除以右邊的值取餘數，然後再將結果賦給左邊的變數。 簡單範例如下：","title":"Go 語言的各種運算符"},{"content":"甚麼是secret 在 Kubernetes 裡，Secret 就像是一個保險箱，可以放你任何不想公開的東西。比如說密碼、API 金鑰、憑證等，這樣的資料可能會被放在 Pod 裡，但你可以用 Secret 來避免直接在應用程式的程式碼中暴露這些機密資料。 可以說 Secret 就像是 ConfigMap 的一個好朋友，但更專門用來保護機密資料的地方。\n為甚麼需要secret 最主要的用意是保護你的敏感資訊，不讓它們在 Pod 或容器中以明文流傳。這樣可以讓我們的應用程式變得更安全，減少機密資訊外洩的風險。還能讓你的秘密資料在不同 Pod 之間分享，並且保有安全性。\n何時使用secret 保存必要應用程式的憑證，如 TLS 證書，以確保安全通信。 儲存應用程式所需的金鑰，包括外部服務的 API 金鑰，確保安全連接。 保管敏感的環境變數，如資料庫密碼等機密驗證資訊，維護應用程式安全性。 安全儲存驗證資訊，如 OAuth 令牌，用於與其他應用程式進行安全交互。 維持隱私的配置設定，如設定文件、金鑰路徑等，確保敏感資訊不外洩。 secret的類型有哪些 內建類型 用途 Opaque 使用者定義的任意資料 kubernetes.io/service-account-token 服務帳戶令牌 kubernetes.io/dockercfg ~/.dockercfg 檔案的序列化形式 kubernetes.io/dockerconfigjson ~/.docker/config.json 檔案的序列化形式 kubernetes.io/basic-auth 用於基本身份驗證的憑證 kubernetes.io/ssh-auth 用於 SSH 身份驗證的憑證 kubernetes.io/tls 用於 TLS 客戶端或伺服器端的資料 bootstrap.kubernetes.io/token 啟動引導令牌資料 如何撰寫使用secret 建立secret 聲明式 apiVersion: v1 kind: Secret metadata: name: my-secret data: username: YWRtaW4= # Base64 編碼的 \u0026#34;admin\u0026#34; password: c2VjcmV0cGFzc3dvcmQ= # Base64 編碼的 \u0026#34;secretpassword\u0026#34; 宣告式 從命令行傳遞資訊建立secret kubectl create secret generic my-secret --from-literal=username=admin --from-literal=password=secretpassword 從檔案建立secret kubectl create secret generic my-secret --from-file=path/to/username.txt --from-file=path/to/password.txt 使用secret 我們可以用剛剛創建的 my-secret 來做以下的範例\nsecret作為環境變數 apiVersion: v1 kind: Pod metadata: name: secret-env-demo-pod spec: containers: - name: demo-container image: busybox command: [\u0026#34;/bin/sh\u0026#34;, \u0026#34;-c\u0026#34;, \u0026#34;echo Username: $USERNAME \u0026amp;\u0026amp; echo Password: $PASSWORD\u0026#34;] env: - name: USERNAME valueFrom: secretKeyRef: name: my-secret key: username - name: PASSWORD valueFrom: secretKeyRef: name: my-secret key: password restartPolicy: Never 透過kubectl logs secret-env-demo-pod查看log\nUsername: admin Password: secretpassword 將secret掛載到一個或多個容器 apiVersion: v1 kind: Pod metadata: name: secret-volume-demo-pod spec: containers: - name: first-container image: busybox command: [\u0026#34;/bin/sh\u0026#34;, \u0026#34;-c\u0026#34;, \u0026#34;cat /etc/secret/username\u0026#34;] volumeMounts: - name: secret-volume mountPath: /etc/secret - name: second-container image: busybox command: [\u0026#34;/bin/sh\u0026#34;, \u0026#34;-c\u0026#34;, \u0026#34;cat /etc/secret/password\u0026#34;] volumeMounts: - name: secret-volume mountPath: /etc/secret volumes: - name: secret-volume secret: secretName: my-secret 使用以下命令檢查輸出\nkubectl logs secret-volume-demo-pod -c first-container kubectl logs secret-volume-demo-pod -c second-container output\n## first-container admin ## second-container secretpassword secret作為拉取private registry image時使用 apiVersion: v1 kind: Pod metadata: name: secret-imagepull-demo-pod spec: containers: - name: demo-container image: \u0026lt;private_registry_image\u0026gt; imagePullSecrets: - name: my-secret secret有哪些特點 強大的資料加密：Secret 的一大優點在於它可以對敏感資料進行強大的加密保護。這保障了秘密資訊不會輕易被未授權的人看到，大幅減低了資訊外洩的風險。 Base64 編碼的轉換：Secret 在儲存資料時會使用 Base64 編碼，但是請注意這並非最高等級的安全標準，它不能取代真正的加密方法。這樣的編碼能夠保護資料，但需要在操作時謹慎以保障資訊安全。 簡便的整合：透過 Secret，我們能夠輕鬆地將敏感資料整合到應用程式中，例如透過環境變數、掛載資料夾等方式，讓 Pod 可以無縫地使用這些敏感資料。 安全的資訊分享：Secret 也提供了一種安全的方式，讓不同的 Pod 或其他 Kubernetes 資源可以共用敏感資訊，同時保持資料的保密性。這讓不同部分的應用能夠互相協作，同時不會威脅資訊安全。 Reference Secret | Kubernetes ","permalink":"https://sz9751210.github.io/posts/k8s-secret/","summary":"甚麼是secret 在 Kubernetes 裡，Secret 就像是一個保險箱，可以放你任何不想公開的東西。比如說密碼、API 金鑰、憑證等，這樣的資料可能會被放在 Pod 裡，但你可以用 Secret 來避免直接在應用程式的程式碼中暴露這些機密資料。 可以說 Secret 就像是 ConfigMap 的一個好朋友，但更專門用來保護機密資料的地方。\n為甚麼需要secret 最主要的用意是保護你的敏感資訊，不讓它們在 Pod 或容器中以明文流傳。這樣可以讓我們的應用程式變得更安全，減少機密資訊外洩的風險。還能讓你的秘密資料在不同 Pod 之間分享，並且保有安全性。\n何時使用secret 保存必要應用程式的憑證，如 TLS 證書，以確保安全通信。 儲存應用程式所需的金鑰，包括外部服務的 API 金鑰，確保安全連接。 保管敏感的環境變數，如資料庫密碼等機密驗證資訊，維護應用程式安全性。 安全儲存驗證資訊，如 OAuth 令牌，用於與其他應用程式進行安全交互。 維持隱私的配置設定，如設定文件、金鑰路徑等，確保敏感資訊不外洩。 secret的類型有哪些 內建類型 用途 Opaque 使用者定義的任意資料 kubernetes.io/service-account-token 服務帳戶令牌 kubernetes.io/dockercfg ~/.dockercfg 檔案的序列化形式 kubernetes.io/dockerconfigjson ~/.docker/config.json 檔案的序列化形式 kubernetes.io/basic-auth 用於基本身份驗證的憑證 kubernetes.io/ssh-auth 用於 SSH 身份驗證的憑證 kubernetes.io/tls 用於 TLS 客戶端或伺服器端的資料 bootstrap.kubernetes.io/token 啟動引導令牌資料 如何撰寫使用secret 建立secret 聲明式 apiVersion: v1 kind: Secret metadata: name: my-secret data: username: YWRtaW4= # Base64 編碼的 \u0026#34;admin\u0026#34; password: c2VjcmV0cGFzc3dvcmQ= # Base64 編碼的 \u0026#34;secretpassword\u0026#34; 宣告式 從命令行傳遞資訊建立secret kubectl create secret generic my-secret --from-literal=username=admin --from-literal=password=secretpassword 從檔案建立secret kubectl create secret generic my-secret --from-file=path/to/username.","title":"Kubernetes Secret"},{"content":"👨‍💻簡介 Go 語言有各種資料型別，分為基本型別和複合型別。基本型別包括：\n整數、浮點數、布林值、字串 複合型別包括：\n陣列、片段、結構、函式、對映、通道、介面 等。 整數型別 整數型別有許多種，像是 int8、int16、int32、int64。我們可以依據實際需求選擇。\n你甚至可以使用 int 關鍵字，它會依據不同作業系統自動選擇大小：\n在 32 位作業系統：int 會變成 int32 在 64 位作業系統：int 會變成 int64 但是，別忘了，數字型別還有其範圍和特點。\n型別 位元組數 最小值 最大值 次方範圍 int8 1 -128 127 -2^7 至 2^7-1 int16 2 -32,768 32,767 -2^15 至 2^15-1 int32 4 -2,147,483,648 2,147,483,647 -2^31 至 2^31-1 int64 8 -9,223,372,036,854,775,808 9,223,372,036,854,775,807 -2^63 至 2^63-1 uint8 1 0 255 0 至 2^8-1 uint16 2 0 65,535 0 至 2^16-1 uint32 4 0 4,294,967,295 0 至 2^32-1 uint64 8 0 18,446,744,073,709,551,615 0 至 2^64-1 可以通過 unsafe.Sizeof 來查看不同長度的整數，在記憶體中的儲存空間。\nvar num2 = 12 fmt.Println(unsafe.Sizeof(num2)) 轉換型別 要進行型別轉換，只需在變數前面指定目標型別即可。\nvar a1 int16 = 10 var a2 int32 = 12 var a3 = int32(a1) + a2 fmt.Println(a3) 但當高位轉低位時，可能會有精度損失。例如，從 16 位轉為 8 位，可能會有數據丟失。\nvar n1 int16 = 130 fmt.Println(int8(n1)) // 變成 -126 數值字面量(literal) 自 Go 1.13 版本起，你可以使用數值字面量語法，以二進制、八進制或十六進制格式來定義數字：\nv := 0b00101101 // 代表二進制的101101 v := 0o377 // 代表八進制的377 進制轉換 你可以透過不同進制來表示數字，例如：\nvar number = 17 fmt.Printf(\u0026#34;原樣輸出：%v\\n\u0026#34;, number) fmt.Printf(\u0026#34;十進制輸出：%d\\n\u0026#34;, number) fmt.Printf(\u0026#34;八進制輸出：%o\\n\u0026#34;, number) fmt.Printf(\u0026#34;二進制輸出：%b\\n\u0026#34;, number) fmt.Printf(\u0026#34;十六進制輸出：%x\\n\u0026#34;, number) 浮點數型別 Go 語言支援兩種浮點數型別：float32 和 float64。這兩種浮點數遵循 IEEE754 標準：\nfloat32 的最大範圍約為 3.4e38，你可以使用常數 math.MaxFloat32 來表示。 float64 的最大範圍約為 1.8e308，你可以使用常數 math.MaxFloat64 來表示。 打印浮點數時，可以使用 fmt 套件的 %f 來控制小數點位數：\nvar pi = math.Pi fmt.Printf(\u0026#34;預設小數點後6位：%f\\n\u0026#34;, pi) fmt.Printf(\u0026#34;小數點後保留2位：%.2f\\n\u0026#34;, pi) 浮點數精度問題 幾乎所有程式語言都會有精度損失的問題，這在計算機科學中是常見的問題。例如：\nd := 1129.6 fmt.Println(d * 100) // 輸出 112959.99999999 如果需要高精度計算，可以考慮使用第三方套件來解決，例如：\nshopspring/decimal: 在 Go 中實現的任意精度固定小數點數字 (github.com)\n布林型別 定義布林型別很簡單：\nvar fl = false if fl { fmt.Println(\u0026#34;true\u0026#34;) } else { fmt.Println(\u0026#34;false\u0026#34;) } 字串型別 在 Go 語言中，字串是原生資料型別，與其他型別一樣使用。Go 語言內部使用 UTF-8 編碼來表示字串。你可以在雙引號（\u0026quot;）中放置內容來表示字串，甚至可以在程式碼中添加非 ASCII 字元。\ns1 := \u0026#34;hello\u0026#34; s2 := \u0026#34;你好\u0026#34; 如果想要定義多行字串，可以使用反引號：\nvar str = `這是第一行 這是第二行` fmt.Println(str) 字串還支援許多常見的操作，例如計算長度、串接、分割、判斷是否包含、前綴和後綴判斷、尋找子字串位置等。\n字串常見操作 len(str)：計算長度 + 或 fmt.Sprintf：串接字串 strings.Split：分割字串 strings.Contains：判斷是否包含 strings.HasPrefix，strings.HasSuffix：前綴/後綴判斷 strings.Index()，strings.LastIndex()：子字串出現的位置 strings.Join()：合併操作 strings.Index()：判斷在字串中的位置 byte 和 rune 型別 構成每個字串的元素稱為「字符」，可以通過遍歷字串元素獲取字符。字符使用單引號 \u0026rsquo;\u0026rsquo; 包裹起來。\nGo語言中的字符有以下兩種型別：\nuint8型別：也叫byte型，代表了ACII碼的一個字符 rune型別：代表一個UTF-8字符 當需要處理中文、日文或其他複合字符時，就需要使用rune型別。rune型別實際上是一個int32。\nGo使用了特殊的rune型別來處理Unicode，讓基於Unicode的文本處理更加方便。也可以使用byte型進行默認字串處理，性能和擴展性都得到考慮。\n需要注意的是，在Go語言中，一個漢字佔用3個位元組（UTF-8編碼），一個字母佔用1個位元組。\npackage main import \u0026#34;fmt\u0026#34; func main() { var a byte = \u0026#39;a\u0026#39; fmt.Println(a) // 輸出ASCII碼值，直接輸出byte（字符）時，顯示字符對應的碼值 fmt.Printf(\u0026#34;%c\u0026#34;, a) // 輸出字符 \u0026#39;a\u0026#39; s := \u0026#34;你好 golang\u0026#34; for i := 0; i \u0026lt; len(s); i++ { fmt.Printf(\u0026#34;%v(%c)\\t\u0026#34;, s[i], s[i]) // 使用 len 循環輸出 ASCII 碼 } for index, v := range s { fmt.Println(index, v) // 通過rune打印UTF-8字符 } } 修改字串 要修改字串，需要先將其轉換成[]rune 或 []byte型別，完成後再轉換成string型別。無論哪種轉換都會重新分配內存，並複製位元組陣列。\n轉換為[]byte型別\ns1 := \u0026#34;big\u0026#34; byteS1 := []byte(s1) byteS1[0] = \u0026#39;p\u0026#39; fmt.Println(string(byteS1)) 轉換為rune型別\ns2 := \u0026#34;你好golang\u0026#34; byteS2 := []rune(s2) byteS2[0] = \u0026#39;我\u0026#39; fmt.Println(string(byteS2)) 基本型別轉換 數值型別轉換 // 整數和浮點數之間的轉換 var aa int8 = 20 var bb int16 = 40 fmt.Println(int16(aa) + bb) // 建議從整數轉換為浮點數 var cc int8 = 20 var dd float32 = 40 fmt.Println(float32(cc) + dd) 建議從低位轉換為高位，這樣可以避免丟失精度。\n轉換為字串型別 轉換為字串型別有兩種方法，一是使用 fmt.Sprintf()，二是使用 strconv 套件的函式。\n使用 fmt.Sprintf()：\n// 字串型別轉換 var i int = 20 var f float64 = 12.456 var t bool = true var b byte = \u0026#39;a\u0026#39; str1 := fmt.Sprintf(\u0026#34;%d\u0026#34;, i) fmt.Printf(\u0026#34;類型：%v-%T \\n\u0026#34;, str1, str1) str2 := fmt.Sprintf(\u0026#34;%f\u0026#34;, f) fmt.Printf(\u0026#34;類型：%v-%T \\n\u0026#34;, str2, str2) str3 := fmt.Sprintf(\u0026#34;%t\u0026#34;, t) fmt.Printf(\u0026#34;類型：%v-%T \\n\u0026#34;, str3, str3) str4 := fmt.Sprintf(\u0026#34;%c\u0026#34;, b) fmt.Printf(\u0026#34;類型：%v-%T \\n\u0026#34;, str4, str4) 使用 strconv 套件的函式：\n// 將int型別轉換為str型別 var num1 int64 = 20 s1 := strconv.FormatInt(num1, 10) fmt.Printf(\u0026#34;轉換：%v - %T\u0026#34;, s1, s1) // 將float型別轉換為string型別 var num2 float64 = 3.1415926 /* 參數1：要轉換的值 參數2：格式化型別 \u0026#39;f\u0026#39;表示float，\u0026#39;b\u0026#39;表示二進制，‘e’表示十進制 參數3：表示保留的小數點，-1表示不格式化小數點 參數4：格式化的型別，傳入64位或32位 */ s2 := strconv.FormatFloat(num2, \u0026#39;f\u0026#39;, -1, 64) fmt.Printf(\u0026#34;轉換：%v-%T\u0026#34;, s2, s2) 字串轉換為數值型別 將字串轉換為數值型別也很容易，使用 strconv 套件即可：\nstr := \u0026#34;10\u0026#34; // 第一個參數：需要轉換的數值，第二個參數：進制，參數三：32位或64位 num,_ = strconv.ParseInt(str, 10, 64) // 轉換為float型別 str2 := \u0026#34;3.141592654\u0026#34; num,_ = strconv.ParseFloat(str2, 10) 記得檢查轉換錯誤（例如無效的字串格式），這就是 _ 的作用。\n📚Reference\nGo Data Types (w3schools.com) Data Types in Go - GeeksforGeeks [Golang] 資料型別 Data Types | PJCHENder 未整理筆記 ","permalink":"https://sz9751210.github.io/posts/golang-datatype/","summary":"👨‍💻簡介 Go 語言有各種資料型別，分為基本型別和複合型別。基本型別包括：\n整數、浮點數、布林值、字串 複合型別包括：\n陣列、片段、結構、函式、對映、通道、介面 等。 整數型別 整數型別有許多種，像是 int8、int16、int32、int64。我們可以依據實際需求選擇。\n你甚至可以使用 int 關鍵字，它會依據不同作業系統自動選擇大小：\n在 32 位作業系統：int 會變成 int32 在 64 位作業系統：int 會變成 int64 但是，別忘了，數字型別還有其範圍和特點。\n型別 位元組數 最小值 最大值 次方範圍 int8 1 -128 127 -2^7 至 2^7-1 int16 2 -32,768 32,767 -2^15 至 2^15-1 int32 4 -2,147,483,648 2,147,483,647 -2^31 至 2^31-1 int64 8 -9,223,372,036,854,775,808 9,223,372,036,854,775,807 -2^63 至 2^63-1 uint8 1 0 255 0 至 2^8-1 uint16 2 0 65,535 0 至 2^16-1 uint32 4 0 4,294,967,295 0 至 2^32-1 uint64 8 0 18,446,744,073,709,551,615 0 至 2^64-1 可以通過 unsafe.","title":"Golang 的資料型別一覽"},{"content":"👨‍💻簡介 在 Golang 中，你可以使用不同的方式來宣告變數和常數。宣告變數時，可以直接指定值，或者使用型別推導，更簡單地用 := 來宣告局部變數。另外，還可以一次宣告多個變數，相同型別的變數可以一起宣告，或者使用括號宣告不同型別的變數。常數則使用 const 關鍵字宣告，確保值不變，有助於提高程式碼的可讀性和穩定性。\n變數的聲明 在 Golang 裡，變數是程式中保存資料的容器。變數名稱由字母、數字、底線組成，但首個字符不能是數字。Golang 的關鍵字和保留字都不能用作變數名稱。\n變數的宣告和初始化方式多種多樣，在使用變數之前，需要先聲明變數。在同一範圍內，不允許重複聲明相同的變數。而且，一旦聲明變數，就必須在之後的程式碼中使用它。\n如果變數在聲明後沒有進行初始化，則打印出來的值將是空的。\n如何定義變數 單變數宣告 普通聲明(variable declaration) 使用 var 關鍵字進行普通聲明，然後指定變數名稱和類型，再賦予初始值。 var name string name = \u0026#34;Alan\u0026#34; 帶初始化的聲明(direct define)： 可以直接指定變數的類型和初始值。 var age int = 25 也可以省略類型，讓變數類型根據初始值自動推斷。\nvar age = 25 簡短變數聲明(short declaration) 在函式內部，可以使用簡化的 := 語法同時宣告並初始化變數。 注意：簡短變數聲明只能用於局部變數，不能用於全局變數的聲明。\nfoo := \u0026#34;hello\u0026#34; bar := 100 多變數宣告 普通聲明 您可以同時宣告多個相同類型的變數。 var a, b int a = 10 b = 20 帶初始化的聲明(direct define)： 可以直接指定多個變數的類型和初始值。 var x, y int = 5, 8 也可以省略類型，讓變數類型根據初始值自動推斷。\nvar x, y = 5, 8 使用簡短變數聲明： 同樣也可以使用簡化的 := 語法同時宣告多個變數。 x, y := 5, 8 使用括號的平行賦值 使用括號 () 可以同時宣告多個不同類型的變數並賦予初始值。 var( foo string bar int ) var ( foo = 5 bar = \u0026#34;abc\u0026#34; ) var ( name string = \u0026#34;Alice\u0026#34; age int = 25 country string = \u0026#34;USA\u0026#34; ) 匿名變數 使用 _ 符號表示匿名變數，適用於不需要使用的變數。\n_, result := calculateSomething() 常數的定義與使用 常數是不會變動的值，可用於定義程式運行期間不會改變的數值。使用 const 關鍵字宣告常數，確保值不變，增強程式碼可讀性和穩定性。\n常數的聲明與變數的聲明非常相似，只需將 var 改成 const，並在聲明時必須賦值。\n// 定義常數 pi，可以在程式的任何地方使用 const pi = 3.14 // 同時宣告兩個常數 const( A = \u0026#34;A\u0026#34; B = \u0026#34;B\u0026#34; ) // 同時宣告多個常數，省略值則與上一行相同 const( A = \u0026#34;A\u0026#34; B C ) 使用 iota 的 Const 常數 iota 是 Golang 的常數計數器，僅能在常數表達式中使用。iota 在每次出現 const 關鍵字時，都會重置為 0（位於 const 區塊的第一行之前）。每新增一行常數聲明，iota 計數一次。\nconst a = iota // a = 0 const ( b = iota // b = 0 c // c = 1 d // d = 2 ) // 可在一開始即決定初始值 const ( b = iota+1 // b = 1 c // c = 2 d // d = 3 ) // 使用 _ 跳過某些值 const ( b = iota // b = 0 _ d // d = 2 ) 📚Reference Effective Go - The Go Programming Language A Tour of Go(variable) A Tour of Go(const) ","permalink":"https://sz9751210.github.io/posts/go-variable-and-const/","summary":"👨‍💻簡介 在 Golang 中，你可以使用不同的方式來宣告變數和常數。宣告變數時，可以直接指定值，或者使用型別推導，更簡單地用 := 來宣告局部變數。另外，還可以一次宣告多個變數，相同型別的變數可以一起宣告，或者使用括號宣告不同型別的變數。常數則使用 const 關鍵字宣告，確保值不變，有助於提高程式碼的可讀性和穩定性。\n變數的聲明 在 Golang 裡，變數是程式中保存資料的容器。變數名稱由字母、數字、底線組成，但首個字符不能是數字。Golang 的關鍵字和保留字都不能用作變數名稱。\n變數的宣告和初始化方式多種多樣，在使用變數之前，需要先聲明變數。在同一範圍內，不允許重複聲明相同的變數。而且，一旦聲明變數，就必須在之後的程式碼中使用它。\n如果變數在聲明後沒有進行初始化，則打印出來的值將是空的。\n如何定義變數 單變數宣告 普通聲明(variable declaration) 使用 var 關鍵字進行普通聲明，然後指定變數名稱和類型，再賦予初始值。 var name string name = \u0026#34;Alan\u0026#34; 帶初始化的聲明(direct define)： 可以直接指定變數的類型和初始值。 var age int = 25 也可以省略類型，讓變數類型根據初始值自動推斷。\nvar age = 25 簡短變數聲明(short declaration) 在函式內部，可以使用簡化的 := 語法同時宣告並初始化變數。 注意：簡短變數聲明只能用於局部變數，不能用於全局變數的聲明。\nfoo := \u0026#34;hello\u0026#34; bar := 100 多變數宣告 普通聲明 您可以同時宣告多個相同類型的變數。 var a, b int a = 10 b = 20 帶初始化的聲明(direct define)： 可以直接指定多個變數的類型和初始值。 var x, y int = 5, 8 也可以省略類型，讓變數類型根據初始值自動推斷。","title":"淺談 Golang 變數與常數：宣告、初始化與使用"},{"content":"👨‍💻簡介 在這篇文章裡，會簡單介紹幾個關鍵的基本概念和語法結構，加快上手這門程式語言。 文件組成\n📦文件組成 一個典型的 Go 語言程式由以下幾個部分構成，讓我們逐一來看：\nPackage 宣告 程式的一開始會有一個 package 宣告，用以指定目前的檔案隸屬於哪個程式套件（package）。\npackage main 匯入套件 我們可以透過 import 關鍵字引入所需的套件（packages）。這些套件提供各式功能，協助我們輕鬆進行開發。\nimport ( \u0026#34;fmt\u0026#34; ) 函式定義 在 Go 語言中，程式邏輯主要由函式（functions）所組成。以下是主要函式 main 的定義，它是每個 Go 程式的起點。\nfunc main() { fmt.Println(\u0026#34;Hello World!\u0026#34;) } 📝語法要點 在編寫 Go 程式時，有幾個語法上的重要要點需要注意：\n語句可以透過換行或分號（;）來分隔。 左大括號 { 不應該單獨出現在一行的開頭，應該與其他語句放在同一行。 🔍註解的用法 在程式碼中，註解可以為程式邏輯提供解釋和說明。Go 語言支援兩種註解格式：\n單行註解：\n// 這是單行註解的範例 多行註解（C 風格）：\n/* 這是多行註解的範例， 可以跨越多行並提供更多細節說明。 */ 📚參考資料 Go Syntax (w3schools.com) ","permalink":"https://sz9751210.github.io/posts/go-syntax/","summary":"👨‍💻簡介 在這篇文章裡，會簡單介紹幾個關鍵的基本概念和語法結構，加快上手這門程式語言。 文件組成\n📦文件組成 一個典型的 Go 語言程式由以下幾個部分構成，讓我們逐一來看：\nPackage 宣告 程式的一開始會有一個 package 宣告，用以指定目前的檔案隸屬於哪個程式套件（package）。\npackage main 匯入套件 我們可以透過 import 關鍵字引入所需的套件（packages）。這些套件提供各式功能，協助我們輕鬆進行開發。\nimport ( \u0026#34;fmt\u0026#34; ) 函式定義 在 Go 語言中，程式邏輯主要由函式（functions）所組成。以下是主要函式 main 的定義，它是每個 Go 程式的起點。\nfunc main() { fmt.Println(\u0026#34;Hello World!\u0026#34;) } 📝語法要點 在編寫 Go 程式時，有幾個語法上的重要要點需要注意：\n語句可以透過換行或分號（;）來分隔。 左大括號 { 不應該單獨出現在一行的開頭，應該與其他語句放在同一行。 🔍註解的用法 在程式碼中，註解可以為程式邏輯提供解釋和說明。Go 語言支援兩種註解格式：\n單行註解：\n// 這是單行註解的範例 多行註解（C 風格）：\n/* 這是多行註解的範例， 可以跨越多行並提供更多細節說明。 */ 📚參考資料 Go Syntax (w3schools.com) ","title":"🚀入門 Go 語言：關鍵概念、語法結構與實用技巧✨"},{"content":"👨‍💻如何在go中驗證SSL憑證 因之前玩過監控證書，最近在接觸golang因此來看看有甚麼方法能夠取得憑證到期日，最後發現有crypto/tls這個module可以用，驗證步驟簡單三步如下\n1. 確認網站是否有SSL證書 package main import ( \u0026#34;crypto/tls\u0026#34; ) func main() { conn, err := tls.Dial(\u0026#34;tcp\u0026#34;, \u0026#34;example.com:80\u0026#34;, nil) if err != nil { panic(\u0026#34;Server doesn\u0026#39;t support SSL certificate err: \u0026#34; + err.Error()) } } 上述程式碼首先使用 tls.Dial 建立TLS連線，語法規則為\ntls.Dial(protocol, website, tls config) 連線成功則返回一個tls.Conn\n執行後會噴以下錯誤\npanic: Server doesn\u0026#39;t support SSL certificate err: tls: first record does not look like a TLS handshake goroutine 1 [running]: 接著將網站改為google重新執行一次程式碼，沒有任何輸出表示正常，也代表網站有啟用SSL\npackage main import ( \u0026#34;crypto/tls\u0026#34; ) func main() { conn, err := tls.Dial(\u0026#34;tcp\u0026#34;, \u0026#34;www.google.com:443\u0026#34;, nil) if err != nil { panic(\u0026#34;Server doesn\u0026#39;t support SSL certificate err: \u0026#34; + err.Error()) } } 2. 確認SSL憑證和網站hostname是否吻合 可使用conn.VerifyHostname驗證server的憑證與hostname是否吻合\npackage main import ( \u0026#34;crypto/tls\u0026#34; ) func main() { conn, err := tls.Dial(\u0026#34;tcp\u0026#34;, \u0026#34;www.google.com:443\u0026#34;, nil) if err != nil { panic(\u0026#34;Server doesn\u0026#39;t support SSL certificate err: \u0026#34; + err.Error()) } err = conn.VerifyHostname(\u0026#34;www.google.com\u0026#34;) if err != nil { panic(\u0026#34;Hostname doesn\u0026#39;t match with certificate: \u0026#34; + err.Error()) } } 3. 驗證SSL憑證的到期日 我們可以透過conn.ConnectionState().PeerCertificates來取得憑證，然後透過NotAfter來取得憑證到期日\npackage main import ( \u0026#34;crypto/tls\u0026#34; \u0026#34;fmt\u0026#34; ) func main() { conn, err := tls.Dial(\u0026#34;tcp\u0026#34;, \u0026#34;www.google.com:443\u0026#34;, nil) if err != nil { panic(\u0026#34;Server doesn\u0026#39;t support SSL certificate err: \u0026#34; + err.Error()) } err = conn.VerifyHostname(\u0026#34;www.google.com\u0026#34;) if err != nil { panic(\u0026#34;Hostname doesn\u0026#39;t match with certificate: \u0026#34; + err.Error()) } expiry := conn.ConnectionState().PeerCertificates[0] fmt.Printf(\u0026#34;Issuer Name: %s\\n\u0026#34;, expiry.Issuer) fmt.Printf(\u0026#34;Expiry: %s \\n\u0026#34;, expiry.NotAfter.Format(\u0026#34;2006-01-02\u0026#34;)) fmt.Printf(\u0026#34;Common Name: %s \\n\u0026#34;, expiry.Issuer.CommonName) } 📚Reference How to Validate SSL Certificates in Go (freecodecamp.org) go - Get remote ssl certificate in golang - Stack Overflow ","permalink":"https://sz9751210.github.io/posts/how-to-validate-ssl-certificates-in-go/","summary":"👨‍💻如何在go中驗證SSL憑證 因之前玩過監控證書，最近在接觸golang因此來看看有甚麼方法能夠取得憑證到期日，最後發現有crypto/tls這個module可以用，驗證步驟簡單三步如下\n1. 確認網站是否有SSL證書 package main import ( \u0026#34;crypto/tls\u0026#34; ) func main() { conn, err := tls.Dial(\u0026#34;tcp\u0026#34;, \u0026#34;example.com:80\u0026#34;, nil) if err != nil { panic(\u0026#34;Server doesn\u0026#39;t support SSL certificate err: \u0026#34; + err.Error()) } } 上述程式碼首先使用 tls.Dial 建立TLS連線，語法規則為\ntls.Dial(protocol, website, tls config) 連線成功則返回一個tls.Conn\n執行後會噴以下錯誤\npanic: Server doesn\u0026#39;t support SSL certificate err: tls: first record does not look like a TLS handshake goroutine 1 [running]: 接著將網站改為google重新執行一次程式碼，沒有任何輸出表示正常，也代表網站有啟用SSL\npackage main import ( \u0026#34;crypto/tls\u0026#34; ) func main() { conn, err := tls.","title":"如何在go中驗證SSL憑證"},{"content":"👨‍💻簡介 今天早上在下kubectl get pods時，突然跳出了以下錯誤\nwarning Unable to connect to the server: x509: certificate has expired or is not yet valid 下了kubeadm alpha certs check-expiration之後才發現原來是憑證過期 因此紀錄一下解決過程\nInformation environment NAME=\u0026#34;CentOS Linux\u0026#34; VERSION=\u0026#34;7 (Core)\u0026#34; ID=\u0026#34;centos\u0026#34; ID_LIKE=\u0026#34;rhel fedora\u0026#34; VERSION_ID=\u0026#34;7\u0026#34; PRETTY_NAME=\u0026#34;CentOS Linux 7 (Core)\u0026#34; ANSI_COLOR=\u0026#34;0;31\u0026#34; CPE_NAME=\u0026#34;cpe:/o:centos:centos:7\u0026#34; HOME_URL=\u0026#34;https://www.centos.org/\u0026#34; BUG_REPORT_URL=\u0026#34;https://bugs.centos.org/\u0026#34; CENTOS_MANTISBT_PROJECT=\u0026#34;CentOS-7\u0026#34; CENTOS_MANTISBT_PROJECT_VERSION=\u0026#34;7\u0026#34; REDHAT_SUPPORT_PRODUCT=\u0026#34;centos\u0026#34; REDHAT_SUPPORT_PRODUCT_VERSION=\u0026#34;7\u0026#34; docker version Client: Version: 1.13.1 API version: 1.26 Package version: docker-1.13.1-162.git64e9980.el7.centos.x86_64 Go version: go1.10.3 Git commit: 64e9980/1.13.1 Built: Wed Jul 1 14:56:42 2020 OS/Arch: linux/amd64 Server: Version: 1.13.1 API version: 1.26 (minimum version 1.12) Package version: docker-1.13.1-162.git64e9980.el7.centos.x86_64 Go version: go1.10.3 Git commit: 64e9980/1.13.1 Built: Wed Jul 1 14:56:42 2020 OS/Arch: linux/amd64 Experimental: false kubeadm version kubeadm version: \u0026amp;version.Info{Major:\u0026#34;1\u0026#34;, Minor:\u0026#34;18\u0026#34;, GitVersion:\u0026#34;v1.18.6\u0026#34;, GitCommit:\u0026#34;dff82dc0de47299ab66c83c626e08b245ab19037\u0026#34;, GitTreeState:\u0026#34;clean\u0026#34;, BuildDate:\u0026#34;2020-07-15T16:56:34Z\u0026#34;, GoVersion:\u0026#34;go1.13.9\u0026#34;, Compiler:\u0026#34;gc\u0026#34;, Platform:\u0026#34;linux/amd64\u0026#34;} k8s version Client Version: version.Info{Major:\u0026#34;1\u0026#34;, Minor:\u0026#34;18\u0026#34;, GitVersion:\u0026#34;v1.18.6\u0026#34;, GitCommit:\u0026#34;dff82dc0de47299ab66c83c626e08b245ab19037\u0026#34;, GitTreeState:\u0026#34;clean\u0026#34;, BuildDate:\u0026#34;2020-07-15T16:58:53Z\u0026#34;, GoVersion:\u0026#34;go1.13.9\u0026#34;, Compiler:\u0026#34;gc\u0026#34;, Platform:\u0026#34;linux/amd64\u0026#34;} Server Version: version.Info{Major:\u0026#34;1\u0026#34;, Minor:\u0026#34;18\u0026#34;, GitVersion:\u0026#34;v1.18.6\u0026#34;, GitCommit:\u0026#34;dff82dc0de47299ab66c83c626e08b245ab19037\u0026#34;, GitTreeState:\u0026#34;clean\u0026#34;, BuildDate:\u0026#34;2020-07-15T16:51:04Z\u0026#34;, GoVersion:\u0026#34;go1.13.9\u0026#34;, Compiler:\u0026#34;gc\u0026#34;, Platform:\u0026#34;linux/amd64\u0026#34;} 💡解決步驟 1. 更新憑證 執行以下命令備份現有k8s 憑證 $ mkdir -p $HOME/k8s-old-certs/pki $ /bin/cp -p /etc/kubernetes/pki/*.* $HOME/k8s-old-certs/pki $ ls -l $HOME/k8s-old-certs/pki/ 輸出類似以下內容:\ntotal 56 -rw-r--r-- 1 root root 1090 Jul 27 2022 apiserver-etcd-client.crt -rw------- 1 root root 1679 Jul 27 2022 apiserver-etcd-client.key -rw-r--r-- 1 root root 1099 Jul 27 2022 apiserver-kubelet-client.crt -rw------- 1 root root 1679 Jul 27 2022 apiserver-kubelet-client.key -rw-r--r-- 1 root root 1229 Jul 27 2022 apiserver.crt -rw------- 1 root root 1675 Jul 27 2022 apiserver.key -rw-r--r-- 1 root root 1025 Jul 25 2020 ca.crt -rw------- 1 root root 1675 Jul 25 2020 ca.key -rw-r--r-- 1 root root 1038 Jul 27 2022 front-proxy-ca.crt -rw------- 1 root root 1675 Jul 27 2022 front-proxy-ca.key -rw-r--r-- 1 root root 1058 Jul 27 2022 front-proxy-client.crt -rw------- 1 root root 1679 Jul 27 2022 front-proxy-client.key -rw------- 1 root root 1679 Jul 25 2020 sa.key -rw------- 1 root root 451 Jul 25 2020 sa.pub 執行以下命令備份現有k8s設定檔 /bin/cp -p /etc/kubernetes/*.conf $HOME/k8s-old-certs ls -ltr $HOME/k8s-old-certs 輸出類似以下內容:\ntotal 36 -rw------- 1 root root 5506 Jul 27 2022 kubelet.conf -rw------- 1 root root 5453 Jul 27 2022 admin.conf -rw------- 1 root root 5489 Jul 27 2022 controller-manager.conf -rw------- 1 root root 5437 Jul 27 2022 scheduler.conf drwxrwxr-x 2 root root 4096 Jul 27 12:05 pki 執行以下命令備份家目錄設定: mkdir -p $HOME/k8s-old-certs/.kube /bin/cp -p ~/.kube/config $HOME/k8s-old-certs/.kube/. ls -l $HOME/k8s-old-certs/.kube/. 輸出類似以下內容:\ntotal 8 -rw------- 1 root root 5454 Jul 27 2022 config 執行以下命令更新所有k8s憑證 kubeadm alpha certs renew all 輸出類似以下內容:\n[renew] Reading configuration from the cluster... [renew] FYI: You can look at this config file with \u0026#39;kubectl -n kube-system get cm kubeadm-config -oyaml\u0026#39; certificate embedded in the kubeconfig file for the admin to use and for kubeadm itself renewed certificate for serving the Kubernetes API renewed certificate the apiserver uses to access etcd renewed certificate for the API server to connect to kubelet renewed certificate embedded in the kubeconfig file for the controller manager to use renewed certificate for liveness probes to healthcheck etcd renewed certificate for etcd nodes to communicate with each other renewed certificate for serving etcd renewed certificate for the front proxy client renewed certificate embedded in the kubeconfig file for the scheduler manager to use renewed 執行以下命令確認憑證是否更新並顯示364天後過期: kubeadm alpha certs check-expiration 輸出類似以下內容:\n[check-expiration] Reading configuration from the cluster... [check-expiration] FYI: You can look at this config file with \u0026#39;kubectl -n kube-system get cm kubeadm-config -oyaml\u0026#39; CERTIFICATE EXPIRES RESIDUAL TIME CERTIFICATE AUTHORITY EXTERNALLY MANAGED admin.conf Jul 26, 2024 04:14 UTC 364d no apiserver Jul 26, 2024 04:15 UTC 364d ca no apiserver-etcd-client Jul 26, 2024 04:15 UTC 364d etcd-ca no apiserver-kubelet-client Jul 26, 2024 04:15 UTC 364d ca no controller-manager.conf Jul 26, 2024 04:15 UTC 364d no etcd-healthcheck-client Jul 26, 2024 04:15 UTC 364d etcd-ca no etcd-peer Jul 26, 2024 04:15 UTC 364d etcd-ca no etcd-server Jul 26, 2024 04:15 UTC 364d etcd-ca no front-proxy-client Jul 26, 2024 04:15 UTC 364d front-proxy-ca no scheduler.conf Jul 26, 2024 04:16 UTC 364d no CERTIFICATE AUTHORITY EXPIRES RESIDUAL TIME EXTERNALLY MANAGED ca Jul 23, 2030 03:21 UTC 6y no etcd-ca Jul 23, 2030 03:21 UTC 6y no front-proxy-ca Jul 24, 2032 03:09 UTC 8y no 2. 確認kubelet設定 這時候下 kubectl get pods可能會噴以下錯誤 warning error: You must be logged in to the server (Unauthorized) 此時可以使用指令比對一下家目錄的設定檔是否更新\ndiff $HOME/.kube/config/ /etc/kubernetes/admin.conf 如果沒顯示任何輸出，原因是家目錄的設定檔沒更新，因此必須複製一份新的設定檔到家目錄\ncp -i /etc/kubernetes/admin.conf $HOME/.kube/config 接著需要重起kubelet以及相關的docker服務(master與node都要重啟)\nsystemctl restart docker systemctl restart kubelet 如果以上指令沒有輸出表示成功，最後確認是否新的設定檔成功\nkubectl get node NAME STATUS ROLES AGE VERSION master Ready \u0026lt;none\u0026gt; 3y2d v1.18.6 worker1 Ready \u0026lt;none\u0026gt; 3y2d v1.18.6 worker2 Ready \u0026lt;none\u0026gt; 3y2d v1.18.6 以上就是這次更新憑證的過程。\n📚Reference Certificate Management with kubeadm | Kubernetes Kubernetes “x509: certificate has expired or is not yet valid” error | by Guilherme Pereira | Medium K8S: Unable To Connect To The Server: X509: Certificate Has Expired Or Is Not Yet Valid | IvoNet k8s自签证书过期x509: certificate has expired or is not yet valid报错 - cerberus43 - 博客园 (cnblogs.com) ","permalink":"https://sz9751210.github.io/posts/k8s-certificate-expired/","summary":"👨‍💻簡介 今天早上在下kubectl get pods時，突然跳出了以下錯誤\nwarning Unable to connect to the server: x509: certificate has expired or is not yet valid 下了kubeadm alpha certs check-expiration之後才發現原來是憑證過期 因此紀錄一下解決過程\nInformation environment NAME=\u0026#34;CentOS Linux\u0026#34; VERSION=\u0026#34;7 (Core)\u0026#34; ID=\u0026#34;centos\u0026#34; ID_LIKE=\u0026#34;rhel fedora\u0026#34; VERSION_ID=\u0026#34;7\u0026#34; PRETTY_NAME=\u0026#34;CentOS Linux 7 (Core)\u0026#34; ANSI_COLOR=\u0026#34;0;31\u0026#34; CPE_NAME=\u0026#34;cpe:/o:centos:centos:7\u0026#34; HOME_URL=\u0026#34;https://www.centos.org/\u0026#34; BUG_REPORT_URL=\u0026#34;https://bugs.centos.org/\u0026#34; CENTOS_MANTISBT_PROJECT=\u0026#34;CentOS-7\u0026#34; CENTOS_MANTISBT_PROJECT_VERSION=\u0026#34;7\u0026#34; REDHAT_SUPPORT_PRODUCT=\u0026#34;centos\u0026#34; REDHAT_SUPPORT_PRODUCT_VERSION=\u0026#34;7\u0026#34; docker version Client: Version: 1.13.1 API version: 1.26 Package version: docker-1.13.1-162.git64e9980.el7.centos.x86_64 Go version: go1.10.3 Git commit: 64e9980/1.13.1 Built: Wed Jul 1 14:56:42 2020 OS/Arch: linux/amd64 Server: Version: 1.","title":"Kubernetes憑證過期：Unable To Connect To The Server: X509: Certificate Has Expired Or Is Not Yet Valid"},{"content":"👨‍💻簡介 因在wsl環境下使用websocket通訊協議，並在windows使用postman發生連線被拒 嘗試了localhost與127.0.0.1都無效，爬文後找到了一些解決辦法，這邊簡單紀錄一下\n使用wsl的vm ip 建立一組新的wsl ip 操作系統(Operating System) Windows/WSL2\nPostman 版本 10.16\n💡解決辦法 1. 使用WSL的VM IP 可透過以下指令查看IP位址\nip add | grep \u0026quot;eth0\u0026quot; wsl hostname -I 2. 建立一組新的WSL VM IP 在wsl建立一組新的ip，在wsl terminal執行 sudo ip addr add 192.168.99.2/24 broadcast 192.168.99.255 dev eth0 label eth0:1 這行指令將會創建一組新的ip 192.168.99.2 給wsl。\n在windows建立一組新的interface，可在windows command prompt 或 powershell執行 netsh interface ip add address \u0026#34;vEthernet (WSL)\u0026#34; 192.168.99.1 255.255.255.0 這行指令將會創建一組新的interface叫vEthernet (WSL)並分配到ip為192.168.99.1，可透過netsh interface ip show addresses查看是否建立成功。\n📚Reference Cannot connect to websocket server running on WSL via \u0026ldquo;localhost\u0026rdquo; · Issue #11204 · postmanlabs/postman-app-support (github.com) ","permalink":"https://sz9751210.github.io/posts/wsl-websocket/","summary":"👨‍💻簡介 因在wsl環境下使用websocket通訊協議，並在windows使用postman發生連線被拒 嘗試了localhost與127.0.0.1都無效，爬文後找到了一些解決辦法，這邊簡單紀錄一下\n使用wsl的vm ip 建立一組新的wsl ip 操作系統(Operating System) Windows/WSL2\nPostman 版本 10.16\n💡解決辦法 1. 使用WSL的VM IP 可透過以下指令查看IP位址\nip add | grep \u0026quot;eth0\u0026quot; wsl hostname -I 2. 建立一組新的WSL VM IP 在wsl建立一組新的ip，在wsl terminal執行 sudo ip addr add 192.168.99.2/24 broadcast 192.168.99.255 dev eth0 label eth0:1 這行指令將會創建一組新的ip 192.168.99.2 給wsl。\n在windows建立一組新的interface，可在windows command prompt 或 powershell執行 netsh interface ip add address \u0026#34;vEthernet (WSL)\u0026#34; 192.168.99.1 255.255.255.0 這行指令將會創建一組新的interface叫vEthernet (WSL)並分配到ip為192.168.99.1，可透過netsh interface ip show addresses查看是否建立成功。\n📚Reference Cannot connect to websocket server running on WSL via \u0026ldquo;localhost\u0026rdquo; · Issue #11204 · postmanlabs/postman-app-support (github.","title":"WSL環境下使用websocket連線被拒"},{"content":"👨‍💻簡介 《 Zeabur - 部署服務 從未如此簡單》\n從來沒想過部署可以如此的方便快速，第一次接觸到Zeabur的時候覺得他跟一般的雲端服務商差不多，架設網站用個vm之類的，但仔細去摸索後才發現他是個想讓開發人員專注在寫扣這件事上，不需去管任何infra相關事項的一個服務，像是架設wordpress需要sql，就簡單的點兩下即可完成，\n或是自己建立在github的部落格，也是一鍵點擊下去建立，並且厲害的是能自動識別github部落格的類型，主流的hexo、hugo都能自動辨識。\n在介面上則是將一個專案用到的服務集中式的管理，Zeabur能夠全部部署在一起，不需去處理連線的問題，在一個單一的組態檔案中來管理服務所需的所有變數，不需要使用.env下去做設定，讓使用者有開箱即用的一流體驗。\n今天就用Zeabur來快速建立wordpress，讓大家看看Zeabur的使用方式。\n🔰基礎介紹 Zeabur 簡介 Zeabur 是一個主打「一鍵部署」的 PaaS 平台，類似的產品台灣的開發者一般比較流行使用 GitHub Pages（前端）以及 Render、Flyio（後端），Zeabur 相比於這些競爭對手，最大的特點在於：\n官方文件、技術支援都有中文 ，且主機位於 GCP 台灣機房 操作更簡單，把 GitHub 上面的程式部署上線真的只需要「一鍵」 一個專案往往會有前端、後端、資料庫 \u0026hellip; 各種服務，Zeabur 能夠全部部署在一起，方便管理 🎯setup 1. 建立project 登入官網後先點選Create Project來建立一個專案，接著輸入專案名稱並點選create 建立成功就會在主控台看到剛剛建立的專案了，我們點選剛剛建立的專案來繼續建立我們需要的服務 2. 建立service 點選Add Service 2.1 新增mysql service 因為wordpress需要連接mysql，因此我們先建立mysql服務 點下去等個幾秒mysql就建立好了，就是這麼的方便快速\n2.2 新增wordpress database 接著我們點選Connect透過terminal連接到mysql去建立資料庫 建立完成後接著回到專案底下來繼續新增我們的wordpress服務\n2.3 新增wordpress service 到這一步wordpress已完成建立\n2.4 建立wordpress domain 建立完成後來接著建立domain 點選我們剛剛建立成功的domain來訪問我們的wordpress，點開後就會顯示wordpress的相關設定\n2.5 設定wordpress後台 看到這個畫面就代表我們的wordpress已經設定完成了 登入後即可進入到wordpress的後台 點選左上角即可訪問我們的網站 以上就是使用zeabur來架設wordpress的設定過程，統整下來真的都是靠點選來建立所需的服務，並且服務是集中式的管理，也因為架設的主機是在GCP的台灣機房，因此速度體驗上也是沒什麼問題，並且官方有提供免費方案可以提供使用者進行免費試用，有興趣的人可以去嚐鮮體驗看看一建部署的強大威力🤓\n📚Reference 🔗官方網站 -\u0026gt; Zeabur - Deploying your service with one click 🔗Github -\u0026gt; Zeabur (github.com) ","permalink":"https://sz9751210.github.io/posts/zeabur/","summary":"👨‍💻簡介 《 Zeabur - 部署服務 從未如此簡單》\n從來沒想過部署可以如此的方便快速，第一次接觸到Zeabur的時候覺得他跟一般的雲端服務商差不多，架設網站用個vm之類的，但仔細去摸索後才發現他是個想讓開發人員專注在寫扣這件事上，不需去管任何infra相關事項的一個服務，像是架設wordpress需要sql，就簡單的點兩下即可完成，\n或是自己建立在github的部落格，也是一鍵點擊下去建立，並且厲害的是能自動識別github部落格的類型，主流的hexo、hugo都能自動辨識。\n在介面上則是將一個專案用到的服務集中式的管理，Zeabur能夠全部部署在一起，不需去處理連線的問題，在一個單一的組態檔案中來管理服務所需的所有變數，不需要使用.env下去做設定，讓使用者有開箱即用的一流體驗。\n今天就用Zeabur來快速建立wordpress，讓大家看看Zeabur的使用方式。\n🔰基礎介紹 Zeabur 簡介 Zeabur 是一個主打「一鍵部署」的 PaaS 平台，類似的產品台灣的開發者一般比較流行使用 GitHub Pages（前端）以及 Render、Flyio（後端），Zeabur 相比於這些競爭對手，最大的特點在於：\n官方文件、技術支援都有中文 ，且主機位於 GCP 台灣機房 操作更簡單，把 GitHub 上面的程式部署上線真的只需要「一鍵」 一個專案往往會有前端、後端、資料庫 \u0026hellip; 各種服務，Zeabur 能夠全部部署在一起，方便管理 🎯setup 1. 建立project 登入官網後先點選Create Project來建立一個專案，接著輸入專案名稱並點選create 建立成功就會在主控台看到剛剛建立的專案了，我們點選剛剛建立的專案來繼續建立我們需要的服務 2. 建立service 點選Add Service 2.1 新增mysql service 因為wordpress需要連接mysql，因此我們先建立mysql服務 點下去等個幾秒mysql就建立好了，就是這麼的方便快速\n2.2 新增wordpress database 接著我們點選Connect透過terminal連接到mysql去建立資料庫 建立完成後接著回到專案底下來繼續新增我們的wordpress服務\n2.3 新增wordpress service 到這一步wordpress已完成建立\n2.4 建立wordpress domain 建立完成後來接著建立domain 點選我們剛剛建立成功的domain來訪問我們的wordpress，點開後就會顯示wordpress的相關設定\n2.5 設定wordpress後台 看到這個畫面就代表我們的wordpress已經設定完成了 登入後即可進入到wordpress的後台 點選左上角即可訪問我們的網站 以上就是使用zeabur來架設wordpress的設定過程，統整下來真的都是靠點選來建立所需的服務，並且服務是集中式的管理，也因為架設的主機是在GCP的台灣機房，因此速度體驗上也是沒什麼問題，並且官方有提供免費方案可以提供使用者進行免費試用，有興趣的人可以去嚐鮮體驗看看一建部署的強大威力🤓\n📚Reference 🔗官方網站 -\u0026gt; Zeabur - Deploying your service with one click 🔗Github -\u0026gt; Zeabur (github.","title":"Zeabur - 部署服務 從未如此簡單"},{"content":"甚麼是Kubernetes ConfigMap ConfigMap主要功用是儲存我們服務的設定，這使得我們可以將我們的應用服務具備可移植性，當需要相對應的環境參數時，只需要修改ConfigMap，而不需要去更動到image即可更換成新的部屬環境。\n為甚麼需要ConfigMap 最主要的用意是共享相同設定。在初期開發時可能只有幾個服務而直接把設定檔寫死，如果在後期變成微服務的架構下，上百個服務都有自己的設定檔在日後維護下會顯得麻煩，因此有了ConfigMap的出現，幫助我們將環境變數與容器鏡像解藕，便於修改應用設定，減少維護成本\n何時使用ConfigMap，ConfigMap使用場景 ConfigMap通常儲存服務的環境變數、命令行參數、配置文件等非機密資料，使用場景有設定檔與容器鏡像分離、多環境支持、共享設定、動態設定更新等等\nConfigMap有哪些特點 解藕配置 -\u0026gt; 將服務的設定檔與容器鏡像分離，使服務在不重新建置新的容器鏡像可修改和管理設定檔，提高容器鏡像的通用性和靈活性 靈活性 -\u0026gt; ConfigMap支援多種格式，並且需要時可動態更新設定，無須重啟服務或重新佈署容器 共享設定 -\u0026gt; ConfigMap允許多個Pod共享同一份設定檔，確保了使用相同設定檔的Pod的一致性，提高設定的可維護性和一致性 集中管理 -\u0026gt; ConfigMap在K8s集群中可以集中管理所有的ConfigMap，不需要逐個修改Pod的設定 如何撰寫使用ConfigMap 創建ConfigMap Imperative(命令式) --from-literal kubectl create configMap myconfig --from-literal=k1=v1 --from-literal=k2=v2 --from-file kubectl create configMap myconfigfromkey --from-file=fromfilekey=from-key Declarative(聲明式) apiVersion: v1 kind: ConfigMap metadata: name: special-config namespace: default data: special.how: very 使用ConfigMap 使用ConfigMap定義容器環境變量 從單一ConfigMap定義容器環境變量 ConfigMap ## create configmap kubectl create configmap special-config --from-literal=special.how=very Pod apiVersion: v1 kind: Pod metadata: name: dapi-test-pod spec: containers: - name: test-container image: registry.k8s.io/busybox command: [ \u0026#34;/bin/sh\u0026#34;, \u0026#34;-c\u0026#34;, \u0026#34;env\u0026#34; ] env: # 定義環境變量 - name: SPECIAL_LEVEL_KEY valueFrom: ConfigMapKeyRef: # ConfigMap 含有你想要指派給 SPECIAL_LEVEL_KEY 的值 name: special-config # 指定想要指派的 value 的 key key: special.how restartPolicy: Never ## create pod kubectl create -f https://kubernetes.io/examples/pods/pod-single-configmap-env-variable.yaml ## Please use the following command to check the output kubectl logs dapi-test-pod ## output KUBERNETES_SERVICE_PORT=443 KUBERNETES_PORT=tcp://10.96.0.1:443 HOSTNAME=dapi-test-pod SHLVL=1 HOME=/root KUBERNETES_PORT_443_TCP_ADDR=10.96.0.1 PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin KUBERNETES_PORT_443_TCP_PORT=443 KUBERNETES_PORT_443_TCP_PROTO=tcp SPECIAL_LEVEL_KEY=very KUBERNETES_PORT_443_TCP=tcp://10.96.0.1:443 KUBERNETES_SERVICE_PORT_HTTPS=443 PWD=/ KUBERNETES_SERVICE_HOST=10.96.0.1 從上述輸出可以看到環境變量有SPECIAL_LEVEL_KEY=very\n從多個ConfigMap定義容器環境變量 ConfigMap apiVersion: v1 kind: ConfigMap metadata: name: special-config namespace: default data: special.how: very --- apiVersion: v1 kind: ConfigMap metadata: name: env-config namespace: default data: log_level: INFO ## create configmap kubectl create -f https://kubernetes.io/examples/ConfigMap/configmap.yaml Pod apiVersion: v1 kind: Pod metadata: name: dapi-test-pod spec: containers: - name: test-container image: registry.k8s.io/busybox command: [ \u0026#34;/bin/sh\u0026#34;, \u0026#34;-c\u0026#34;, \u0026#34;env\u0026#34; ] env: - name: SPECIAL_LEVEL_KEY valueFrom: ConfigMapKeyRef: name: special-config key: special.how - name: LOG_LEVEL valueFrom: ConfigMapKeyRef: name: env-config key: log_level restartPolicy: Never ## create pod kubectl create -f https://kubernetes.io/examples/pods/pod-multiple-configmap-env-variable.yaml ## Please use the following command to check the output kubectl logs dapi-test-pod ## output KUBERNETES_PORT=tcp://10.96.0.1:443 KUBERNETES_SERVICE_PORT=443 LOG_LEVEL=INFO HOSTNAME=dapi-test-pod SHLVL=1 HOME=/root KUBERNETES_PORT_443_TCP_ADDR=10.96.0.1 PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin KUBERNETES_PORT_443_TCP_PORT=443 KUBERNETES_PORT_443_TCP_PROTO=tcp SPECIAL_LEVEL_KEY=very KUBERNETES_PORT_443_TCP=tcp://10.96.0.1:443 KUBERNETES_SERVICE_PORT_HTTPS=443 PWD=/ KUBERNETES_SERVICE_HOST=10.96.0.1 從上述輸出可以看到環境變量有LOG_LEVEL=INFO和SPECIAL_LEVEL_KEY=very\n在ConfigMap設定key-value pairs定義容器環境變量 ConfigMap apiVersion: v1 kind: ConfigMap metadata: name: special-config namespace: default data: SPECIAL_LEVEL: very SPECIAL_TYPE: charm ## create configmap kubectl create -f https://kubernetes.io/examples/configmap/configmap-multikeys.yaml Pod apiVersion: v1 kind: Pod metadata: name: dapi-test-pod spec: containers: - name: test-container image: registry.k8s.io/busybox command: [ \u0026#34;/bin/sh\u0026#34;, \u0026#34;-c\u0026#34;, \u0026#34;env\u0026#34; ] envFrom: - ConfigMapRef: name: special-config restartPolicy: Never ## create pod kubectl create -f https://kubernetes.io/examples/pods/pod-configmap-envFrom.yaml 我們使用了 envFrom 來將 ConfigMap 中的所有 data 都定義成容器環境變量。\n## Please use the following command to check the output kubectl logs dapi-test-pod ## output KUBERNETES_PORT=tcp://10.96.0.1:443 KUBERNETES_SERVICE_PORT=443 HOSTNAME=dapi-test-pod SHLVL=1 HOME=/root SPECIAL_LEVEL=very KUBERNETES_PORT_443_TCP_ADDR=10.96.0.1 PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin KUBERNETES_PORT_443_TCP_PORT=443 KUBERNETES_PORT_443_TCP_PROTO=tcp KUBERNETES_PORT_443_TCP=tcp://10.96.0.1:443 KUBERNETES_SERVICE_PORT_HTTPS=443 PWD=/ KUBERNETES_SERVICE_HOST=10.96.0.1 SPECIAL_TYPE=charm 從上述輸出可以看到環境變量有SPECIAL_LEVEL=very和SPECIAL_TYPE=charm。\n在Pod commands使用ConfigMap定義的環境變量 ConfigMap apiVersion: v1 kind: ConfigMap metadata: name: special-config namespace: default data: SPECIAL_LEVEL: very SPECIAL_TYPE: charm ## create configmap kubectl create -f https://kubernetes.io/examples/configmap/configmap-multikeys.yaml Pod apiVersion: v1 kind: Pod metadata: name: dapi-test-pod spec: containers: - name: test-container image: registry.k8s.io/busybox command: [ \u0026#34;/bin/echo\u0026#34;, \u0026#34;$(SPECIAL_LEVEL_KEY) $(SPECIAL_TYPE_KEY)\u0026#34; ] env: - name: SPECIAL_LEVEL_KEY valueFrom: ConfigMapKeyRef: name: special-config key: SPECIAL_LEVEL - name: SPECIAL_TYPE_KEY valueFrom: ConfigMapKeyRef: name: special-config key: SPECIAL_TYPE restartPolicy: Never ## create pod kubectl create -f https://kubernetes.io/examples/pods/pod-configmap-env-var-valueFrom.yaml 我們可以使用ConfigMap定義好的環境變量在容器的command和args，使用語法為$(VAR_NAME)\n## Please use the following command to check the output kubectl logs dapi-test-pod ## output very charm 將 ConfigMap 資料加到 Volume 當我們建立ConfigMap使用--from-file，檔名會變成data區塊的key，而內容則會變成該key的value\nConfigMap apiVersion: v1 kind: ConfigMap metadata: name: special-config namespace: default data: SPECIAL_LEVEL: very SPECIAL_TYPE: charm ## create configmap kubectl create -f https://kubernetes.io/examples/configmap/configmap-multikeys.yaml Pod apiVersion: v1 kind: Pod metadata: name: dapi-test-pod spec: containers: - name: test-container image: registry.k8s.io/busybox command: [ \u0026#34;/bin/sh\u0026#34;, \u0026#34;-c\u0026#34;, \u0026#34;ls /etc/config/\u0026#34; ] volumeMounts: - name: config-volume mountPath: /etc/config volumes: - name: config-volume ConfigMap: # 提供container要使用的configmap name name: special-config restartPolicy: Never ## create pod kubectl create -f https://kubernetes.io/examples/pods/pod-configmap-volume.yaml 將ConfigMap name 添加到volumes區塊進行掛載，在此範例中，mountPath會是/etc/config\n## Please use the following command to check the output kubectl logs dapi-test-pod ## output SPECIAL_LEVEL SPECIAL_TYPE 此Pod會去執行ls /etc/config，如果該目錄下有其他檔案會被刪除，因為使用的掛載方式是mountPath\n將ConfigMap資料加到Volume特定路徑 ConfigMap apiVersion: v1 kind: ConfigMap metadata: name: special-config namespace: default data: SPECIAL_LEVEL: very SPECIAL_TYPE: charm ## create configmap kubectl create -f https://kubernetes.io/examples/configmap/configmap-multikeys.yaml Pod apiVersion: v1 kind: Pod metadata: name: dapi-test-pod spec: containers: - name: test-container image: k8s.gcr.io/busybox command: [ \u0026#34;/bin/sh\u0026#34;,\u0026#34;-c\u0026#34;,\u0026#34;cat /etc/config/keys\u0026#34; ] volumeMounts: - name: config-volume mountPath: /etc/config volumes: - name: config-volume ConfigMap: name: special-config items: - key: SPECIAL_LEVEL path: keys restartPolicy: Never ## create pod kubectl create -f https://kubernetes.io/examples/pods/pod-configmap-volume-specific-key.yaml 使用 path 欄位來指定特定 ConfigMap item 到想要的檔案路徑。 在此範例中, SPECIAL_LEVEL item 將會被掛載到 config-volume volume 中的 /etc/config/keys\n## Please use the following command to check the output kubectl logs dapi-test-pod ## output very Reference ConfigMaps | Kubernetes 一文弄懂ConfigMap在K8S中的各种玩法以及应用场景 - 掘金 (juejin.cn) Kubernetes — ConfigMap. 簡單來說, 在我們的應用中, 當我們需要儲存一些較沒有敏感性的設定檔, 像是… | by Ray Lee | 李宗叡 | Learn or Die | Medium Day 18 - 使用 ConfigMaps - iT 邦幫忙::一起幫忙解決難題，拯救 IT 人的一天 (ithome.com.tw) K8s之ConfigMap - Happy Coding, Happy Life (wldandan.github.io) ConfigMap_云容器引擎 CCE_Kubernetes基础知识_配置管理_华为云 (huaweicloud.com) [Kubernetes / K8s] ConfigMap 用於讓不同的微服務共享配置| Configure a Pod to Use a ConfigMap | by KouWei.Lee | k8s筆記 | Medium ","permalink":"https://sz9751210.github.io/posts/k8s-configmap/","summary":"甚麼是Kubernetes ConfigMap ConfigMap主要功用是儲存我們服務的設定，這使得我們可以將我們的應用服務具備可移植性，當需要相對應的環境參數時，只需要修改ConfigMap，而不需要去更動到image即可更換成新的部屬環境。\n為甚麼需要ConfigMap 最主要的用意是共享相同設定。在初期開發時可能只有幾個服務而直接把設定檔寫死，如果在後期變成微服務的架構下，上百個服務都有自己的設定檔在日後維護下會顯得麻煩，因此有了ConfigMap的出現，幫助我們將環境變數與容器鏡像解藕，便於修改應用設定，減少維護成本\n何時使用ConfigMap，ConfigMap使用場景 ConfigMap通常儲存服務的環境變數、命令行參數、配置文件等非機密資料，使用場景有設定檔與容器鏡像分離、多環境支持、共享設定、動態設定更新等等\nConfigMap有哪些特點 解藕配置 -\u0026gt; 將服務的設定檔與容器鏡像分離，使服務在不重新建置新的容器鏡像可修改和管理設定檔，提高容器鏡像的通用性和靈活性 靈活性 -\u0026gt; ConfigMap支援多種格式，並且需要時可動態更新設定，無須重啟服務或重新佈署容器 共享設定 -\u0026gt; ConfigMap允許多個Pod共享同一份設定檔，確保了使用相同設定檔的Pod的一致性，提高設定的可維護性和一致性 集中管理 -\u0026gt; ConfigMap在K8s集群中可以集中管理所有的ConfigMap，不需要逐個修改Pod的設定 如何撰寫使用ConfigMap 創建ConfigMap Imperative(命令式) --from-literal kubectl create configMap myconfig --from-literal=k1=v1 --from-literal=k2=v2 --from-file kubectl create configMap myconfigfromkey --from-file=fromfilekey=from-key Declarative(聲明式) apiVersion: v1 kind: ConfigMap metadata: name: special-config namespace: default data: special.how: very 使用ConfigMap 使用ConfigMap定義容器環境變量 從單一ConfigMap定義容器環境變量 ConfigMap ## create configmap kubectl create configmap special-config --from-literal=special.how=very Pod apiVersion: v1 kind: Pod metadata: name: dapi-test-pod spec: containers: - name: test-container image: registry.","title":"Kubernetes ConfigMap"},{"content":"什麼是 Kubernetes Deployment? 一樣先來個官網解說\nA Deployment provides declarative updates for Pods and ReplicaSets.\nYou describe a desired state in a Deployment, and the Deployment Controller changes the actual state to the desired state at a controlled rate. You can define Deployments to create new ReplicaSets, or to remove existing Deployments and adopt all their resources with new Deployments.\n跟ReplicaSet不同，Deployment的工作主要是為 pod \u0026amp; replicaset 提供了一個宣告式的設定 \u0026amp; 更新方式，透過定義 desired status，Deployment controller 會在所謂的 controlled rate 下達到使用者所期望的狀態，這些機制是由 k8s 自動化完成，因此官方建議應該透過 Deployment 來佈署 pod \u0026amp; replicaset。\n為什麼需要Deployment 因為Pod無法實現自我更新，必須砍掉重建後才會是新的內容，這樣會導致服務中斷，有了Deployment的出現，對Pod進行管理與版本控制，而在Deployment的背後使用Replicaset來確保指定數量的Pod運行，在更新方面，可根據指定的更新策略來控制版本更新。\nDeployment是如何運作的 在k8s中，Pod是最小的資源單位，Pod的副本管理是透過Replicaset實現，而Deployment則是控制Replicaset，並不是直接對Pod進行管理。\n甚麼時候使用Deployment Deployment 在以下情況下適合使用：\n應用程式的部署和管理：Deployment 提供了一個方便且可靠的方式來部署和管理應用程式。它允許您定義應用程式的配置，包括容器映像、資源需求、環境變數等，並確保指定數量的 Pod 在運行。\n滾動更新和回滾：當需要對應用程式進行更新時，Deployment 提供了滾動更新的能力。它可以逐步部署新版本的應用程式，同時確保舊版本的 Pod 在新版本完全運行之前持續提供服務。如果新版本出現問題，Deployment 還允許回滾到先前的版本。\n應用程式的擴展性和負載均衡：Deployment 允許指定應用程式的副本數，以根據需求自動擴展或收縮應用程式的副本數。這使得應用程式能夠彈性地應對流量的變化，確保高效的資源利用和良好的用戶體驗。\n高可用性和容錯能力：Deployment 通過管理多個 Pod 的運行，提供了高可用性和容錯能力。如果某個 Pod 發生故障或需要進行維護，Deployment 會自動替換它，確保應用程式持續運行並提供無中斷的服務。\n多環境部署：如果需要在不同的環境中部署應用程式（如開發、測試、正式），Deployment 提供了一致的部署方式，確保在不同環境中的應用程式配置和版本的一致性，簡化了部署和管理的流程。\nDeployment有哪些特性 產生並管理 ReplicaSet：Deployment 可以自動創建和管理與其關聯的 ReplicaSet 物件。ReplicaSet 確保指定數量的 Pod 實例正在運行，並根據 Deployment 物件的配置來維護所需的 Pod 數量。\n滾動更新和回滾：Deployment 提供了滾動更新的能力，使您能夠逐步將新版本的應用程式部署到生產環境中，同時確保舊版本的 Pod 在新版本完全運行之前持續提供服務。如果新版本出現問題，Deployment 還允許您輕鬆地回滾到先前的版本。\n健康檢查和自我修復：Deployment 可以定期檢查 Pod 的健康狀態，並根據定義的健康檢查條件進行自我修復。如果 Pod 遇到故障或不符合健康檢查條件，Deployment 會自動替換該 Pod，以確保應用程式的高可用性。\n部署策略：Deployment 允許您指定部署策略，例如最大並行部署數量、最大不可用 Pod 數量等。這些策略可用於控制部署的速度和可靠性，並減少對應用程式的影響。\n環境變數和資源配置：Deployment 允許您在運行中的應用程式上動態配置環境變數和資源需求。這使得在不中斷服務的情況下，可以調整應用程式的配置，例如修改連接字串、調整內存和CPU的資源分配等。\n多環境部署：Deployment 可以用於在不同環境（如開發、測試、生產）中部署應用程式，並提供一致的部署方式和管理能力。這使得在不同環境中保持應用程式配置和版本的一致性變得更容易。\n如何使用Deployment 創建deployment apiVersion: apps/v1 # 定義api版本 kind: Deployment # 定義資源類型 metadata: # 定義元數據 name: nginx-deployment labels: app: nginx spec: strategy: type: RollingUpdate # 更新策略 rollingUpdate: maxUnavailable: 25% # 當更新時，無法使用的Pod佔整體Pod數量的比例 maxSurge: 25% # 當更新時，Pod可以超過desired status數量的比例 progressDeadlineSeconds: 600 # 部屬的最長等待時間，當超過則回報\u0026#34;failed progressing\u0026#34; minReadySeconds: 0 # 服務部屬後準備到可接收流量的時間 revisionHistoryLimit: 10 # 可rollback的版本數 replicas: 3 # 副本數 selector: # 定義label selector matchLabels: app: nginx template: # pod template metadata: labels: app: nginx spec: containers: - name: nginx image: nginx:1.14.2 ports: - containerPort: 80 resources: requests: cpu: 200m memory: 512Mi 查看Deployment \u0026gt; kubectl get deployments.apps NAME READY UP-TO-DATE AVAILABLE AGE nginx-deployment 3/3 3 3 24m \u0026gt; kubectl get deployments.apps -o wide NAME READY UP-TO-DATE AVAILABLE AGE CONTAINERS IMAGES SELECTOR nginx-deployment 3/3 3 3 24m nginx nginx:1.8 app=nginx 更新Deployment 更新image版本 \u0026gt; kubectl set image deployment nginx-deployment nginx=nginx:1.9 deployment.apps/nginx-deployment image updated \u0026gt; kubectl get deployments.apps -o wide NAME READY UP-TO-DATE AVAILABLE AGE CONTAINERS IMAGES SELECTOR nginx-deployment 3/3 1 3 37m nginx nginx:1.9 app=nginx 查看更新狀態 \u0026gt; kubectl rollout status deployment nginx-deployment deployment \u0026#34;nginx-deployment\u0026#34; successfully rolled out 修改pod template \u0026gt; kubectl edit deployment nginx-deployment 回退Deployment 檢查Deployment的升級歷史紀錄 \u0026gt; kubectl rollout history deployment nginx-deployment deployment.apps/nginx-deployment REVISION CHANGE-CAUSE 1 nginx:1.7.9 2 nginx:1.8 查看特定版本的紀錄 \u0026gt; kubectl rollout history deployment nginx-deployment --revision=2 deployment.apps/nginx-deployment with revision #2 Pod Template: Labels: app=nginx pod-template-hash=58f44756c Annotations: kubernetes.io/change-cause: nginx:1.8 Containers: nginx: Image: nginx:1.8 Port: 80/TCP Host Port: 0/TCP Environment: \u0026lt;none\u0026gt; Mounts: \u0026lt;none\u0026gt; Volumes: \u0026lt;none\u0026gt; 回退到指定版本 \u0026gt; kubectl rollout undo deployment nginx-deployment --to-revision 1 deployment.apps/nginx-deployment rolled back 擴縮Deployment 指定數量 \u0026gt; kubectl scale deployment nginx-deployment --replicas 2 deployment.apps/nginx-deployment scaled 水平自動擴縮，根據當前Pod的CPU利用率當作擴縮依據 kubectl autoscale deployment nginx-deployment --max 5 --min 3 --cpu-percent 70 如果是使用minikube，得啟用metrics-server的addon\nminikube addons list ## 查看minikube的addon minikube addons enable metrics-server ## 啟用metrics-server的addon\n暫停和恢復Deployment \u0026gt; kubectl rollout pause deployment nginx-deployment deployment.apps/nginx-deployment paused \u0026gt; kubectl rollout resume deployment nginx-deployment deployment.apps/nginx-deployment resumed 在暫停期間任意修改deployment都不會更新，暫停前的狀態將繼續它的功能\nDeployment cheat sheet Reference Deployments | Kubernetes Deployment · Kubernetes 中文指南——云原生应用架构实战手册 (jimmysong.io) Kubernetes 那些事 — Deployment 與 ReplicaSet（一） | by Andy Chen | Andy的技術分享blog | Medium ","permalink":"https://sz9751210.github.io/posts/k8s-deploy/","summary":"什麼是 Kubernetes Deployment? 一樣先來個官網解說\nA Deployment provides declarative updates for Pods and ReplicaSets.\nYou describe a desired state in a Deployment, and the Deployment Controller changes the actual state to the desired state at a controlled rate. You can define Deployments to create new ReplicaSets, or to remove existing Deployments and adopt all their resources with new Deployments.\n跟ReplicaSet不同，Deployment的工作主要是為 pod \u0026amp; replicaset 提供了一個宣告式的設定 \u0026amp; 更新方式，透過定義 desired status，Deployment controller 會在所謂的 controlled rate 下達到使用者所期望的狀態，這些機制是由 k8s 自動化完成，因此官方建議應該透過 Deployment 來佈署 pod \u0026amp; replicaset。","title":"Kubernetes Deployment：Overview"},{"content":"👨‍💻Intro 為了實現vscode在wsl環境下使用ssh連接到gce的需求，在爬文後找到一篇解法，因此記錄下來，方便日後查詢\n🎯setup 建立ssh.bat檔案，並放在windows下任意位置 C:\\Windows\\system32\\wsl.exe ssh %* vscode設定ssh.bat路徑 打開vscode的settings -\u0026gt; extensions -\u0026gt; Remote - SSH -\u0026gt; Remote.SSH.path將ssh.bat所在路徑貼上\n透過管理員身分打開CMD建立連結\nC:\\Users\\User\u0026gt;mklink /D \u0026#34;C:\\Users\\User\\.ssh\u0026#34; \u0026#34;\\\\wsl$\\Ubuntu-20.04\\home\\alan\\.ssh\u0026#34; ## 成功後會顯示以下訊息 已建立 C:\\Users\\User\\.ssh 的符號連結 \u0026lt;\u0026lt;===\u0026gt;\u0026gt; \\\\wsl$\\Ubuntu-20.04\\home\\alan\\.ssh 指令介紹 mklink mklink [option] Source Target mklink：建立連結\n/D ：連結類型為資料夾\nSource：windows連結路徑\nTarget：wsl家目錄的.ssh資料夾\nReference Can I SSH from WSL in Visual Studio Code? - Stack Overflow Using WSL for Remote-SSH in VS Code – Zit Seng\u0026rsquo;s Blog Sync VSCode’s SSH with WSL2 – Zit Seng\u0026rsquo;s Blog Mklink 指令建立 Symbolic Link | ShunNien\u0026rsquo;s Blog ","permalink":"https://sz9751210.github.io/posts/vscode-wsl-ssh/","summary":"👨‍💻Intro 為了實現vscode在wsl環境下使用ssh連接到gce的需求，在爬文後找到一篇解法，因此記錄下來，方便日後查詢\n🎯setup 建立ssh.bat檔案，並放在windows下任意位置 C:\\Windows\\system32\\wsl.exe ssh %* vscode設定ssh.bat路徑 打開vscode的settings -\u0026gt; extensions -\u0026gt; Remote - SSH -\u0026gt; Remote.SSH.path將ssh.bat所在路徑貼上\n透過管理員身分打開CMD建立連結\nC:\\Users\\User\u0026gt;mklink /D \u0026#34;C:\\Users\\User\\.ssh\u0026#34; \u0026#34;\\\\wsl$\\Ubuntu-20.04\\home\\alan\\.ssh\u0026#34; ## 成功後會顯示以下訊息 已建立 C:\\Users\\User\\.ssh 的符號連結 \u0026lt;\u0026lt;===\u0026gt;\u0026gt; \\\\wsl$\\Ubuntu-20.04\\home\\alan\\.ssh 指令介紹 mklink mklink [option] Source Target mklink：建立連結\n/D ：連結類型為資料夾\nSource：windows連結路徑\nTarget：wsl家目錄的.ssh資料夾\nReference Can I SSH from WSL in Visual Studio Code? - Stack Overflow Using WSL for Remote-SSH in VS Code – Zit Seng\u0026rsquo;s Blog Sync VSCode’s SSH with WSL2 – Zit Seng\u0026rsquo;s Blog Mklink 指令建立 Symbolic Link | ShunNien\u0026rsquo;s Blog ","title":"vscode在wsl環境下連接ssh"},{"content":"GitLab不僅是一個源代碼管理工具，它還提供了一個統一的平台，將開發、運營和安全等流程整合在一起。通過GitLab，可以在單一的應用程序中進行專案計劃、源代碼管理、分支控制、CI/CD等操作。不論角色為何，GitLab提供了一個統一的資訊來源，讓你輕鬆地管理和追蹤整個開發流程。它消除了工具鏈的複雜性，提高了端到端流程的可視性，從而幫助組織更快地實現變革。\n本篇文章主要紀錄使用docker建立gitlab的教學\n準備環境 環境 OS Ubuntu 20.04 LTS Gitlab Gitlab-ce:15.8.0-ce.0 Docker Engine 23.0.5 安裝gitlab 在安裝之前，先講解一下gitlab有哪些重要的資料需要掛載的，主要有以下三個路徑\n/var/opt/gitlab: 這個路徑主要儲存GitLab的資料。包括Git repo、用戶資料、配置文件等。掛載到本地後，即使容器發生意外被刪除或重新創建，資料也能夠得到保留，達到數據持久化。\n./gitlab/logs:/var/log/gitlab: 這個路徑主要儲存GitLab的log。log包含GitLab的運行log、錯誤log等重要資訊。掛載到本地後，方便日後查看和管理log，並進行故障排除和監控。\n/etc/gitlab: 這個路徑主要儲存GitLab的設定檔，包含系統設定、用戶權限、外部整合等設定。掛載到本地後，可根據需求進行自定義調整。\n講解完以上重要的掛載路徑後，接下來講解使用docker建立gitlab\ndocker版 docker run -d \\ --name gitlab \\ --restart always \\ --privileged \\ -p 8080:80 \\ -p 443:443 \\ -p 22:22 \\ -v ./gitlab/data:/var/opt/gitlab \\ -v ./gitlab/logs:/var/log/gitlab \\ -v ./gitlab/config:/etc/gitlab \\ gitlab/gitlab-ce:15.8.0-ce.0 docker-compose版 先建立docker-compose.yaml 將以下內容貼上 version: \u0026#34;3.6\u0026#34; services: gitlab: image: gitlab/gitlab-ce:15.8.0-ce.0 container_name: gitlab restart: always privileged: true hostname: \u0026#39;localhost\u0026#39; ports: - \u0026#39;8080:80\u0026#39; - \u0026#39;443:443\u0026#39; - \u0026#39;22:22\u0026#39; volumes: - \u0026#39;./gitlab/data:/var/opt/gitlab\u0026#39; - \u0026#39;./gitlab/logs:/var/log/gitlab\u0026#39; - \u0026#39;./gitlab/config:/etc/gitlab\u0026#39; 執行docker-compose up -d讓gitlab在後台運行 執行docker-compose logs -f檢查gitlab log是否有異常 登入gitlab 打開瀏覽器輸入localhost:8080就會看到以下畫面 預設密碼可進到gitlab容器內下cat /etc/initial_root_password\n成功登入後就可以看到以下畫面，到這一步就已經完成gitlab的建立了\n","permalink":"https://sz9751210.github.io/posts/docker-install-gitlab/","summary":"GitLab不僅是一個源代碼管理工具，它還提供了一個統一的平台，將開發、運營和安全等流程整合在一起。通過GitLab，可以在單一的應用程序中進行專案計劃、源代碼管理、分支控制、CI/CD等操作。不論角色為何，GitLab提供了一個統一的資訊來源，讓你輕鬆地管理和追蹤整個開發流程。它消除了工具鏈的複雜性，提高了端到端流程的可視性，從而幫助組織更快地實現變革。\n本篇文章主要紀錄使用docker建立gitlab的教學\n準備環境 環境 OS Ubuntu 20.04 LTS Gitlab Gitlab-ce:15.8.0-ce.0 Docker Engine 23.0.5 安裝gitlab 在安裝之前，先講解一下gitlab有哪些重要的資料需要掛載的，主要有以下三個路徑\n/var/opt/gitlab: 這個路徑主要儲存GitLab的資料。包括Git repo、用戶資料、配置文件等。掛載到本地後，即使容器發生意外被刪除或重新創建，資料也能夠得到保留，達到數據持久化。\n./gitlab/logs:/var/log/gitlab: 這個路徑主要儲存GitLab的log。log包含GitLab的運行log、錯誤log等重要資訊。掛載到本地後，方便日後查看和管理log，並進行故障排除和監控。\n/etc/gitlab: 這個路徑主要儲存GitLab的設定檔，包含系統設定、用戶權限、外部整合等設定。掛載到本地後，可根據需求進行自定義調整。\n講解完以上重要的掛載路徑後，接下來講解使用docker建立gitlab\ndocker版 docker run -d \\ --name gitlab \\ --restart always \\ --privileged \\ -p 8080:80 \\ -p 443:443 \\ -p 22:22 \\ -v ./gitlab/data:/var/opt/gitlab \\ -v ./gitlab/logs:/var/log/gitlab \\ -v ./gitlab/config:/etc/gitlab \\ gitlab/gitlab-ce:15.8.0-ce.0 docker-compose版 先建立docker-compose.yaml 將以下內容貼上 version: \u0026#34;3.6\u0026#34; services: gitlab: image: gitlab/gitlab-ce:15.8.0-ce.0 container_name: gitlab restart: always privileged: true hostname: \u0026#39;localhost\u0026#39; ports: - \u0026#39;8080:80\u0026#39; - \u0026#39;443:443\u0026#39; - \u0026#39;22:22\u0026#39; volumes: - \u0026#39;.","title":"使用Docker安裝GitLab"},{"content":"服務上雲後有時會需要固定一組IP主動對外發出連線，這時要考慮安全性與獨立性的問題，在爬文後發現了GCP推出的Cloud NAT，本篇文章簡單介紹一下這個工具的使用。\n什麼是Cloud NAT GCP Cloud NAT是GCP上的一種服務，它提供了一個管理和部署Google Cloud上的NAT（Network Address Translation）的解決方案。 GCP Cloud NAT能夠讓使用者在不公開VM或GKE的外網IP情況下，透過共用一組IP對外溝通，外部服務無法直接存取Cloud NAT 閘道後的任何資源，確保了服務的安全性。\n什麼時候使用Cloud NAT 在需要使用私有IP地址與外網連接時，可以使用Cloud NAT。 例如：在Pod訪問外網時需要固定Public IP的情境下會使用到。\n如何使用Cloud NAT 準備環境 設定gcloud至正確專案 gcloud config set project \u0026lt;PROJECT_ID\u0026gt; 建立VPC網路與子網路 建立一台無外網的vm，region選asia-east1 ，zone選asia-east1-b，網路選剛剛建立的nat-network，子網選nat-subnet-192 建立防火牆並允許35.235.240.0/20網段，允許tcp 22 port，目標為無外網的vm 到IAP頁面並選擇SSH和TCP資源設定權限 到剛剛建立的vm curl httpbin.org/ip，此時應該是無法連線到外部\n設定NAT 到Cloud NAT建立NAT gateway，並選擇稍早創建的VPC以及創建Router 這時候在curl一次就會有一組對外ip了，此ip即為nat自動幫我們創建的外部ip 有了 Cloud NAT ，可以在不使用外部ip的情況下，與外網連線且同時阻擋了由外部的存取，增加了不少安全性，降低主機被攻擊的風險。\nReference Cloud NAT overview | Google Cloud Set up Cloud NAT with Compute Engine | Google Cloud 利用 Cloud NAT 維持雲端的獨立性與安全性 - PeerOne Technology 皮偶玩互動科技 - Medium ","permalink":"https://sz9751210.github.io/posts/gcp-cloud-nat/","summary":"服務上雲後有時會需要固定一組IP主動對外發出連線，這時要考慮安全性與獨立性的問題，在爬文後發現了GCP推出的Cloud NAT，本篇文章簡單介紹一下這個工具的使用。\n什麼是Cloud NAT GCP Cloud NAT是GCP上的一種服務，它提供了一個管理和部署Google Cloud上的NAT（Network Address Translation）的解決方案。 GCP Cloud NAT能夠讓使用者在不公開VM或GKE的外網IP情況下，透過共用一組IP對外溝通，外部服務無法直接存取Cloud NAT 閘道後的任何資源，確保了服務的安全性。\n什麼時候使用Cloud NAT 在需要使用私有IP地址與外網連接時，可以使用Cloud NAT。 例如：在Pod訪問外網時需要固定Public IP的情境下會使用到。\n如何使用Cloud NAT 準備環境 設定gcloud至正確專案 gcloud config set project \u0026lt;PROJECT_ID\u0026gt; 建立VPC網路與子網路 建立一台無外網的vm，region選asia-east1 ，zone選asia-east1-b，網路選剛剛建立的nat-network，子網選nat-subnet-192 建立防火牆並允許35.235.240.0/20網段，允許tcp 22 port，目標為無外網的vm 到IAP頁面並選擇SSH和TCP資源設定權限 到剛剛建立的vm curl httpbin.org/ip，此時應該是無法連線到外部\n設定NAT 到Cloud NAT建立NAT gateway，並選擇稍早創建的VPC以及創建Router 這時候在curl一次就會有一組對外ip了，此ip即為nat自動幫我們創建的外部ip 有了 Cloud NAT ，可以在不使用外部ip的情況下，與外網連線且同時阻擋了由外部的存取，增加了不少安全性，降低主機被攻擊的風險。\nReference Cloud NAT overview | Google Cloud Set up Cloud NAT with Compute Engine | Google Cloud 利用 Cloud NAT 維持雲端的獨立性與安全性 - PeerOne Technology 皮偶玩互動科技 - Medium ","title":"GCP Cloud NAT：Overview"},{"content":"什麼是 Kubernetes ReplicaSet? 先來個官網解說\nA ReplicaSet\u0026rsquo;s purpose is to maintain a stable set of replica Pods running at any given time. As such, it is often used to guarantee the availability of a specified number of identical Pods.\n根據上述描述，Replica Set主要的作用是確保始終都有一定數量的相同Pod可用，保證服務的高可用性。\nKubernetes RS是Kubernetes中的一種控制器，主要用於管理Pod的複製和伸縮，確保Pod的數量。RS具有以下幾種特性 自動管理pod的副本數量：確保指定數量的Pod跟使用者所期望的一致(desired status)，如果發生故障或需要擴展，它會自動創建或刪除Pod。 確保Pod的健康狀態：如果發生故障會對失敗的Pod進行重新調度 創建Pod的Template：當需要新的Pod時會根據定義的Pod Template創建 為什麼需要Replicaset? 在Kubernetes集群中，Pod的管理對於系統的可靠性和彈性至關重要。如果一個Pod發生故障，RS會自動創建一個新的Pod來代替它，確保服務繼續運行。同時，當服務需要擴展以滿足流量增加時，Kubernetes RS也可以自動創建額外的Pod。因此RS解決了以下問題：\n確保服務的高可用性和可靠性：RS可以自動維護一定數量的Pod，確保服務在Pod失敗時仍然可以正常運行。 方便服務的擴展：使用RS可以根據需求調整Pod的副本數量，實現服務的快速擴展。 簡化服務管理：RS可以自動調整Pod的數量，減少手動管理的工作量。 Kubernetes Replicaset是如何運作的？ 定義RS，指定所需的Pod副本數量和Pod Template，創建後，ReplicaSet使用定義好的Pod Template創建Pod，並開始監控每個Pod的狀態以及數量是否與定義的一致(desired status)，如果低於指定副本數則會創建Pod，高於指定副本數則會刪除Pod，當Pod被意外刪除時會創建新的Pod來做替代。\n什麼時候使用Replicaset？ 使用RS通常適用於以下情況：\n需要確保一定數量的Pod正在運行，以保持服務的可用性和可靠性。 需要能夠自動擴展和縮小Pod數量，以應對流量變化和其他需求。 希望能夠自動替換發生故障的Pod，以確保服務的連續運行。 需要管理一個服務的多個Pod，並且希望使用Kubernetes提供的自動化功能，例如調度、網路配置和負載平衡。 Kubernetes Replicaset有哪些特性？ 高可用性：RS的目的是維護一個穩定的Pod副本集，確保始終有一定數量的相同Pod可用，從而保證服務的高可用性。\n健康檢查和自動恢復：ReplicaSet可以通過定期檢查Pod副本的健康狀態來確保服務始終運行。當Pod故障或被刪除時，ReplicaSet會自動創建新的Pod來代替故障的Pod，確保服務的可用性及穩定性。\n自動擴縮：RS會監視Pod副本數量，並自動創建或刪除Pod副本以確保Pod副本數量達到指定的數量。使服務可以自動擴展和縮放，以應對不同的負載。\n版本控制：RS允許在不中斷現有服務的情況下部署新版本。在部署新版本之前先創建一些新Pod副本，然後再刪除舊Pod副本，這樣服務就可以實現無間斷的升級。\n動態標籤選擇：RS可以使用標籤選擇器來選擇Pod副本。可以基於Pod的標籤、名稱和其他屬性進行靈活的選擇。\n動態更新：RS支持動態更新，可以在運行時修改Pod的設定，從而實現靈活的應用程序管理。\n如何使用Replicaset? 宣告式(Declarative) 透過創建一個包含Pod Template的yaml檔，定義Pod的Container和其他元素，例如服務的Image和Configure。然後，可以在yaml檔中指定要創建的Pod數量和其他屬性，例如採用哪種調度策略和如何處理故障。 apiVersion: apps/v1 # 定義api版本 kind: ReplicaSet # 定義資源類型 metadata: # 定義元數據 name: frontend labels: app: guestbook tier: frontend spec: # 定義Pod的規格 replicas: 3 # 定義副本數量 selector: matchLabels: tier: frontend # 選擇Pod的Label template: metadata: labels: tier: frontend # 要創建的Pod的Label spec: # 容器規格 containers: - name: php-redis image: gcr.io/google_samples/gb-frontend:v3 在 ReplicaSet 中，.spec.template.metadata.labels 的值必須與 spec.selector.matchLabels 值相匹配，否則該配置會被 API 拒絕。\n命令式(Imperative) 創建RS kubectl create replicaset \u0026lt;replicaset-name\u0026gt; --image=\u0026lt;image-name\u0026gt; --replicas=\u0026lt;number-of-replicas\u0026gt; 查看RS kubectl describe replicaset \u0026lt;replicaset-name\u0026gt; kubectl get replicaset \u0026lt;replicaset-name\u0026gt; 刪除RS kubectl delete replicaset \u0026lt;replicaset-name\u0026gt; 擴縮RS kubectl scale replicaset \u0026lt;replicaset-name\u0026gt; --replicas=\u0026lt;number-of-replicas\u0026gt; 暫停RS更新 kubectl rollout pause replicaset \u0026lt;replicaset-name\u0026gt; 恢復RS更新 kubectl rollout resume replicaset \u0026lt;replicaset-name\u0026gt; 查看RS更新歷史 kubectl rollout history replicaset \u0026lt;replicaset-name\u0026gt; 回滾更新 kubectl rollout undo replicaset \u0026lt;replicaset-name\u0026gt; Reference ReplicaSet | Kubernetes Kubernetes ReplicaSet 介紹 | 小信豬的原始部落 (godleon.github.io) ","permalink":"https://sz9751210.github.io/posts/k8s-rs/","summary":"什麼是 Kubernetes ReplicaSet? 先來個官網解說\nA ReplicaSet\u0026rsquo;s purpose is to maintain a stable set of replica Pods running at any given time. As such, it is often used to guarantee the availability of a specified number of identical Pods.\n根據上述描述，Replica Set主要的作用是確保始終都有一定數量的相同Pod可用，保證服務的高可用性。\nKubernetes RS是Kubernetes中的一種控制器，主要用於管理Pod的複製和伸縮，確保Pod的數量。RS具有以下幾種特性 自動管理pod的副本數量：確保指定數量的Pod跟使用者所期望的一致(desired status)，如果發生故障或需要擴展，它會自動創建或刪除Pod。 確保Pod的健康狀態：如果發生故障會對失敗的Pod進行重新調度 創建Pod的Template：當需要新的Pod時會根據定義的Pod Template創建 為什麼需要Replicaset? 在Kubernetes集群中，Pod的管理對於系統的可靠性和彈性至關重要。如果一個Pod發生故障，RS會自動創建一個新的Pod來代替它，確保服務繼續運行。同時，當服務需要擴展以滿足流量增加時，Kubernetes RS也可以自動創建額外的Pod。因此RS解決了以下問題：\n確保服務的高可用性和可靠性：RS可以自動維護一定數量的Pod，確保服務在Pod失敗時仍然可以正常運行。 方便服務的擴展：使用RS可以根據需求調整Pod的副本數量，實現服務的快速擴展。 簡化服務管理：RS可以自動調整Pod的數量，減少手動管理的工作量。 Kubernetes Replicaset是如何運作的？ 定義RS，指定所需的Pod副本數量和Pod Template，創建後，ReplicaSet使用定義好的Pod Template創建Pod，並開始監控每個Pod的狀態以及數量是否與定義的一致(desired status)，如果低於指定副本數則會創建Pod，高於指定副本數則會刪除Pod，當Pod被意外刪除時會創建新的Pod來做替代。\n什麼時候使用Replicaset？ 使用RS通常適用於以下情況：\n需要確保一定數量的Pod正在運行，以保持服務的可用性和可靠性。 需要能夠自動擴展和縮小Pod數量，以應對流量變化和其他需求。 希望能夠自動替換發生故障的Pod，以確保服務的連續運行。 需要管理一個服務的多個Pod，並且希望使用Kubernetes提供的自動化功能，例如調度、網路配置和負載平衡。 Kubernetes Replicaset有哪些特性？ 高可用性：RS的目的是維護一個穩定的Pod副本集，確保始終有一定數量的相同Pod可用，從而保證服務的高可用性。\n健康檢查和自動恢復：ReplicaSet可以通過定期檢查Pod副本的健康狀態來確保服務始終運行。當Pod故障或被刪除時，ReplicaSet會自動創建新的Pod來代替故障的Pod，確保服務的可用性及穩定性。\n自動擴縮：RS會監視Pod副本數量，並自動創建或刪除Pod副本以確保Pod副本數量達到指定的數量。使服務可以自動擴展和縮放，以應對不同的負載。","title":"Kubernetes ReplicaSet：Overview"},{"content":"什麼是Kubernetes Service？ 先來個官網的解說\nA Kubernetes Service is an abstraction which defines a logical set of Pods and a policy by which to access them.\n白話文就是，訪問Pod用的一個Component。ＸＤ\nKubernetes Service是個抽象概念，通過Service，當我們的Pod創建好後，定義訪問它們的策略，該如何去訪問一群相同邏輯的Pod，給Pod提供一組穩定的IP或是Port。\n因此也可以把Service當作是一種掛在一群運行相同應用程式前面的LoadBalancer，詳見下圖。\n圖片來源\n為什麼需要Kubernetes Service？ 因為在Kubernetes集群中，Pod的IP地址是不穩定的，可能因為重新調度或重啟Container而改變了IP。為了使其他應用程式能夠穩定地訪問Pod，需要使用Kubernetes Service。\nKubernetes Service是如何工作的？ 當Pod啟動時，它們會自動註冊到Kubernetes集群中的一個服務發現機制中，例如Kubernetes DNS或etcd。Service會監聽這個服務發現機制，並根據Label Selector選擇要提供服務的Pod。\n當其他應用程式需要訪問Pod時，它們可以通過Service的IP和Port進行訪問，Service會將請求根據Label Selector轉發到選定的Pod。由於Service的IP和端口是穩定的，即使Pod的IP地址發生變化，其他應用程式依然可以一直使用相同的IP和Port訪問該Pod。\n圖片來源\nKubernetes Service的類型有哪些？ Kubernetes Service有以下四種類型：\nClusterIP: 在Kubernetes集群內部使用，通常用於應用程式的內部通訊。 NodePort: 將Pod暴露到Kubernetes集群的外部，並使用Node的IP和一個Static Port進行訪問。 LoadBalancer: LoadBalancer是ClusterIP和NodePort的一種擴展。在公有雲上使用，使用雲供應商提供的LoadBalancer將流量轉發到Service中的Pod。 ExternalName: 允許服務將外部DNS名稱映射到Kubernetes集群內部的svc名稱上。這樣可以在不修改應用程式代碼的情況下實現外部服務的訪問。 圖片來源 Kubernetes Service有哪些功能？ Kubernetes Service具有以下功能：\n透明地將請求轉發到Pod中，無需修改應用程式代碼。 提供負載均衡，分散流量到多個Pod中。 支持多種協議，例如TCP、UDP和HTTP。 可以設置Session Affinity，將請求路由到相同的Pod。 可以進行Port轉發，將請求轉發到Pod中的不同Port。 支持跨命名空間訪問。 如何創建和管理Kubernetes Service： 要創建 Kubernetes Service，可以使用以下兩種方式： 宣告式(Declarative) kind: Service apiVersion: v1 metadata: name: my-service spec: # type 一共有四種(ClusterIP, NodePort, LoadBalancer, ExternalName)，預設是 ClusterIP type: ClusterIP # 選擇帶有 \u0026#34;app=MyApp\u0026#34; 的 pod selector: app: MyApp # Service 實際對外服務的設定 ports: # 使用的協定與port，預設為TCP - protocol: TCP port: 80 # Pod對外開放的port，如無設定，預設與spec.ports.port相同 targetPort: 9376 透過以上的定義，網路的流向會呈現下方的樣子：\nRequest \u0026lt;---\u0026gt; Service(tcp:80) \u0026lt;---\u0026gt; Endpoint(tcp:9376) \u0026lt;---\u0026gt; Pod\nService 會將符合 Label Selector 設定的 Pod 建立 Endpoint resource object 做搭配。\n命令式(Imperative) kubectl create service nodeport \u0026lt;myservicename\u0026gt; 管理svc，可用以下方式： Svc查詢： kubectl get svc kubectl describe svc kubectl get svc -o wide 顯示Label Selector選定的Label。 Svc的更新：kubectl edit svc Svc的刪除：kubectl delete svc Reference Service | Kubernetes Kubernetes — Service Types Overview | by Ashish Patel | DevOps Mojo | Medium Kubernetes Service 概念詳解 | Kubernetes (tachingchen.com) [Kubernetes] Service Overview | 小信豬的原始部落 (godleon.github.io) ","permalink":"https://sz9751210.github.io/posts/k8s-svc/","summary":"什麼是Kubernetes Service？ 先來個官網的解說\nA Kubernetes Service is an abstraction which defines a logical set of Pods and a policy by which to access them.\n白話文就是，訪問Pod用的一個Component。ＸＤ\nKubernetes Service是個抽象概念，通過Service，當我們的Pod創建好後，定義訪問它們的策略，該如何去訪問一群相同邏輯的Pod，給Pod提供一組穩定的IP或是Port。\n因此也可以把Service當作是一種掛在一群運行相同應用程式前面的LoadBalancer，詳見下圖。\n圖片來源\n為什麼需要Kubernetes Service？ 因為在Kubernetes集群中，Pod的IP地址是不穩定的，可能因為重新調度或重啟Container而改變了IP。為了使其他應用程式能夠穩定地訪問Pod，需要使用Kubernetes Service。\nKubernetes Service是如何工作的？ 當Pod啟動時，它們會自動註冊到Kubernetes集群中的一個服務發現機制中，例如Kubernetes DNS或etcd。Service會監聽這個服務發現機制，並根據Label Selector選擇要提供服務的Pod。\n當其他應用程式需要訪問Pod時，它們可以通過Service的IP和Port進行訪問，Service會將請求根據Label Selector轉發到選定的Pod。由於Service的IP和端口是穩定的，即使Pod的IP地址發生變化，其他應用程式依然可以一直使用相同的IP和Port訪問該Pod。\n圖片來源\nKubernetes Service的類型有哪些？ Kubernetes Service有以下四種類型：\nClusterIP: 在Kubernetes集群內部使用，通常用於應用程式的內部通訊。 NodePort: 將Pod暴露到Kubernetes集群的外部，並使用Node的IP和一個Static Port進行訪問。 LoadBalancer: LoadBalancer是ClusterIP和NodePort的一種擴展。在公有雲上使用，使用雲供應商提供的LoadBalancer將流量轉發到Service中的Pod。 ExternalName: 允許服務將外部DNS名稱映射到Kubernetes集群內部的svc名稱上。這樣可以在不修改應用程式代碼的情況下實現外部服務的訪問。 圖片來源 Kubernetes Service有哪些功能？ Kubernetes Service具有以下功能：\n透明地將請求轉發到Pod中，無需修改應用程式代碼。 提供負載均衡，分散流量到多個Pod中。 支持多種協議，例如TCP、UDP和HTTP。 可以設置Session Affinity，將請求路由到相同的Pod。 可以進行Port轉發，將請求轉發到Pod中的不同Port。 支持跨命名空間訪問。 如何創建和管理Kubernetes Service： 要創建 Kubernetes Service，可以使用以下兩種方式： 宣告式(Declarative) kind: Service apiVersion: v1 metadata: name: my-service spec: # type 一共有四種(ClusterIP, NodePort, LoadBalancer, ExternalName)，預設是 ClusterIP type: ClusterIP # 選擇帶有 \u0026#34;app=MyApp\u0026#34; 的 pod selector: app: MyApp # Service 實際對外服務的設定 ports: # 使用的協定與port，預設為TCP - protocol: TCP port: 80 # Pod對外開放的port，如無設定，預設與spec.","title":"Kubernetes Service：Overview"},{"content":"Kubernetes是現代應用程序開發和部署的重要技術，而Pod是Kubernetes中最小的部署單位。Pod是一個或多個container的集合，它們共享一個網路命名空間和一個網路接口。Pod不僅提供了一個簡單而強大的container環境，還可以用於實現多種container編排方案，例如負載平衡、數據管理、多container協作等。\n本文將深入探討Kubernetes中的Pod，介紹Pod的基本概念、設計原則和實現方式，以及與其他資源的關係。您將學習如何創建和配置Pod，如何使用Kubernetes管理Pod，以及如何通過Pod實現高效、彈性和可靠的應用程序部署。\n什麼是Kubernetes Pod Kubernetes Pod是Kubernetes集群中最小的部署單位。一個Pod可以包含一個或多個container，這些container共享相同的網路和儲存空間。Pod提供了一個環境，讓container可以協同工作，形成一個應用程序。\nPod的結構和特性 Pod包含以下元素：\n共享網路空間 (Networking)：Pod 中的所有container共享相同的網路空間，可以在container之間通過 localhost 進行通信。 共享儲存空間 (Shared Storage)：Pod 中的所有container共享相同的儲存空間，可以在container之間共享文件、環境變量等。 容器 (Containers)：Pod 中可以包含一個或多個container，這些container可以共享同一個網路和儲存空間，方便container之間的互相協作。 存活和重啟策略 (Liveness and Restart Policy)：Pod 的存活策略指定了在容器出現異常情況時，Kubernetes 如何應對，如重新啟動 container 或者將其標記為失敗。Pod 的重啟策略則指定了當 Pod 中的所有 container 都停止運行時，Kubernetes 如何進行重啟。 元數據 (Metadata)：Pod 中包含一些元數據，如 Pod 名稱、命名空間、標籤等，這些元數據可以用於管理和監控 Pod。 Pod的特性包括：\n生命週期短暫 可以擁有多個container 具有唯一的IP地址 具有獨立的儲存空間 具有網路隔離 如何創建和管理Pod 要創建 Kubernetes Pod，可以使用以下兩種方式： 宣告式（Declarative）：使用 YAML 或 JSON 格式的文件來定義 Pod 的結構、元資料和規格，包括 Pod 名稱、container image、資源限制、網路設定等。 apiVersion: v1 kind: Pod metadata: name: my-pod spec: containers: - name: nginx-container image: nginx:latest ports: - containerPort: 80 接著使用kubectl創建pod\nkubectl create -f my-pod.yaml 命令式（Imperative）：命令式方式是通過在命令行中執行指令，將 Pod、Service、Replication Controller 或其他 Kubernetes 資源創建和管理。 kubectl run my-pod --image=nginx --port=80 要管理pod，則有以下幾種方式：\nPod 的查詢：使用 kubectl get pods 或是 kubectl describe pods 命令查詢 Kubernetes 集群中的 Pod，以了解其狀態、命名空間、IP 地址等信息。\nPod 的更新：當container image或配置發生變化時，可以通過kubectl edit pod 來編輯Pod的 YAML 或 JSON 文件，然後使用 kubectl apply 命令來更新 Pod。\nPod 的刪除：使用 kubectl delete pod 命令刪除 Kubernetes 集群中的 Pod。\nPod 的擴展：可以使用 Deployment、ReplicaSet 等 Kubernetes 資源進行 Pod 的擴展，自動創建、管理多個 Pod，以實現應用程序的高可用性。\nPod 的健康檢查：可以定義 Pod 的 LivenessProbe、ReadinessProbe 檢查container是否正常運行，當container不可用時，Kubernetes 會自動重啟container或調度 Pod 到其他節點。\nPod 的日誌查詢：可以使用 kubectl logs pod 命令查詢 Pod 中 container 的日誌，以了解 container 運行情況。\nPod 的port轉發：可以使用 kubectl port-forward pod 命令將 Pod 中 container 的 port 轉發到本地 port，以便進行調試和測試。\nPod的生命週期 Pod的生命週期包括以下階段：\nPending：Pod正在等待Kubernetes集群分配資源 Running：Pod正在運行中 Succeeded：Pod已經完成工作並成功退出 Failed：Pod因為某些原因無法運行或者已經退出 Unknown：Kubernetes無法獲取Pod的狀態 Pod的網路和儲存設定 Pod的網路和儲存設定包括以下方面：\ncontainer的port和協議\n在 Pod 配置中，可以通過 containerPort 屬性來指定container需要暴露的port和協議。下面是一個示例：\napiVersion: v1 kind: Pod metadata: name: web-pod spec: containers: - name: web-container image: nginx ports: - containerPort: 80 protocol: TCP 在這個範例中，定義了一個名為 web-pod 的 Pod，其中包含一個名為 web-container 的container，該container需要暴露 TCP 協議的 80 port。 Pod的IP地址和主機名稱\n在 Pod 中，每個container都有自己的 IP 地址和主機名稱。可以通過 hostname、subdomain 和 ip 屬性來設定它們。\napiVersion: v1 kind: Pod metadata: name: web-pod spec: hostname: web-host subdomain: example.com containers: - name: web-container image: nginx 在這個範例中，定義了一個名為 web-pod 的 Pod，其中包含一個名為 web-container 的container。還通過 hostname 屬性設定了container的主機名稱為 web-host，通過 subdomain 屬性設定了container的子域名為 example.com。 Pod的網路策略\n在 Kubernetes 中，可以通過 networkPolicy 屬性設定 Pod 的網路策略，以控制哪些 Pod 可以訪問該 Pod。\napiVersion: v1 kind: Pod metadata: name: web-pod spec: containers: - name: web-container image: nginx networkPolicy: podSelector: matchLabels: app: web ingress: - from: - podSelector: matchLabels: app: db 在這個範例中，定義了一個名為 web-pod 的 Pod，其中包含一個名為 web-container 的container。通過 networkPolicy 屬性設定了該 Pod 的網路策略，只允許來自標籤為 app=db 的 Pod 訪問它。 Pod的儲存設定\n在 Pod 中，可以通過 volumes 屬性設定儲存設定。\napiVersion: v1 kind: Pod metadata: name: web-pod spec: containers: - name: web-container image: nginx volumeMounts: - name: data-volume mountPath: /data volumes: - name: data-volume emptyDir: {} 在這個範例中，定義了一個名為 web-pod 的 Pod，其中包含一個名為 web-container 的container。通過 volumeMounts 屬性設定了一個名為 data-volume 的卷並將其掛載到container的 /data 目錄下，並通過 volumes 屬性定義了這個卷的內容，這裡使用了一個 emptyDir 卷，表示它是一個空目錄。\nReference Pod | Kubernetes ","permalink":"https://sz9751210.github.io/posts/k8s-pod/","summary":"Kubernetes是現代應用程序開發和部署的重要技術，而Pod是Kubernetes中最小的部署單位。Pod是一個或多個container的集合，它們共享一個網路命名空間和一個網路接口。Pod不僅提供了一個簡單而強大的container環境，還可以用於實現多種container編排方案，例如負載平衡、數據管理、多container協作等。\n本文將深入探討Kubernetes中的Pod，介紹Pod的基本概念、設計原則和實現方式，以及與其他資源的關係。您將學習如何創建和配置Pod，如何使用Kubernetes管理Pod，以及如何通過Pod實現高效、彈性和可靠的應用程序部署。\n什麼是Kubernetes Pod Kubernetes Pod是Kubernetes集群中最小的部署單位。一個Pod可以包含一個或多個container，這些container共享相同的網路和儲存空間。Pod提供了一個環境，讓container可以協同工作，形成一個應用程序。\nPod的結構和特性 Pod包含以下元素：\n共享網路空間 (Networking)：Pod 中的所有container共享相同的網路空間，可以在container之間通過 localhost 進行通信。 共享儲存空間 (Shared Storage)：Pod 中的所有container共享相同的儲存空間，可以在container之間共享文件、環境變量等。 容器 (Containers)：Pod 中可以包含一個或多個container，這些container可以共享同一個網路和儲存空間，方便container之間的互相協作。 存活和重啟策略 (Liveness and Restart Policy)：Pod 的存活策略指定了在容器出現異常情況時，Kubernetes 如何應對，如重新啟動 container 或者將其標記為失敗。Pod 的重啟策略則指定了當 Pod 中的所有 container 都停止運行時，Kubernetes 如何進行重啟。 元數據 (Metadata)：Pod 中包含一些元數據，如 Pod 名稱、命名空間、標籤等，這些元數據可以用於管理和監控 Pod。 Pod的特性包括：\n生命週期短暫 可以擁有多個container 具有唯一的IP地址 具有獨立的儲存空間 具有網路隔離 如何創建和管理Pod 要創建 Kubernetes Pod，可以使用以下兩種方式： 宣告式（Declarative）：使用 YAML 或 JSON 格式的文件來定義 Pod 的結構、元資料和規格，包括 Pod 名稱、container image、資源限制、網路設定等。 apiVersion: v1 kind: Pod metadata: name: my-pod spec: containers: - name: nginx-container image: nginx:latest ports: - containerPort: 80 接著使用kubectl創建pod","title":"Kubernetes Pod：Overview"},{"content":"標題：5 ChatGPT features to boost your daily work\n連結：5 ChatGPT features to boost your daily work | by Josep Ferrer | Geek Culture | Jan, 2023 | Medium\n機器學習技術正逐漸地應用到日常工作之中，ChatGPT 便是其中之一。ChatGPT 是由 OpenAI 訓練的一個大型語言模型，它能夠根據輸入的文字，生成各種形式的回應，包括文字、代碼和語言翻譯等。\n在這篇文章中，作者將介紹 ChatGPT 的五個強大功能，這些功能可以幫助開發者提高工作效率和生產力。\n產生語言框架：ChatGPT 可以生成編碼框架，幫助開發人員更快速地開始編碼。\n研究和比較：ChatGPT 可以幫助使用者對不同主題進行研究和比較，包括比較產品、服務、技術、公司等等。\n理解代碼：ChatGPT 可以分析並幫助使用者理解代碼，包括程式語言、代碼段和概念等。\n為代碼添加註釋：ChatGPT 可以根據輸入的代碼，產生相應的註釋，幫助使用者更輕鬆地理解代碼和更有效地與團隊成員協作。\n使用特定風格重寫代碼：ChatGPT 可以根據輸入的代碼，重寫代碼並生成相應的代碼風格，以滿足不同的編碼標準和最佳實踐。\n","permalink":"https://sz9751210.github.io/posts/5-chatgpt-features-to-boost-your-daily-work/","summary":"標題：5 ChatGPT features to boost your daily work\n連結：5 ChatGPT features to boost your daily work | by Josep Ferrer | Geek Culture | Jan, 2023 | Medium\n機器學習技術正逐漸地應用到日常工作之中，ChatGPT 便是其中之一。ChatGPT 是由 OpenAI 訓練的一個大型語言模型，它能夠根據輸入的文字，生成各種形式的回應，包括文字、代碼和語言翻譯等。\n在這篇文章中，作者將介紹 ChatGPT 的五個強大功能，這些功能可以幫助開發者提高工作效率和生產力。\n產生語言框架：ChatGPT 可以生成編碼框架，幫助開發人員更快速地開始編碼。\n研究和比較：ChatGPT 可以幫助使用者對不同主題進行研究和比較，包括比較產品、服務、技術、公司等等。\n理解代碼：ChatGPT 可以分析並幫助使用者理解代碼，包括程式語言、代碼段和概念等。\n為代碼添加註釋：ChatGPT 可以根據輸入的代碼，產生相應的註釋，幫助使用者更輕鬆地理解代碼和更有效地與團隊成員協作。\n使用特定風格重寫代碼：ChatGPT 可以根據輸入的代碼，重寫代碼並生成相應的代碼風格，以滿足不同的編碼標準和最佳實踐。","title":"閱讀筆記：5 ChatGPT features to boost your daily work"},{"content":"Intro👨‍💻 在gcp環境下使用ansible playbook 建立k8s cluster，目前base image為centos 7，安裝方式類似elk stack，一樣先等master安裝完後產生token，接著安裝slave。\n使用的CRI為containerd，CNI為calico\n資料夾結構 . ├── README.md ├── create_k8s_master_instance.yaml ├── create_k8s_slave_instance.yaml ├── files │ ├── instance │ └── k8s ├── group_vars │ └── all ├── inventory │ └── k8s.cluster.host ├── inventory.instance.create.yml.example ├── k8s-setup.sh ├── roles │ ├── instance │ ├── k8s │ ├── monitor │ └── ops_agent └── vars ├── instance ├── k8s └── monitor 使用指南 設定機器資訊：複製好inventory.instance.create.yml.example後，可參考inventory裡的設定，主要設定gcp的資訊， 設定group_vars的env.yml，改成自己的gcp的專案以及要設定的region 可使用k8s-setup.sh進行一鍵安裝 sh ./k8s-setup.sh 建置流程 k8s_master -\u0026gt; k8s_slave\n指令 ANSIBLE_HOST_KEY_CHECKING=False ansible-playbook -i inventory.instance.create.yml create_xxx_instance.yaml -v 安裝完後可以去master切成root確認是否有組成cluster\n預計添加功能 添加自定義CRI與CNI 可選k8s版本 可依照base image進行相對應的安裝 Reference Install Kubernetes Cluster on CentOS 7 with kubeadm | ComputingForGeeks\nAutomating Kubernetes Cluster Using Ansible | by Shubham Mehta | Medium\n🔗專案repo –\u0026gt; sz9751210/ansible-k8s (github.com)\n","permalink":"https://sz9751210.github.io/posts/ansible-k8s/","summary":"Intro👨‍💻 在gcp環境下使用ansible playbook 建立k8s cluster，目前base image為centos 7，安裝方式類似elk stack，一樣先等master安裝完後產生token，接著安裝slave。\n使用的CRI為containerd，CNI為calico\n資料夾結構 . ├── README.md ├── create_k8s_master_instance.yaml ├── create_k8s_slave_instance.yaml ├── files │ ├── instance │ └── k8s ├── group_vars │ └── all ├── inventory │ └── k8s.cluster.host ├── inventory.instance.create.yml.example ├── k8s-setup.sh ├── roles │ ├── instance │ ├── k8s │ ├── monitor │ └── ops_agent └── vars ├── instance ├── k8s └── monitor 使用指南 設定機器資訊：複製好inventory.instance.create.yml.example後，可參考inventory裡的設定，主要設定gcp的資訊， 設定group_vars的env.yml，改成自己的gcp的專案以及要設定的region 可使用k8s-setup.sh進行一鍵安裝 sh ./k8s-setup.sh 建置流程 k8s_master -\u0026gt; k8s_slave","title":"ansible k8s"},{"content":"標題：15 Best Practices when working with Docker\n連結：15 Best Practices when working with Docker | by Ali Zeynalli | Dec, 2022 | Medium\n本篇文章作者根據經驗以及自身研究整理出了15個使用Docker的技巧與提示\n1. 進行中的工作不應保存在未命名、已停止的容器中 如果進行中的工作保存在不好的容器中，可能會導致資料丟失、風險以及安全問題、不利於協作\n2. 定期清理Image 幫助釋放存儲空間，優化Docker引擎性能，減少安全風險，以及維持主機整潔，易於管理。\n3. 使用授權的相依套件 可以帶來更好的合法性、安全性、可靠性、支持性和法律責任。\n4. 將變化很大的部分放在 DockerFile 的末尾 因為Docker會將每個步驟緩存為一個單獨的容器，重複的操作將不會重新執行，將變化較大的部分放在最後可提高性能\n5. 不要在容器啟動時就獲取相依套件 避免在容器啟動時獲取依賴包帶來的問題，並提高容器的啟動速度和可管理性。最佳實踐是在構建Image時就獲取依賴包，並將它們打包到Image中。另外，還可以使用多階段構建和緩存等技術來優化構建過程，提高構建速度和效率。\n6. 不要掛載共享資料夾 有助於提高容器的可移植性、安全性、可重現性和可管理性。\n7. 保持Image simple and small 可以提高應用程序的可移植性、降低安全風險、減少Image大小、提高Image構建和管理效率。\n8. 從頭開始構建 最大限度地減少相依\n9. Tag Image 使用合理的Tag，有助於對Image進行排序\n10. 使用小型基礎Image 例如-slim或-alpine，可以帶來更明確的依賴項、更少的儲存、更少的安全漏洞和攻擊面以及更快的構建時間。\n11. 使用官方Image 帶來可靠性、安全性、活躍的社群支持以及易用性等好處。\n12. 創建臨時容器 Dockerfile定義的Image應該盡可能是臨時的，提供隔離環境、避免依賴衝突、快速清理、易於重複，提高工作效率與可靠性，方便快速測試，不必擔心對主機有影響。\n13. 使用multi-stage構建 幫助減小Docker Image的大小，優化構建速度，簡化構建過程，以及提高Docker Image的安全性。\n14. 將多行參數進行排序 將多個RUN命令組合起來，減少Image層數、構建時間、優化Image緩存、增加Dockerfile可讀性。\n15. 使用.Dockerignore 從構建中排除不必要的文件，減少Image大小並增加構建速度。\n","permalink":"https://sz9751210.github.io/posts/15-best-practices-when-working-with-docker/","summary":"標題：15 Best Practices when working with Docker\n連結：15 Best Practices when working with Docker | by Ali Zeynalli | Dec, 2022 | Medium\n本篇文章作者根據經驗以及自身研究整理出了15個使用Docker的技巧與提示\n1. 進行中的工作不應保存在未命名、已停止的容器中 如果進行中的工作保存在不好的容器中，可能會導致資料丟失、風險以及安全問題、不利於協作\n2. 定期清理Image 幫助釋放存儲空間，優化Docker引擎性能，減少安全風險，以及維持主機整潔，易於管理。\n3. 使用授權的相依套件 可以帶來更好的合法性、安全性、可靠性、支持性和法律責任。\n4. 將變化很大的部分放在 DockerFile 的末尾 因為Docker會將每個步驟緩存為一個單獨的容器，重複的操作將不會重新執行，將變化較大的部分放在最後可提高性能\n5. 不要在容器啟動時就獲取相依套件 避免在容器啟動時獲取依賴包帶來的問題，並提高容器的啟動速度和可管理性。最佳實踐是在構建Image時就獲取依賴包，並將它們打包到Image中。另外，還可以使用多階段構建和緩存等技術來優化構建過程，提高構建速度和效率。\n6. 不要掛載共享資料夾 有助於提高容器的可移植性、安全性、可重現性和可管理性。\n7. 保持Image simple and small 可以提高應用程序的可移植性、降低安全風險、減少Image大小、提高Image構建和管理效率。\n8. 從頭開始構建 最大限度地減少相依\n9. Tag Image 使用合理的Tag，有助於對Image進行排序\n10. 使用小型基礎Image 例如-slim或-alpine，可以帶來更明確的依賴項、更少的儲存、更少的安全漏洞和攻擊面以及更快的構建時間。\n11. 使用官方Image 帶來可靠性、安全性、活躍的社群支持以及易用性等好處。\n12. 創建臨時容器 Dockerfile定義的Image應該盡可能是臨時的，提供隔離環境、避免依賴衝突、快速清理、易於重複，提高工作效率與可靠性，方便快速測試，不必擔心對主機有影響。\n13. 使用multi-stage構建 幫助減小Docker Image的大小，優化構建速度，簡化構建過程，以及提高Docker Image的安全性。","title":"閱讀筆記：15 Best Practices when working with Docker"},{"content":"👨‍💻簡介 什麼是crontab Crontab 是一個 Unix 系統下的定時任務管理工具。它允許用戶自動在特定時間執行指令或程式，而無需人工干預。Crontab 文件中的每一行都代表一個定時任務，其中指定了任務執行的時間，以及要執行的指令或程式。\ncrontab用在哪 適用於週期性的任務，例如每天定時備份檔案，或者每周定時發送報表等等。使用 Crontab 可以大大簡化這些任務的管理，避免因人為錯誤而導致的問題。\n語法 crontab [ -e [UserName] | -l [UserName] | -r [UserName] | -v [UserName] | File ] 選項 參數 說明 -e UserName 編輯crontab -l UserName 顯示當前用戶的crontab -r UserName 移除當前用戶的crontab -v UserName 顯示當前用戶的cron jobs狀態 格式 # ┌───────────── 分鐘 (0 - 59) # │ ┌─────────── 小時 (0 - 23) # │ │ ┌───────── 日 (1 - 31) # │ │ │ ┌─────── 月 (1 - 12) # │ │ │ │ ┌───── 星期幾 (0 - 7，0 是週日，6 是週六，7 也是週日) # │ │ │ │ │ # * * * * * /path/to/command 範例 查看自己的crontab crontab -l 查看指定用戶的crontab sudo crontab -u alan -l 編輯crontab crontab -e 編輯指定用戶的crontab sudo crontab -u alan -e 刪除crontab crontab -r 擴展 參數 說明 crontab格式 @reboot 每次重開機執行一次 @yearly 每年執行一次 0 0 1 1 * @annualy 每年執行一次 0 0 1 1 * @monthly 每月執行一次 0 0 1 * * @weekly 每週執行一次 0 0 * * 0 @daily 每天執行一次 0 0 * * * @hourly 每小時執行一次 0 * * * * 限制特定用戶執行crontab 使用場景：系統安全性考量 使用到的檔案 /etc/cron.allow：白名單 /etc/cron.deny：黑名單 如果 /etc/cron.allow 與 /etc/cron.deny 兩個設定檔都不存在，則就只有系統管理者 root 能夠使用 crontab。\n範例：允許user1可以用crontab echo \u0026#34;user1\u0026#34; \u0026gt; /etc/cron.allow Reference 鳥哥私房菜 - 第十五章、例行性工作排程(crontab) (vbird.org) Linux 設定 crontab 例行性工作排程教學與範例 - G. T. Wang (gtwang.org) How to allow only specific non-root user(s) to use crontab – The Geek Diary ","permalink":"https://sz9751210.github.io/posts/linux-crontab/","summary":"👨‍💻簡介 什麼是crontab Crontab 是一個 Unix 系統下的定時任務管理工具。它允許用戶自動在特定時間執行指令或程式，而無需人工干預。Crontab 文件中的每一行都代表一個定時任務，其中指定了任務執行的時間，以及要執行的指令或程式。\ncrontab用在哪 適用於週期性的任務，例如每天定時備份檔案，或者每周定時發送報表等等。使用 Crontab 可以大大簡化這些任務的管理，避免因人為錯誤而導致的問題。\n語法 crontab [ -e [UserName] | -l [UserName] | -r [UserName] | -v [UserName] | File ] 選項 參數 說明 -e UserName 編輯crontab -l UserName 顯示當前用戶的crontab -r UserName 移除當前用戶的crontab -v UserName 顯示當前用戶的cron jobs狀態 格式 # ┌───────────── 分鐘 (0 - 59) # │ ┌─────────── 小時 (0 - 23) # │ │ ┌───────── 日 (1 - 31) # │ │ │ ┌─────── 月 (1 - 12) # │ │ │ │ ┌───── 星期幾 (0 - 7，0 是週日，6 是週六，7 也是週日) # │ │ │ │ │ # * * * * * /path/to/command 範例 查看自己的crontab crontab -l 查看指定用戶的crontab sudo crontab -u alan -l 編輯crontab crontab -e 編輯指定用戶的crontab sudo crontab -u alan -e 刪除crontab crontab -r 擴展 參數 說明 crontab格式 @reboot 每次重開機執行一次 @yearly 每年執行一次 0 0 1 1 * @annualy 每年執行一次 0 0 1 1 * @monthly 每月執行一次 0 0 1 * * @weekly 每週執行一次 0 0 * * 0 @daily 每天執行一次 0 0 * * * @hourly 每小時執行一次 0 * * * * 限制特定用戶執行crontab 使用場景：系統安全性考量 使用到的檔案 /etc/cron.","title":"Linux 定時任務[crontab]"},{"content":"Intro🧑‍💻 紀錄有哪些方式可以ssh到gce機器\n放key到中繼資料 Compute Enging -\u0026gt; 中繼資料 -\u0026gt; 安全殼層金鑰 使用TCP Tunneling\ngcloud compute start-iap-tunnel --project project-id --zone vm-zone --local-host-port 127.0.0.1:10001 vm-host 22 使用gcloud ssh gcloud compute ssh --zone vm-zone vm-host --tunnel-through-iap --project project-id 可編寫tunnel的script\n## dev gcloud compute start-iap-tunnel dev-border 22 --local-host-port 127.0.0.1:10120 --zone asia-east1-b --project gcp-project \u0026amp; ## test gcloud compute start-iap-tunnel test-border 22 --local-host-port localhost:10121 --zone asia-east1-b --project gcp-project \u0026amp; ## prod gcloud compute start-iap-tunnel prod-border 22 --zone asia-east1-b --local-host-port 127.0.0.1:10122 --project gcp-project \u0026amp; Reference 使用 IAP 进行 TCP 转发 | Identity-Aware Proxy | Google Cloud SSH TCP Tunneling using Google Cloud SDK Identity Aware Proxy Commands (github.com) ","permalink":"https://sz9751210.github.io/posts/gcp%E8%B7%B3%E6%9D%BF%E6%A9%9Fssh%E7%9B%B8%E9%97%9C%E8%A8%AD%E5%AE%9A/","summary":"Intro🧑‍💻 紀錄有哪些方式可以ssh到gce機器\n放key到中繼資料 Compute Enging -\u0026gt; 中繼資料 -\u0026gt; 安全殼層金鑰 使用TCP Tunneling\ngcloud compute start-iap-tunnel --project project-id --zone vm-zone --local-host-port 127.0.0.1:10001 vm-host 22 使用gcloud ssh gcloud compute ssh --zone vm-zone vm-host --tunnel-through-iap --project project-id 可編寫tunnel的script\n## dev gcloud compute start-iap-tunnel dev-border 22 --local-host-port 127.0.0.1:10120 --zone asia-east1-b --project gcp-project \u0026amp; ## test gcloud compute start-iap-tunnel test-border 22 --local-host-port localhost:10121 --zone asia-east1-b --project gcp-project \u0026amp; ## prod gcloud compute start-iap-tunnel prod-border 22 --zone asia-east1-b --local-host-port 127.","title":"gcp遠端連線的幾種方式"},{"content":"簡介👩‍💻 最近在研究terraform與ansible的整合，不過還在摸索中，機器的版控對於維運來講相對重要，這時候有terraform的出現，在建立機器後會隨之產生機器的狀態檔，而ansible則是在建立好機器後幫助我完成我所需的機器相關設定\n這是一款terraform結合ansible的小玩具，在gcp環境下使用terraform幫我建置好機器，接著使用local exec執行ansible的playbook完成機器的設定\n資料夾結構 ├───ansible-playbook │ ├───group_vars │ │ └───all │ ├───roles │ │ ├───instance │ │ │ └───tasks │ │ └───ops_agent │ │ └───tasks │ └───vars │ └───instance ├───modules │ └───main.tf │ └───variables.tf └───roles └───general └───general.tf ansible-playbook：放置ansible相關工具 modules：放置主要使用的resource以及定義好的變數 roles：放置自定義參數 使用指南 先建立gcp sa給terraform可以有建立vm的權限，接著可以下\nterraform init -\u0026gt; 先讓terraform下載相關的repo terraform plan -\u0026gt; 查看terraform會做哪些事情，一開始都會先去檢查狀態檔，最上面代表動作，此範例為create，最下面的plan代表總共有4個resource會add terraform apply -\u0026gt; 建立機器指令，apply一樣會把plan的部分也顯示出來，並詢問是否要繼續，打上yes後便會開始建置機器 terraform destroy -\u0026gt; 機器建立完要刪除時下這指令，destroy一樣會去檢查狀態檔，這次的動作為destroy，最下面的plan顯示4個資源會被destroy terraform show -\u0026gt; 可以顯示當前terraform的狀態 🔗專案repo \u0026ndash;\u0026gt; https://github.com/sz9751210/terraform-demo\n","permalink":"https://sz9751210.github.io/posts/terraform-ansible/","summary":"簡介👩‍💻 最近在研究terraform與ansible的整合，不過還在摸索中，機器的版控對於維運來講相對重要，這時候有terraform的出現，在建立機器後會隨之產生機器的狀態檔，而ansible則是在建立好機器後幫助我完成我所需的機器相關設定\n這是一款terraform結合ansible的小玩具，在gcp環境下使用terraform幫我建置好機器，接著使用local exec執行ansible的playbook完成機器的設定\n資料夾結構 ├───ansible-playbook │ ├───group_vars │ │ └───all │ ├───roles │ │ ├───instance │ │ │ └───tasks │ │ └───ops_agent │ │ └───tasks │ └───vars │ └───instance ├───modules │ └───main.tf │ └───variables.tf └───roles └───general └───general.tf ansible-playbook：放置ansible相關工具 modules：放置主要使用的resource以及定義好的變數 roles：放置自定義參數 使用指南 先建立gcp sa給terraform可以有建立vm的權限，接著可以下\nterraform init -\u0026gt; 先讓terraform下載相關的repo terraform plan -\u0026gt; 查看terraform會做哪些事情，一開始都會先去檢查狀態檔，最上面代表動作，此範例為create，最下面的plan代表總共有4個resource會add terraform apply -\u0026gt; 建立機器指令，apply一樣會把plan的部分也顯示出來，並詢問是否要繼續，打上yes後便會開始建置機器 terraform destroy -\u0026gt; 機器建立完要刪除時下這指令，destroy一樣會去檢查狀態檔，這次的動作為destroy，最下面的plan顯示4個資源會被destroy terraform show -\u0026gt; 可以顯示當前terraform的狀態 🔗專案repo \u0026ndash;\u0026gt; https://github.com/sz9751210/terraform-demo","title":"terraform-ansible"},{"content":"安裝與設定所需依賴 安裝依賴套件 sudo yum install -y curl policycoreutils-python openssh-server perl 啟動 SSH 服務 sudo systemctl enable sshd sudo systemctl start sshd 防火牆開啟網頁要用的PORT網頁 sudo firewall-cmd --permanent --add-service=http sudo firewall-cmd --permanent --add-service=https sudo systemctl reload firewalld 安裝 SMTP Server (Postfix)，發送通知email用 sudo yum install postfix sudo systemctl enable postfix sudo systemctl start postfix 添加gitlab repo以及安裝package Add Gitlab package 可自行選擇要安裝CE版還是EE版，如果要安裝EE版則把gitlab-ce改成gitlab-ee即可 curl https://packages.gitlab.com/install/repositories/gitlab/gitlab-ce/script.rpm.sh | sudo bash Install Gitlab 這邊建置是使用內網，因此使用http的方式下去做設定 sudo EXTERNAL_URL=\u0026#34;http://{{ internal_ip }}\u0026#34; yum install -y gitlab-ce reference Download and install GitLab | GitLab\n","permalink":"https://sz9751210.github.io/posts/centos7%E5%AE%89%E8%A3%9Dgitlab/","summary":"安裝與設定所需依賴 安裝依賴套件 sudo yum install -y curl policycoreutils-python openssh-server perl 啟動 SSH 服務 sudo systemctl enable sshd sudo systemctl start sshd 防火牆開啟網頁要用的PORT網頁 sudo firewall-cmd --permanent --add-service=http sudo firewall-cmd --permanent --add-service=https sudo systemctl reload firewalld 安裝 SMTP Server (Postfix)，發送通知email用 sudo yum install postfix sudo systemctl enable postfix sudo systemctl start postfix 添加gitlab repo以及安裝package Add Gitlab package 可自行選擇要安裝CE版還是EE版，如果要安裝EE版則把gitlab-ce改成gitlab-ee即可 curl https://packages.gitlab.com/install/repositories/gitlab/gitlab-ce/script.rpm.sh | sudo bash Install Gitlab 這邊建置是使用內網，因此使用http的方式下去做設定 sudo EXTERNAL_URL=\u0026#34;http://{{ internal_ip }}\u0026#34; yum install -y gitlab-ce reference Download and install GitLab | GitLab","title":"Centos 7 安裝gitlab"},{"content":"使用Rake task 將user_name改成要變更密碼的user name即可\nsudo gitlab-rake \u0026#34;gitlab:password:reset[user_name]\u0026#34; 使用Rails console 開啟rails console sudo gitlab-rails console 取得user 透過username user = User.find_by_username \u0026#39;user_name\u0026#39; 透過userID user = User.find(uid) 透過email user = User.find_by(email: \u0026#39;user@example.com\u0026#39;) 重置密碼 new_password = \u0026#39;my_new_password\u0026#39; user.password = new_password user.password_confirmation = new_password 儲存修改 user.save! 退出console exit ","permalink":"https://sz9751210.github.io/posts/gitlab-%E4%BF%AE%E6%94%B9%E5%AF%86%E7%A2%BC/","summary":"使用Rake task 將user_name改成要變更密碼的user name即可\nsudo gitlab-rake \u0026#34;gitlab:password:reset[user_name]\u0026#34; 使用Rails console 開啟rails console sudo gitlab-rails console 取得user 透過username user = User.find_by_username \u0026#39;user_name\u0026#39; 透過userID user = User.find(uid) 透過email user = User.find_by(email: \u0026#39;user@example.com\u0026#39;) 重置密碼 new_password = \u0026#39;my_new_password\u0026#39; user.password = new_password user.password_confirmation = new_password 儲存修改 user.save! 退出console exit ","title":"Gitlab 修改密碼"},{"content":"題目描述 將一個已經排序好的list中重複的數字刪去，並回傳list長度，必須以in-place的方式處理，不能使用額外的空間\n解題思路 使用兩個指針，一個紀錄都沒重複的次數(slow)，一個紀錄當前沒重複的數字(fast)，如果重複，則更新沒重複的數字\nPython class Solution: def removeDuplicates(self, nums: List[int]) -\u0026gt; int: n = len(nums) if n \u0026lt; 2: return n slow, fast = 1, 1 for fast in range(1,n): if nums[fast-1] != nums[fast]: nums[slow] = nums[fast] slow += 1 return slow Golang func removeDuplicates(nums []int) int { n := len(nums) if n \u0026lt; 2 { return n } slow, fast := 1, 1 for fast \u0026lt; n { if nums[fast-1] != nums[fast] { nums[slow] = nums[fast] slow++ } fast++ } return slow } ","permalink":"https://sz9751210.github.io/posts/leetcode-26/","summary":"題目描述 將一個已經排序好的list中重複的數字刪去，並回傳list長度，必須以in-place的方式處理，不能使用額外的空間\n解題思路 使用兩個指針，一個紀錄都沒重複的次數(slow)，一個紀錄當前沒重複的數字(fast)，如果重複，則更新沒重複的數字\nPython class Solution: def removeDuplicates(self, nums: List[int]) -\u0026gt; int: n = len(nums) if n \u0026lt; 2: return n slow, fast = 1, 1 for fast in range(1,n): if nums[fast-1] != nums[fast]: nums[slow] = nums[fast] slow += 1 return slow Golang func removeDuplicates(nums []int) int { n := len(nums) if n \u0026lt; 2 { return n } slow, fast := 1, 1 for fast \u0026lt; n { if nums[fast-1] !","title":"leetcode 26. Remove Duplicates from Sorted Array"},{"content":"題目描述 給一個長度固定的list，將裡面出現的0做複製，並將剩餘的元素往右移\n解題思路 使用單指針做遍歷，條件有兩個，都符合才做處理\n假如當前元素為0 考慮最後一個元素也為0要小於list長度 Python class Solution: def duplicateZeros(self, arr: List[int]) -\u0026gt; None: \u0026#34;\u0026#34;\u0026#34; Do not return anything, modify arr in-place instead. \u0026#34;\u0026#34;\u0026#34; i = 0 while i \u0026lt; len(arr): if arr[i] == 0 and i + 1 \u0026lt; len(arr): arr.insert(i+1, 0) arr.pop() i += 1 i += 1 Golang func duplicateZeros(arr []int) { for i := 0; i \u0026lt; len(arr); i++ { if arr[i] == 0 \u0026amp;\u0026amp; i+1 \u0026lt; len(arr) { arr = append(arr[:i+1], arr[i:len(arr)-1]...) i ++ } } } ","permalink":"https://sz9751210.github.io/posts/leetcode-1089/","summary":"題目描述 給一個長度固定的list，將裡面出現的0做複製，並將剩餘的元素往右移\n解題思路 使用單指針做遍歷，條件有兩個，都符合才做處理\n假如當前元素為0 考慮最後一個元素也為0要小於list長度 Python class Solution: def duplicateZeros(self, arr: List[int]) -\u0026gt; None: \u0026#34;\u0026#34;\u0026#34; Do not return anything, modify arr in-place instead. \u0026#34;\u0026#34;\u0026#34; i = 0 while i \u0026lt; len(arr): if arr[i] == 0 and i + 1 \u0026lt; len(arr): arr.insert(i+1, 0) arr.pop() i += 1 i += 1 Golang func duplicateZeros(arr []int) { for i := 0; i \u0026lt; len(arr); i++ { if arr[i] == 0 \u0026amp;\u0026amp; i+1 \u0026lt; len(arr) { arr = append(arr[:i+1], arr[i:len(arr)-1].","title":"leetcode 1089 - Duplicate Zeros"},{"content":"題目描述 給一個列表以及一個列表裡兩數相加起來的數，返回此兩數的列表位置\n解題思路 可用字典結構當作存取位置用，並用遍歷將相減後還沒有出現的數存進字典裡，之後如果有遍歷到字典裡的數即可立馬返回位置\n一樣使用雙指針，將list的index跟element分組做排序，因此新的list為由小到大，接著使用雙指針，一個指向頭一個指向尾，相加如果小於target則代表start太小，相加如果大於target代表end太大\nPython 原本想用兩個for去解決\nclass Solution: def twoSum(self, nums: List[int], target: int) -\u0026gt; List[int]: for i in range(len(nums)): left = nums[i+1:] for j in range(len(left)): if (nums[i] + left[j]) == target: return i, j+i+1 但提交後噴了time limit exceeded\nclass Solution: def twoSum(self, nums: List[int], target: int) -\u0026gt; List[int]: dict = {} for i in range(len(nums)): if target - nums[i] not in dict: dict[nums[i]] = i else: return [dict[target - nums[i]], i] class Solution: def twoSum(self, nums: List[int], target: int) -\u0026gt; List[int]: list_ele_idx = [(ele, idx) for idx, ele in enumerate(nums)] # 主要讓ele在前，使sort生效，因此前面會寫成(ele, idx)，讓ele可以排序 list_ele_idx.sort() start, end = 0, len(nums)-1 while(start \u0026lt; end): if list_ele_idx[start][0] + list_ele_idx[end][0] == target: return sorted([list_ele_idx[start][1], list_ele_idx[end][1]]) elif list_ele_idx[start][0] + list_ele_idx[end][0] \u0026lt; target: # need bigger start += 1 else: # nums[start] + nums[end] \u0026gt; target: # need smaller end -= 1 else: return [-1, -1] ","permalink":"https://sz9751210.github.io/posts/leetcode-01/","summary":"題目描述 給一個列表以及一個列表裡兩數相加起來的數，返回此兩數的列表位置\n解題思路 可用字典結構當作存取位置用，並用遍歷將相減後還沒有出現的數存進字典裡，之後如果有遍歷到字典裡的數即可立馬返回位置\n一樣使用雙指針，將list的index跟element分組做排序，因此新的list為由小到大，接著使用雙指針，一個指向頭一個指向尾，相加如果小於target則代表start太小，相加如果大於target代表end太大\nPython 原本想用兩個for去解決\nclass Solution: def twoSum(self, nums: List[int], target: int) -\u0026gt; List[int]: for i in range(len(nums)): left = nums[i+1:] for j in range(len(left)): if (nums[i] + left[j]) == target: return i, j+i+1 但提交後噴了time limit exceeded\nclass Solution: def twoSum(self, nums: List[int], target: int) -\u0026gt; List[int]: dict = {} for i in range(len(nums)): if target - nums[i] not in dict: dict[nums[i]] = i else: return [dict[target - nums[i]], i] class Solution: def twoSum(self, nums: List[int], target: int) -\u0026gt; List[int]: list_ele_idx = [(ele, idx) for idx, ele in enumerate(nums)] # 主要讓ele在前，使sort生效，因此前面會寫成(ele, idx)，讓ele可以排序 list_ele_idx.","title":"leetcode 01. two sum"},{"content":"題目描述 給定一個數組nums和一個值val，你需要原地移除所有數值等於val的元素，返回移除後數組的新長度。\n時間複雜度為O(1)，不用考慮移除後的數組順序\n解題思路 可先定義好一個指針，拿來加上長度，並用for判別是否為val，最後返回指針長度\n使用雙指針，快的指針去負責遍歷整個list，慢的指針去紀錄是否有遇到題目給的值，是的話就跳過，最後返回slow\nPython class Solution: def removeElement(self, nums: List[int], val: int) -\u0026gt; int: ptr = 0 for num in nums: if num != val: nums[ptr] = num ptr += 1 return ptr class Solution: def removeElement(self, nums: List[int], val: int) -\u0026gt; int: fast = slow = 0 while(fast \u0026lt; len(nums)): if(nums[fast] != val): nums[slow] = nums[fast] slow+=1 fast+=1 return slow Golang func removeElement(nums []int, val int) int { fast, slow := 0, 0 for fast \u0026lt; len(nums) { if nums[fast] != val { nums[slow] = nums[fast] slow++ } fast++ } return slow } ","permalink":"https://sz9751210.github.io/posts/leetcode-27/","summary":"題目描述 給定一個數組nums和一個值val，你需要原地移除所有數值等於val的元素，返回移除後數組的新長度。\n時間複雜度為O(1)，不用考慮移除後的數組順序\n解題思路 可先定義好一個指針，拿來加上長度，並用for判別是否為val，最後返回指針長度\n使用雙指針，快的指針去負責遍歷整個list，慢的指針去紀錄是否有遇到題目給的值，是的話就跳過，最後返回slow\nPython class Solution: def removeElement(self, nums: List[int], val: int) -\u0026gt; int: ptr = 0 for num in nums: if num != val: nums[ptr] = num ptr += 1 return ptr class Solution: def removeElement(self, nums: List[int], val: int) -\u0026gt; int: fast = slow = 0 while(fast \u0026lt; len(nums)): if(nums[fast] != val): nums[slow] = nums[fast] slow+=1 fast+=1 return slow Golang func removeElement(nums []int, val int) int { fast, slow := 0, 0 for fast \u0026lt; len(nums) { if nums[fast] !","title":"leetCode 27. Remove Element"},{"content":"👨‍💻簡介 last 用途：列出目前與過去登入系統的使用者相關資訊 語法 last [OPTIONS] [num,time,name,tty] 參數 參數 說明 -f file 指定登入的日誌檔案(預設是/var/log/wtmp) -num 指定last顯示幾行資訊 -n num 與-num相同 -t time[YYYYMMDDHHMMSS] 顯示指定時間的登入資訊 -R 不顯示主機名 -a 在最後一列顯示主機名 -d 將非本地登入的使用者ip轉換成主機名 -F 顯示所有的登入和登出時間和日期 -i 顯示ip地址而不是主機名 -o 讀取舊的日誌檔案 -w 顯示使用者名稱和域名 -x 顯示系統關機資訊和執行級別的變化資訊 欄位說明 last # output 1 2 3 4 5 alan pts/2 192.168.56.1 Mon Oct 25 21:37 still logged in reboot system boot 3.10.0-1160.42.2 Mon Oct 25 21:16 - 22:39 (01:22) alan pts/0 192.168.56.1 Sun Oct 24 23:18 - 05:47 (06:28) reboot system boot 3.10.0-1160.42.2 Sun Oct 24 23:15 - 22:39 (23:24) alan pts/2 192.168.56.1 Fri Oct 22 02:07 - 05:44 (03:37) 欄位 說明 登入用戶 顯示登錄用戶的姓名 登入終端 顯示用戶如何連接到系統，但如果是重啟進入，則是會顯示system boot 登入主機 顯示從哪連接到系統，欄位可為主機名或是IP位址(遠端)、空值(tty)、kernel版本(重啟)、應用程序(PID.windowID) 登入時間 顯示用戶登入的時間 登出時間 顯示用戶登出的時間，欄位可為時間戳(登出)、still running(開機)、still logged in(用戶登入中)、down(機器關機)、crash(系統崩潰) 基本操作 顯示最近登入的5筆資訊 last -5 or last -n 5 顯示用戶在某時段登入的資訊 last -t 20211026151111 root 顯示終端tty1的登入資訊 last 1 or last tty1 參考資料 Linux last Command | Baeldung on Linux Linux基礎命令—last | IT人 (iter01.com) ","permalink":"https://sz9751210.github.io/posts/linux-last/","summary":"👨‍💻簡介 last 用途：列出目前與過去登入系統的使用者相關資訊 語法 last [OPTIONS] [num,time,name,tty] 參數 參數 說明 -f file 指定登入的日誌檔案(預設是/var/log/wtmp) -num 指定last顯示幾行資訊 -n num 與-num相同 -t time[YYYYMMDDHHMMSS] 顯示指定時間的登入資訊 -R 不顯示主機名 -a 在最後一列顯示主機名 -d 將非本地登入的使用者ip轉換成主機名 -F 顯示所有的登入和登出時間和日期 -i 顯示ip地址而不是主機名 -o 讀取舊的日誌檔案 -w 顯示使用者名稱和域名 -x 顯示系統關機資訊和執行級別的變化資訊 欄位說明 last # output 1 2 3 4 5 alan pts/2 192.168.56.1 Mon Oct 25 21:37 still logged in reboot system boot 3.10.0-1160.42.2 Mon Oct 25 21:16 - 22:39 (01:22) alan pts/0 192.168.56.1 Sun Oct 24 23:18 - 05:47 (06:28) reboot system boot 3.","title":"Linux 列出登入資訊[last]"},{"content":"👨‍💻簡介 id 用途：顯示用戶的ID，以及所屬群組的ID。 語法 id [OPTIONS] userName 參數 參數 說明 -Z, \u0026ndash;context 顯示當前用戶的安全上下文 -g, \u0026ndash;group 顯示所屬群組ID -G, \u0026ndash;groups 顯示所有群組ID -n, \u0026ndash;name 顯示用戶 -r, \u0026ndash;real 顯示實際ID -u, \u0026ndash;user 顯示用戶ID 基本操作 顯示當前用戶訊息 id # output uid=1000(alan) gid=1000(alan) groups=1000(alan),996(vboxsf) context=unconfined_u:unconfined_r:unconfined_t:s0-s0:c0.c1023 顯示用戶群組id id -g # output 1000 顯示指定用戶訊息 id root ","permalink":"https://sz9751210.github.io/posts/linux-id/","summary":"👨‍💻簡介 id 用途：顯示用戶的ID，以及所屬群組的ID。 語法 id [OPTIONS] userName 參數 參數 說明 -Z, \u0026ndash;context 顯示當前用戶的安全上下文 -g, \u0026ndash;group 顯示所屬群組ID -G, \u0026ndash;groups 顯示所有群組ID -n, \u0026ndash;name 顯示用戶 -r, \u0026ndash;real 顯示實際ID -u, \u0026ndash;user 顯示用戶ID 基本操作 顯示當前用戶訊息 id # output uid=1000(alan) gid=1000(alan) groups=1000(alan),996(vboxsf) context=unconfined_u:unconfined_r:unconfined_t:s0-s0:c0.c1023 顯示用戶群組id id -g # output 1000 顯示指定用戶訊息 id root ","title":"Linux 顯示用戶資訊[id]"},{"content":"👨‍💻簡介 passwd 用途：修改使用者密碼 語法 passwd [OPTIONS] username 參數 參數 說明 -k, \u0026ndash;keep-tokens 保留未過期的驗證 token -d, \u0026ndash;delete 刪除 named 帳號的密碼 (只有 root 可執行) -l, \u0026ndash;lock 鎖住 named 帳號的密碼 (只有 root 可執行) -u, \u0026ndash;unlock 解開 named 帳號的密碼鎖定 (只有 root 可執行) -e, \u0026ndash;expire 讓 named 帳號的密碼過期 (只有 root 可執行) -f, \u0026ndash;force 強制作業 -x, \u0026ndash;maximum=DAYS 最大密碼有效期限 (只有 root 可執行) -n, \u0026ndash;minimum=DAYS 最小密碼有效期限 (只有 root 可執行) -w, \u0026ndash;warning=DAYS 用戶在密碼過期前收到警告的天數 (只有root可執行) -i, \u0026ndash;inactive=DAYS 帳號在密碼過期後即將被停用前的天數 (只有root可執行) -S, \u0026ndash;status 回報 named 帳號上的密碼狀態 (只有 root 可執行) \u0026ndash;stdin 由 stdin 讀取新的 token (只有 root 可執行) 基本操作 修改使用者密碼 passwd myuser 顯示使用者密碼狀態 passwd -S myuser # output myuser PS 2021-11-26 0 99999 7 -1 欄位 範例 帳號名稱 myuser 密碼狀態，狀態包含鎖定密碼(LK)、無密碼(NP)與可用密碼(PS) PS 上次修改密碼時間 2021-11-26 密碼最短使用期限，單位為天 0 密碼最長使用期限，單位為天 99999 密碼過期前警告期間，單位為天 7 密碼過期後可使用的期間，單位為天 -1 刪除使用者密碼 passwd -d myuser 讓密碼過期，強制使用者更新密碼 passwd -e myuser # 下次登入時，就會跳出通知說要更改密碼 You are required to change your password immediately (root enforced) WARNING: Your password has expired. You must change your password now and login again! Changing password for user myuser. Changing password for myuser. (current) UNIX password: 鎖定與解鎖使用者密碼 passwd -l myuser 此指令會使/etc/shadow的使用者密碼欄位前面多了!!\n該狀態下使用者無法變更帳號密碼\n要解除鎖定可用-u\npasswd -u myuser 設定密碼期限 # 至少五天才能改一次密碼 passwd -n 5 myuser # 密碼最多只能用30天 passwd -x 30 myuser # 快過期前7天送警告 passwd -w 7 myuser # 寬限期設定，超過5天將無法再登入 passwd -i 5 myuser 參考資料 Linux passwd命令 | 菜鸟教程 (runoob.com) Linux 的 passwd 指令範例教學 - G. T. Wang (gtwang.org) ","permalink":"https://sz9751210.github.io/posts/linux-passwd/","summary":"👨‍💻簡介 passwd 用途：修改使用者密碼 語法 passwd [OPTIONS] username 參數 參數 說明 -k, \u0026ndash;keep-tokens 保留未過期的驗證 token -d, \u0026ndash;delete 刪除 named 帳號的密碼 (只有 root 可執行) -l, \u0026ndash;lock 鎖住 named 帳號的密碼 (只有 root 可執行) -u, \u0026ndash;unlock 解開 named 帳號的密碼鎖定 (只有 root 可執行) -e, \u0026ndash;expire 讓 named 帳號的密碼過期 (只有 root 可執行) -f, \u0026ndash;force 強制作業 -x, \u0026ndash;maximum=DAYS 最大密碼有效期限 (只有 root 可執行) -n, \u0026ndash;minimum=DAYS 最小密碼有效期限 (只有 root 可執行) -w, \u0026ndash;warning=DAYS 用戶在密碼過期前收到警告的天數 (只有root可執行) -i, \u0026ndash;inactive=DAYS 帳號在密碼過期後即將被停用前的天數 (只有root可執行) -S, \u0026ndash;status 回報 named 帳號上的密碼狀態 (只有 root 可執行) \u0026ndash;stdin 由 stdin 讀取新的 token (只有 root 可執行) 基本操作 修改使用者密碼 passwd myuser 顯示使用者密碼狀態 passwd -S myuser # output myuser PS 2021-11-26 0 99999 7 -1 欄位 範例 帳號名稱 myuser 密碼狀態，狀態包含鎖定密碼(LK)、無密碼(NP)與可用密碼(PS) PS 上次修改密碼時間 2021-11-26 密碼最短使用期限，單位為天 0 密碼最長使用期限，單位為天 99999 密碼過期前警告期間，單位為天 7 密碼過期後可使用的期間，單位為天 -1 刪除使用者密碼 passwd -d myuser 讓密碼過期，強制使用者更新密碼 passwd -e myuser # 下次登入時，就會跳出通知說要更改密碼 You are required to change your password immediately (root enforced) WARNING: Your password has expired.","title":"Linux 修改密碼[passwd]"},{"content":"👨‍💻簡介 有時候修改掛載的config檔，無法即時更新，需要重啟pod才會生效，為了解決這個問題，k8s-reloader因此而誕生，透過觀察掛載的configmap或是secret的變化自動對掛載的物件做滾動更新。\n以下為在minikube環境下，透過掛載nginx-config檔並搭配reloader這個插件進行熱部署。\n🔗github-repo : stakater/Reloader: A Kubernetes controller to watch changes in ConfigMap and Secrets and do rolling upgrades on Pods with their associated Deployment, StatefulSet, DaemonSet and DeploymentConfig – [✩Star] if you\u0026rsquo;re using it! (github.com) 🔰基礎介紹 運作原理 Reloader偵測所有資源變化，對有變化的資源使用SHA1計算資源的哈西值 Reloader查看是否有設定相關的annotation，並查看有設定annotation資源的特殊環境變量 對有設定annotation的資源比對其哈希值，如果環境變量中哈希值不同，則更新環境變量，如果環境變量不存在，則創建一個 環境變量名稱 ConfigMap：STAKATER_{configmap_name}_CONFIGMAP ，比如 ConfigMap 的名稱為 foo，則生成的環境變量的名稱為：STAKATER_FOO_CONFIGMAP。 Secret：STAKATER_{secret_name}_SECRET ，比如 Secret 的名稱為 foo，則生成的環境變量的名稱為：STAKATER_FOO_SECRET。 環境變量的值 使用 SHA1 計算的 ConfigMap 或者 Secret 的哈希值。\n版本需求 k8s版本需 \u0026gt;= 1.9\n安裝方式 使用Manifests安裝 kubectl apply -f https://raw.githubusercontent.com/stakater/Reloader/master/deployments/kubernetes/reloader.yaml 使用Kustomize安裝 kubectl apply -k https://github.com/stakater/Reloader/deployments/kubernetes apiVersion: kustomize.config.k8s.io/v1beta1 kind: Kustomization bases: - https://github.com/stakater/Reloader/deployments/kubernetes namespace: reloader 使用Helm安裝 helm repo add stakater https://stakater.github.io/stakater-charts helm repo update helm install stakater/reloader # For helm3 add --generate-name flag or set the release name 預設情況下，reloader會偵測所有namespace的資源，如果要針對單一namespace可使用--set reloader.watchGlobally為false，以下範例為安裝在test namespace並只偵測test namespace底下的資源\nhelm install stakater/reloader --set reloader.watchGlobally=false --namespace test # For helm3 add --generate-name flag or set the release name 使用方式 自動偵測所有資源 設定reloader.stakater.com/auto: \u0026quot;true\u0026quot;\nkind: Deployment metadata: annotations: reloader.stakater.com/auto: \u0026#34;true\u0026#34; spec: template: metadata: 限制只偵測有設定annotations的資源 deploy設定reloader.stakater.com/search: \u0026quot;true\u0026quot;，configmap等資源設定reloader.stakater.com/match: \u0026quot;true\u0026quot;\nkind: Deployment metadata: annotations: reloader.stakater.com/search: \u0026#34;true\u0026#34; spec: template: --- kind: ConfigMap metadata: annotations: reloader.stakater.com/match: \u0026#34;true\u0026#34; data: key: value reloader.stakater.com/auto與reloader.stakater.com/search不能同時使用\n如果使用reloader.stakater.com/auto，則reloader.stakater.com/match不管有沒有設定都會被偵測\n只偵測特定資源 資源使用,做分隔\nConfigmap kind: Deployment metadata: annotations: configmap.reloader.stakater.com/reload: \u0026#34;foo-configmap\u0026#34; spec: template: metadata: Secret kind: Deployment metadata: annotations: secret.reloader.stakater.com/reload: \u0026#34;foo-secret,bar-secret,baz-secret\u0026#34; spec: template: metadata: 🎯setup 部署reloader kubectl apply -f https://raw.githubusercontent.com/stakater/Reloader/master/deployments/kubernetes/reloader.yaml 部署nginx服務\n建立以下檔案 apiVersion: v1 kind: ConfigMap metadata: name: nginx-map annotations: reloader.stakater.com/match: \u0026#34;true\u0026#34; data: test.conf: | server { listen 80; server_name abc.com; location / { root /usr/share/nginx/html ; index index.html index.htm; } } --- apiVersion: apps/v1 kind: Deployment metadata: name: nginx annotations: configmap.reloader.stakater.com/reload: \u0026#34;nginx-map\u0026#34; spec: replicas: 2 selector: matchLabels: service: http-server template: metadata: labels: service: http-server spec: containers: - name: nginx image: sz9751210/nginx-reloader:v1 imagePullPolicy: IfNotPresent ports: - containerPort: 80 volumeMounts: - mountPath: /etc/nginx/conf.d # mount nginx-conf volumn to /etc/nginx/conf.d readOnly: true name: deployment-nginx-conf volumes: - name: deployment-nginx-conf configMap: name: nginx-map # place ConfigMap `nginx-conf` on /etc/nginx --- apiVersion: v1 kind: Service metadata: name: nginx-service spec: selector: service: http-server ports: - port: 80 targetPort: 80 部署 kubectl apply -f k8s-reloader-demo.yaml 打開瀏覽器查看nginx\nminikube service nginx-service --url 預設應該會顯示default page\n這時候將configmap裡的index.html改成index.html1\n這時候刷新頁面就會看到顯示reload page了\nReference stakater/Reloader: A Kubernetes controller to watch changes in ConfigMap and Secrets and do rolling upgrades on Pods with their associated Deployment, StatefulSet, DaemonSet and DeploymentConfig\n【k8s】使用 Reloader 实现热部署\nConfigMap Reloader — Automatically reload new data from ConfigMap/Secret to deployments | by Navratan Lal Gupta | Linux Shots | Medium\n","permalink":"https://sz9751210.github.io/posts/k8s-reloader/","summary":"👨‍💻簡介 有時候修改掛載的config檔，無法即時更新，需要重啟pod才會生效，為了解決這個問題，k8s-reloader因此而誕生，透過觀察掛載的configmap或是secret的變化自動對掛載的物件做滾動更新。\n以下為在minikube環境下，透過掛載nginx-config檔並搭配reloader這個插件進行熱部署。\n🔗github-repo : stakater/Reloader: A Kubernetes controller to watch changes in ConfigMap and Secrets and do rolling upgrades on Pods with their associated Deployment, StatefulSet, DaemonSet and DeploymentConfig – [✩Star] if you\u0026rsquo;re using it! (github.com) 🔰基礎介紹 運作原理 Reloader偵測所有資源變化，對有變化的資源使用SHA1計算資源的哈西值 Reloader查看是否有設定相關的annotation，並查看有設定annotation資源的特殊環境變量 對有設定annotation的資源比對其哈希值，如果環境變量中哈希值不同，則更新環境變量，如果環境變量不存在，則創建一個 環境變量名稱 ConfigMap：STAKATER_{configmap_name}_CONFIGMAP ，比如 ConfigMap 的名稱為 foo，則生成的環境變量的名稱為：STAKATER_FOO_CONFIGMAP。 Secret：STAKATER_{secret_name}_SECRET ，比如 Secret 的名稱為 foo，則生成的環境變量的名稱為：STAKATER_FOO_SECRET。 環境變量的值 使用 SHA1 計算的 ConfigMap 或者 Secret 的哈希值。\n版本需求 k8s版本需 \u0026gt;= 1.9\n安裝方式 使用Manifests安裝 kubectl apply -f https://raw.","title":"k8s-reloader"},{"content":"👨‍💻簡介 timedatectl 用途：修改系統時間 語法 timedatectl [OPTIONS] command 參數 參數 說明 \u0026ndash;no-pager 不將程序的輸出內容管道(pipe)給分頁程序 \u0026ndash;no-ask-password 在執行特權操作時不向用戶索要密碼。 -H \u0026ndash;host=[USER@]HOST 操作指定的遠程主機 -M \u0026ndash;machine=CONTAINER 在本地容器內執行操作。 必須明確指定容器的名稱。 \u0026ndash;adjust-system-clock 當使用set-local-rtc命令時，若使用了此選項，則表示根據RTC時間來更新系統時鐘。若未使用此選項，則表示根據系統時鐘來更新RTC時間 指令 指令 說明 status 顯示系統時鐘與RTC的當前狀態， 包括時區設置與網絡時間同步服務的狀態。 set-time TIME 將系統時鐘設爲指定的時間， 並同時更新RTC時間。 [TIME] 是一個形如 \u0026ldquo;2012-10-30 18:17:16\u0026quot;的時間字符串。 set-timezone ZONE 設置系統時區，也就是更新 /etc/localtime 軟連接的指向。 可以用下面的 list-timezones命令列出所有可用時區。 如果RTC被設爲本地時間， 此命令還會同時更新RTC時間。 list-timezones 列出所有可用時區，每行一個。 列出的值可以用作前述 set-timezone 命令的參數。 set-local-rtc BOOL 設爲 \u0026ldquo;no\u0026rdquo; 表示在RTC中存儲UTC時間； 設爲 \u0026ldquo;yes\u0026rdquo; 表示在RTC中存儲本地時間。應該盡一切可能在RTC中存儲UTC時間 set-ntp BOOL 是否開啓網絡時間同步。 設爲 \u0026ldquo;yes\u0026rdquo; 則啓用並啓動 systemd-timesyncd.service 服務， 設爲\u0026quot;no\u0026rdquo; 則停止並停用它 基本操作 顯示當前系統時間 timedatectl or timedatectl status 開啟網路時間同步服務 timedatectl set-ntp true 設定日期與時間 # 改時間和日期 timedatectl set-time \u0026#34;2021-11-01 10:10:00\u0026#34; # 只改日期 timedatectl set-time \u0026#34;2021-11-01\u0026#34; timedatectl set-time 20211101 # 只改時間 timedatectl set-time \u0026#34;10:10:00\u0026#34; timedatectl set-time 10:10:00 檢查時區 timedatectl list-timezones # 根據地理位置查看時區 timedatectl list-timezones | grep \u0026#34;Asia/B.*\u0026#34; 設定時區 timedatectl set-timezone \u0026#34;Asia/Taipei\u0026#34; # 設定為世界協調時間(UTC) timedatectl set-timezone UTC 參考資料 Ubuntu Manpage: timedatectl - 控制系統的時間與日期 Linux 手動更改系統時間：date、hwclock 與 timedatectl 指令用法教學 - G. T. Wang (gtwang.org) Linux下使用timedatectl命令時間時區操作詳解_osc_02985929 - MdEditor (gushiciku.cn) 相關指令 date hwclock ","permalink":"https://sz9751210.github.io/posts/linux-timedatectl/","summary":"👨‍💻簡介 timedatectl 用途：修改系統時間 語法 timedatectl [OPTIONS] command 參數 參數 說明 \u0026ndash;no-pager 不將程序的輸出內容管道(pipe)給分頁程序 \u0026ndash;no-ask-password 在執行特權操作時不向用戶索要密碼。 -H \u0026ndash;host=[USER@]HOST 操作指定的遠程主機 -M \u0026ndash;machine=CONTAINER 在本地容器內執行操作。 必須明確指定容器的名稱。 \u0026ndash;adjust-system-clock 當使用set-local-rtc命令時，若使用了此選項，則表示根據RTC時間來更新系統時鐘。若未使用此選項，則表示根據系統時鐘來更新RTC時間 指令 指令 說明 status 顯示系統時鐘與RTC的當前狀態， 包括時區設置與網絡時間同步服務的狀態。 set-time TIME 將系統時鐘設爲指定的時間， 並同時更新RTC時間。 [TIME] 是一個形如 \u0026ldquo;2012-10-30 18:17:16\u0026quot;的時間字符串。 set-timezone ZONE 設置系統時區，也就是更新 /etc/localtime 軟連接的指向。 可以用下面的 list-timezones命令列出所有可用時區。 如果RTC被設爲本地時間， 此命令還會同時更新RTC時間。 list-timezones 列出所有可用時區，每行一個。 列出的值可以用作前述 set-timezone 命令的參數。 set-local-rtc BOOL 設爲 \u0026ldquo;no\u0026rdquo; 表示在RTC中存儲UTC時間； 設爲 \u0026ldquo;yes\u0026rdquo; 表示在RTC中存儲本地時間。應該盡一切可能在RTC中存儲UTC時間 set-ntp BOOL 是否開啓網絡時間同步。 設爲 \u0026ldquo;yes\u0026rdquo; 則啓用並啓動 systemd-timesyncd.service 服務， 設爲\u0026quot;no\u0026rdquo; 則停止並停用它 基本操作 顯示當前系統時間 timedatectl or timedatectl status 開啟網路時間同步服務 timedatectl set-ntp true 設定日期與時間 # 改時間和日期 timedatectl set-time \u0026#34;2021-11-01 10:10:00\u0026#34; # 只改日期 timedatectl set-time \u0026#34;2021-11-01\u0026#34; timedatectl set-time 20211101 # 只改時間 timedatectl set-time \u0026#34;10:10:00\u0026#34; timedatectl set-time 10:10:00 檢查時區 timedatectl list-timezones # 根據地理位置查看時區 timedatectl list-timezones | grep \u0026#34;Asia/B.","title":"Linux 修改時間[timedatectl]"},{"content":"👨‍💻簡介 sed(stream editor) 用途：用於處理文件，字串取代、複製、刪除等功能，進行處理時並不會改變當前的檔案，而是將處理過程存放在[模式空間]的緩衝區，結束目前的指令後輸出，接著再處理下一個指令直到結束 語法 sed [OPTIONS] script or inputfile 參數(常用) 參數 說明 -n, \u0026ndash;quiet, \u0026ndash;silent 沈默模式 -e script, \u0026ndash;expression=script 直接在命令模式設定好script來進行編輯 -f script檔案, \u0026ndash;file=script檔案 使用指定的script檔案來進行編輯 -i 修改檔案，常用於自動化腳本 動作 說明 a 新增，在指定的行數的「下一行」插入字串。未指定行數的話則是在「每一行」之後插入字串 c 取代，替換指定行數為預替換的字串 d 刪除，刪除指定的行。常與-i選項搭配，用來修改檔案時移除不需要的行 i 插入，與a相同，差別在於a指令是在指定行數之後插入，i是在指定行數之前插入 p 列印，通常搭配-n選項做使用，只列印出受影響的行數 s 取代，支持正則表達式，用來取代字串 flags 說明 [0-9] 數字表示只搜尋或者取代第 N 個數字所指示的那個樣板字串 g 全部取代 I 忽略大小寫 w 把符合的結果寫入檔案。和加了 -n 選項搭配 p 旗標的結果一樣。此旗標如果有和其它旗標搭配使用，必須放在最後面 基本操作 參數 搭配文件sed.txt\nI have a pen, I have an apple Ah Apple pen I have a pen, I have pineapple Ah Pineapple pen Apple pen Pineapple pen Ah Pen Pie Pineapple Apple Pen Pen Pie Pineapple Apple Pen 使用-n沈默模式 # 使用s取代每一行第一次出現的have修改成had sed -n \u0026#39;s/have/had/1p\u0026#39; sed.txt # 透過沈默模式修改文件，默認不會印出東西，需搭配p則會顯示有修改的行 使用-e設定規則 # 把檔案中每行第一次出現的的pen換成pencil並存到sed_output.txt，-e為默認選項，可加可不加 sed -e \u0026#39;s/pen/pencil/\u0026#39; sed.txt \u0026gt; sed_output.txt # 多條件方式，有-e不需要分號分隔，無-e則需要做分隔 sed -e \u0026#39;s/pen/pencil/\u0026#39; -e \u0026#39;s/have/had/\u0026#39; sed.txt sed \u0026#39;s/pen/pencil/; s/have/had/\u0026#39; sed.txt 使用-f指定script檔案進行修改 假設有個script檔案sed_command.txt如下\ns/pen/pencil/ s/have/had/ # 將每一行第一次出現的pen以及have做替換 sed -f sed_command.txt sed.txt 使用-i直接修改檔案 sed -i \u0026#39;s/pen/pencil/\u0026#39; sed.txt 動作 使用a新增字串 # 在第一行之後新增字串 sed \u0026#39;1a I have both\u0026#39; sed.txt # 多行新增，在第一行到第四行這四行的後面都新增字串 sed \u0026#39;1,4a I have both\u0026#39; sed.txt 使用c做字串替換 # 取代第二行，改為I have both sed \u0026#39;2c I have both\u0026#39; sed.txt # 多行取代，將1到5行壓縮為一行並改為字串 sed \u0026#39;1,5c I have both\u0026#39; sed.txt 使用d進行刪除指定行或字串行 # 刪除第一行 sed 1d sed.txt # 刪除一到五行 sed 1,5d sed.txt # 刪除pen出現的行 sed \u0026#39;/pen/d\u0026#39; sed.txt 使用i進行插入 # 在第一行之前插入字串 sed \u0026#39;1i I have both\u0026#39; sed.txt # 在第一到第三行的每行之前插入字串 sed \u0026#39;1,3i I have both\u0026#39; sed.txt 使用p進行列印出影響行，通常配合-n選項搭配使用 # 將have取代為had並列印出來 sed -n \u0026#39;s/have/had/1p\u0026#39; sed.txt 使用s做字串取代 語法格式\ns/regexp/replacement/[flags] 參考資料 sed, a stream editor (gnu.org) Linux sed 命令 | 菜鸟教程 (runoob.com) 在 Linux 命令列中轉換大小寫 | IT人 (iter01.com) Linux 指令 SED 用法教學、取代範例、詳解 - TerryL Linux sed 字串取代用法與範例 | ShengYu Talk (shengyu7697.github.io) ","permalink":"https://sz9751210.github.io/posts/linux-sed/","summary":"👨‍💻簡介 sed(stream editor) 用途：用於處理文件，字串取代、複製、刪除等功能，進行處理時並不會改變當前的檔案，而是將處理過程存放在[模式空間]的緩衝區，結束目前的指令後輸出，接著再處理下一個指令直到結束 語法 sed [OPTIONS] script or inputfile 參數(常用) 參數 說明 -n, \u0026ndash;quiet, \u0026ndash;silent 沈默模式 -e script, \u0026ndash;expression=script 直接在命令模式設定好script來進行編輯 -f script檔案, \u0026ndash;file=script檔案 使用指定的script檔案來進行編輯 -i 修改檔案，常用於自動化腳本 動作 說明 a 新增，在指定的行數的「下一行」插入字串。未指定行數的話則是在「每一行」之後插入字串 c 取代，替換指定行數為預替換的字串 d 刪除，刪除指定的行。常與-i選項搭配，用來修改檔案時移除不需要的行 i 插入，與a相同，差別在於a指令是在指定行數之後插入，i是在指定行數之前插入 p 列印，通常搭配-n選項做使用，只列印出受影響的行數 s 取代，支持正則表達式，用來取代字串 flags 說明 [0-9] 數字表示只搜尋或者取代第 N 個數字所指示的那個樣板字串 g 全部取代 I 忽略大小寫 w 把符合的結果寫入檔案。和加了 -n 選項搭配 p 旗標的結果一樣。此旗標如果有和其它旗標搭配使用，必須放在最後面 基本操作 參數 搭配文件sed.txt\nI have a pen, I have an apple Ah Apple pen I have a pen, I have pineapple Ah Pineapple pen Apple pen Pineapple pen Ah Pen Pie Pineapple Apple Pen Pen Pie Pineapple Apple Pen 使用-n沈默模式 # 使用s取代每一行第一次出現的have修改成had sed -n \u0026#39;s/have/had/1p\u0026#39; sed.","title":"Linux 修改字串[sed]"},{"content":"👨‍💻簡介 grep 用途：查找文件內符合條件的字符串 語法 grep [-abcEFGhHilLnqrsvVwxy][-A\u0026lt;顯示行數\u0026gt;][-B\u0026lt;顯示列數\u0026gt;][-C\u0026lt;顯示列數\u0026gt;][-d\u0026lt;進行動作\u0026gt;][-e\u0026lt;範本樣式\u0026gt;][-f\u0026lt;範本文件\u0026gt;][--help][範本樣式][文件或目錄...] 參數 正規表示式選項 說明 -E, \u0026ndash;extended-regexp 使用擴展正則表達式 -F, \u0026ndash;fixed-strings 將樣式視為固定字符串的列表 -G, \u0026ndash;basic-regexp 將樣式視為普通的表示法來使用 -P, \u0026ndash;perl-regexp 將樣式視為perl的表示法來使用 -e, \u0026ndash;regexp=PATTERN 指定字符串做為查找文件內容的樣式 -f, \u0026ndash;file=FILE 指定規則文件，其內容含有一個或多個規則樣式，讓grep查找符合規則條件的文件內容，格式為每行一個規則樣式 -i, \u0026ndash;ignore-case 忽略大小寫的差異 -w, \u0026ndash;word-regexp 只匹配整個單詞，而不是字符串的一部分 -x, \u0026ndash;line-regexp 只顯示全列符合的列 -z, \u0026ndash;null-data 設定資料列結尾為空白位元組，非換列符號 -s, \u0026ndash;no-messages 不顯示不存在或無匹配文本的錯誤信息 -v, \u0026ndash;invert-match 將匹配的資料排除 參數 說明 -m, \u0026ndash;max-count=NUM 在達到 NUM 符合項目後停止 -b, \u0026ndash;byte-offset 在顯示符合樣式的那一行之前，標示出該行第一個字符的編號 -n, \u0026ndash;line-number 標示匹配文字的行號 \u0026ndash;line-buffered 輸出每列後清除輸出 -H, \u0026ndash;with-filename 印出每個符合項目的檔名 -h, \u0026ndash;no-filename 查詢多文件時不顯示文件名 \u0026ndash;label=LABEL 以 LABEL 作標準輸入的檔名前綴 -o, \u0026ndash;only-matching 只顯示每列中符合 PATTERN 的部分 -q, \u0026ndash;quiet, \u0026ndash;silent 不顯示任何信息 \u0026ndash;binary-files=TYPE 設定二進制檔案為 TYPE 的檔案;TYPE 為 \u0026ldquo;binary\u0026rdquo;、\u0026ldquo;text\u0026rdquo; 或 \u0026ldquo;without-match\u0026rdquo; -a, \u0026ndash;text 不要忽略二進制的數據 -I 不匹配二進制的東西 -d, \u0026ndash;directories=ACTION 目錄操作的動作，讀取、遞歸、跳過 -D, \u0026ndash;devices=ACTION 設置對設備的動作，FIFO和管道的操作，動作有，讀取、跳過 -r, \u0026ndash;recursive 在指定目錄與其子目錄下所有的檔案中，搜尋指定的關鍵字 -R, \u0026ndash;dereference-recursive 與-r相同，但遵循軟連結 \u0026ndash;include=FILE_PATTERN 從特定的檔案中尋找關鍵字 \u0026ndash;exclude=FILE_PATTERN 跳過匹配FILE_PATTERN 的文件和目錄 \u0026ndash;exclude-from=FILE 跳過所有除FILE 以外的文件 \u0026ndash;exclude-dir=PATTERN 跳過匹配PATTERN 的目錄 -L, \u0026ndash;files-without-match 列出不匹配的文件名 -l, \u0026ndash;files-with-matches 只列出匹配的文件名 -c, \u0026ndash;count 只輸出匹配行的計數 -Z, \u0026ndash;null 在搜尋的字串後面印出空字符 內容控制 說明 -B, \u0026ndash;before-context=NUM 顯示前幾行 -A, \u0026ndash;after-context=NUM 顯示後幾行 -C, \u0026ndash;context=NUM, -NUM 顯示前後各幾行 \u0026ndash;group-separator=SEP 使用A、-B或-C時，在組之間打印SEP而不是\u0026ndash;線 \u0026ndash;no-group-separator 使用A、-B或-C時，在組之間不打印seperator \u0026ndash;color[=WHEN],\u0026ndash;colour[=WHEN] 使用顏色標示的方式，將成功匹配的部分文字標示出來，方便使用者閱讀。顏色標示功能可以透過 --color=never、--color=always、--color=auto 這幾種參數來關閉、開啟或設為自動 -U, \u0026ndash;binary 使用標誌高亮匹配字串 -u, \u0026ndash;unix-byte-offsets 使用標誌高亮匹配字串 基本操作 指定文件查詢關鍵字 # 在file這個文件裡尋找test關鍵字 grep test file 透過匹配方式搜尋 # 在/etc/目錄下所有.conf檔搜尋linux關鍵字 grep linux /etc/*.conf 不分大小寫搜尋 # 在當前目錄底下搜尋linux關鍵字 grep -i linux . 反向匹配 # 在當前目錄下，顯示不包含linux的行 grep -v linux . 顯示行號 grep -n linux . 遞迴搜尋檔案 # 在當前目錄及其子目錄下，搜尋linux關鍵字 grep -r linux . # 在當前目錄及其子目錄下，並且檔名為log結尾的文件，搜尋linux關鍵字 grep -r --include=\u0026#34;*.log\u0026#34; linux . 不顯示錯誤訊息 grep linux . 2\u0026gt;/dev/null 顯示前後幾行 # 多顯示後一行 grep -A 1 linux . # 多顯示前一行 grep -B 1 linux . # 多顯示前後各一行 grep -C 1 linux . 實用範例 # 依照時間排序並計算哪個時間log數量最多 grep -oP \u0026#39;2021:[0-2][0-9]:[0-5][0-9]\u0026#39;| sort | uniq -c 參考資料 grep linux 命令 在线中文手册 (51yip.com) grep(1) - Linux manual page (man7.org) Linux 匹配文字 grep 指令用法教學與範例 - G. T. Wang (gtwang.org) ","permalink":"https://sz9751210.github.io/posts/linux-grep/","summary":"👨‍💻簡介 grep 用途：查找文件內符合條件的字符串 語法 grep [-abcEFGhHilLnqrsvVwxy][-A\u0026lt;顯示行數\u0026gt;][-B\u0026lt;顯示列數\u0026gt;][-C\u0026lt;顯示列數\u0026gt;][-d\u0026lt;進行動作\u0026gt;][-e\u0026lt;範本樣式\u0026gt;][-f\u0026lt;範本文件\u0026gt;][--help][範本樣式][文件或目錄...] 參數 正規表示式選項 說明 -E, \u0026ndash;extended-regexp 使用擴展正則表達式 -F, \u0026ndash;fixed-strings 將樣式視為固定字符串的列表 -G, \u0026ndash;basic-regexp 將樣式視為普通的表示法來使用 -P, \u0026ndash;perl-regexp 將樣式視為perl的表示法來使用 -e, \u0026ndash;regexp=PATTERN 指定字符串做為查找文件內容的樣式 -f, \u0026ndash;file=FILE 指定規則文件，其內容含有一個或多個規則樣式，讓grep查找符合規則條件的文件內容，格式為每行一個規則樣式 -i, \u0026ndash;ignore-case 忽略大小寫的差異 -w, \u0026ndash;word-regexp 只匹配整個單詞，而不是字符串的一部分 -x, \u0026ndash;line-regexp 只顯示全列符合的列 -z, \u0026ndash;null-data 設定資料列結尾為空白位元組，非換列符號 -s, \u0026ndash;no-messages 不顯示不存在或無匹配文本的錯誤信息 -v, \u0026ndash;invert-match 將匹配的資料排除 參數 說明 -m, \u0026ndash;max-count=NUM 在達到 NUM 符合項目後停止 -b, \u0026ndash;byte-offset 在顯示符合樣式的那一行之前，標示出該行第一個字符的編號 -n, \u0026ndash;line-number 標示匹配文字的行號 \u0026ndash;line-buffered 輸出每列後清除輸出 -H, \u0026ndash;with-filename 印出每個符合項目的檔名 -h, \u0026ndash;no-filename 查詢多文件時不顯示文件名 \u0026ndash;label=LABEL 以 LABEL 作標準輸入的檔名前綴 -o, \u0026ndash;only-matching 只顯示每列中符合 PATTERN 的部分 -q, \u0026ndash;quiet, \u0026ndash;silent 不顯示任何信息 \u0026ndash;binary-files=TYPE 設定二進制檔案為 TYPE 的檔案;TYPE 為 \u0026ldquo;binary\u0026rdquo;、\u0026ldquo;text\u0026rdquo; 或 \u0026ldquo;without-match\u0026rdquo; -a, \u0026ndash;text 不要忽略二進制的數據 -I 不匹配二進制的東西 -d, \u0026ndash;directories=ACTION 目錄操作的動作，讀取、遞歸、跳過 -D, \u0026ndash;devices=ACTION 設置對設備的動作，FIFO和管道的操作，動作有，讀取、跳過 -r, \u0026ndash;recursive 在指定目錄與其子目錄下所有的檔案中，搜尋指定的關鍵字 -R, \u0026ndash;dereference-recursive 與-r相同，但遵循軟連結 \u0026ndash;include=FILE_PATTERN 從特定的檔案中尋找關鍵字 \u0026ndash;exclude=FILE_PATTERN 跳過匹配FILE_PATTERN 的文件和目錄 \u0026ndash;exclude-from=FILE 跳過所有除FILE 以外的文件 \u0026ndash;exclude-dir=PATTERN 跳過匹配PATTERN 的目錄 -L, \u0026ndash;files-without-match 列出不匹配的文件名 -l, \u0026ndash;files-with-matches 只列出匹配的文件名 -c, \u0026ndash;count 只輸出匹配行的計數 -Z, \u0026ndash;null 在搜尋的字串後面印出空字符 內容控制 說明 -B, \u0026ndash;before-context=NUM 顯示前幾行 -A, \u0026ndash;after-context=NUM 顯示後幾行 -C, \u0026ndash;context=NUM, -NUM 顯示前後各幾行 \u0026ndash;group-separator=SEP 使用A、-B或-C時，在組之間打印SEP而不是\u0026ndash;線 \u0026ndash;no-group-separator 使用A、-B或-C時，在組之間不打印seperator \u0026ndash;color[=WHEN],\u0026ndash;colour[=WHEN] 使用顏色標示的方式，將成功匹配的部分文字標示出來，方便使用者閱讀。顏色標示功能可以透過 --color=never、--color=always、--color=auto 這幾種參數來關閉、開啟或設為自動 -U, \u0026ndash;binary 使用標誌高亮匹配字串 -u, \u0026ndash;unix-byte-offsets 使用標誌高亮匹配字串 基本操作 指定文件查詢關鍵字 # 在file這個文件裡尋找test關鍵字 grep test file 透過匹配方式搜尋 # 在/etc/目錄下所有.","title":"Linux 篩選字串[grep]"},{"content":"👨‍💻簡介 rsync 用途：用來複製與備份檔案的工具，它可以處理本機或遠端的檔案同步工作 語法 rsync [OPTIONS] src [dest/user@host:dest] 參數 參數 說明 -v, \u0026ndash;verbose verbose 模式，輸出比較詳細的訊息 -r, \u0026ndash;recursive 遞迴（recursive）備份所有子目錄下的目錄與檔案 -a, \u0026ndash;archive 封裝備份模式，相當於 -rlptgoD，遞迴備份所有子目錄下的目錄與檔案，保留連結檔、檔案的擁有者、群組、權限以及時間戳記 -z, \u0026ndash;compress 啟用壓縮，可減少網路傳輸資料量 -h, \u0026ndash;human-readable 將數字以比較容易閱讀的格式輸出 -q, –quiet 與 -v 相反，安靜模式，略過正常資訊，僅顯示錯誤訊息 -l, –links 複製連結而不是連結內容 -g, –group 保留檔案的原始群組狀態(權限不足則無法繼承) -o, –owner 保留檔案的原始擁有者(權限不足則無法繼承) -t,–times 保留檔案的原始時間參數 -e 使用的通道協定，例如使用 ssh 通道，則 -e ssh -u, \u0026ndash;update 在備份時會略過所有已經存在於目的端，且文件時間比要備份的檔案為新的檔案 -p, \u0026ndash;perms 表示要保留檔案的權限資訊 -D 表示要保留設備檔案資訊 \u0026ndash;delete 刪除來源端已經不存在但在目的端存在的檔案 \u0026ndash;force 當目的端的目錄被覆蓋時，就強制先刪除該目錄 \u0026ndash;bwlimit=RATE 限制資料傳輸速度上限 \u0026ndash;progress 即時顯示傳輸進度 \u0026ndash;exclude=PATTERN 排除符合匹配的檔案 \u0026ndash;include=PATTERN 只備份符合匹配的檔案 \u0026ndash;min-size=SIZE 指定備份檔案的最小值 \u0026ndash;max-size=SIZE 指定備份檔案的最大值 \u0026ndash;remove-source-files 自動刪除來源檔案 -n, \u0026ndash;dry-run debug模式，測試rsync餐數 \u0026ndash;existing 只更新既有的檔案，排除新增的檔案 -i, \u0026ndash;itemize-changes 查看個別檔案的變動資訊 基本操作 複製本地端檔案或目錄 rsync -avh mylog.log /local/path/ rsync -avh /mypath /home/alan/ 本地備份至遠端，將本地myfile.gz備份到遠端/remote/path/目錄下 rsync -avzh ./myfile.gz host@ip:/remote/path/ 遠端備份至本地 rsync -avzh host@ip:/remote/path/myfile.gz /local/path 限制網速 rsync -avzh --bwlimit=100k host@ip:/remote/path/myfile.gz /local/path 顯示傳輸進度 rsync -avzh --progress host@ip:/remote/path/myfile.gz /local/path 同步刪除目的端檔案 rsync -avzh --delete host@ip:/remote/path/myfile.gz /local/path 備份特定檔案 # 排除掉結尾為.txt的檔案 rsync -avh --exclude \u0026#39;*.txt\u0026#39; src/path dest/path # 只備份結尾為.txt的檔案 rsync -avh --include \u0026#39;*.txt\u0026#39; src/path dest/path 限制檔案大小 # 只備份1mb以上的檔案 rsync -avh --min-size=1m src/path dest/path # 只備份最大1k的檔案 rsync -avh --max-size=1k src/path dest/path # 只備份1k以上1mb以下的檔案 rsync -avh --min-size=1k --max-size=1m src/path dest/path 自動刪除來源檔案 # 將src/path的檔案備份到dest/path後清空，相當於mv的效果 rsync -avh --remove-source-files src/path dest/path 10, 測試rsync參數\nrsync -avh --dry-run src/path dest/path 搭配crontab做定期備份 # m h dom mon dow command 0 5 * * 1 rsync -a /path/to/folder /path/to/backup/ 只更新已存在的檔案 rsync -avh --existing src/path dest/path 參考資料 Rsync Command in Linux with Examples | Linuxize Linux 使用 rsync 遠端檔案同步與備份工具教學與範例 - G. T. Wang (gtwang.org) Linux下如何使用Rsync備份伺服器重要資料 | IT人 (iter01.com) 相關指令 scp ","permalink":"https://sz9751210.github.io/posts/linux-rsync/","summary":"👨‍💻簡介 rsync 用途：用來複製與備份檔案的工具，它可以處理本機或遠端的檔案同步工作 語法 rsync [OPTIONS] src [dest/user@host:dest] 參數 參數 說明 -v, \u0026ndash;verbose verbose 模式，輸出比較詳細的訊息 -r, \u0026ndash;recursive 遞迴（recursive）備份所有子目錄下的目錄與檔案 -a, \u0026ndash;archive 封裝備份模式，相當於 -rlptgoD，遞迴備份所有子目錄下的目錄與檔案，保留連結檔、檔案的擁有者、群組、權限以及時間戳記 -z, \u0026ndash;compress 啟用壓縮，可減少網路傳輸資料量 -h, \u0026ndash;human-readable 將數字以比較容易閱讀的格式輸出 -q, –quiet 與 -v 相反，安靜模式，略過正常資訊，僅顯示錯誤訊息 -l, –links 複製連結而不是連結內容 -g, –group 保留檔案的原始群組狀態(權限不足則無法繼承) -o, –owner 保留檔案的原始擁有者(權限不足則無法繼承) -t,–times 保留檔案的原始時間參數 -e 使用的通道協定，例如使用 ssh 通道，則 -e ssh -u, \u0026ndash;update 在備份時會略過所有已經存在於目的端，且文件時間比要備份的檔案為新的檔案 -p, \u0026ndash;perms 表示要保留檔案的權限資訊 -D 表示要保留設備檔案資訊 \u0026ndash;delete 刪除來源端已經不存在但在目的端存在的檔案 \u0026ndash;force 當目的端的目錄被覆蓋時，就強制先刪除該目錄 \u0026ndash;bwlimit=RATE 限制資料傳輸速度上限 \u0026ndash;progress 即時顯示傳輸進度 \u0026ndash;exclude=PATTERN 排除符合匹配的檔案 \u0026ndash;include=PATTERN 只備份符合匹配的檔案 \u0026ndash;min-size=SIZE 指定備份檔案的最小值 \u0026ndash;max-size=SIZE 指定備份檔案的最大值 \u0026ndash;remove-source-files 自動刪除來源檔案 -n, \u0026ndash;dry-run debug模式，測試rsync餐數 \u0026ndash;existing 只更新既有的檔案，排除新增的檔案 -i, \u0026ndash;itemize-changes 查看個別檔案的變動資訊 基本操作 複製本地端檔案或目錄 rsync -avh mylog.","title":"Linux 同步檔案[rsync]"},{"content":"👨‍💻簡介 find 用途：在目錄中找尋文件 語法 find path [OPTIONS] 參數(常用) 參數 說明 -mount, -xdev 只檢查和指定目錄在同一個文件系統下的文件，避免列出其它文件系統中的文件 -amin n 指定檔案的最後存取時間，單位為分鐘，在過去n分鐘內被存取過 -anewer file 比文件file更晚被存取過的文件 -atime n 指定檔案的最後存取時間（access time），單位為天 -cmin n 指定檔案狀態相關資訊最後修改的時間，單位為分鐘 -cnewer file 比文件file更新的文件 -ctime n 指定檔案狀態相關資訊最後修改的時間（status time），單位為天 -mtime n 指定檔案的最後修改時間（modification time），單位為天 -mmin n 指定檔案的最後修改時間，單位為分鐘 -empty 搜尋空檔案 -ipath p, -path p 路徑名稱符合 p 的文件，ipath 會忽略大小寫 -name name, -iname name 文件名稱符合 name 的文件。 iname 會忽略大小寫 -size n 指定檔案的大小 -type c 指定檔案的類型 -perm 指定檔案的權限 -user 指定檔案擁有者 -group 指定檔案的群組 -exec 對使用find的搜尋結果執行特定指令 基本操作 指定檔名搜尋 # 搜尋在當前目錄底下，檔名為file.txt的檔案 find . -name file.txt # 透過正則搜尋符合的匹配txt檔案 find . -name \u0026#34;*.txt\u0026#34; # 使用絕對路徑不分大小寫搜尋檔案 find /home -iname file.txt 指定檔案修改與存取時間搜尋 # 搜尋當前目錄下過去5天內檔案狀態有被存取過的檔案 find . -atime -5 # 搜尋當前目錄下過去5分鐘檔案狀態有被修改過的檔案 find . -cmin -5 # 搜尋當前目錄下，上次修改時間是在5天以上、10天以下的檔案 find . -mtime +5 -mtime -10 atime（Accesstime）指的是文件最後一次被訪問的時間； mtime（Modifytime）指的是文件內容被修改的時間，但不包括權限的修改，比如用vim編輯器修改內容； ctime（Changetime）指的是文件的權限、擁有者、所屬組及鏈接數發上改變的時間。 指定檔案類型搜尋 # 搜尋當前目錄及子目錄下，類型為文件 find . -type f # 搜尋當前目錄及子目錄下，類型為目錄 find . -type d b: 區塊裝置文件 c: 字型裝置文件 d: 目錄 p: 具名的pipe(FIFO) f: 一般的檔案 l: 連結檔，如果與 -L 或 -follow 參數同時使用時，就只會搜尋到有問題的連結檔，如果想要與 -L 同時使用，請改用 -xtype s: socket 檔案 指定檔案權限搜尋 # 搜尋當前目錄下權限為777的檔案 find . -type f -perm 777 # 搜尋當前目錄下權限不是777的檔案 find . -type f ! -perm 777 # 搜尋當前目錄下權限為644而且有SGID的檔案 find . -type f -perm 2644 # 搜尋當前目錄下，user只有read的權限的檔案 find . -type f -perm /u=r 如果不帶有任何前綴，則只有完全符合的檔案才會成功匹配 如果帶有-，則代表同時符合，任何一類用戶（ugo）的權限中的每一位（rwx）都要同時符合mode所表示的條件，9位權限之間存在“與”關係。 如果帶有/，則代表至少符合，任何一類用戶（ugo）的權限中的任何一位（rwx）符合mode所表示的條件即可，9位權限之間存在“或”關係。 指定檔案屬性搜尋 # 搜尋當前目錄下，user為root的檔案 find . -user root # 搜尋當前目錄下，group為root的檔案 find . -group root 指定檔案大小搜尋 # 搜尋當前目錄下，檔案大小剛好是50MB的檔案 find . -size 50M # 搜尋當前目錄下，檔案大小介於50MB到100MB之間的檔案 find . -size +50M -size -100M # 搜尋當前目錄下，大於100MB的檔案並將其刪除 find . -size +100M -exec rm -rf {} \\; 指定搜尋空檔案與隱藏檔案 # 搜尋當前目錄下的空目錄 find . -type d -empty # 搜尋當前目錄下的隱藏檔案 find . -type f -name \u0026#34;.*\u0026#34; 實用範例 # 搜尋當前目錄下，檔案大小在10MB以上的log檔，並將其刪除 find . -type f -name *.log -size +10M -exec rm {} \\; # 搜尋當前目錄下所有的php檔案，並找尋有關鍵字ok以及匹配處的以下5行 find ./ -name \\*.php -exec grep -wnHA5 ok {} \\; # 搜尋當前目錄下所有檔案，並找出有network關鍵字的檔案 find . -name \u0026#34;*\u0026#34; | xargs grep \u0026#34;network\u0026#34; 在 -exec 前面是 find 指令找出想要的檔案，在 -exec 後面的 command 是要執行的指令, 而 { } 包著的是找到的檔案或目錄，後面需要加上 ; 完結。\n參考資料 man find SGID Unix/Linux 的 find 指令使用教學、技巧與範例整理 根据文件属性或权限进行find查找 使用 Linux find 尋找檔案/尋找資料夾 Linux find 指令的 exec 參數 ","permalink":"https://sz9751210.github.io/posts/linux-find/","summary":"👨‍💻簡介 find 用途：在目錄中找尋文件 語法 find path [OPTIONS] 參數(常用) 參數 說明 -mount, -xdev 只檢查和指定目錄在同一個文件系統下的文件，避免列出其它文件系統中的文件 -amin n 指定檔案的最後存取時間，單位為分鐘，在過去n分鐘內被存取過 -anewer file 比文件file更晚被存取過的文件 -atime n 指定檔案的最後存取時間（access time），單位為天 -cmin n 指定檔案狀態相關資訊最後修改的時間，單位為分鐘 -cnewer file 比文件file更新的文件 -ctime n 指定檔案狀態相關資訊最後修改的時間（status time），單位為天 -mtime n 指定檔案的最後修改時間（modification time），單位為天 -mmin n 指定檔案的最後修改時間，單位為分鐘 -empty 搜尋空檔案 -ipath p, -path p 路徑名稱符合 p 的文件，ipath 會忽略大小寫 -name name, -iname name 文件名稱符合 name 的文件。 iname 會忽略大小寫 -size n 指定檔案的大小 -type c 指定檔案的類型 -perm 指定檔案的權限 -user 指定檔案擁有者 -group 指定檔案的群組 -exec 對使用find的搜尋結果執行特定指令 基本操作 指定檔名搜尋 # 搜尋在當前目錄底下，檔名為file.","title":"Linux 查找文件[find]"},{"content":"👨‍💻簡介 logrotate 用途：日誌文件管理工具，用於切割日誌，壓縮轉存，刪除舊的日誌文件，並創建新的日誌文件 預設配置文件位置： /etc/logrotate.conf /etc/logrotate.d 運行機制 logrotate是透過cron來運行的，透過/etc/cron.daily/logrotate這腳本，如要查看cron.daily運行方式，可查看/etc/anacrontab\n# /etc/anacrontab: configuration file for anacron # See anacron(8) and anacrontab(5) for details. SHELL=/bin/sh PATH=/sbin:/bin:/usr/sbin:/usr/bin MAILTO=root # the maximal random delay added to the base delay of the jobs RANDOM_DELAY=45 # the jobs will be started during the following hours only START_HOURS_RANGE=3-22 #period in days delay in minutes job-identifier command 1\t5\tcron.daily\tnice run-parts /etc/cron.daily 7\t25\tcron.weekly\tnice run-parts /etc/cron.weekly @monthly 45\tcron.monthly\tnice run-parts /etc/cron.monthly 上面可看到執行cron.daily是在凌晨3.到22.之間，並且隨機延遲45分鐘\n語法 logrotate [OPTIONS] config_file 參數 選項 說明 -d, \u0026ndash;debug debug模式，測試配置文件是否有錯誤 -f, \u0026ndash;force 強制轉儲文件 -m, \u0026ndash;mail=command 壓縮日誌後，發送日誌到指定郵箱 -s, \u0026ndash;state=statefile 使用指定的狀態文件 -v, \u0026ndash;verbose 顯示轉儲過程 -l, \u0026ndash;log=STRING log file 設定檔參數 說明 compress 在輪循任務完成後，已輪循的歸檔將使用 gzip 進行壓縮 compresscmd 指定壓縮工具，默認為gzip uncompresscmd 指定解壓縮工具，默認為gunziip compressext 指定要在壓縮日誌文件上使用的擴展名，默認遵循配置的壓縮命令 compressoptions 壓縮指令的選項配置\u0008， copy 製作log檔的副本，與create互斥 copytruncate 用於還在打開中的日誌文件，把當前日誌備份並截斷 create mode owner group 以指定的權限創建全新的日誌文件，同時 logrotate 也會重命名原始日誌文件 daily 日誌文件將按天輪循 dateext 使用當前日期作為命名格式 dateformat format_string 配合dateext使用，緊跟在下一行出現，定義文件切割後的文件名，必須配合dateext使用，只支持%Y %m %d %s這四個參數 delaycompress 和 compress 一起使用時，轉儲的日誌文件到下一次轉儲時才壓縮 extension ext 維護擴展名 ifempty 即使是空文件也轉儲 include file_or_directory 將logrotate格式的檔案或是目錄整個引進或 mail address 把轉儲的日誌文件發送到指定的 E-mail 地址 mailfirst 當啟用mail參數時，寄出剛rotated的文件 maillast 使用 mail 命令時，郵寄即將到期的文件，而不是剛剛旋轉的文件 maxage count 刪除超過count天的rotated日誌 minsize size 日誌文件在大於size字節時rotated，但不會在額外指定的時間間隔（每天、每週、每月或每年）之前輪換。使用minsize時，會同時考慮日誌文件的大小和時間戳，size選項則不會 missingok 在日誌輪循期間，任何錯誤將被忽略，例如\u0026quot;文件無法找到\u0026quot;之類的錯誤 monthly 日誌文件將按月輪循 nocompress 不壓縮 nocopy 不複製 nocopytruncate 備份日誌文件但是不截斷 nocreate 不建立新的日誌文件 nodelaycompress 覆蓋 delaycompress 選項，轉儲同時壓縮 nodateext rotate不帶日期 nomail 轉儲時不發送日誌文件 nomissingok log檔不存在會噴錯 noolddir 轉儲後的日誌文件和當前日誌文件放在同一個目錄下 nosharedscripts Run prerotate and postrotate scripts for every log file which is rotated noshred 刪除舊log時不要使用shred。 notifempty 如果日誌文件為空，輪循不會進行 olddir directory 儲後的日誌文件放入指定的目錄，必須和當前日誌文件在同一個文件系統 postrotate/endscript 在所有其它指令完成後，postrotate和endscript裡面指定的命令將被執行 prerotate/endscript 在轉儲以前需要執行的命令可以放入這個對，這兩個關鍵字必須單獨成行 firstaction/endscript firstaction以及endscript之間優先執行 lastaction/endscript lastaction以及endscript之間最後執行 rotate count 指定日誌文件刪除之前轉儲的次數，一次將存儲count個歸檔日誌。對於第count+1個歸檔，時間最久的歸檔將被刪除，0指沒有備份 size size 當日誌文件到達指定的大小時才轉儲 sharedscripts 運行postrotate腳本，作用是在所有日誌都輪轉後統一執行一次腳本。如果沒有配置這個，那麼每個日誌輪轉後都會執行一次腳本 shred 使用shred -u而不是unlink()刪除log文件。這應該確保log在預定刪除後不可讀 shredcycles count 要求 GNU shred(1) 在刪除之前覆蓋日誌文件計數次數 start count This is the number to use as the base for rotation. tabooext [+] list 不轉儲指定擴展名的文件 weekly 日誌文件將按週輪循 yearly 日誌文件將按年輪循 基本操作 調用/etc/logrotate.d下配置的所有日誌 logrotate /etc/logrotate.conf 指定logrotate檔 logrotate /etc/logrotate.d/logrotate_file 使用debug模式進行故障排除 logrotate -d /etc/logrotate.d/logrotate_file 強制rotate logrotate -df /etc/logrotate.d/logrotate_file 顯示rotate過程 logrotate -v /etc/logrotate.d/logrotate_file 配置文件案例 syslog /var/log/cron /var/log/maillog /var/log/messages /var/log/secure /var/log/spooler { missingok sharedscripts postrotate /bin/kill -HUP `cat /var/run/syslogd.pid 2\u0026gt; /dev/null` 2\u0026gt; /dev/null || true endscript } jenkins /var/log/jenkins/jenkins.log /var/log/jenkins/access_log { compress dateext maxage 365 rotate 99 size=+4096k notifempty missingok create 644 copytruncate } nginx /var/log/nginx/*.log /var/log/nginx/*/*.log{ daily missingok rotate 14 compress delaycompress notifempty create 640 root adm sharedscripts postrotate [ ! -f /var/run/nginx.pid ] || kill -USR1 `cat /var/run/nginx.pid` endscript } 參考資料 Linux 日志切割神器 logrotate 原理介绍和配置详解 | HelloDog (wsgzao.github.io) logrotate(8) - Linux man page (die.net) logrotate机制和原理 — 0xFEE1C001 (lightxue.com) How to Use logrotate to Manage Log Files | Linode 系统运维|Linux日志文件总管——logrotate 系统运维|Linux日志文件总管——logrotate (51cto.com) Logrotate 因為父目錄權限而執行失敗 – Mr. 沙先生 (shazi.info) 相關指令(可選) ","permalink":"https://sz9751210.github.io/posts/linux-logrotate/","summary":"👨‍💻簡介 logrotate 用途：日誌文件管理工具，用於切割日誌，壓縮轉存，刪除舊的日誌文件，並創建新的日誌文件 預設配置文件位置： /etc/logrotate.conf /etc/logrotate.d 運行機制 logrotate是透過cron來運行的，透過/etc/cron.daily/logrotate這腳本，如要查看cron.daily運行方式，可查看/etc/anacrontab\n# /etc/anacrontab: configuration file for anacron # See anacron(8) and anacrontab(5) for details. SHELL=/bin/sh PATH=/sbin:/bin:/usr/sbin:/usr/bin MAILTO=root # the maximal random delay added to the base delay of the jobs RANDOM_DELAY=45 # the jobs will be started during the following hours only START_HOURS_RANGE=3-22 #period in days delay in minutes job-identifier command 1\t5\tcron.daily\tnice run-parts /etc/cron.daily 7\t25\tcron.weekly\tnice run-parts /etc/cron.weekly @monthly 45\tcron.","title":"Linux 日誌管理[logrotate]"},{"content":"👨‍💻簡介 cut 用途：文字處理工具，可以將每一行文字的部分字元或是欄位擷取出來 語法 cut [OPTIONS] FILE 參數 參數 說明 -b, \u0026ndash;bytes=LIST 擷取指定的範圍，以 bytes 作為單位 -c, \u0026ndash;characters=LIST 擷取指定的範圍，以字元數量作為單位 -d, \u0026ndash;delimiter=DELIM 指定分隔字元，預設是用 tab 作為分隔 -f, \u0026ndash;fields=LIST 輸出指定的範圍，這個是每行資料的第幾個欄位作為區分 -n with -b: don\u0026rsquo;t split multibyte characters \u0026ndash;complement 排除未擷取的欄位 -s, \u0026ndash;only-delimited 如果該行沒有分隔字元，不會顯示該行資料 \u0026ndash;output-delimiter=字串 改變輸出欄位的分隔字元 基本操作 擷取字元 # 擷取從第二個字元到最後 cut -c 2- file # 擷取從開始到第二個字元 cut -c -2 file # 擷取第2-3,5-8,10-12個字元 cut -c 2-3,5-8,10-12 file 排除字元 # 排除2-5字元，其餘都擷取 cut -c 2-5 --complement 擷取欄位 # 將逗號當作分隔符，擷取第二個欄位 cut -d , -f 2 file # 將逗號當作分隔符，擷取第1-3個欄位以及第五個欄位 cut -d , -f 1-3,5 file 排除欄位 # 排除第二個欄位，擷取剩餘的欄位 cut -d , -f 2 --complement file 改變輸出欄位分隔字元 # 將逗號當作分隔符，擷取第1,3欄位並將分隔符從,改成: cut -d , -f 1,3 --output-delimiter=\u0026#34;:\u0026#34; 組合技 # 找出所有python程式的PID與指令內容 ps aux | grep python | sed \u0026#39;s/\\s\\+/ /g\u0026#39; | cut -d \u0026#39; \u0026#39; -f 2,11- 參考資料 Linux 的 cut 擷取部份字元、欄位指令教學與常用範例整理 - G. T. Wang (gtwang.org) cut 指令: 擷取檔案每行指定範圍資料 (ltsplus.com) Bash Cut Command with Examples (linuxhint.com) 相關指令(可選) sed awk ","permalink":"https://sz9751210.github.io/posts/linux-cut/","summary":"👨‍💻簡介 cut 用途：文字處理工具，可以將每一行文字的部分字元或是欄位擷取出來 語法 cut [OPTIONS] FILE 參數 參數 說明 -b, \u0026ndash;bytes=LIST 擷取指定的範圍，以 bytes 作為單位 -c, \u0026ndash;characters=LIST 擷取指定的範圍，以字元數量作為單位 -d, \u0026ndash;delimiter=DELIM 指定分隔字元，預設是用 tab 作為分隔 -f, \u0026ndash;fields=LIST 輸出指定的範圍，這個是每行資料的第幾個欄位作為區分 -n with -b: don\u0026rsquo;t split multibyte characters \u0026ndash;complement 排除未擷取的欄位 -s, \u0026ndash;only-delimited 如果該行沒有分隔字元，不會顯示該行資料 \u0026ndash;output-delimiter=字串 改變輸出欄位的分隔字元 基本操作 擷取字元 # 擷取從第二個字元到最後 cut -c 2- file # 擷取從開始到第二個字元 cut -c -2 file # 擷取第2-3,5-8,10-12個字元 cut -c 2-3,5-8,10-12 file 排除字元 # 排除2-5字元，其餘都擷取 cut -c 2-5 --complement 擷取欄位 # 將逗號當作分隔符，擷取第二個欄位 cut -d , -f 2 file # 將逗號當作分隔符，擷取第1-3個欄位以及第五個欄位 cut -d , -f 1-3,5 file 排除欄位 # 排除第二個欄位，擷取剩餘的欄位 cut -d , -f 2 --complement file 改變輸出欄位分隔字元 # 將逗號當作分隔符，擷取第1,3欄位並將分隔符從,改成: cut -d , -f 1,3 --output-delimiter=\u0026#34;:\u0026#34; 組合技 # 找出所有python程式的PID與指令內容 ps aux | grep python | sed \u0026#39;s/\\s\\+/ /g\u0026#39; | cut -d \u0026#39; \u0026#39; -f 2,11- 參考資料 Linux 的 cut 擷取部份字元、欄位指令教學與常用範例整理 - G.","title":"Linux 擷取部分字元[cut]"},{"content":"刪除本地分支 先使用 git branch -a(all) 列出所有分支，再使用 -d(delete) 後面接著要刪除的分支名稱即可\ngit branch -a # *master # test # remote/origin/master # remote/origin/test git branch -d test # Deleted branch test (was ########). 刪除遠程分支 刪除遠程分支必須使用 git push 加上 --delete 參數，並且必須在push後加上 remote name\ngit branch -a # *master # test # remote/origin/master # remote/origin/test git push origin --delete test # To \u0026lt;URL of your repository\u0026gt;.git # - [deleted] test 參考資料 How to delete remote branches in Git (educative.io) ","permalink":"https://sz9751210.github.io/posts/git-%E5%88%AA%E9%99%A4%E9%81%A0%E7%A8%8B%E5%88%86%E6%94%AF/","summary":"刪除本地分支 先使用 git branch -a(all) 列出所有分支，再使用 -d(delete) 後面接著要刪除的分支名稱即可\ngit branch -a # *master # test # remote/origin/master # remote/origin/test git branch -d test # Deleted branch test (was ########). 刪除遠程分支 刪除遠程分支必須使用 git push 加上 --delete 參數，並且必須在push後加上 remote name\ngit branch -a # *master # test # remote/origin/master # remote/origin/test git push origin --delete test # To \u0026lt;URL of your repository\u0026gt;.git # - [deleted] test 參考資料 How to delete remote branches in Git (educative.","title":"git-刪除遠程分支"},{"content":"安裝環境 windows 10 python 3.8.0 安裝步驟 1.下載python 網址:Python\n點擊Download\n選擇windows的可執行安裝檔，目前大多都以64位元為主 2.安裝過程 3.檢查環境 ","permalink":"https://sz9751210.github.io/posts/python-installation/","summary":"安裝環境 windows 10 python 3.8.0 安裝步驟 1.下載python 網址:Python\n點擊Download\n選擇windows的可執行安裝檔，目前大多都以64位元為主 2.安裝過程 3.檢查環境 ","title":"python-installation"},{"content":"👨‍💻簡介 cp(copy) 用途：複製檔案(copy)和目錄 語法 cp [OPTIONS] SOURCE DEST 參數 參數 說明 -a, \u0026ndash;archive 效果同-dpR，保留連結、文件屬性，並複製目錄下的所有內容，通常在複製目錄時使用 \u0026ndash;attributes-only 只複製文件的屬性，內容不複製 \u0026ndash;backup[=CONTROL] 備份每個現有的目標文件 -b 不接受參數版的\u0026ndash;backup \u0026ndash;copy-contents 遞歸模式下複製特殊文件的內容 -d 複製時保留軟連結 -f, \u0026ndash;force 強制覆蓋已經存在的目標文件，不會跳出提示 -i, \u0026ndash;interactive 與-f選項相反，在覆蓋目標文件之前給出提示，要求用戶確認是否覆蓋，回答 y 時目標文件將被覆蓋。 -H 跟隨源文件命令行中顯式給出的符號鏈接 -l, \u0026ndash;link 使用硬鏈接取代複製 -L, \u0026ndash;dereference 總是跟隨源文件中的符號鏈接 -n, \u0026ndash;no-clobber 不要覆寫已有的文件（覆蓋先前給出的 -i 選項） -P, \u0026ndash;no-dereference 永遠不要跟隨源文件中的符號鏈接 -p 不接受參數版的\u0026ndash;preserve \u0026ndash;preserve[=ATTR_LIST] 除複製文件的內容外，還把修改時間和訪問權限也複製到新文件中。保留指定的屬性（默認：模式、從屬關係、時間戳），如果可能的話還有額外屬性：上下文、鏈接（links）、xattr、all \u0026ndash;no-preserve=ATTR_LIST 不要保留指定的屬性 \u0026ndash;parents 在目標目錄下使用完整的源文件名 -R, -r, \u0026ndash;recursive 遞歸複製目錄 \u0026ndash;reflink[=WHEN] 控制克隆/寫入時複製（CoW）副本。詳情見下文 \u0026ndash;remove-destination 打開目的 \u0026ndash;sparse=WHEN 控制稀疏文件的創建。詳情見下文 \u0026ndash;strip-trailing-slashes 移除每個源文件參數後的任何末尾斜槓 -s, \u0026ndash;symbolic-link 建立軟連結而不是複制 -S, \u0026ndash;suffix=後置字串 覆蓋原本的備份後綴 -t, \u0026ndash;target-directory=目錄 將所有源文件參數給出的內容複製到目標目錄中 -T, \u0026ndash;no-target-directory 將目標文件當作普通文件對待（而不是目錄） -u, \u0026ndash;update 僅在源文件比目標文件新，或者目標文件不存在的情況下複製 -v, \u0026ndash;verbose 顯示覆蓋訊息 -x, \u0026ndash;one-file-system 停留在當前文件系統中 -Z 將目標文件的 SELinux 安全上下文設置為默認類型 \u0026ndash;context[=CTX] 類似-Z，或者如果給定了上下文（CTX）那麼將SELinux或者SMACK 安全上下文設置爲給定值 默認情況下，程序會使用一種粗糙的啓發式算法探測源文件是否是稀疏的，若判定爲稀疏，則目標文件也會以稀疏形式創建。這個行爲可以通過\n--sparse=auto指定。若指定 --sparse=always，將在源文件包含足夠多內容爲零的字節序列時將其視作稀疏文件。使用 --sparse=never 以禁止創建稀疏文件。 當指定了--reflink[=always]時，進行輕量級複製，其中的數據塊僅在被修改時進行復制。如果這樣的複製失敗，或無法實行，或者指定了--reflink=auto時，回退到標準複製。\n備份的後綴爲\u0026quot;~\u0026quot;，除非設置了--suffix或者SIMPLE_BACKUP_SUFFIX。版本控制方式可以使用 --backup選項或者VERSION_CONTROL環境變量進行指定。可用的值如下：\nnone, off：永遠不製作備份（即使給出了 \u0026ndash;backup ） numbered, t：製作編號的備份 existing, nil：如果已編號副本存在則編號，否則採用簡單方式 simple, never：總是製作簡單備份 作爲一個特例，cp將在同時給出force選項與backup選項，並且源文件和目標文件是同一個已存在普通文件的情況下製作備份副本。 基本操作 複製目錄 cp -r source/ destdir 複製並改名 cp aaa bbb 複製目錄及屬性 cp -rp source/ destdir 複製多檔到單目錄下 cp aaa bbb destdir 透過匹配複製 cp *.log dest 參考資料 Ubuntu Manpage: cp - 複製文件和目錄 Linux cp 指令用法 (link.idv.tw) Linux cp Command Examples (linuxhint.com) ","permalink":"https://sz9751210.github.io/posts/linux-cp/","summary":"👨‍💻簡介 cp(copy) 用途：複製檔案(copy)和目錄 語法 cp [OPTIONS] SOURCE DEST 參數 參數 說明 -a, \u0026ndash;archive 效果同-dpR，保留連結、文件屬性，並複製目錄下的所有內容，通常在複製目錄時使用 \u0026ndash;attributes-only 只複製文件的屬性，內容不複製 \u0026ndash;backup[=CONTROL] 備份每個現有的目標文件 -b 不接受參數版的\u0026ndash;backup \u0026ndash;copy-contents 遞歸模式下複製特殊文件的內容 -d 複製時保留軟連結 -f, \u0026ndash;force 強制覆蓋已經存在的目標文件，不會跳出提示 -i, \u0026ndash;interactive 與-f選項相反，在覆蓋目標文件之前給出提示，要求用戶確認是否覆蓋，回答 y 時目標文件將被覆蓋。 -H 跟隨源文件命令行中顯式給出的符號鏈接 -l, \u0026ndash;link 使用硬鏈接取代複製 -L, \u0026ndash;dereference 總是跟隨源文件中的符號鏈接 -n, \u0026ndash;no-clobber 不要覆寫已有的文件（覆蓋先前給出的 -i 選項） -P, \u0026ndash;no-dereference 永遠不要跟隨源文件中的符號鏈接 -p 不接受參數版的\u0026ndash;preserve \u0026ndash;preserve[=ATTR_LIST] 除複製文件的內容外，還把修改時間和訪問權限也複製到新文件中。保留指定的屬性（默認：模式、從屬關係、時間戳），如果可能的話還有額外屬性：上下文、鏈接（links）、xattr、all \u0026ndash;no-preserve=ATTR_LIST 不要保留指定的屬性 \u0026ndash;parents 在目標目錄下使用完整的源文件名 -R, -r, \u0026ndash;recursive 遞歸複製目錄 \u0026ndash;reflink[=WHEN] 控制克隆/寫入時複製（CoW）副本。詳情見下文 \u0026ndash;remove-destination 打開目的 \u0026ndash;sparse=WHEN 控制稀疏文件的創建。詳情見下文 \u0026ndash;strip-trailing-slashes 移除每個源文件參數後的任何末尾斜槓 -s, \u0026ndash;symbolic-link 建立軟連結而不是複制 -S, \u0026ndash;suffix=後置字串 覆蓋原本的備份後綴 -t, \u0026ndash;target-directory=目錄 將所有源文件參數給出的內容複製到目標目錄中 -T, \u0026ndash;no-target-directory 將目標文件當作普通文件對待（而不是目錄） -u, \u0026ndash;update 僅在源文件比目標文件新，或者目標文件不存在的情況下複製 -v, \u0026ndash;verbose 顯示覆蓋訊息 -x, \u0026ndash;one-file-system 停留在當前文件系統中 -Z 將目標文件的 SELinux 安全上下文設置為默認類型 \u0026ndash;context[=CTX] 類似-Z，或者如果給定了上下文（CTX）那麼將SELinux或者SMACK 安全上下文設置爲給定值 默認情況下，程序會使用一種粗糙的啓發式算法探測源文件是否是稀疏的，若判定爲稀疏，則目標文件也會以稀疏形式創建。這個行爲可以通過","title":"Linux 複製檔案[cp]"},{"content":"因為git忽略的原則為之前沒有被追蹤的檔案，因此可能開發到一半才會需要新增gitignore來進行忽略，但是失效\n解決的辦法為刪掉本地快取(改變成未被追蹤的狀態)，接著在新增要忽略的檔案到gitignore裡\ngit rm -r --cached . git add . git commit -m \u0026#34;init gitignore\u0026#34; ","permalink":"https://sz9751210.github.io/posts/gitignore%E5%A4%B1%E6%95%88%E7%9A%84%E8%A7%A3%E6%B1%BA%E8%BE%A6%E6%B3%95/","summary":"因為git忽略的原則為之前沒有被追蹤的檔案，因此可能開發到一半才會需要新增gitignore來進行忽略，但是失效\n解決的辦法為刪掉本地快取(改變成未被追蹤的狀態)，接著在新增要忽略的檔案到gitignore裡\ngit rm -r --cached . git add . git commit -m \u0026#34;init gitignore\u0026#34; ","title":"gitignore失效的解決辦法"},{"content":"👨‍💻簡介 chmod(change mode) 用途：控制用戶對文件的權限，linux 的文件權限分為三種身分，owner/group/others，而權限也分為三種，read/write/execute，權重如下表格 權限 權重 r 4 w 2 x 1 語法 chmod [OPTIONS] [mode] [檔案或目錄] 參數 參數 說明 -c, \u0026ndash;changes 效果類似\u0026quot;-v\u0026quot;參數，但僅回報更改的部分。 -f, \u0026ndash;silent, \u0026ndash;quiet 不顯示錯誤資訊。 -v, \u0026ndash;verbose 顯示指令執行過程。 \u0026ndash;no-preserve-root 取消對 root 文件系統的保護 \u0026ndash;preserve-root 保留對 root 文件系統的保護 \u0026ndash;reference=RFILE 把指定文件或目錄的權限全部設成和參考文件或目錄的權限相同。 -R, \u0026ndash;recursive 遞迴處理，將指定目錄下的所有檔及子目錄一併處理。 符號模式 who(用戶類型) 說明 u(user) 所有者 g(group) 所屬組 o(others) 其他用戶 a(all) 所有用戶，等於ugo operator 說明 + 新增權限 - 移除權限 = 設定權限 模式 說明 r 可讀權限 w 可寫權限 x 可執行權限 絕對模式 參數 權限 rwx 7 讀+寫+執行 rwx 6 讀+寫 rw- 5 讀+執行 r-x 4 只讀 r\u0026ndash; 3 寫+執行 -wx 2 只寫 -w- 1 只執行 \u0026ndash;x 0 無 \u0026mdash; 基本操作 將檔案變成user可執行 假設原本檔案權限為-rw-rw-r--\n指令 mode chmod u+x chmod u=rwx chmod 764 將檔案設定user可寫，group以及others無法寫 假設原本檔案權限為-r--rw-rw-\n指令 mode chmod u+w,go-w chmod u=rw,go=r chmod 644 將資料夾底下的權限都設定一樣的 chmod -R a+r dirName ","permalink":"https://sz9751210.github.io/posts/linux-chmod/","summary":"👨‍💻簡介 chmod(change mode) 用途：控制用戶對文件的權限，linux 的文件權限分為三種身分，owner/group/others，而權限也分為三種，read/write/execute，權重如下表格 權限 權重 r 4 w 2 x 1 語法 chmod [OPTIONS] [mode] [檔案或目錄] 參數 參數 說明 -c, \u0026ndash;changes 效果類似\u0026quot;-v\u0026quot;參數，但僅回報更改的部分。 -f, \u0026ndash;silent, \u0026ndash;quiet 不顯示錯誤資訊。 -v, \u0026ndash;verbose 顯示指令執行過程。 \u0026ndash;no-preserve-root 取消對 root 文件系統的保護 \u0026ndash;preserve-root 保留對 root 文件系統的保護 \u0026ndash;reference=RFILE 把指定文件或目錄的權限全部設成和參考文件或目錄的權限相同。 -R, \u0026ndash;recursive 遞迴處理，將指定目錄下的所有檔及子目錄一併處理。 符號模式 who(用戶類型) 說明 u(user) 所有者 g(group) 所屬組 o(others) 其他用戶 a(all) 所有用戶，等於ugo operator 說明 + 新增權限 - 移除權限 = 設定權限 模式 說明 r 可讀權限 w 可寫權限 x 可執行權限 絕對模式 參數 權限 rwx 7 讀+寫+執行 rwx 6 讀+寫 rw- 5 讀+執行 r-x 4 只讀 r\u0026ndash; 3 寫+執行 -wx 2 只寫 -w- 1 只執行 \u0026ndash;x 0 無 \u0026mdash; 基本操作 將檔案變成user可執行 假設原本檔案權限為-rw-rw-r--","title":"Linux 修改權限[chmod]"},{"content":"紀錄一下hugo的建置過程\n1. 安裝hugo windows安裝 Chocolatey choco install hugo -confirm Scoop scoop install hugo macos安裝 brew install hugo linux安裝 sudo apt-get install hugo 2. 建立網站 hugo new site myblog -f yaml 3. 下載主題 git clone https://github.com/adityatelange/hugo-PaperMod themes/PaperMod --depth=1 4. 建立about, tags page 建立about page hugo new about.md 修改config檔 menu: main: - identifier: tags name: tags url: /tags/ weight: 1 - identifier: about name: about url: /about/ weight: 2 5. 依照需求美化版面 Hugo PaperMod 優化\n6. 推到github 修改config檔的baseURL為自己的github.io網址 刪掉theme底下的.git，如果有自己修改的話就版控這個主題 將自己的github.io的repo設定成submodule git submodule add git@github.com:sz9751210/sz9751210.github.io.git public 在myblog下hugo生成靜態網頁 到public資料夾將生成的檔案都推到github.io的repo 到自己的github page查看結果 ","permalink":"https://sz9751210.github.io/posts/hugo-setup/","summary":"紀錄一下hugo的建置過程\n1. 安裝hugo windows安裝 Chocolatey choco install hugo -confirm Scoop scoop install hugo macos安裝 brew install hugo linux安裝 sudo apt-get install hugo 2. 建立網站 hugo new site myblog -f yaml 3. 下載主題 git clone https://github.com/adityatelange/hugo-PaperMod themes/PaperMod --depth=1 4. 建立about, tags page 建立about page hugo new about.md 修改config檔 menu: main: - identifier: tags name: tags url: /tags/ weight: 1 - identifier: about name: about url: /about/ weight: 2 5. 依照需求美化版面 Hugo PaperMod 優化","title":"Hugo Setup"},{"content":"簡單紀錄一下papermod主題的優化，持續更新\u0026hellip;\n1. 目錄放側邊 替換以下路徑的code layouts/partials/toc.html\n{{- $headers := findRE \u0026#34;\u0026lt;h[1-6].*?\u0026gt;(.|\\n])+?\u0026lt;/h[1-6]\u0026gt;\u0026#34; .Content -}} {{- $has_headers := ge (len $headers) 1 -}} {{- if $has_headers -}} \u0026lt;aside id=\u0026#34;toc-container\u0026#34; class=\u0026#34;toc-container wide\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;toc\u0026#34;\u0026gt; \u0026lt;details {{if (.Param \u0026#34;TocOpen\u0026#34;) }} open{{ end }}\u0026gt; \u0026lt;summary accesskey=\u0026#34;c\u0026#34; title=\u0026#34;(Alt + C)\u0026#34;\u0026gt; \u0026lt;span class=\u0026#34;details\u0026#34;\u0026gt;{{- i18n \u0026#34;toc\u0026#34; | default \u0026#34;Table of Contents\u0026#34; }}\u0026lt;/span\u0026gt; \u0026lt;/summary\u0026gt; \u0026lt;div class=\u0026#34;inner\u0026#34;\u0026gt; {{- $largest := 6 -}} {{- range $headers -}} {{- $headerLevel := index (findRE \u0026#34;[1-6]\u0026#34; . 1) 0 -}} {{- $headerLevel := len (seq $headerLevel) -}} {{- if lt $headerLevel $largest -}} {{- $largest = $headerLevel -}} {{- end -}} {{- end -}} {{- $firstHeaderLevel := len (seq (index (findRE \u0026#34;[1-6]\u0026#34; (index $headers 0) 1) 0)) -}} {{- $.Scratch.Set \u0026#34;bareul\u0026#34; slice -}} \u0026lt;ul\u0026gt; {{- range seq (sub $firstHeaderLevel $largest) -}} \u0026lt;ul\u0026gt; {{- $.Scratch.Add \u0026#34;bareul\u0026#34; (sub (add $largest .) 1) -}} {{- end -}} {{- range $i, $header := $headers -}} {{- $headerLevel := index (findRE \u0026#34;[1-6]\u0026#34; . 1) 0 -}} {{- $headerLevel := len (seq $headerLevel) -}} {{/* get id=\u0026#34;xyz\u0026#34; */}} {{- $id := index (findRE \u0026#34;(id=\\\u0026#34;(.*?)\\\u0026#34;)\u0026#34; $header 9) 0 }} {{- /* strip id=\u0026#34;\u0026#34; to leave xyz, no way to get regex capturing groups in hugo */ -}} {{- $cleanedID := replace (replace $id \u0026#34;id=\\\u0026#34;\u0026#34; \u0026#34;\u0026#34;) \u0026#34;\\\u0026#34;\u0026#34; \u0026#34;\u0026#34; }} {{- $header := replaceRE \u0026#34;\u0026lt;h[1-6].*?\u0026gt;((.|\\n])+?)\u0026lt;/h[1-6]\u0026gt;\u0026#34; \u0026#34;$1\u0026#34; $header -}} {{- if ne $i 0 -}} {{- $prevHeaderLevel := index (findRE \u0026#34;[1-6]\u0026#34; (index $headers (sub $i 1)) 1) 0 -}} {{- $prevHeaderLevel := len (seq $prevHeaderLevel) -}} {{- if gt $headerLevel $prevHeaderLevel -}} {{- range seq $prevHeaderLevel (sub $headerLevel 1) -}} \u0026lt;ul\u0026gt; {{/* the first should not be recorded */}} {{- if ne $prevHeaderLevel . -}} {{- $.Scratch.Add \u0026#34;bareul\u0026#34; . -}} {{- end -}} {{- end -}} {{- else -}} \u0026lt;/li\u0026gt; {{- if lt $headerLevel $prevHeaderLevel -}} {{- range seq (sub $prevHeaderLevel 1) -1 $headerLevel -}} {{- if in ($.Scratch.Get \u0026#34;bareul\u0026#34;) . -}} \u0026lt;/ul\u0026gt; {{/* manually do pop item */}} {{- $tmp := $.Scratch.Get \u0026#34;bareul\u0026#34; -}} {{- $.Scratch.Delete \u0026#34;bareul\u0026#34; -}} {{- $.Scratch.Set \u0026#34;bareul\u0026#34; slice}} {{- range seq (sub (len $tmp) 1) -}} {{- $.Scratch.Add \u0026#34;bareul\u0026#34; (index $tmp (sub . 1)) -}} {{- end -}} {{- else -}} \u0026lt;/ul\u0026gt; \u0026lt;/li\u0026gt; {{- end -}} {{- end -}} {{- end -}} {{- end }} \u0026lt;li\u0026gt; \u0026lt;a href=\u0026#34;#{{- $cleanedID -}}\u0026#34; aria-label=\u0026#34;{{- $header | plainify -}}\u0026#34;\u0026gt;{{- $header | safeHTML -}}\u0026lt;/a\u0026gt; {{- else }} \u0026lt;li\u0026gt; \u0026lt;a href=\u0026#34;#{{- $cleanedID -}}\u0026#34; aria-label=\u0026#34;{{- $header | plainify -}}\u0026#34;\u0026gt;{{- $header | safeHTML -}}\u0026lt;/a\u0026gt; {{- end -}} {{- end -}} \u0026lt;!-- {{- $firstHeaderLevel := len (seq (index (findRE \u0026#34;[1-6]\u0026#34; (index $headers 0) 1) 0)) -}} --\u0026gt; {{- $firstHeaderLevel := $largest }} {{- $lastHeaderLevel := len (seq (index (findRE \u0026#34;[1-6]\u0026#34; (index $headers (sub (len $headers) 1)) 1) 0)) }} \u0026lt;/li\u0026gt; {{- range seq (sub $lastHeaderLevel $firstHeaderLevel) -}} {{- if in ($.Scratch.Get \u0026#34;bareul\u0026#34;) (add . $firstHeaderLevel) }} \u0026lt;/ul\u0026gt; {{- else }} \u0026lt;/ul\u0026gt; \u0026lt;/li\u0026gt; {{- end -}} {{- end }} \u0026lt;/ul\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/details\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/aside\u0026gt; \u0026lt;script\u0026gt; let activeElement; let elements; window.addEventListener(\u0026#39;DOMContentLoaded\u0026#39;, function (event) { checkTocPosition(); elements = document.querySelectorAll(\u0026#39;h1[id],h2[id],h3[id],h4[id],h5[id],h6[id]\u0026#39;); // Make the first header active activeElement = elements[0]; const id = encodeURI(activeElement.getAttribute(\u0026#39;id\u0026#39;)).toLowerCase(); document.querySelector(`.inner ul li a[href=\u0026#34;#${id}\u0026#34;]`).classList.add(\u0026#39;active\u0026#39;); }, false); window.addEventListener(\u0026#39;resize\u0026#39;, function(event) { checkTocPosition(); }, false); window.addEventListener(\u0026#39;scroll\u0026#39;, () =\u0026gt; { // Check if there is an object in the top half of the screen or keep the last item active activeElement = Array.from(elements).find((element) =\u0026gt; { if ((getOffsetTop(element) - window.pageYOffset) \u0026gt; 0 \u0026amp;\u0026amp; (getOffsetTop(element) - window.pageYOffset) \u0026lt; window.innerHeight/2) { return element; } }) || activeElement elements.forEach(element =\u0026gt; { const id = encodeURI(element.getAttribute(\u0026#39;id\u0026#39;)).toLowerCase(); if (element === activeElement){ document.querySelector(`.inner ul li a[href=\u0026#34;#${id}\u0026#34;]`).classList.add(\u0026#39;active\u0026#39;); } else { document.querySelector(`.inner ul li a[href=\u0026#34;#${id}\u0026#34;]`).classList.remove(\u0026#39;active\u0026#39;); } }) }, false); const main = parseInt(getComputedStyle(document.body).getPropertyValue(\u0026#39;--article-width\u0026#39;), 10); const toc = parseInt(getComputedStyle(document.body).getPropertyValue(\u0026#39;--toc-width\u0026#39;), 10); const gap = parseInt(getComputedStyle(document.body).getPropertyValue(\u0026#39;--gap\u0026#39;), 10); function checkTocPosition() { const width = document.body.scrollWidth; if (width - main - (toc * 2) - (gap * 4) \u0026gt; 0) { document.getElementById(\u0026#34;toc-container\u0026#34;).classList.add(\u0026#34;wide\u0026#34;); } else { document.getElementById(\u0026#34;toc-container\u0026#34;).classList.remove(\u0026#34;wide\u0026#34;); } } function getOffsetTop(element) { if (!element.getClientRects().length) { return 0; } let rect = element.getBoundingClientRect(); let win = element.ownerDocument.defaultView; return rect.top + win.pageYOffset; } \u0026lt;/script\u0026gt; {{- end }} 在\\themes\\PaperMod\\assets\\css\\extended底下新建一個.css檔，命名為toc-left.css\n:root { --nav-width: 1380px; --article-width: 650px; --toc-width: 300px; } .toc { margin: 0 2px 40px 2px; border: 1px solid var(--border); background: var(--entry); border-radius: var(--radius); padding: 0.4em; } .toc-container.wide { position: absolute; height: 100%; border-right: 1px solid var(--border); left: calc((var(--toc-width) + var(--gap)) * -1); top: calc(var(--gap) * 2); width: var(--toc-width); } .wide .toc { position: sticky; top: var(--gap); border: unset; background: unset; border-radius: unset; width: 100%; margin: 0 2px 40px 2px; } .toc details summary { cursor: zoom-in; margin-inline-start: 20px; padding: 12px 0; } .toc details[open] summary { font-weight: 500; } .toc-container.wide .toc .inner { margin: 0; } .active { font-size: 110%; font-weight: 600; } .toc ul { list-style-type: circle; } .toc .inner { margin: 0 0 0 20px; padding: 0px 15px 15px 20px; font-size: 16px; /*目录显示高度*/ max-height: 83vh; overflow-y: auto; } .toc .inner::-webkit-scrollbar-thumb { /*滚动条*/ background: var(--border); border: 7px solid var(--theme); border-radius: var(--radius); } .toc li ul { margin-inline-start: calc(var(--gap) * 0.5); list-style-type: none; } .toc li { list-style: none; font-size: 0.95rem; padding-bottom: 5px; } .toc li a:hover { color: var(--secondary); } 2. 主頁圖片縮小擺右側 到layouts/_default/list.html，新增一個div，命名為post-info，把entry-header以及entry-content包進去 \u0026lt;article class=\u0026#34;{{ $class }}\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;post-info\u0026#34;\u0026gt; \u0026lt;!--加在這裡--\u0026gt; \u0026lt;header class=\u0026#34;entry-header\u0026#34;\u0026gt; \u0026lt;h2\u0026gt; {{- .Title }} {{- if .Draft }}\u0026lt;sup\u0026gt;\u0026lt;span class=\u0026#34;entry-isdraft\u0026#34;\u0026gt;\u0026amp;nbsp;\u0026amp;nbsp;[draft]\u0026lt;/span\u0026gt;\u0026lt;/sup\u0026gt;{{- end }} \u0026lt;/h2\u0026gt; \u0026lt;/header\u0026gt; {{- if (ne (.Param \u0026#34;hideSummary\u0026#34;) true) }} \u0026lt;div class=\u0026#34;entry-content\u0026#34;\u0026gt; \u0026lt;p\u0026gt;{{ .Summary | plainify | htmlUnescape }}{{ if .Truncated }}...{{ end }}\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; {{- end }} {{- if not (.Param \u0026#34;hideMeta\u0026#34;) }} \u0026lt;footer class=\u0026#34;entry-footer\u0026#34;\u0026gt; {{- partial \u0026#34;post_meta.html\u0026#34; . -}} \u0026lt;/footer\u0026gt; {{- end }} \u0026lt;/div\u0026gt; \u0026lt;!--加在這裡--\u0026gt; \u0026lt;!-- 下面這兩行從原本的\u0026lt;article class=\u0026#34;{{ $class }}\u0026#34;\u0026gt;和\u0026lt;header class=\u0026#34;entry-header\u0026#34;\u0026gt;搬下來 --\u0026gt; {{- $isHidden := (site.Params.cover.hidden | default site.Params.cover.hiddenInList) }} {{- partial \u0026#34;cover.html\u0026#34; (dict \u0026#34;cxt\u0026#34; . \u0026#34;IsHome\u0026#34; true \u0026#34;isHidden\u0026#34; $isHidden) }} \u0026lt;a class=\u0026#34;entry-link\u0026#34; aria-label=\u0026#34;post link to {{ .Title | plainify }}\u0026#34; href=\u0026#34;{{ .Permalink }}\u0026#34;\u0026gt;\u0026lt;/a\u0026gt; \u0026lt;/article\u0026gt; {{- end }} 在\\themes\\PaperMod\\assets\\css\\extended底下新建一個.css檔，命名為image-left.css .post-entry { display: flex; flex-direction: row; align-items: center; } .entry-cover { overflow: hidden; padding-left: 18px; height: 100%; width: 50%; margin-bottom: unset; } .post-info { display: inline-block; overflow: hidden; width: 90%; } 修改主頁與內文的差異\n在layouts/partials/cover.html，複製一份並命名為cover1.html 把cover1.html裡的\u0026lt;figure class=\u0026quot;entry-cover\u0026quot;\u0026gt;改為\u0026lt;figure class=\u0026quot;entry-cover1\u0026quot;\u0026gt; 在layouts/_default/single.html把{{- partial \u0026quot;cover.html\u0026quot; (dict \u0026quot;cxt\u0026quot; . \u0026quot;IsHome\u0026quot; false \u0026quot;isHidden\u0026quot; $isHidden) }}改為{{- partial \u0026quot;cover1.html\u0026quot; (dict \u0026quot;cxt\u0026quot; . \u0026quot;IsHome\u0026quot; false \u0026quot;isHidden\u0026quot; $isHidden) }} 3. Mac風格的code blocks 在\\themes\\PaperMod\\assets\\css\\extended底下新建一個.css檔，命名為mac-code-blocks.css\npre { position: relative; padding: 30px 10px 10px 10px; } .post-content pre code { font-family: Consolas; } pre::after { display: block; content: \u0026#34; \u0026#34;; position: absolute; border-radius: 50%; background: #ff5f56; width: 12px; height: 12px; top: 0; left: 12px; margin-top: 12px; -webkit-box-shadow: 20px 0 #ffbd2e, 40px 0 #27c93f; box-shadow: 20px 0 #ffbd2e, 40px 0 #27c93f; } 4. 讓tags與categories頁面的文章也顯示縮圖 assets/css/common/post-entry.css\n.tag-entry .entry-cover { display: flex; } ","permalink":"https://sz9751210.github.io/posts/hugo-papermod-enforce/","summary":"簡單紀錄一下papermod主題的優化，持續更新\u0026hellip;\n1. 目錄放側邊 替換以下路徑的code layouts/partials/toc.html\n{{- $headers := findRE \u0026#34;\u0026lt;h[1-6].*?\u0026gt;(.|\\n])+?\u0026lt;/h[1-6]\u0026gt;\u0026#34; .Content -}} {{- $has_headers := ge (len $headers) 1 -}} {{- if $has_headers -}} \u0026lt;aside id=\u0026#34;toc-container\u0026#34; class=\u0026#34;toc-container wide\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;toc\u0026#34;\u0026gt; \u0026lt;details {{if (.Param \u0026#34;TocOpen\u0026#34;) }} open{{ end }}\u0026gt; \u0026lt;summary accesskey=\u0026#34;c\u0026#34; title=\u0026#34;(Alt + C)\u0026#34;\u0026gt; \u0026lt;span class=\u0026#34;details\u0026#34;\u0026gt;{{- i18n \u0026#34;toc\u0026#34; | default \u0026#34;Table of Contents\u0026#34; }}\u0026lt;/span\u0026gt; \u0026lt;/summary\u0026gt; \u0026lt;div class=\u0026#34;inner\u0026#34;\u0026gt; {{- $largest := 6 -}} {{- range $headers -}} {{- $headerLevel := index (findRE \u0026#34;[1-6]\u0026#34; .","title":"Hugo PaperMod 優化"},{"content":" Know How, Know Why, Know What and When 把時間花在哪裡，成就就在哪裡 time is your most valuable resource, speed is your best friend 用實作來學習，永遠是初學的王道!以實戰來練習，永遠是進階的捷徑! Practice makes perfect. All experience comes from mistakes. Don\u0026rsquo;t be one of the leeches. ","permalink":"https://sz9751210.github.io/quote/","summary":" Know How, Know Why, Know What and When 把時間花在哪裡，成就就在哪裡 time is your most valuable resource, speed is your best friend 用實作來學習，永遠是初學的王道!以實戰來練習，永遠是進階的捷徑! Practice makes perfect. All experience comes from mistakes. Don\u0026rsquo;t be one of the leeches. ","title":"Quote"},{"content":"👨‍💻簡介 chgrp(change group) 用途：用於改變文件或目錄的所屬群組 語法 chgrp [OPTIONS] [文件或目錄] 參數 參數 說明 -c, \u0026ndash;changes 效果類似\u0026quot;-v\u0026quot;參數，但僅回報更改的部分。 -f, \u0026ndash;silent, \u0026ndash;quiet 不顯示錯誤資訊。 -v, \u0026ndash;verbose 顯示指令執行過程。 \u0026ndash;dereference 與-h相反，只對連結的對象做修改，而不是連結本身 -h, \u0026ndash;no-dereference 只對軟連結的檔作修改，而不更動其他任何相關檔。 \u0026ndash;no-preserve-root 取消對 root 文件系統的保護 \u0026ndash;preserve-root 保留對 root 文件系統的保護 \u0026ndash;reference=RFILE 把指定文件或目錄的所屬群組全部設成和參考文件或目錄的所屬群組相同。 -R, \u0026ndash;recursive 遞迴處理，將指定目錄下的所有檔及子目錄一併處理。 -H 如果命令行參數是軟連結到一個目錄，遍歷它 -L 遍歷每個軟連結到目錄的鏈接 -P 不遍歷任何軟連結（默認） 基本操作 改變文件的群組屬性 將test的所屬組更改為alan\nchgrp alan test 根據指定文件改變文件的群組屬性 test2參考test的群組屬性，使得test與test2的群組屬性相同\nchgrp --reference=test test2 ","permalink":"https://sz9751210.github.io/posts/linux-chgrp/","summary":"👨‍💻簡介 chgrp(change group) 用途：用於改變文件或目錄的所屬群組 語法 chgrp [OPTIONS] [文件或目錄] 參數 參數 說明 -c, \u0026ndash;changes 效果類似\u0026quot;-v\u0026quot;參數，但僅回報更改的部分。 -f, \u0026ndash;silent, \u0026ndash;quiet 不顯示錯誤資訊。 -v, \u0026ndash;verbose 顯示指令執行過程。 \u0026ndash;dereference 與-h相反，只對連結的對象做修改，而不是連結本身 -h, \u0026ndash;no-dereference 只對軟連結的檔作修改，而不更動其他任何相關檔。 \u0026ndash;no-preserve-root 取消對 root 文件系統的保護 \u0026ndash;preserve-root 保留對 root 文件系統的保護 \u0026ndash;reference=RFILE 把指定文件或目錄的所屬群組全部設成和參考文件或目錄的所屬群組相同。 -R, \u0026ndash;recursive 遞迴處理，將指定目錄下的所有檔及子目錄一併處理。 -H 如果命令行參數是軟連結到一個目錄，遍歷它 -L 遍歷每個軟連結到目錄的鏈接 -P 不遍歷任何軟連結（默認） 基本操作 改變文件的群組屬性 將test的所屬組更改為alan\nchgrp alan test 根據指定文件改變文件的群組屬性 test2參考test的群組屬性，使得test與test2的群組屬性相同\nchgrp --reference=test test2 ","title":"Linux 修改群組[chgrp]"},{"content":"專注於學習devops的菜雞工程師，凡事力求一鍵部署，喜歡寫一些小玩具嘗試新技術，時而分享好書的閱讀心得以及好文。\n","permalink":"https://sz9751210.github.io/about/","summary":"專注於學習devops的菜雞工程師，凡事力求一鍵部署，喜歡寫一些小玩具嘗試新技術，時而分享好書的閱讀心得以及好文。","title":"關於我"},{"content":"👨‍💻簡介 less 用途：對文件或其它輸出進行分頁顯示的工具，可查看壓縮檔 語法 less [OPTIONS] fileName 參數 參數 說明 -b \u0026lt;緩衝區大小\u0026gt; 設置緩衝區的大小 -e 當文件顯示結束後，自動離開 -f 強迫打開特殊文件，例如外圍設備代號、目錄和二進制文件 -g 只標誌最後搜索的關鍵詞 -i 忽略搜索時的大小寫 -m 顯示類似more指令的百分比 -N 顯示每行的行號 -o \u0026lt;文件名\u0026gt; 將less 輸出的內容在指定文件中保存起來 -Q 不使用警告音 -s 顯示連續空行為一行 -S 行過長時間將超出部分捨棄 -x \u0026lt;數字\u0026gt; 將「tab」鍵顯示為規定的數字空格 less模式下 用法 說明 /字符串 向下搜索「字符串」的功能 ?字符串 向上搜索「字符串」的功能 n 重複前一個搜索（與 / 或 ? 有關） N 反向重複前一個搜索（與 / 或 ? 有關） b 向後翻一頁 d 向後翻半頁 h 顯示幫助界面 q/ZZ 退出less 指令 u 向前滾動半頁 y 向前滾動一行 空格鍵 滾動一頁 回車鍵 滾動一行 j 下一行 k 上一行 [pagedown]： 向下翻動一頁 [pageup]： 向上翻動一頁 F 類似 tail -f 的效果，讀取寫入文件的最新內容， 按 ctrl+C 停止。 v 使用配置的編輯器進入編輯模式， shift+ZZ 保存退出到 less 查看模式。 g 移動到第一行 G 移動到最後一行 \u0026amp;pattern 僅顯示匹配模式的行，而不是整個文件 ma 使用 a 標記文本的當前位置 \u0026lsquo;a 導航到標記 a 處 :n 切換到下一個文件 :p 切換到上一個文件 基本操作 less test ","permalink":"https://sz9751210.github.io/posts/linux-less/","summary":"👨‍💻簡介 less 用途：對文件或其它輸出進行分頁顯示的工具，可查看壓縮檔 語法 less [OPTIONS] fileName 參數 參數 說明 -b \u0026lt;緩衝區大小\u0026gt; 設置緩衝區的大小 -e 當文件顯示結束後，自動離開 -f 強迫打開特殊文件，例如外圍設備代號、目錄和二進制文件 -g 只標誌最後搜索的關鍵詞 -i 忽略搜索時的大小寫 -m 顯示類似more指令的百分比 -N 顯示每行的行號 -o \u0026lt;文件名\u0026gt; 將less 輸出的內容在指定文件中保存起來 -Q 不使用警告音 -s 顯示連續空行為一行 -S 行過長時間將超出部分捨棄 -x \u0026lt;數字\u0026gt; 將「tab」鍵顯示為規定的數字空格 less模式下 用法 說明 /字符串 向下搜索「字符串」的功能 ?字符串 向上搜索「字符串」的功能 n 重複前一個搜索（與 / 或 ? 有關） N 反向重複前一個搜索（與 / 或 ? 有關） b 向後翻一頁 d 向後翻半頁 h 顯示幫助界面 q/ZZ 退出less 指令 u 向前滾動半頁 y 向前滾動一行 空格鍵 滾動一頁 回車鍵 滾動一行 j 下一行 k 上一行 [pagedown]： 向下翻動一頁 [pageup]： 向上翻動一頁 F 類似 tail -f 的效果，讀取寫入文件的最新內容， 按 ctrl+C 停止。 v 使用配置的編輯器進入編輯模式， shift+ZZ 保存退出到 less 查看模式。 g 移動到第一行 G 移動到最後一行 \u0026amp;pattern 僅顯示匹配模式的行，而不是整個文件 ma 使用 a 標記文本的當前位置 \u0026lsquo;a 導航到標記 a 處 :n 切換到下一個文件 :p 切換到上一個文件 基本操作 less test ","title":"Linux 分頁查看檔案[less]"},{"content":"👨‍💻簡介 tail 用途：印出結尾，與 head 相法的功用 語法 tail [option] [fileName] 參數 參數 說明 -n \u0026lt;行數\u0026gt; 顯示尾部 N 行的訊息 (N 為數字) -c \u0026lt;字節數\u0026gt; 顯示尾部倒數 N bytes 的字元 (N 為數字) -q 隱藏文件名 -v 顯示文件名 -f 循環讀取，持續監看最新追加的內容，常用於查閱正在改變的日誌文件。 基本操作 假設有一個檔案 tail_test 長這樣\ntest1 test2 test3 查看後 2 行 tail -n 2 head_test # output test2 test3 查看後兩個字 head -c 2 tail_test # output t3% 顯示文件名 tail -v tail_test # output ==\u0026gt; tail_test \u0026lt;== test1 test2 test3 相關指令(可選) grep sort ","permalink":"https://sz9751210.github.io/posts/linux-tail/","summary":"👨‍💻簡介 tail 用途：印出結尾，與 head 相法的功用 語法 tail [option] [fileName] 參數 參數 說明 -n \u0026lt;行數\u0026gt; 顯示尾部 N 行的訊息 (N 為數字) -c \u0026lt;字節數\u0026gt; 顯示尾部倒數 N bytes 的字元 (N 為數字) -q 隱藏文件名 -v 顯示文件名 -f 循環讀取，持續監看最新追加的內容，常用於查閱正在改變的日誌文件。 基本操作 假設有一個檔案 tail_test 長這樣\ntest1 test2 test3 查看後 2 行 tail -n 2 head_test # output test2 test3 查看後兩個字 head -c 2 tail_test # output t3% 顯示文件名 tail -v tail_test # output ==\u0026gt; tail_test \u0026lt;== test1 test2 test3 相關指令(可選) grep sort ","title":"Linux 查看結尾文字[tail]"},{"content":"👨‍💻簡介 head 用途：用來顯示開頭的文字區塊，看該檔案頭部 (預設為 10 行) 語法 head [option] [fileName] 參數 參數 說明 -n \u0026lt;行數\u0026gt; 顯示前 N 行的訊息 (N 為數字) -c \u0026lt;字節數\u0026gt; 顯示前 N bytes 的字元 (N 為數字) -q 隱藏文件名 -v 顯示文件名 基本操作 假設有一個檔案 head_test 長這樣\ntest1 test2 test3 查看前 2 行 head -n 2 head_test # output test1 test2 查看前兩個字 head -c 2 head_test # output te% 顯示文件名 head -v head_test # output ==\u0026gt; head_test \u0026lt;== test1 test2 test3 ","permalink":"https://sz9751210.github.io/posts/linux-head/","summary":"\u003ch2 id=\"簡介\"\u003e👨‍💻簡介\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003ehead\u003c/li\u003e\n\u003cli\u003e用途：用來顯示開頭的文字區塊，看該檔案頭部 (預設為 10 行)\u003c/li\u003e\n\u003c/ul\u003e","title":"Linux 查看開頭文字[head]"},{"content":"👨‍💻簡介 cat 用途：查看文件，把檔案串連接後傳到基本輸出 語法 cat [-AbeEnstTuv] [--help] [--version] fileName 參數 參數 說明 -A, \u0026ndash;show-all 等價於-vET -b, \u0026ndash;number-nonblank 和 -n 相似，只不過對於空白行不編號 -e 等價於-vE -E, \u0026ndash;show-ends 在每一行末端加入$ -n, \u0026ndash;number 由 1 開始對所有輸出的行數編號 -s, \u0026ndash;squeeze-blank 當遇到有連續兩行以上的空白行，就代換為一行的空白行 -t 等價於-vT -T, \u0026ndash;show-tabs 以^I 取代 TAB -u 輸出時不必經過緩衝區。（原來是預設為使用緩衝區）。 -v, \u0026ndash;show-nonprinting 除了 LFD 及 TAB 之外，使用^及 M-表示法顯示字元 \u0026ndash;help 列出幫助資訊 \u0026ndash;version 列出版本資訊 基本操作 查看檔案 cat test1 查看檔案並顯示行號 假設有個檔案test2長這樣\ntest1 test2 cat -n test2 # ountput 1 test1 2 3 4 test2 如果要對空白行取消編號的話可改用-b選項\ncat -b test2 # ountput 1 test1 2 test2 如果要把一行以上的空白行合併為一行可使用-s選項\ncat -s test2 # output aaa bbb ","permalink":"https://sz9751210.github.io/posts/linux-cat/","summary":"\u003ch2 id=\"簡介\"\u003e👨‍💻簡介\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003ecat\u003c/li\u003e\n\u003cli\u003e用途：查看文件，把檔案串連接後傳到基本輸出\u003c/li\u003e\n\u003c/ul\u003e","title":"Linux 查看檔案[cat]"},{"content":"👨‍💻簡介 chown(change owner) 用途：變更文件或目錄的權限 語法 chmod [OPTIONS] [user:group] file or dir 參數 參數 說明 -c, \u0026ndash;changes 效果類似-v，但僅回傳更改的部分 -f, \u0026ndash;silent, \u0026ndash;quiet 不顯示錯誤訊息 -v, \u0026ndash;verbose 顯示指令執行過程 \u0026ndash;dereference 效果和-h參數相同 -h, \u0026ndash;no-dereference 只對軟連結的文件做修改，而不更動其它任何相關文件 \u0026ndash;from=CURRENT_OWNER:CURRENT_GROUP 確認修改前的擁有者及所屬群組正確才進行修改 \u0026ndash;no-preserve-root do not treat \u0026lsquo;/\u0026rsquo; specially (the default) \u0026ndash;preserve-root fail to operate recursively on \u0026lsquo;/\u0026rsquo; \u0026ndash;reference=RFILE 把指定文件或目錄的擁有者與所屬群組全都改成和參考文件或目錄一樣 -R, \u0026ndash;recursive 遞歸處理，將指定目錄下的所有文件以及子目錄一併處理 -H if a command line argument is a symbolic link to a directory, traverse it -L traverse every symbolic link to a directory encountered -P do not traverse any symbolic links (default) 基本操作 將檔案或目錄修改擁有者 chown alan file1 將檔案或目錄修改所屬群組 chown :alangroup file1 同時修改擁有者及所屬組 chown alan:alangroup file1 遞歸修改整個資料夾裡的所有檔案 chown -R alan:alangroup dir 顯示執行結果 chown -v alan:alangroup file1 不顯示錯誤訊息 chown -f alan:alangroup file1 參考文件屬性進行修改 chown --reference=reffile file1 事先確認擁有者與群組在進行修改 chown --from=root:root alan:alangroup file1 只確認擁有者或是群組 # 只確認擁有者 chown --from=root alan:alangroup file1 # 只確認所屬組 chown --from=:root alan:alangroup file1 參考資料 Linux 更改檔案擁有者與群組，chown 指令使用教學與範例 - G. T. Wang (gtwang.org) ","permalink":"https://sz9751210.github.io/posts/linux-chown/","summary":"👨‍💻簡介 chown(change owner) 用途：變更文件或目錄的權限 語法 chmod [OPTIONS] [user:group] file or dir 參數 參數 說明 -c, \u0026ndash;changes 效果類似-v，但僅回傳更改的部分 -f, \u0026ndash;silent, \u0026ndash;quiet 不顯示錯誤訊息 -v, \u0026ndash;verbose 顯示指令執行過程 \u0026ndash;dereference 效果和-h參數相同 -h, \u0026ndash;no-dereference 只對軟連結的文件做修改，而不更動其它任何相關文件 \u0026ndash;from=CURRENT_OWNER:CURRENT_GROUP 確認修改前的擁有者及所屬群組正確才進行修改 \u0026ndash;no-preserve-root do not treat \u0026lsquo;/\u0026rsquo; specially (the default) \u0026ndash;preserve-root fail to operate recursively on \u0026lsquo;/\u0026rsquo; \u0026ndash;reference=RFILE 把指定文件或目錄的擁有者與所屬群組全都改成和參考文件或目錄一樣 -R, \u0026ndash;recursive 遞歸處理，將指定目錄下的所有文件以及子目錄一併處理 -H if a command line argument is a symbolic link to a directory, traverse it -L traverse every symbolic link to a directory encountered -P do not traverse any symbolic links (default) 基本操作 將檔案或目錄修改擁有者 chown alan file1 將檔案或目錄修改所屬群組 chown :alangroup file1 同時修改擁有者及所屬組 chown alan:alangroup file1 遞歸修改整個資料夾裡的所有檔案 chown -R alan:alangroup dir 顯示執行結果 chown -v alan:alangroup file1 不顯示錯誤訊息 chown -f alan:alangroup file1 參考文件屬性進行修改 chown --reference=reffile file1 事先確認擁有者與群組在進行修改 chown --from=root:root alan:alangroup file1 只確認擁有者或是群組 # 只確認擁有者 chown --from=root alan:alangroup file1 # 只確認所屬組 chown --from=:root alan:alangroup file1 參考資料 Linux 更改檔案擁有者與群組，chown 指令使用教學與範例 - G.","title":"Linux 修改目錄權限[chown]"},{"content":"👨‍💻簡介 幫自己紀錄一下如何處理linux機器的指標\nCPU top(交互模式) top P b x y top(預設指定CPU) top -o %CPU ps ps aux --sort -pcpu MEM top top M b x y top(預設指定MEM) top -o %MEM ps ps aux --sort -pmem swap free free -h vmstat vmstat swapon swapon -s proc_file cat /proc/swaps shell for file in /proc/*/status ; do awk \u0026#39;/VmSwap|Name/{printf $2 \u0026#34; \u0026#34; $3}END{ print \u0026#34;\u0026#34;}\u0026#39; $file; done | sort -k 2 -n -r | less 參考資料 8 Useful Commands to Monitor Swap Space Usage in Linux (tecmint.com) Linux Find Out What Process Are Using Swap Space - nixCraft (cyberciti.biz) 筆記: Linux 建立 Swap, 以及 Swap 使用狀況監控, OOM @mini box 迷你盒子 - nidBox親子盒子 Linux 查看正在吃 swap 的程式 – Tsung\u0026rsquo;s Blog (longwin.com.tw) disk df df -h du du -shc /path/* du -h -x --max-depth=1 conn netstat # 查看80 port的總連線數 netstat -na | grep 80 | wc -l # 統計連線的ip netstat -ntu | grep ESTAB | awk \u0026#39;{print $5}\u0026#39; | cut -d: -f1 | sort | uniq -c | sort -nr ","permalink":"https://sz9751210.github.io/posts/%E7%B3%BB%E7%B5%B1%E7%95%B0%E5%B8%B8%E6%8C%87%E6%A8%99%E9%99%A4%E9%8C%AF/","summary":"\u003ch2 id=\"簡介\"\u003e👨‍💻簡介\u003c/h2\u003e\n\u003cp\u003e幫自己紀錄一下如何處理linux機器的指標\u003c/p\u003e","title":"系統異常指標除錯"},{"content":"📔心得 之前因為常需要跑devops相關工具，因此開發環境完全是用Ubuntu的圖形化介面，但偶爾會遇到一些延遲以及小bug，偶然的機會下發現在windows設定git-bash似乎也能達到一樣的效果，也能順便增加對windows開發人員生態系的了解，因此本篇主要是針對如何設定美麗的terminal以及vscode也整合，紀錄一下以便日後查詢\n👨‍💻簡介 欲安裝項目\nwindows terminal git-bash zsh oh-my-zsh p10k plugins 🎯setup 安裝windows terminal 點開市集搜尋windows terminal，windows 11用戶預設已安裝\n安裝git-bash for windows 到官網下載windows版本，需注意記得打勾git-bash for windows terminal\n安裝zsh 去msys2下載zsh的二進制檔案\n解壓縮並複製zsh覆蓋到git安裝目錄\noh-my-zsh 安裝oh-my-zsh 打開git-bash輸入以下指令進行安裝\nsh -c \u0026#34;$(curl -fsSL https://raw.githubusercontent.com/ohmyzsh/ohmyzsh/master/tools/install.sh)\u0026#34; 設定預設啟動zsh 在家目錄新增.bashrc，以我的範例為C:\\Users\\alan\\.bashrc，把以下的code貼上\nif [ -t 1 ]; then exec zsh fi p10k 安裝相對應字體 這邊使用FireCode當做範例，下載好後解壓縮並安裝 🔗下載連結 \u0026ndash;\u0026gt; Nerd Fonts - Iconic font aggregator, glyphs/icons collection, \u0026amp; fonts patcher\n打開終端機並選擇設定，選擇git-bash -\u0026gt; 外觀 -\u0026gt; 字體，選擇FiraCode NF\n安裝p10k 透過git下載p10k到家目錄下\ngit clone --depth=1 https://github.com/romkatv/powerlevel10k.git ${ZSH_CUSTOM:-$HOME/.oh-my-zsh/custom}/themes/powerlevel10k 修改~/.zshrc的ZSH_THEME\n設定p10k 重新讀取zsh 設定檔\nsource ~/.zshrc 會進入p10k的樣式設定，這時候樣式都會正常，因為前面已經安裝相對應的字體，\n接著就按照說明完成樣式設定，就能開始享受在linux環境下幾乎一樣的終端機體驗🚀\n安裝插件 zsh-syntax-highlighting 語法高亮 官方安裝指南\ngit clone https://github.com/zsh-users/zsh-syntax-highlighting.git ${ZSH_CUSTOM:-~/.oh-my-zsh/custom}/plugins/zsh-syntax-highlighting 在.zshrc加入插件\nzsh-autosuggestions 自動補全 官方安裝指南\ngit clone https://github.com/zsh-users/zsh-autosuggestions ${ZSH_CUSTOM:-~/.oh-my-zsh/custom}/plugins/zsh-autosuggestions 在.zshrc加入插件\n插件都安裝好後就重載設定檔即可\n","permalink":"https://sz9751210.github.io/posts/windows-terminal-setup/","summary":"\u003ch2 id=\"心得\"\u003e📔心得\u003c/h2\u003e\n\u003cp\u003e之前因為常需要跑devops相關工具，因此開發環境完全是用Ubuntu的圖形化介面，但偶爾會遇到一些延遲以及小bug，偶然的機會下發現在windows設定git-bash似乎也能達到一樣的效果，也能順便增加對windows開發人員生態系的了解，因此本篇主要是針對如何設定美麗的terminal以及vscode也整合，紀錄一下以便日後查詢\u003c/p\u003e\n\u003ch2 id=\"簡介\"\u003e👨‍💻簡介\u003c/h2\u003e\n\u003cp\u003e欲安裝項目\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003ewindows terminal\u003c/li\u003e\n\u003cli\u003egit-bash\u003c/li\u003e\n\u003cli\u003ezsh\u003c/li\u003e\n\u003cli\u003eoh-my-zsh\u003c/li\u003e\n\u003cli\u003ep10k\u003c/li\u003e\n\u003cli\u003eplugins\u003c/li\u003e\n\u003c/ul\u003e","title":"windows terminal + git-bash + zsh + oh-my-zsh"},{"content":"📔心得 之前都介紹docker監控container，這次來點不一樣的，直接裝在k8s裡面去監控pod的一些指標。\n基本的指標像是cpu, mem, pod數量, node數量等等，都能透過kube-state-metrics完成，而如果想要監控一些流量的指標，像是tcp連線數，tw數等，則是需要另外在服務的pod裡另外寫node-exporter的container，組成side-car的形式，讓exporter將指標送往prometheus。\n在撰寫的過程，遇到比較大的難題是prometheus的config檔撰寫，一開始打算使用docker-compose的方式起monitor服務，然後去call k8s cluster取得相關指標，但常常call不到服務，可能是因為minikube的關係，在本地也跑docker，最後改成直接安裝在k8s裡面，另外建立一個namespace放監控相關的服務，有機會在測試kind以及k3s。\ndemo用的deploy使用skaffold這本地開發k8s的神器，搭配kustomize可讓我依據所需測試的環境下去做自動佈署，有機會再另外介紹這工具。\n之後預計會再新增prometheus adapter，讓我的prometheus metrics可以成為我hpa的擴縮判斷，因為基本的hpa指標只有cpu以及mem，如果可以依照網路流量變大，幫我擴展pod，當流量變小時幫我縮pod，讓我能自定義指標，相信使用k8s的效益會更大。\n🔗詳細專案位置 \u0026ndash;\u0026gt; https://github.com/sz9751210/k8s-monitor\n👨‍💻簡介 在minikube環境下安裝prometheus以及grafana監控 k8s\ndemo-deploy：測試用deployment 使用skaffold搭配kustomize的方式下去佈署 prometheus, kube-state-metrics：撈取服務相關指標 grafana：監控UI 🎯setup start minikube minikube start deploy demo-deployment cd demo-deploy \u0026amp;\u0026amp; skaffold run -p prod install monitor sh ./install_monitor.sh setting data source 使用上面執行完的grafana url http://192.168.x.x:xxx 輸入帳號密碼：admin 選擇data source -\u0026gt; add data source -\u0026gt; prometheus url設定為http://prometheus:9090 -\u0026gt; 點擊save import grafana ui 點擊左上角回到首頁並選擇旁邊的dashboard -\u0026gt; import 到grafana/dashboard/複製dashboard.json貼到grafana並點擊load -\u0026gt; import ✅TODO 使用壓測pod去測試hpa 使用prometheus-adapter自定義指標 ","permalink":"https://sz9751210.github.io/posts/k8s-monitor/","summary":"\u003ch2 id=\"心得\"\u003e📔心得\u003c/h2\u003e\n\u003cp\u003e之前都介紹docker監控container，這次來點不一樣的，直接裝在k8s裡面去監控pod的一些指標。\u003c/p\u003e\n\u003cp\u003e基本的指標像是cpu, mem, pod數量, node數量等等，都能透過kube-state-metrics完成，而如果想要監控一些流量的指標，像是tcp連線數，tw數等，則是需要另外在服務的pod裡另外寫node-exporter的container，組成side-car的形式，讓exporter將指標送往prometheus。\u003c/p\u003e\n\u003cp\u003e在撰寫的過程，遇到比較大的難題是prometheus的config檔撰寫，一開始打算使用docker-compose的方式起monitor服務，然後去call k8s cluster取得相關指標，但常常call不到服務，可能是因為minikube的關係，在本地也跑docker，最後改成直接安裝在k8s裡面，另外建立一個namespace放監控相關的服務，有機會在測試kind以及k3s。\u003c/p\u003e\n\u003cp\u003edemo用的deploy使用skaffold這本地開發k8s的神器，搭配kustomize可讓我依據所需測試的環境下去做自動佈署，有機會再另外介紹這工具。\u003c/p\u003e\n\u003cp\u003e之後預計會再新增prometheus adapter，讓我的prometheus metrics可以成為我hpa的擴縮判斷，因為基本的hpa指標只有cpu以及mem，如果可以依照網路流量變大，幫我擴展pod，當流量變小時幫我縮pod，讓我能自定義指標，相信使用k8s的效益會更大。\u003c/p\u003e\n\u003cp\u003e🔗詳細專案位置 \u0026ndash;\u0026gt; \u003ca href=\"https://github.com/sz9751210/k8s-monitor\"\u003ehttps://github.com/sz9751210/k8s-monitor\u003c/a\u003e\u003c/p\u003e","title":"K8S-monitor"},{"content":"📚讀後心得 當初在研究Elastic Stack，ILM這部份還不熟時，剛好搜尋到喬叔的鐵人賽文章，閱讀時彷彿挖到了寶，對於Index的管理講解得非常透徹，從Index如何被建立，使用Template以及Alias，再到導入ILM以及搭配Rollover以及Shrink等方式達到索引、搜尋、儲存等最佳化，一步一步穩定順利的完成，真的很感動。\n之前使用Elastic Stack並沒有使用到ILM的配置，所以單個Index可能會超過官方建議的大小，並且使用的是以一天為單位，但實務上並非每個服務都是固定的大小，因此導入ILM對於整體的效能會有更好的幫助，並且使用三溫暖架構，讓最新的log都放在效能較好的機器上，較舊的log則隨著自定義的時間轉移到效能較差的機器上，讓搜尋能有更好的體驗。\n而Rollover的使用，當資料量達到設定的條件、或是時間過太久，將Index進行rotate，產生新的Index來接收新的資料，讓原先的Index依照ILM的設定進入下一個warm phase階段。\nForce Merge以及Shrink則是針對Segment Files數量以及Shards數量進行合併達到最佳化，Segment files的單檔愈大，總數愈少，空間使用率愈好，而已刪除的文件，會是透過「標示為刪除」的方式紀錄在新的Segment File，並且會等到merge時才真正的刪除，因此Force Merge將Shard中的Segment Files進行合併，可以釋放被標記要被刪除的文件在原先是read-only的Segment File所佔用的空間，藉此提升搜尋效率，；而Shrink則是減少Shards的數量，變少的規則是原先數值的因數，減少Shard的數量，增加Shard的大小，好處是可以提升搜尋的效率，儲存利用率也會較佳，壞處是如果Cluster rebalancing時成本較高，並且會限制資料被分散處理的能力，因此建議使用在較舊的資料上下去做優化處理。\n書中還有提到很多最佳化的技巧，例如Shards建議的大小、memory cache的建議大小、Indexing大量資料時的處理方式等等，各種神奇的優化技巧可以讓你針對自己的使用情境下去做測試以及改善，讓你的Elastic Stack頭好壯壯，最後也感謝喬叔的經驗分享，讓我在研究Elastic Stack上少走了很多彎路，底下會放上鐵人賽的連結。\n🔗【喬叔帶你上手Elastic Stack】總目錄 \u0026ndash;\u0026gt; https://ithelp.ithome.com.tw/users/20129543/ironman/3148\n","permalink":"https://sz9751210.github.io/posts/%E5%96%AC%E5%8F%94%E5%B8%B6%E4%BD%A0%E4%B8%8A%E6%89%8Belastic-stackelasticsearch%E7%9A%84%E6%9C%80%E4%BD%B3%E5%AF%A6%E8%B8%90%E8%88%87%E6%9C%80%E4%BD%B3%E5%8C%96%E6%8A%80%E5%B7%A7/","summary":"\u003ch2 id=\"讀後心得\"\u003e📚讀後心得\u003c/h2\u003e\n\u003cp\u003e當初在研究Elastic Stack，ILM這部份還不熟時，剛好搜尋到喬叔的鐵人賽文章，閱讀時彷彿挖到了寶，對於Index的管理講解得非常透徹，從Index如何被建立，使用Template以及Alias，再到導入ILM以及搭配Rollover以及Shrink等方式達到索引、搜尋、儲存等最佳化，一步一步穩定順利的完成，真的很感動。\u003c/p\u003e\n\u003cp\u003e之前使用Elastic Stack並沒有使用到ILM的配置，所以單個Index可能會超過官方建議的大小，並且使用的是以一天為單位，但實務上並非每個服務都是固定的大小，因此導入ILM對於整體的效能會有更好的幫助，並且使用三溫暖架構，讓最新的log都放在效能較好的機器上，較舊的log則隨著自定義的時間轉移到效能較差的機器上，讓搜尋能有更好的體驗。\u003c/p\u003e","title":"喬叔帶你上手Elastic Stack：Elasticsearch的最佳實踐與最佳化技巧"},{"content":"👀QUICK REVIEW The book in 3 Sentences 用三段話說明這本書的內容1\n像管理公司一樣管理自己，像享受遊戲一樣享受生活 硬實力決定起點，軟實力決定能走多快多遠 Learning, Doing, Learning and Teaching Purpose of the book 書的目的\n教導你如何成為全方位的軟體開發人員 期望給你各方面有用、實用又可用的忠告。 告訴你軟技能的重要性 My Top 3 Quotes 我最喜歡的 3 句 Quotes\n越努力將船駛向失敗，從相反方向吹來的成功之風就越強 唯有讓我參與其中，才是真正的學習 信念轉成思想 思想化作文字 文字觸發行動 行動成為習慣 習慣建立價值 價值決定命運 📚讀後心得 本書不教你寫程式，教導你程式以外的實用技能，讓你知道一名成功的軟體開發人員，不能只會寫code，還要有精彩的人生。\n書中作者很系統的歸納了程序員職業發展的方方面面，包括職業目標、公司選擇、如何學習、如何理財、健康和精神、自我認知等等，或許其中的一些觀點之前都零散的接觸過，這裡作者能結合自己的經驗，將這些話題一一展開，，並且引發了我更多的思考，而這些思考，將貫穿我整個職業生涯乃至人生。\n全文總共分為如下幾個方面：\n職業：職業的各個方面，包括面試，辭職，個人創業。把自己當成一家公司看待，不過我們這家公司只為一個客戶服務，就是我們工作的單位。 自我行銷：包括行銷重要性，一致性，網絡行銷等。 學習：十步學習法。尋找導師\u0026amp;\u0026amp;成為導師。 生產力：番茄鐘，定量執行法。也從科學的角度解釋瞭如何更有生產力。 理財：觀念大多數來自其他理財書籍。例如窮爸爸富爸爸。 健身：健身重要性。以及應該用上科技工具。 心靈：講述如何保持正面心態，擁抱失敗，跳脫舒適圈。 讀這本書最有感的地方是學習的篇章，作者提出的十步驟學習法讓我印象深刻，重點如下\n要先知道全貌，有初步的了解，然後決定想學習範圍，並把大主題拆成小主題，方便設定目標。 透過設定的目標，尋找相關的資源，並建立學習計劃。 對自己的目標學習最小量的知識，足以讓接下來的實作可完成。 實作當作是玩玩具，邊動手操作邊玩邊學，儘可能讓自己所設定的目標，學習計劃都使用上，做一個小小的專題，增加對自己所學的瞭解。 把自己所學到的知識，用自己的話講出來，化輸入為輸出。 另外還有生產力那個章節，番茄鐘的使用也讓我很有共鳴，利用番茄鐘工作法，可以知道自己的生產力落在哪個範圍，畢竟我們一天的專注力有限，如何分配事情的先後順序變得更為重要。\n","permalink":"https://sz9751210.github.io/posts/soft-skills-%E8%BB%9F%E5%AF%A6%E5%8A%9B%E8%BB%9F%E9%AB%94%E9%96%8B%E7%99%BC%E4%BA%BA%E5%93%A1%E7%9A%84%E7%94%9F%E5%AD%98%E6%89%8B%E5%86%8A/","summary":"\u003ch2 id=\"quick-review\"\u003e👀QUICK REVIEW\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003eThe book in 3 Sentences 用三段話說明這本書的內容1\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e像管理公司一樣管理自己，像享受遊戲一樣享受生活\u003c/li\u003e\n\u003cli\u003e硬實力決定起點，軟實力決定能走多快多遠\u003c/li\u003e\n\u003cli\u003eLearning, Doing, Learning and Teaching\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003ePurpose of the book 書的目的\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e教導你如何成為全方位的軟體開發人員\u003c/li\u003e\n\u003cli\u003e期望給你各方面有用、實用又可用的忠告。\u003c/li\u003e\n\u003cli\u003e告訴你軟技能的重要性\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eMy Top 3 Quotes 我最喜歡的 3 句 Quotes\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e越努力將船駛向失敗，從相反方向吹來的成功之風就越強\u003c/li\u003e\n\u003cli\u003e唯有讓我參與其中，才是真正的學習\u003c/li\u003e\n\u003cli\u003e信念轉成思想 思想化作文字 文字觸發行動 行動成為習慣 習慣建立價值 價值決定命運\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e","title":"Soft Skills 軟實力｜軟體開發人員的生存手冊"},{"content":"📔心得 最近，我在探索 Ansible 自動化工具的過程中，決定運用它來建立 ELK Stack，這是我之前使用 Docker 建立的經驗的延伸。在這個過程中，我想分享一下我的學習心得。\n尋找資源 我開始了解 ELK Stack 的安裝過程，首先閱讀了官方文件，熟悉了整個設置流程。接著，我尋找 Ansible 中相關的模組，這讓我更好地理解如何在 Ansible 中實現相同的步驟。\n目錄結構的重要性 在撰寫 Ansible Playbook 過程中，我學到了良好的目錄結構是多麼重要。我從最初只有一個主要的 main.yml 開始，逐漸分解出根目錄下的多個 .yml 檔案，然後使用 include 來引入任務。這種結構讓整個 Playbook 更加模組化，易於管理。\n使用模板和變數 在創建模板時，我發現了 Jinja2 語法的威力。我可以直接套用變數，這讓我的模板在複製到目標主機時能自動載入所需的參數。此外，我還學會了如何根據我的主機清單（inventory）來動態設定這些參數，這真是強大的功能。\n感謝凍仁大的指南 我要特別感謝凍仁大（作者）的 Ansible 教程，我從他的 Ansible GitBook 中學到了許多寶貴的資訊。他的教程簡潔明瞭，對於初學者也非常友好。他的教程甚至提供了 Ansible 在使用 Docker Compose 方面的實際練習，這讓我能更好地掌握 Ansible 的操作技巧。另外，使用 Jupyter Notebook 執行 Ansible 模組也讓我的學習過程更加便利。\n如果你對於 Ansible 自動化配置技巧感興趣，我推薦你閱讀這份凍仁大的 Ansible 指南，連結在下方：\n🔗凍仁大ansible指南 \u0026ndash;\u0026gt; 現代 IT 人一定要知道的 Ansible 自動化組態技巧\n此外，我還將我使用 Ansible 建立 ELK Stack 的 Playbook 放在了以下的 GitHub 倉庫，歡迎參考：\n🔗Ansible-ELK repo \u0026ndash;\u0026gt; Ansible-ELK\n這次的學習讓我更深入地理解了自動化的價值，也讓我更有信心在日後的專案中運用 Ansible 來簡化配置流程。\n👨‍💻簡介 在 GCP 環境下使用 Ansible Playbook 建立 ELK Stack\nElasticsearch：主要會先需要先跑init master，接著再去跑seed host去加入master組成cluster架構，邏輯上還有可修改的地方，目前先以兩份yaml分開跑下去做建立，在跑完init master後會先建立iim以及index template Logstash：直接將pipeline等設定直接複製到主機中。 Kibana：設定與 Elasticsearch 的連接資訊。 📁資料夾結構 . ├── create_elasticsearch_master_instance.yaml ├── create_elasticsearch_slave_instance.yaml ├── create_filebeat_instance.yaml ├── create_kibana_instance.yaml ├── create_logstash_instance.yaml ├── files │ ├── elasticsearch │ │ ├── api.sh │ │ ├── certs │ │ └── elasticsearch.repo │ ├── kibana │ │ └── kibana.repo │ └── logstash │ ├── conf.d │ │ └── logstash.conf │ ├── logstash.repo │ ├── logstash.yml │ └── pipelines.yml ├── group_vars │ └── all │ ├── env.yml copy.example │ └── package.yml ├── inventory │ └── elk.test.node ├── inventory.instance.create.yml.example ├── README.md ├── roles │ ├── elasticsearch │ │ ├── tasks │ │ │ ├── create_disk.yml │ │ │ ├── install_elastic.yml │ │ │ ├── main.yml │ │ │ ├── setup_disk.yml │ │ │ ├── setup_elastic_master.yml │ │ │ └── setup_elastic_slave.yml │ │ └── templates │ │ └── elasticsearch.yml.j2 │ ├── instance │ │ └── tasks │ │ ├── create.yml │ │ └── setup.yml │ ├── kibana │ │ ├── tasks │ │ │ └── main.yml │ │ └── templates │ │ └── kibana.yml.j2 │ └── logstash │ └── tasks │ └── main.yml └── vars ├── elasticsearch │ ├── elasticsearch_var.yml │ └── elasticsearch_var.yml.example ├── instance │ ├── instance_var.yml │ └── instance_var.yml.example ├── kibana │ ├── kibana_var.yml │ └── kibana_var.yml.example └── logstash ├── logstash_var.yml └── logstash_var.yml.example 🔰基礎介紹 設定機器資訊：複製好inventory.instance.create.yml.example後，可參考inventory裡的設定，主要設定gcp的資訊，elasticsearch的node_role為data_role，可參考以下連結 Elasticsearch Multi-Tier Architecture | Hot, Warm, Cold \u0026amp; Frozen\n設定group_vars的env.yml，改成自己的gcp的專案以及要設定的region\n設定vars裡的相對yml，可參考範例\nelasticsearch：主要設定掛載的硬碟資訊 kibana,logstash：設定elasticsearch的host資訊 🎯setup elasticsearch_master -\u0026gt; elasticsearch_slave -\u0026gt; logstash -\u0026gt; kibana\n指令 ANSIBLE_HOST_KEY_CHECKING=False ansible-playbook -i inventory.instance.create.yml create_xxx_instance.yaml -v golang ✅TODO elasticsearch playbook 優化 添加filebeat role disk 修改建置資料夾 ","permalink":"https://sz9751210.github.io/posts/ansible-elk/","summary":"📔心得 最近，我在探索 Ansible 自動化工具的過程中，決定運用它來建立 ELK Stack，這是我之前使用 Docker 建立的經驗的延伸。在這個過程中，我想分享一下我的學習心得。\n尋找資源 我開始了解 ELK Stack 的安裝過程，首先閱讀了官方文件，熟悉了整個設置流程。接著，我尋找 Ansible 中相關的模組，這讓我更好地理解如何在 Ansible 中實現相同的步驟。\n目錄結構的重要性 在撰寫 Ansible Playbook 過程中，我學到了良好的目錄結構是多麼重要。我從最初只有一個主要的 main.yml 開始，逐漸分解出根目錄下的多個 .yml 檔案，然後使用 include 來引入任務。這種結構讓整個 Playbook 更加模組化，易於管理。\n使用模板和變數 在創建模板時，我發現了 Jinja2 語法的威力。我可以直接套用變數，這讓我的模板在複製到目標主機時能自動載入所需的參數。此外，我還學會了如何根據我的主機清單（inventory）來動態設定這些參數，這真是強大的功能。\n感謝凍仁大的指南 我要特別感謝凍仁大（作者）的 Ansible 教程，我從他的 Ansible GitBook 中學到了許多寶貴的資訊。他的教程簡潔明瞭，對於初學者也非常友好。他的教程甚至提供了 Ansible 在使用 Docker Compose 方面的實際練習，這讓我能更好地掌握 Ansible 的操作技巧。另外，使用 Jupyter Notebook 執行 Ansible 模組也讓我的學習過程更加便利。\n如果你對於 Ansible 自動化配置技巧感興趣，我推薦你閱讀這份凍仁大的 Ansible 指南，連結在下方：\n🔗凍仁大ansible指南 \u0026ndash;\u0026gt; 現代 IT 人一定要知道的 Ansible 自動化組態技巧\n此外，我還將我使用 Ansible 建立 ELK Stack 的 Playbook 放在了以下的 GitHub 倉庫，歡迎參考：","title":"在 GCP 環境下使用 Ansible 自動化建立 ELK Stack"},{"content":"👀QUICK REVIEW The book in 3 Sentences 用三段話說明這本書的內容\n為了學習而寫 闡述是最有效的學習方法 簡要記述內容中提出的主要想法，而不是蒐集引文，並努力思考與其他不同內容的想法連結再一起 Purpose of the book 書的目的\n提供大腦一個外部記憶體去儲存細節與參考資料，讓大腦能專注在發揮創造力與深入的學習 透過原子性將多個重點的大筆記拆解成像是卡片一樣的小筆記 具有連結性，將各個小筆記的點透過關聯性連結成大筆記 My Top 3 Quotes 我最喜歡的 3 句 Quotes\n如果你無法清楚地說出來，你就無法真正的理解 人必須要找出想法的不同之處，掌握其中的差異，不管這些差異式很明顯可見，還是隱藏在概念裡 正確的學習代表的是理解，而理解是指用有意義的方式，連接到已知的知識 📚讀後心得 《 卡片盒筆記：最高效思考筆記術，德國教授超強秘技，促進寫作、學習與思考，使你洞見源源不斷，成為專家 》\n從以前做筆記都是使用資料夾的分類邏輯，接著會碰到如果一篇筆記有兩種以上的概念時，要如何去分類，這問題也是困擾了我很久，在網路上搜尋筆記法，剛好看到obsidian這套軟體，他裏面的反向連結功能真的太強大了，讓我能透過索引的方式去整理我的筆記，讓我的大腦可以更專注在眼前的任務上，也很感謝朱騏老師，在鐵人邦的obsidian系列文幫助了我很多，讓我做筆記有很多的改變，連結我會放在最下面。\n這本書讀完後，讓我對於卡片盒筆記法有更深入的瞭解，這本書不僅僅是教導做筆記的方法，而是一個完整的思考、工作流程和有效學習的方法。\n書中有提到蔡加尼克效應：還未完成的工作項目，會佔據我們的短期記憶，直到完成為止。\n要讓我們的大腦停止去想某件工作，不用等到那件工作做完，只要把他們記下來，並讓自己想像「我會去處理」，這樣大腦就會停止去想它了。\n因為大腦無法區別真正已做完以及未完成的事，如果把某件事記下來，就可以把它從大腦中清除掉。讓一個外部系統去儲存那些還沒做完的事情。\n現在做的筆記，觀眾是未來的自己，因為筆記做完不久，就會回到一無所知的狀態，要表達清楚給未來的自己，就需要真正的理解。\n而如何以有意義的方式，將某個訊息連接到其他訊息？\n第一步是思考某訊息，並把他寫出來，接著是思考這個訊息跟其他脈絡有甚麼關聯性。\n大腦與卡片盒的分工，負責細節與參考資料，確保資料保持客觀完整，讓大腦能夠專注在重要的事情上，而大腦負責自由發揮創造力，更深入的學習與整體性的規劃。\n而卡片盒的用意是，問這張卡片的意義為何？為何連接到某事？跟某事差異？它跟甚麼類似？\n只要連結合理，卡片就能彼此連結，所以卡片盒並不是根據主題分類。\n書中還提到過度井然有序會妨礙學習\n書中舉了教導學生認識不同的藝術風格，首先用傳統的方式，把屬於相同藝術風格的多幅繪畫展示給一組學生看，接著刻意打亂藝術風格給另一組學生看，結果反而是各種不同風格繪畫。\n混在一起的那一組學生，更快學會如何分辨不同的藝術風格。這顯示了與其用主題分類，不如表達清楚各種差異和相同之處，強化規類的能力以及創造合理的分類能力。\n本書搭配obsidian真的是一個完美的搭配，很感謝作者以身作則應用卡片盒筆記法的智慧結晶產出此書。\n🔗【Obsidian 使用教學】總目錄 \u0026ndash;\u0026gt; https://reurl.cc/NRZ9bx\n","permalink":"https://sz9751210.github.io/posts/%E5%8D%A1%E7%89%87%E7%9B%92%E7%AD%86%E8%A8%98%E6%9C%80%E9%AB%98%E6%95%88%E6%80%9D%E8%80%83%E7%AD%86%E8%A8%98%E8%A1%93%E5%BE%B7%E5%9C%8B%E6%95%99%E6%8E%88%E8%B6%85%E5%BC%B7%E7%A7%98%E6%8A%80%E4%BF%83%E9%80%B2%E5%AF%AB%E4%BD%9C%E5%AD%B8%E7%BF%92%E8%88%87%E6%80%9D%E8%80%83%E4%BD%BF%E4%BD%A0%E6%B4%9E%E8%A6%8B%E6%BA%90%E6%BA%90%E4%B8%8D%E6%96%B7%E6%88%90%E7%82%BA%E5%B0%88%E5%AE%B6/","summary":"\u003ch2 id=\"quick-review\"\u003e👀QUICK REVIEW\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003eThe book in 3 Sentences 用三段話說明這本書的內容\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e為了學習而寫\u003c/li\u003e\n\u003cli\u003e闡述是最有效的學習方法\u003c/li\u003e\n\u003cli\u003e簡要記述內容中提出的主要想法，而不是蒐集引文，並努力思考與其他不同內容的想法連結再一起\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003ePurpose of the book 書的目的\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e提供大腦一個外部記憶體去儲存細節與參考資料，讓大腦能專注在發揮創造力與深入的學習\u003c/li\u003e\n\u003cli\u003e透過原子性將多個重點的大筆記拆解成像是卡片一樣的小筆記\u003c/li\u003e\n\u003cli\u003e具有連結性，將各個小筆記的點透過關聯性連結成大筆記\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eMy Top 3 Quotes 我最喜歡的 3 句 Quotes\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e如果你無法清楚地說出來，你就無法真正的理解\u003c/li\u003e\n\u003cli\u003e人必須要找出想法的不同之處，掌握其中的差異，不管這些差異式很明顯可見，還是隱藏在概念裡\u003c/li\u003e\n\u003cli\u003e正確的學習代表的是理解，而理解是指用有意義的方式，連接到已知的知識\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e","title":"卡片盒筆記：最高效思考筆記術，德國教授超強秘技，促進寫作、學習與思考，使你洞見源源不斷，成為專家"},{"content":"📔心得 一直以來都在使用container下去跑測試環境，所以都是使用docker指令下去做除錯，最近因緣際會下找到這一款可以透過UI看全部的container狀態，真的覺得好用到爆炸，所以來介紹一下這款容器化管理神器。\n基本上能用docker指令做到的事情，portainer都能做到，像是docker ps，查看所有container，接著點擊某個container，就會顯示基本的container訊息。裡面能針對這個container查看logs，inspect，stat等等，功能非常齊全。 我自己最常使用的就是docker logs，透過UI可以直接點擊Logs查看，方便很多。\n依照類型也會分出stack，container，image，network，volume等等，都可各別下去做新增，查看與管理，有時候東西建了忘記刪，這邊會顯示unused，打勾後就能一鍵移除。\nportainer從拉image到deploy container都能透過ui完成，對於更新版本也是很有一套，可以透過設定pull latest並點擊recreate進行container的更新，對於常常使用container測試者真的是一大福音。\n👨‍💻簡介 portainer主要讓我們能有個UI介面管理我們的docker，對於初學docker指令不太熟的使用者能快速進入docker的世界，並且可從docker hub一鍵拉取image，設定network、volume等進行快速部署，都可藉由portainer完成。 🎯setup 透過docker-compose.yml建立portainer 建立docker-compose.yml # docker-compose.yml version: \u0026#34;3\u0026#34; services: portainer: image: portainer/portainer-ce volumes: - /var/run/docker.sock:/var/run/docker.sock - portainer_data:/data ports: - 9000:9000 container_name: portainer volumes: portainer_data: {} 執行docker-compose up -d\n設定系統管理員 finish 🔰基礎介紹(本地環境) 1. Dashboard 上面的Environment info為當前本地的系統環境基本資訊 6 core cpu 8.3 ram docker版本為20.10.17 URL為我掛載的docker.sock路徑 底下為當前所有的docker配置 2. Stacks 使用docker-compose起的就會形成一個stack，可顯示當前所跑的stack list，以及這個stack跑的container資訊 如果要自己新增stack可點擊Add stack把自己寫好的docker-compose.yml貼上去並按下Deploy the stack即可建立。 3. Containers 可針對container做啟動停止暫停刪除等等的基本操作，在list介面可顯示當前所有container的基礎資訊。Quick Actions從左到右分別為Logs、Inspect、Stats、Exec Console、Attach Console Logs：方便查看當前container log狀況 Inspect：跟docker inspect一樣，但可視程度較高，有轉成樹狀結構 Stats：可查看cpu、mem、network等使用率，以及顯示當前使用了哪些進程 Exec Console：一鍵進入容器內操作 新增container的方式也是很簡單，透過Add container之後設定image的基本設定即可成功建立container，底下也可設定volume、network等等。 4. Images 這邊最上面可直接輸入image name做pull image的動作，下面則是顯示當前本地所有的images，對於沒再使用的image這邊會顯示Unused真的方便許多，一鍵即可移除，點擊進去可看到image的基本資訊，並且能顯示image layers，對於自己撰寫dockerfile幫助很大。 如果要自己建立image可點擊Build a new image，將自己寫的dockerfile貼上去建立image。 ","permalink":"https://sz9751210.github.io/posts/portainer-intro/","summary":"\u003ch2 id=\"心得\"\u003e📔心得\u003c/h2\u003e\n\u003cp\u003e一直以來都在使用container下去跑測試環境，所以都是使用docker指令下去做除錯，最近因緣際會下找到這一款可以透過UI看全部的container狀態，真的覺得好用到爆炸，所以來介紹一下這款容器化管理神器。\u003c/p\u003e\n\u003cp\u003e基本上能用docker指令做到的事情，portainer都能做到，像是docker ps，查看所有container，接著點擊某個container，就會顯示基本的container訊息。裡面能針對這個container查看logs，inspect，stat等等，功能非常齊全。\n我自己最常使用的就是docker logs，透過UI可以直接點擊Logs查看，方便很多。\u003c/p\u003e\n\u003cp\u003e依照類型也會分出stack，container，image，network，volume等等，都可各別下去做新增，查看與管理，有時候東西建了忘記刪，這邊會顯示unused，打勾後就能一鍵移除。\u003c/p\u003e\n\u003cp\u003eportainer從拉image到deploy container都能透過ui完成，對於更新版本也是很有一套，可以透過設定pull latest並點擊recreate進行container的更新，對於常常使用container測試者真的是一大福音。\u003c/p\u003e\n\u003ch2 id=\"簡介\"\u003e👨‍💻簡介\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003eportainer主要讓我們能有個UI介面管理我們的docker，對於初學docker指令不太熟的使用者能快速進入docker的世界，並且可從docker hub一鍵拉取image，設定network、volume等進行快速部署，都可藉由portainer完成。\u003c/li\u003e\n\u003c/ul\u003e","title":"Portainer：一款圖形化容器管理工具"},{"content":"簡介 因常會在新機器跑container，藉此紀錄安裝過程，順便寫下腳本安裝懶人包 安裝docker 檢查系統中是否已經安裝了docker 執行：ps -ef |grep docker\n如上圖所示，說明系統中並沒有安裝docker\n添加docker-ce倉庫 安裝yum倉庫管理工具 sudo yum update -y sudo yum install -y yum-utils 配置docker yum源 sudo yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo\t安裝docker engine sudo yum install docker-ce docker-ce-cli containerd.io docker-compose-plugin 啟動docker \u0026amp;\u0026amp; 設置開機啟動docker sudo systemctl start docker.service sudo systemctl enable docker.service 安裝docker-compose Install Docker Compose CLI plugin | Docker Documentation\n透過curl下載docker-compose COMPOSE_VERSION=$(curl -s https://api.github.com/repos/docker/compose/releases/latest | grep \u0026#39;tag_name\u0026#39; | cut -d\\\u0026#34; -f4) sh -c \u0026#34;curl -L https://github.com/docker/compose/releases/download/${COMPOSE_VERSION}/docker-compose-`uname -s`-`uname -m` \u0026gt; /usr/local/bin/docker-compose\u0026#34; 將docker-compose變成可執行檔 chmod +x /usr/local/bin/docker-compose 建立連結 ln -s /usr/local/bin/docker-compose docker-compose 確認是否安裝成功 docker-compose -v 腳本自動化安裝docker \u0026amp;\u0026amp; docker-compose #!/bin/bash # ----- Install docker ----- # echo \u0026#34;install docker\u0026#34; sudo yum update -y sudo yum install -y yum-utils sudo yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo sudo yum install docker-ce docker-ce-cli containerd.io docker-compose-plugin # start \u0026amp; enable docker.service sudo systemctl start docker.service sudo systemctl enable docker.service # ----- Install docker-compose ----- # echo \u0026#34;install docker-compose\u0026#34; # get latest docker compose released tag COMPOSE_VERSION=$(curl -s https://api.github.com/repos/docker/compose/releases/latest | grep \u0026#39;tag_name\u0026#39; | cut -d\\\u0026#34; -f4) sudo curl -L \u0026#34;https://github.com/docker/compose/releases/download/${COMPOSE_VERSION}/docker-compose-$(uname -s)-$(uname -m)\u0026#34; -o /usr/local/bin/docker-compose sudo chmod +x /usr/local/bin/docker-compose sudo ln -s /usr/local/bin/docker-compose /usr/bin/docker-compose # Output compose version docker-compose --version exit 0 ","permalink":"https://sz9751210.github.io/posts/centos-%E5%AE%89%E8%A3%9Ddocker-%E5%92%8C-docker-compose/","summary":"\u003ch2 id=\"簡介\"\u003e簡介\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e因常會在新機器跑container，藉此紀錄安裝過程，順便寫下腳本安裝懶人包\u003c/li\u003e\n\u003c/ul\u003e","title":"CentOS 安裝docker 和 docker-compose"},{"content":"📔心得 因最近在研究elk-stack，藉此紀錄一下使用docker-compose建立起elk-stack的架構，在建立的過程中，比較多遇到的是記憶體使用率的配置不足，導致容器無法成功啟動，或是config檔權限的問題，因此在filebeat的部分會直接把config檔放進去並改成root權限。\n之後希望能再增加logstash的pipeline功能，在實務上可多個服務做篩選，以及elasticsearch的資料安全性配置SSL和叢集架構，並導入ILM做log的空間管理。\n監控的部分則是拿之前做的小專案直接套用並呈現，所以整體流程大致上差不多，多了個elasticsearch_exporter，可查看更多elasticsearch的整體狀況，例如index、shard的數量，資料大小，寫入速率等等。\n🔗詳細專案位置 \u0026ndash;\u0026gt; ELFK-stack-monitor\n👨‍💻簡介 🔰ELFK-stack：使用docker-compose建立起elk-stack的架構，主要先從alpine產生假資料並存到filebeat讀取的資料夾，接著filebeat將資料送往logstash，在實務上，會在logstash做filter的功能(未來會新增)，接著送到elasticsearch存起來，並透過kibana的ui下去做搜尋所需的log資料。\n🔰Monitor：使用cadvisor監控所有容器以及elasticsearch_exporter監控elasticsearch的狀態，並把資料送到prometheus儲存起來，最後透過grafana的ui呈現。\n🔰基礎介紹 ⚙️ELFK-stack : alpine+filebeat(送資料) -\u0026gt; logstash(filter) -\u0026gt; elasticsearch(db) -\u0026gt; kibana(ui)\n⚙️Monitor : cadvisor,elasticsearch_exporter(monitor) -\u0026gt; prometheus(db) -\u0026gt; grafana(ui)\n🎯setup 使用docker-compose啟動服務 sudo docker-compose up -d 進到localhost:5601按照以下圖示設定index pattern 可進到localhost:3000查看grafana dashboard，帳密都為admin container-dashboard ** elasticsearch-dashboard ✅TODO 新增log filter 添加ssl cluster架構的elastic ","permalink":"https://sz9751210.github.io/posts/elfk-stack-monitor/","summary":"\u003ch2 id=\"心得\"\u003e📔心得\u003c/h2\u003e\n\u003cp\u003e因最近在研究elk-stack，藉此紀錄一下使用docker-compose建立起elk-stack的架構，在建立的過程中，比較多遇到的是記憶體使用率的配置不足，導致容器無法成功啟動，或是config檔權限的問題，因此在filebeat的部分會直接把config檔放進去並改成root權限。\u003c/p\u003e\n\u003cp\u003e之後希望能再增加logstash的pipeline功能，在實務上可多個服務做篩選，以及elasticsearch的資料安全性配置SSL和叢集架構，並導入ILM做log的空間管理。\u003c/p\u003e\n\u003cp\u003e監控的部分則是拿之前做的小專案直接套用並呈現，所以整體流程大致上差不多，多了個elasticsearch_exporter，可查看更多elasticsearch的整體狀況，例如index、shard的數量，資料大小，寫入速率等等。\u003c/p\u003e\n\u003cp\u003e🔗詳細專案位置 \u0026ndash;\u0026gt; \u003ca href=\"https://github.com/sz9751210/ELFK-stack-monitor\"\u003eELFK-stack-monitor\u003c/a\u003e\u003c/p\u003e\n\u003ch2 id=\"簡介\"\u003e👨‍💻簡介\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e🔰ELFK-stack：使用docker-compose建立起elk-stack的架構，主要先從alpine產生假資料並存到filebeat讀取的資料夾，接著filebeat將資料送往logstash，在實務上，會在logstash做filter的功能(未來會新增)，接著送到elasticsearch存起來，並透過kibana的ui下去做搜尋所需的log資料。\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e🔰Monitor：使用cadvisor監控所有容器以及elasticsearch_exporter監控elasticsearch的狀態，並把資料送到prometheus儲存起來，最後透過grafana的ui呈現。\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e","title":"ELFK-stack-monitor"},{"content":"👨‍💻簡介 🔰ELFK-stack：使用docker-compose建立起tick-stack的架構，撈取的指標從config/telegraf.conf設定，並送往influxdb從起來，chronograf為ui介面，查看撈取的時間序列指標狀態，最後kapacitor則是處理告警的部分．\n流程 ⚙️TICK-stack : telrgraf(送資料) -\u0026gt; influxdb(存資料) -\u0026gt; chronograf(ui) -\u0026gt; kapacitor(alert) 環境建置 本篇github repo在此 -\u0026gt; TICK_Stack-tutorial\ntelegraf設定 使用telegraf.conf設定輸出資料庫\n[[outputs.influxdb]] urls = [\u0026#34;http://influxdb:8086\u0026#34;] database = \u0026#34;telegraf\u0026#34; # 要使用的資料庫 username = \u0026#34;admin\u0026#34; password = \u0026#34;admin\u0026#34; influxdb設定 使用configuration.env設定帳密以及資料庫\n# InfluxDB options INFLUXDB_DB=telegraf INFLUXDB_ADMIN_USER=admin INFLUXDB_ADMIN_PASSWORD=admin kapacitor設定 使用kapacitor.conf\n設定讀取的資料庫 [[influxdb]] enabled = true name = \u0026#34;telegraf\u0026#34; default = false urls = [\u0026#34;http://influxdb:8086\u0026#34;] username = \u0026#34;admin\u0026#34; password = \u0026#34;admin\u0026#34; 設定告警telegram [telegram] enabled = true url = \u0026#34;https://api.telegram.org/bot\u0026#34; token = \u0026#34;bot-token\u0026#34; 啟動環境 docker-compose up 接著去本地chronograf http://IP:8888 設定influxdb以及kapacitor\nhttp:// IP :8086 for influxdb http:// IP :9092 for kapacitor 告警設計 參考cpu_alert.tick.example\n使用告警 透過kapacitor cd /var/lib/kapacitor # cpu_alert為任務task_id # 定義任務 kapacitor define cpu_alert -tick cpu_alert.tick -type stream -dbrp telegraf.autogen # 啟動任務 kapacitor enable cpu_alert # 停止任務 kapacitor disable cpu_alert # 刪除任務 kapacitor delete tasks cpu_alert # 列出所有任務 kapacitor list tasks 透過chronograf 選到左邊的alerting -\u0026gt; write TICKscript 輸入task_id -\u0026gt; 把script貼上 -\u0026gt; 選擇類型為stream -\u0026gt; 選擇db -\u0026gt; 按下儲存後下方會判斷script是否正常 完成後可回到manage task管理當前task 可透過點擊enabled下方圓點一鍵啟動/停用任務 alert history可查看告警訊息\ngreen:OK white:INFO,WARN red:CRIT ============================\n查看alert寫回db訊息 參考資料 https://github.com/sz9751210/docker-telegraf-influx-grafana-stack https://www.influxdata.com/time-series-platform/kapacitor/ https://tanjiti.github.io/2018/12/18/%E5%BC%80%E6%BA%90kapacitor%E6%93%8D%E4%BD%9C%E6%89%8B%E5%86%8C/ ","permalink":"https://sz9751210.github.io/posts/tick-stack-tutorial/","summary":"\u003ch2 id=\"簡介\"\u003e👨‍💻簡介\u003c/h2\u003e\n\u003cp\u003e🔰ELFK-stack：使用docker-compose建立起tick-stack的架構，撈取的指標從config/telegraf.conf設定，並送往influxdb從起來，chronograf為ui介面，查看撈取的時間序列指標狀態，最後kapacitor則是處理告警的部分．\u003c/p\u003e\n\u003ch2 id=\"流程\"\u003e流程\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e⚙️TICK-stack : telrgraf(送資料) -\u0026gt; influxdb(存資料) -\u0026gt; chronograf(ui) -\u0026gt; kapacitor(alert)\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"環境建置\"\u003e環境建置\u003c/h2\u003e\n\u003cp\u003e本篇github repo在此 -\u0026gt;  \u003ca href=\"https://github.com/sz9751210/TICK_Stack-tutorial\"\u003eTICK_Stack-tutorial\u003c/a\u003e\u003c/p\u003e","title":"TICK-Stack-tutorial"},{"content":"Python 基本語法 python 語法的後綴名是以.py 結尾 python 執行方式 使用交互介面執行 使用 python test.py 命令執行 使用./test.py 執行 python 標示符 以單下劃線開頭的屬性，表示是類的私有屬性(包括方法，變量)。如:_foo表示不能直接訪問的類屬性。 以雙下劃線開頭的 __foo 代表類的私有成員； 以雙下劃線開頭和結尾的 __foo__ 代表 Python 里特殊方法專用的標識，如 __init__() 代表類的構造函數。 換行縮進 python 不使用{}來控制 code 範圍，而使用縮進來控制。一般都使用四個空格做縮進(PEP8規定)。 #!/usr/bin/python # -*- coding: UTF-8 -*- print \u0026#34;hello world\u0026#34;; if True: print(\u0026#34;Answer:\u0026#34;); print(\u0026#34;true\u0026#34;); else: print(\u0026#34;Answer:\u0026#34;); # 沒有嚴格縮進，在執行時會報錯 print(\u0026#34;false\u0026#34;); python 引號 Python 可以使用引號(')、雙引號(\u0026quot;)、三引號( ''' 或 \u0026quot;\u0026quot;\u0026quot; ) 來表示字符串。 三引號(\u0026quot;\u0026quot;\u0026quot;)可以由多行組成，是編寫多行文本的快捷語法，常用於文檔字符串。 # 單引號以及雙引號 \u0026#39;This is a string\u0026#39; \u0026#34;This is a string\u0026#34; # 引號包含引號 \u0026#34;We call it \u0026#39;Dog\u0026#39;...... \u0026#34; # 雙引號內可包含單引號 \u0026#39;We call it \u0026#34;Dog\u0026#34;...... \u0026#39; # 單引號內可包含雙引號 # 三雙引號可直接換行 \u0026#34;\u0026#34;\u0026#34;haha, this is a dog.\u0026#34;\u0026#34;\u0026#34; # 三單引號需要換行符 \u0026#39;\u0026#39;\u0026#39;haha, \\ this is a dog.\u0026#39;\u0026#39;\u0026#39; python 注釋 python 中單行註釋採用#開頭 python 中多行註釋使用三個單引號(''')或三個雙引號(\u0026quot;\u0026quot;\u0026quot;) 多行註釋通常用來為 Python 文件、模塊、類或者函數等添加版權或者功能描述信息。 # 單行 # 註釋內容 # 多行 \u0026#39;\u0026#39;\u0026#39;(\u0026#34;\u0026#34;\u0026#34;) 使用 3 個單引號分別作為註釋的開頭和結尾 可以一次性註釋多行內容 這裡面的內容全部是註釋內容 \u0026#39;\u0026#39;\u0026#39;(\u0026#34;\u0026#34;\u0026#34;) Python 空行 函數之間或 class 的方法之間用空行分隔，表示一段新的代碼的開始。class 和函數入口之間也用一行空行分隔，以突出函數入口的開始。 多個語句組成的代碼組 縮進相同的一組語句構成一個代碼塊，我們稱之代碼組。 子句: 像 if、while、def 和 class 這樣的複合語句，首行以關鍵字開始，以冒號( : )結束，該行之後的一行或多行代碼構成代碼組。 if expression: suite elif expression: suite else: suite python 變量類型 變量可以指定不同的數據類型，這些變量可以存儲整數，小數或字符。 python 變量賦值 變量賦值不需要聲明類型，變數的資料型別將根據分配給它的值的型別自動來定義。 每個變量在使用前必須賦值，變量賦值以後該變量才會被創建 不可以取保留字 只能由大小寫字母、數字、 _ 、 中文組成變數名稱 英文字母大小寫視為不同的變數名稱 counter = 100 # 賦值整型變量 miles = 1000.0 # 浮點型 name = \u0026#34;alan\u0026#34; # 字符串 print(count), print(miles), print(name); 多變量賦值，變數之間用，分隔 # 2 被分配給 x，4.124 被分配給 y，字串 Python 被分配給 z。 x, y, z = 2, 4.124, \u0026#34;Python\u0026#34; # 三個變數都是Blue x = y = z = \u0026#34;Blue\u0026#34; 刪除變數 del x python 資料型態 數值型態： int float bool 字串型態： str chr 容器型態： list dict tuple Python 基本的純量類型 整數（int） 浮點數（float） 文字（str） 布林（bool） None（NoneType） 整數和浮點數 整數與浮點數使用數學運算符號進行運算 會搭配運算符號進行運算 + 、 - 、 * 、 / ：加減乘除 ** ：次方 % ：回傳餘數 // ：回傳商數 字串 我們使用成雙的單引號 \u0026rsquo;\u0026rsquo; 或成對的雙引號 \u0026quot;\u0026quot; 來建立文字類型 如果建立的字串有包含不成對的引號，則需要使用跳脫字元\\來完成宣告 python 格式化字串 %-formatting print(\u0026#34;I am %s.%s\u0026#34;%(\u0026#34;Alan\u0026#34;,\u0026#34;wang\u0026#34;)) # output I am Alan.wang str.format()（Python 2.6+） # 基本使用 s = \u0026#39;I am {first_name} {middle_name}. {last_name}\u0026#39; print(s.format(first_name=\u0026#39;Monkey\u0026#39;, middle_name=\u0026#39;D\u0026#39;, last_name=\u0026#39;Luffy\u0026#39;)) # output I am Monkey D. Luffy # 調整輸出樣式：^(居中）、\u0026lt;（向左對齊）、\u0026gt;（向右對齊） print(\u0026#39;{:^10s}\u0026#39;.format(\u0026#39;a\u0026#39;)) # ^：居中對齊，10：寬度為10，s：以string輸出 # output a # 以 {:,} 的方式以逗號分隔數字 print(\u0026#39;{:,}\u0026#39;.format(100000000)) # output 100,000,000 f-string（Python 3.6+） # variables first_name = \u0026#34;Monkey\u0026#34; middle_name = \u0026#34;D\u0026#34; last_name = \u0026#34;Luffy\u0026#34; # f-string f\u0026#34;I am {first_name} {middle_name}. {last_name}\u0026#34; # Output: \u0026#34;I am Monkey D. Luffy\u0026#34; 布林 進行判斷條件或者資料篩選的時候會需要仰賴布林（bool），布林只有 True 與 False 這兩個值。 print(type(True)) print(type(False)) Python（或者絕大多數的程式語言）對於英文的大小寫是敏感的（case-sensitive），像是 True 會被識別為布林，但是 TRUE 或者 true 則會被視作物件名稱。 # recognized as bool print(type(True)) print(type(False)) # recognized as object names print(type(true)) print(type(TRUE)) print(type(false)) print(type(FALSE)) True 跟數值 1 相等； False 跟數值 0 相等。如果在數值運算中納入了布林不會產生任何問題。 print(True == 1) # output：True print(False == 0) # output：True print(1 + True) # output：2 print(1 + False) # output：1 判斷條件簡介 == 、 !=：等於以及不等於 \u0026gt; 、 \u0026gt;= 、 \u0026lt; 、 \u0026lt;=：大於、大於等於、小於以及小於等於 is 、 is not：是否為相同的值與類型 and 、 or：交集與聯集 not：非 in ：是否存在於 None None 是所謂的無值，或者可以用 NA 值（Not Available）或 NaN 值（Not a Number）去體會它 None 是無回傳值函數中的預設輸出值、也是搜索特徵函數找不到情況下的預設輸出值 # 宣告了一個只有 pass 保留字內容的 hello_world() 函數，這就是一個所謂的無回傳值函數 def hello_world(): pass print(hello_world()) # output：None print(type(hello_world())) # output：\u0026lt;class \u0026#39;NoneType\u0026#39;\u0026gt; 判斷純量類型的函數 使用 isinstance(x, classinfo) 函數判斷純量類型，其中 x 輸入物件名稱、 classinfo 輸入類型名稱。 # 判斷是否為整數 print(isinstance(87, int)) # output：True print(isinstance(\u0026#34;87\u0026#34;, int)) # output：False # 判斷是否為浮點數 print(isinstance(87.0, float)) # output：True print(isinstance(87, float)) # output：False # 判斷是否為文字 print(isinstance(\u0026#34;True\u0026#34;, str)) # output：True print(isinstance(True, str)) # output：False # 判斷是否為布林 print(isinstance(False, bool)) # output：True print(isinstance(\u0026#34;False\u0026#34;, bool)) # output：False # 判斷是否為 None print(isinstance(None, type(None))) # output：True print(isinstance(\u0026#34;None\u0026#34;, type(None))) # output：False 使用 type()函數回傳純量類型 my_int = 87 my_float = 8.7 my_str = \u0026#34;Hello Python\u0026#34; bool_true = True bool_false = False none_type = None print(type(my_int)) print(type(my_float)) print(type(my_str)) print(type(bool_true)) print(type(bool_false)) print(type(none_type)) # output ## \u0026lt;class \u0026#39;int\u0026#39;\u0026gt; ## \u0026lt;class \u0026#39;float\u0026#39;\u0026gt; ## \u0026lt;class \u0026#39;str\u0026#39;\u0026gt; ## \u0026lt;class \u0026#39;bool\u0026#39;\u0026gt; ## \u0026lt;class \u0026#39;bool\u0026#39;\u0026gt; ## \u0026lt;class \u0026#39;NoneType\u0026#39;\u0026gt; python 類型轉換 純量轉換 使用與目標轉換類型同名的函數轉換純量類型。\nint()：轉換純量為整數類型 float()：轉換純量為浮點數類型 bool()：轉換純量為布林類型，除了 0 以外的數字都是True str()：轉換純量為文字類型 # 轉換成整數 print(int(8.7)) print(int(True)) print(int(False)) print(int(\u0026#34;87\u0026#34;)) # output 8 1 0 87 # 轉換成浮點數 print(float(87)) print(float(True)) print(float(False)) print(float(\u0026#34;87\u0026#34;)) # output 87.0 1.0 0.0 87.0 # 轉換成布林 print(bool(0)) print(bool(0.0)) print(bool(1)) print(bool(1.0)) print(bool(8.7)) print(bool(-8.7)) # output False False True True True True # 轉換成字串 print(str(87)) print(str(87.0)) print(str(True)) print(str(False)) # output 87 87.0 True False python 運算符 算數運算符 x=5, y=2\n運算符 名稱 範例 + 加法 x + y = 7 - 減法 x - y = 3 * 乘法 x * y = 10 / 除法 x / y = 2.5 % 取餘數 x % y = 1 ** 指數 x ** y = 25 // 取整除 x // y = 2 + 與 * 也可用於字串 (string) ， + 用於字串相接， * 用於複製字串\na = \u0026#34;a\u0026#34; b = a + \u0026#34;b\u0026#34; # 字串連接， b 會等於 \u0026#34;ab\u0026#34; c = a * 3 # 字串重複三倍， c 會等於 \u0026#34;aaa\u0026#34; 賦值運算符 x = 5 = 0101 , 3 = 0011\n運算符 名稱 範例 解答 = 賦值 x = 5 x = 5 += 加法賦值 x += 3 \u0026mdash;\u0026gt; x = x + 3 x = 8 -= 減法賦值 x -= 3 \u0026mdash;\u0026gt; x = x - 3 x = 2 *= 乘法賦值 x * = 3 \u0026mdash;\u0026gt; x = x * 3 x = 15 /= 除法賦值 x /= 3 \u0026mdash;\u0026gt; x = x / 3 x = 1.666\u0026hellip; %= 取餘賦值 x %= 3 \u0026mdash;\u0026gt; x = x % 3 x = 2 //= 取整除賦值 x //= 3 \u0026mdash;\u0026gt; x = x // 3 x = 1 **= 指數賦值 x **= 3 \u0026mdash;\u0026gt; x = x ** 3 x = 125 \u0026amp;= AND 賦值 x \u0026amp;= 3 \u0026mdash;\u0026gt; x = x \u0026amp; 3 x = 1 = 0001 |= OR 賦值 x |= 3 \u0026mdash;\u0026gt; x = x | 3 x = 7 = 0111 ^= XOR 賦值 x ^= 3 \u0026mdash;\u0026gt; x = x ^ 3 x = 6 = 0110 \u0026raquo;= 右移賦值 x \u0026raquo;= 3 \u0026mdash;\u0026gt; x = x \u0026raquo; 3 x = 0 = 0000 = 5 * 1/2**3 = 5/8 \u0026laquo;= 左移賦值 x \u0026laquo;= 3 \u0026mdash;\u0026gt; x = x \u0026laquo; 3 x = 40 = 0010 1000 = 5 * 2**3 = 5 * 8 比較運算符 運算符 名稱 範例 == 相等 x == y != 不相等 x != y \u0026gt; 大於 x \u0026gt; y \u0026lt; 小於 x \u0026lt; y \u0026gt;= 大於等於 x \u0026gt;= y \u0026lt;= 小於等於 x \u0026lt;= y 邏輯(布林)運算符 x = 4\n運算符 名稱 範例 and 與運算 - 兩者為 True，返回 True x \u0026lt; 5 and x \u0026lt; 10 \u0026mdash;\u0026gt; True or 或運算 - 其中一者為 True，返回 True x \u0026lt; 5 or x \u0026lt; 4 \u0026mdash;\u0026gt; True not 非運算 - 兩者為 Faluse，返回 True not(x \u0026lt; 5 and x \u0026lt; 10) \u0026mdash;\u0026gt; False 身分運算符 運算符 描述 範例 is 如果兩個變量是同一個對象(具有相同的記憶體位置)，則返回 True x is y is not 如果兩個變量不是同一個對象(不是指向相同的記憶體位置)，則返回 True x is not y 成員運算符 運算符 描述 範例 in 當 in 前面的變數在後面的序列中時，結果為 True x in y not in 當 in 前面的變數不在後面的序列中時，結果為 True x not in y 位元運算符 a = 5\n運算符 名稱 範例 \u0026amp; AND(位與操作符) - 當兩側數字在該位上都是 1 的時候，結果該位也為 1，否則為 0 a \u0026amp; 2 = 0 = 0000 | OR(位或操作符) - 當兩側數字在該位上只要有一個是 1 的時候，結果該位為 1，否則為 0 a | 2 = 7 = 0111 ^ XOR(位異或操作符) - 當兩側數字對應位二進位制相異時(其中一位為 1，另一位為 0)，結果為 1 a ^ 2 = 7 = ~ NOT(位取反操作符) - 對運算元進行按位取反操作，1 變成 0，0 變成 1 ~a = -6 = -(0101 + 1) = -(0110) \u0026laquo; 左移操作符 - 將 \u0026laquo; 左側的數字左移若干位，右側補 0，左側高位數捨棄 a \u0026laquo; 2 = 20 = 0001 0100 \u0026raquo; 右移操作符 - 將 \u0026raquo; 左側的數字右移若干位，左側補齊 0 a \u0026raquo; 2 = 1 = 0001 python 條件語句與迴圈控制 條件語句：當程式流程在進行的過程，需要根據某個條件來決定是否執行接下來的動作時使用。 迴圈控制：處理資料時，若是想要重複執行某些相同的步驟時，就會使用到迴圈。 條件語句 if 若判斷條件成立，則執行底下縮排的敘述內容；反之，則不動作。 if condition: statement if-else 若condition 為真 (True)，則執行 statement1；反之，則執行statement2。 if condition: statement1 for True condition else: statement2 for False condition if-elif-else elif 的個數是沒有限制的，可以依照自己的需求而定。 if condition1: statement1 for True Condition1 elif condition2 : statement2 for True Condition2 elif condition3 : statement3 for True Condition3 else: statements for Each Condition False 巢狀if ID = input() year = int(ID[1:3]) if year \u0026lt; 4: print(\u0026#34;Graduated\u0026#34;) elif year \u0026lt;= 7 and year \u0026gt;= 4: if year == 7: print(\u0026#34;Freshman\u0026#34;) elif year == 6: print(\u0026#34;Sophomore\u0026#34;) elif year == 5: print(\u0026#34;Junior\u0026#34;) elif year == 4: print(\u0026#34;Senior\u0026#34;) else: print(\u0026#34;Not Registered Yet\u0026#34;) 迴圈控制 單層 for-loop 適用在「已知迴圈數」的問題 for和in中間放自訂變數，in後面可接一個序列(ex. list) 迴圈會依序從序列裡取得元素，將元素指派給前面的自訂變數，並執行迴圈裡的內容 通常會跟range()做一個搭配使用 range(起始值，終止值，遞增(減)值)\nfor x in sequence: # 放要執行的東西 # 迴圈搭配list依序印出內容 sequences = [0, 1,\u0026#39;jason\u0026#39;,2.5] for i in sequences: print(i) # output 0 1 jason 2.5 # 迴圈搭配range()使用 for i in range(3): print(i, end=\u0026#34; \u0026#34;) print() # 換行 for i in range(10,2,-2): print(i, end=\u0026#34; \u0026#34;) # output 0 1 2 10 8 6 4 巢狀 for-loop 迴圈裡面又包覆著其他的迴圈。 處理的問題具有重複執行某段敘述的特性，而且這些敘述受到兩個 (或兩個以上) 的變數來分別控制其變化 # 九九乘法表 for i in range(1, 10): for j in range(1, 10): if j == 9: print(\u0026#34;\\t\u0026#34;, i*j) # j == 9時，換行 else: print(\u0026#34;\\t\u0026#34;, i*j, end = \u0026#39;\u0026#39;) # j \u0026lt; 9時，不換行 while loops 適用在「無法預知迴圈數」的問題 while test_expression: Body of while # 產生1到10的序列 i = 1 while i \u0026lt;= 10: print(i, end=\u0026#34; \u0026#34;) i = i + 1 break 和 continue(迴圈不規則結束) break：中斷迴圈的執行並跳脫迴圈結構，繼續執行迴圈外的敘述。 continue：不中斷迴圈；只跳過迴圈內 continue 後面的剩餘敘述，接著繼續執行下一次的迴圈運作。 規則的結束方式是當迴圈的判斷條件不再符合時，迴圈自然結束；而不規則的迴圈結束則是在迴圈自然結束前，我們已經得到想要的運算結果，利用強制中斷的方式來結束迴圈。\nfor i in \u0026#34;Hey Alan\u0026#34;: if i == \u0026#34;l\u0026#34;: break print(i, end=\u0026#34; \u0026#34;) print() for i in \u0026#34;Hey Alan\u0026#34;: if i == \u0026#34;l\u0026#34;: continue print(i, end=\u0026#34; \u0026#34;) # output H e y A H e y A a n python保留字 定義：語言本身的編譯器中已經定義過的單詞，具有特定含義和用途，使用者不能再將這些單詞作為變數名或函數名、類名使用。 保留字 說明 and 邏輯與操作，用於表示式運算 as 用於轉換資料型別 assert 用於判斷變數或條件表示式的結果 async 用於啟用非同步操作 await 用於非同步操作中等待協程返回 break 中斷迴圈語句的執行 class 定義類 continue 繼續執行下一次迴圈 def 定義函數或方法 del 刪除變數或序列的值 elif 條件語句，與 if、else 結合使用 else 條件語句，與 if、else 結合使用；也可用於異常或迴圈語句 except 包含捕獲異常後的處理程式碼塊，與 try、finally 結合使用 False 含義為假的邏輯值 finally 包含捕獲異常後的始終要呼叫的程式碼塊，與 try、except 結合使用 for 迴圈語句 from 用於匯入模組，與 import 結合使用 global 用於在函數或其他區域性作用域中使用全域性變數 if 條件語句，與 elif、else 結合使用 import 匯入模組，與 from 結合使用 in 判斷變數是否在序列中 is 判斷變數是否為某個類的範例 lambda 定義匿名函數 None 表示一個空物件或是一個特殊的空值 nonlocal 用於在函數或其他作用域中使用外層（非全域性）變數 not 邏輯非操作，用於表示式運算 or 邏輯或操作，用於表示式運算 pass 空的類、方法或函數的預留位置 raise 用於丟擲異常 return 從函數返回計算結果 True 含義為真的邏輯值 try 測試執行可能出現異常的程式碼，與 except, finally 結合使用 while 迴圈語句 with 簡化 Python 的語句 yield 從函數依次返回值 ","permalink":"https://sz9751210.github.io/posts/python-%E5%9F%BA%E7%A4%8E/","summary":"\u003ch2 id=\"python-基本語法\"\u003ePython 基本語法\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003epython 語法的後綴名是以.py 結尾\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"python-執行方式\"\u003epython 執行方式\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e使用交互介面執行\u003c/li\u003e\n\u003cli\u003e使用 python test.py 命令執行\u003c/li\u003e\n\u003cli\u003e使用./test.py 執行\u003c/li\u003e\n\u003c/ul\u003e","title":"python 基礎"},{"content":"CentOS 7 安裝及設定Jenkins 介紹 開源且免費的CI工具，由Java編寫的，提供了持續構建以及部署的功能，是一個自動化的server\n環境 CentOS 7 安裝步驟 1. 添加Jenkins Repository [root@jenkins ~]# wget --no-check-certificate -O /etc/yum.repos.d/jenkins.repo http://pkg.jenkins.io/redhat-stable/jenkins.repo [root@jenkins ~]# rpm --import http://pkg.jenkins.io/redhat-stable/jenkins.io.key 2. 安裝Jenkins以及Java [root@jenkins ~]# yum install -y jenkins java-1.8.0-openjdk 3. 啟動並啟用Jenkins [root@jenkins ~]# systemctl start jenkins* [root@jenkins ~]# systemctl enable jenkins* 4. 在防火牆開啟80以及8080 的port [root@jenkins ~]# firewall-cmd --zone=public --add-port=8080/tcp --permanent success [root@jenkins ~]# firewall-cmd --zone=public --add-service=http --permanent success [root@jenkins ~]# firewall-cmd --reload success 5. 透過網頁打開Jenkins 存取URL：http://:8080\n管理員密碼創建並存儲在日誌文件 /var/log/jenkins/jenkins.log 中。接著透過以下指令取得初始密碼\n[root@localhost ~]# grep -A 5 password /var/log/jenkins/jenkins.log Jenkins initial setup is required. An admin user has been created and a password generated. Please use the following password to proceed to installation: Admin password This may also be found at: /var/lib/jenkins/secrets/initialAdminPassword 接著安裝插件，可直接選Install suggested plugins\n接著來建立管理者帳號\n到此所有設定都已完成，即可開始使用Jenkins\n參考資料 How to install and Configure Jenkins on CentOS 7 and RHEL 7 (linuxtechi.com)\n","permalink":"https://sz9751210.github.io/posts/jenkins-installation-centos/","summary":"\u003ch1 id=\"centos-7-安裝及設定jenkins\"\u003eCentOS 7 安裝及設定Jenkins\u003c/h1\u003e\n\u003ch2 id=\"介紹\"\u003e介紹\u003c/h2\u003e\n\u003cp\u003e開源且免費的CI工具，由Java編寫的，提供了持續構建以及部署的功能，是一個自動化的server\u003c/p\u003e","title":"Jenkins 安裝教學(CentOS)"},{"content":"👀QUICK REVIEW The book in 3 Sentences 用三段話說明這本書的內容\n從歷史帶到實戰的基礎書籍 由淺入深循序漸進的步調講解每個章節的主題 極度白話文的一本書 How the Book Changed Me? 這本書為我帶來什麼改變\n更了解自己對的區塊鏈與加密貨幣的意義 對於詐騙手法有更多的了解以及知名的案例 對於泡沫風險分析有更加的了解 My Top 3 Quotes 我最喜歡的 3 句 Quotes\nDYOR FOMO 量化交易 📚讀後心得 這本書是由知名youtuber 腦哥 所出的一本書，書中用極為白話的口語描述關於區塊鏈與加密貨幣的各種說明。此書主要分成四章，一開始先簡單講解甚麼是加密貨幣，區塊鏈等技術，比特幣的誕生，以及作者對於比特幣的未來看法，接著第二章實戰教學如何購買加密貨幣，交易所的介紹，以及作者看好的加密貨幣類型以及用途，還有幣圈的知識管道分享，以及NFT的簡單介紹，第三章主要先講解詐騙以及泡沫風險分析，諸如龐氏騙局，駭客事件，穩定幣危機，51攻擊等等，最後則是講解在幣圈有哪些獲利方式，從簡單的長期持有到高獲利的合約交易以及有玩樂性質的gamefi，對於新手來說是本極度易上手的書。\n","permalink":"https://sz9751210.github.io/posts/%E6%AF%94%E7%89%B9%E5%B9%A3%E6%8A%95%E8%B3%87%E9%87%91%E5%BE%8B%E5%8A%A0%E5%AF%86%E8%B2%A8%E5%B9%A3%E5%AF%A6%E6%88%B0%E6%95%99%E5%AD%B8%E8%88%87%E9%80%B2%E9%9A%8E%E7%8D%B2%E5%88%A9%E6%B3%95/","summary":"\u003ch2 id=\"quick-review\"\u003e👀QUICK REVIEW\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003eThe book in 3 Sentences 用三段話說明這本書的內容\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e從歷史帶到實戰的基礎書籍\u003c/li\u003e\n\u003cli\u003e由淺入深循序漸進的步調講解每個章節的主題\u003c/li\u003e\n\u003cli\u003e極度白話文的一本書\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eHow the Book Changed Me? 這本書為我帶來什麼改變\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e更了解自己對的區塊鏈與加密貨幣的意義\u003c/li\u003e\n\u003cli\u003e對於詐騙手法有更多的了解以及知名的案例\u003c/li\u003e\n\u003cli\u003e對於泡沫風險分析有更加的了解\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eMy Top 3 Quotes 我最喜歡的 3 句 Quotes\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eDYOR\u003c/li\u003e\n\u003cli\u003eFOMO\u003c/li\u003e\n\u003cli\u003e量化交易\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e","title":"比特幣投資金律：加密貨幣實戰教學與進階獲利法"},{"content":" 題目描述：給一個字串，依照題目給的表格，計算出字串對應的值並做加總\n思路：依照題目給的表格做一個字典，接著定義一個變數做加總，並依照題目所給的前一位的值小於當前的值時，做相對應的處理\nclass Solution: def romanToInt(self, s: str) -\u0026gt; int: numeral_map = {\u0026#34;I\u0026#34;:1, \u0026#34;V\u0026#34;:5, \u0026#34;X\u0026#34;:10, \u0026#34;L\u0026#34;:50, \u0026#34;C\u0026#34;:100, \u0026#34;D\u0026#34;:500, \u0026#34;M\u0026#34;:1000} result = 0 for i in range(len(s)): if i\u0026gt;0 and numeral_map[s[i]] \u0026gt; numeral_map[s[i-1]]: result += numeral_map[s[i]] - 2* numeral_map[s[i-1]] else: result += numeral_map[s[i]] return result ","permalink":"https://sz9751210.github.io/posts/leetcode-13/","summary":" 題目描述：給一個字串，依照題目給的表格，計算出字串對應的值並做加總\n思路：依照題目給的表格做一個字典，接著定義一個變數做加總，並依照題目所給的前一位的值小於當前的值時，做相對應的處理\nclass Solution: def romanToInt(self, s: str) -\u0026gt; int: numeral_map = {\u0026#34;I\u0026#34;:1, \u0026#34;V\u0026#34;:5, \u0026#34;X\u0026#34;:10, \u0026#34;L\u0026#34;:50, \u0026#34;C\u0026#34;:100, \u0026#34;D\u0026#34;:500, \u0026#34;M\u0026#34;:1000} result = 0 for i in range(len(s)): if i\u0026gt;0 and numeral_map[s[i]] \u0026gt; numeral_map[s[i-1]]: result += numeral_map[s[i]] - 2* numeral_map[s[i-1]] else: result += numeral_map[s[i]] return result ","title":"leetCode 13. Roman to Integer"},{"content":"👀QUICK REVIEW The book in 3 Sentences 用三段話說明這本書的內容\n天才並非真的存在，刻意練習才是真正通往專家的唯一途徑 練習的質與量勝過於單純的練習量 專注投入與信念至關重要 How the Book Changed Me? 這本書為我帶來什麼改變\n讓練習在你眼中成為一種投資，而不是耗費 沒有人可以不投注及大量的練習就發展出非凡技能 My Top 3 Quotes 我最喜歡的 3 句 Quotes\n人之所以停止學習、不再進步，不是因為到達天生能力的極限，而是因為某些原因不再練習，或者從未開始練習。 技能越高超，心智表徵越成熟，越了解這領域，代表自己更懂欠缺甚麼，也因此更能發揮刻意練習的效果，磨練技巧可以改善心智表徵，心智表徵又有助於技能進步 當你不再相信自己能達成目標時千萬別放棄，先和自己約定好，等到重回先前水準或突破高原期後再說，到時大概就會繼續下去了。 📚讀後心得 書的目的：教導如何使用刻意練習來達到學習技能並邁向專家的路\nCH1：有目標的練習 第一部分講解目標練習法，透過設定短期目標，並完成來達成整體效果，例如，提升打字速度，長期目標可能是一分鐘200字，目前卡關在一分鐘90字，短期目標可設定一分鐘連續100字三字，利用聚沙成塔的概念便是目標練習法的核心\n目標練習法需要意見回饋，可能像是打字，立即顯示一分鐘打幾個字，要認清自己的弱點，才能做適時的修正\n目標練習法必須跨出舒適圈，每次都有新的挑戰，例如目標一分鐘200字，達成後往250字，逼近自己的極限，成功就在增加字數，失敗就減少\n目標練習法的隱藏關鍵之一是設法克服障礙，例如打字一直卡關，可能是某個手指頭不夠靈活經常按錯，又或是對於鍵盤位置不夠熟悉，克服障礙最理想的做法，是透過尋找並嘗試不同方法來突破瓶頸\n目標練習法總結：設定清楚的目標和實現那些目標的計畫，並找出一個監測進步程度的方式，然後跨出舒適圈，專注地練習，並且要找出維持動機的方法\nCH2：駕馭大腦與身體的適應力 人類大腦會因為密集訓練而成長 改變，大腦的適應力在程度和種類上與身體的非常相似，可透過有意識的刻意練習形塑大腦\n長期訓練會導致與正在培養的技能相關的大腦部位產生變化\n刻意練習的目標卻不僅是發展潛能，還要打造潛能，做到以前做不到的事，恆定性受到挑戰，得離開舒適圈，迫使大腦或身體去適應，做到了，學習不再只是一個實踐某種遺傳命運的方式，而成了按照自己ˋ的選擇掌控個人命運與打造潛能的方法\nCH3：心智表徵 心智表徵，舉例像是打字，想像自己打某些字的指法\n刻意練習講求的正是發展出種種更高效率的心智表徵，讓你可以運用於你正在練習的任何活動中\n心智表徵的一項重要特色是 領域限定性，也就是只適用於正在培養的技能，例如，打字快可能無法運用在寫作上\n盡管短期記憶有其限制，人卻能運用心智表徵快速處理大量資訊，也就是建立心智圖，透過點與點之間的連結\n專家與凡人在心智表徵的差異在於質與量不同，例如可能要打其他比較難的字，會需要想出怎樣才會打得更快，寫程式也是，要考慮如何做出想要的樣子，如何優化，差別在於此\n而建立好的心智表徵，則是盡可能建立多個點，書中以狗為例子，建立了多摸牠們的毛，拍拍牠們的頭，多建立這些點並連成線\n在某個主題上投注的心力越多，心智表徵就越精細，理解 消化新資訊的能力也越強\n專家擁有優越的資訊組織能力\n監控並評估自身表現，必要時調整心智表徵以提升其效能\n本身察覺錯誤的能力高低也影響心智表徵的建立\nCH4：刻意練習的黃金法則 技能越高超，心智表徵越成熟，越了解這領域，代表自己更懂欠缺甚麼，也因此更能發揮刻意練習的效果，磨練技巧可以改善心智表徵，心智表徵又有助於技能進步\n當逼迫自己去做一件新的事，無論是培養新技能或是精進既有技能，同時也是在擴充、加強心智表徵，而這些心智表徵又反過來讓你有可能超越之前的極限。\n沒有人可以不投注及大量的練習就發展出非凡技能\n刻意練習與目標練習法有兩大差異\n該領域必須發展得相當成熟，佼佼者的表現水準和新手有極大差距 刻意練習需要有個老師提供可以幫助學生改善表現的練習活動 刻意練習等於是有方向和方法的目標練習法\n刻意練習特色\n刻意練習培養的技能已經有其他人知道該怎麼做，也已建立成效頗佳的訓練技巧。設計練習方式及負責監督的老師或教練應該熟悉頂尖專家的能力，並清楚該如何以最好的方法培養這些技能 跨出舒適圈後才能奏效，需要學生不斷嘗試去突破現階段的技能水準。這意味著幾乎得傾盡全力，所以往往不會太有樂趣 必須有定義清楚明確的目標，且往往涉及改進想要達到的表現得某個面向，而不能只設定模糊的整體改善目標。整體目標設定完成後，老師或教練會制定計畫，其中的一連串改善細項便會累積成向前邁進的一大步，改進想要達到的表現的某個面向，可以讓學生看見自身表現已經藉由訓練改善了 必須刻意進行，必須全神貫注，有意識地行動。光是遵從老師或教練的指導是不夠的，還得專注於自身練習的具體目標，才能適時調整，以掌控練習過程 刻意練習包含意見回饋，並根據該回饋調整努力方向。訓練初期得到的意見回括多來自老師或教練，他們會監控訓練過程並點出問題，提出解決之道。到後期學生也必須學會自我監督並察覺錯誤，隨之因應調整，而自我監督的本領則仰賴有效的心智表徵 刻意練習技能產生有效的心智表徵，也仰賴心智表徵運作。提升表現和改善心智表徵相輔相成，表現提升了，心智表徵就變得更精細有效，反之亦然，心智表徵有助於監控練習和實際上場時的狀況，讓人以正確的方式行動，也能察覺錯誤，並加以改正。 刻意練習幾乎等於加強或調整先前習得的技能，必須注重該技能的特定面向，努力改善，而隨著時間過去，每一步的改善最終會打造出專家級的表現。因為新技能以既有技能為基礎，老師必須在一開始就教導正確的基本功，這樣學生後來達到更高階的水準時，才不必從頭學習基本技能。 做法:先找出頂尖專家，弄清楚他們做了些甚麼才能如此成功，接著發展出讓自己可以做到那些事的訓練技巧\n有效的意見回饋不只是反應做得正確與否，更會討論過程\n這套方法是否能讓人離開舒適圈，嘗試帶有挑戰性的事務，能否讓人及時獲得與表現和可能的改善方式有關的意見回饋，建立這套方法的人有沒有在該領域找出頂尖專家，又是否了解專家與泛泛之輩的不同，其設計是否著眼於培養該領域專家具備的技能\n如何提升相關技能大於如何傳授相關知識，讓訓練著重於行動而非知識\nCH6：在日常生活中運用刻意練習原則 第一步，找個好老師：老師的重要任務之一，是協助學生發展個人的心智表徵，才能針對表現自我監控和修正，並視個人的改變更換老師，例如沒進步時 專注與投入至關重要：開始分心或覺得輕鬆好玩時，大概就代表沒有進步，想要從中獲得最大益處的關鍵，在於專注，有意識的發展技能並精益求精，學會以這種方式投入，便是提升練習效益最強大的方法。剛開始學著專注於練習的人無法維持數小時的注意力，因此一開始必須將練習時間設定得比較短，然後逐漸拉長。專注與投入至關重要，所以每回的訓練時間較短、但目標清楚，是更快速培養出新技能的最佳方法，在較短的時間內投入百分之百的努力，效果強過花了較長時間卻只投入百分之七十的努力，一旦發現自己無法專注，就結束這回合的訓練，並要確保睡眠充足，才能以最大的專注力進行訓練 沒有老師怎麼辦：有目標的練習或刻意練習的一項特色，在於挑戰做不到的事(離開舒適圈)，反覆練習，聚焦於自己的做法、自己的弱點，以及如何改善。富蘭克林實踐了夢想，是因為他針對寫作的不同面向設計出練習活動。好老師或好教練的主要貢獻之一，便是針對你正在努力培養的技能量身訂做類似的練習；若沒有老師，就得自己設計一套練習活動。漫不經心地重複同一件事毫無助益，重複的目的在發現自己的弱點，並聚焦於加強弱點，嘗試不同的方式改善，直到找出最佳策略為止，例如想加強英語理解能力或聽力，先觀看一步有字幕的影片，接著關掉字幕試著理解，接著打開對答案如此反覆，直到都成功，比起看好幾部片來得更有效率。想在沒有老師的情況下有效練習一項技能，建議記住三個重點：專注投入、意見回饋、解決問題。將技能分成可以有效重複練習和分析的幾個部分，確定弱點何在，並找出解決辦法。要建立有效的心智表徵，便得嘗試重現頂尖專家的成果，從失敗中認識自身弱點後再次嘗試，如此一再重複。心智表徵奏效與否，和採取行動密不可分。不能光憑思考，而是必須透過仿作加強練習，才能建立起自己所追求的心智表徵。 突破高原期，表現不再停滯不前：剛開始學習新事物時進步迅速很正常，不然也至少會穩定向前。一旦碰到停滯不前的狀況，自然會認為自己遭遇難以克服的障礙，因而往往不再試著向前邁進，反而認命地在高原徘徊。這就是各個領域的許多人不再進步的原因。突破瓶頸的最佳方式，就是以新的方法挑戰自己的大腦或身體，比平常更用力地逼迫自己，一點點就好，就像打字，卡在某個組合，就專注練習某個組合的打字節奏，如果要提升打字速度，就縮短一點時間打出平常的單字量，然後分析錯誤從何而來，找出速度快不起來的原因，設計一些練習來提升速度，而不只是再三重覆嘗試。突破高原期方法：先找出進步停滯的原因，犯了哪些錯，何時做錯的，迫使自己離開舒適圈，看哪個問題先顯露出來，設計改善這個問題的練習方法 找出持續不懈的動機：維持動機，可從兩點切入：持續的理由和停止的理由。會停止原本想做的事，是因為停止的理由終究強過於持續的理由，因此想維持動機，可以增強持續的理由或減弱停止的理由，而要讓動機發揮效用，通常必須兩者兼具。減弱停止的理由最有效的做法，撥出固定時間排除其他所有義務和令你分心的事，好好練習。在最佳狀況下要迫使自己練習可能就夠困難了，如果有其他是可以忙，往往會被引誘去做，而且會合理化地告訴自己那件事真的非做不可。經常如此，就會逐漸疏於練習，讓訓練計畫走進死胡同。可好好擬定練習時間，例如早晨，干擾因素最少，好的計畫有助於避開許多可能導致練習時間縮短的事情。找出可能干擾訓練的因素，並盡量減低影響。頂尖專家有兩個習慣，第一個是照顧身體：讓自己睡眠充足，不靠鬧鐘叫醒，並保持身體健康，第二個是將練習時間控制在大約一小時：人無法全神貫注超過一小時太多，訓練初期能集中注意力的時間可能更短，建議想將練習拉長至超過一小時的人每練一小時都休息片刻(番茄鐘)。增加持續的意願，在練習一陣子並看見成果後，技能本身就可能成為動機的一部份，讓你為自己的表現自豪，讓練習在你眼中成為一種投資，而不是耗費，另一個關鍵是相信自己能成功。想放棄可以，但至少先練習到恢復先前的水準，這時便會發現，持續進步的確有可能，之前只不過是一時的挫敗，信念的重要不容忽視。無論是因為退步或進入高原期，當你不再相信自己能達成目標時千萬別放棄，先和自己約定好，等到重回先前水準或突破高原期後再說，到時大概就會繼續下去了。最強而有力的外部動機之一是社會動機，最直接的就是得到他人的認可或欽佩。建立和維持社會動機最好的方法，就是讓自己身邊圍繞著你努力時會給予鼓勵、支持和挑戰的人，邀請興趣相同的人共組團體，或是加入現有的社團，將團體中的夥伴情誼和共同目標化為達成自身目標的額外動機。但本質上，刻意練習絕對是條寂寞的路。盡管可以和志同道合的人組成團體，彼此鼓勵，大多數的進步還是得靠獨自練習。將這條漫長的路分成一連串可達成的目標，一次聚焦一項。刻意練習是能通往實現夢想的路 CH7：邁向非凡的路線圖 專家的養成會經過四個不同的階段：產生興趣、變得認真、全心投入、開闢新路\n產生興趣：許多孩子一開始有動機探索或嘗試新事物，是出於與生俱來的好奇心或遊戲性，因此父母有機會以剛萌芽的興趣做為產開某項活動的跳板。讚美與獲得新技能的滿感會使孩子動力更強。手足間的競爭有激勵的作用。 變得認真：鼓勵，在培養技能和習慣的同時，也維持興趣與動機。協助孩子找到喜歡的相關活動，以維持長時間的動力，也就是培養心智表徵，培養音樂的表徵可以是找尋好聽的音樂，享受獨自在練習室演奏喜愛的曲子帶來的快樂。在這個階段的前半部，父母和老師的鼓勵與支持對孩子的進步至關重要，但等到孩子開始嘗到辛苦努力帶來的果實，就逐漸變得可以自我激勵。 全心投入：技能隨著年齡漸長而退步，多是因為訓練減少或中止。就算年齡增長，一定還是可以學會新技能 開闢新路：創造力其實和下苦功及長時間維持專注的能力相輔相成，這些正是一開始造就他們專家級能力的刻意練習的要素 非凡能力都是大量練習和訓練的結果，奇才或自閉學者無法證明特殊天賦的存在。人之所以停止學習、不再進步，不是因為到達天生能力的極限，而是因為某些原因不再練習，或者從未開始練習。\n刻意練習基本原則：將學習目標分解為一連串具體技能，並設計練習活動以正確的順序教導每一項技能，然後運用意見回饋監控進展。最後的勝利屬於更努力練習的人，而不屬於一開始靠智力或其他天賦佔上風者。\nCH8：如何解釋’’天賦’’這回事 老師在準備教案時，決定學生應該具備哪些能力，遠比決定應該具備那些知識有效，因為培養能力的過程中自然會獲得知識。先列出能力後，再化為一系列具體的學習目標，建立完善的心智表徵。\n設計一系列提點問題和學習任務，幫助他們達到老師訂定的學習目標。各個提點問題和任務的挑選標準是要能開啟討論，藉此鼓勵學生了解、應用正在學習的概念，進而運用這些概念回答問題和完成任務。設計問題另一個目的是激勵學生踏出舒適圈，讓學生思考，並在犯錯時讓學生能獲得即時的回應和改正建議。\nCH9：用刻意練習打造全新的世界 刻意練習原則路線圖：先確認學生應該學會的能力，目標在於技能，而非知識。找出學生學習某項技能應該使用的方式之後，了解專家的作法，尤其重要的是必須盡可能弄清楚專家運用的心智表徵。然後，將技能分解成幾個步驟，每個步驟都應該讓學生離開舒適圈，但又不至於遙不可及。接著開始充分反覆練習和提供意見回饋，也就是嘗試、失敗、意見回饋、再次嘗試，如此一再循環，學生便會在過程中建立起自己的心智表徵。\n協助學生培養某領域技能和心智表徵的最佳方法，便是提供可以模仿和學習的範例，並結合高品質的練習\n之所以不無聊，是因為總有新的跳站和契機\n可塑性與適應力極高的大腦並且搭配正確訓練\n學習變成一種創造能力的方法，而不是引導個人發揮固有能力，使人天生的潛能不具限制，我們醫生做的各式各樣的事情塑造而成，學習不是一種達到潛能的方法，而是發展潛能，創造出自己的潛能，此書將會介紹正確的練習方法(刻意練習)，以及如何應用\n任何領域裡最有效最有用的練習方式都是藉由掌控大腦與身體的適應力，一步步創造出之前不可能擁有的能力\n讀了這本書之後，讓我最有改觀的就是天才是靠努力得來的，並且有目標的大量練習，注重練習的質與量才是真正通往天才的唯一途徑，書中講述了許多被世人認為是天才，但經過自己深入暸解後並非是如此，並且舉例了天才背後不為人知的秘密，’’刻意練習’’，書中也說明了學習並不是引導個人發揮固有能力，而是讓學習變成一種創造能力的方法，學習不是一種達到潛能的方法，而是發展潛能，創造出自己的潛能，並且點破了’’一萬小時法則’’的迷思以及誤解， 讓練習在你眼中成為一種投資，而不是耗費，沒有人可以不投注大量的練習就發展出非凡技能，因此我也打算利用這個方法讓我在學習技能的道路上更有效率以及系統的大量練習，看是否也能讓我頭痛已久的能力也能成為我拿手的技能。\n","permalink":"https://sz9751210.github.io/posts/%E5%88%BB%E6%84%8F%E7%B7%B4%E7%BF%92/","summary":"\u003ch2 id=\"quick-review\"\u003e👀QUICK REVIEW\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003eThe book in 3 Sentences 用三段話說明這本書的內容\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e天才並非真的存在，刻意練習才是真正通往專家的唯一途徑\u003c/li\u003e\n\u003cli\u003e練習的質與量勝過於單純的練習量\u003c/li\u003e\n\u003cli\u003e專注投入與信念至關重要\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eHow the Book Changed Me? 這本書為我帶來什麼改變\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e讓練習在你眼中成為一種投資，而不是耗費\u003c/li\u003e\n\u003cli\u003e沒有人可以不投注及大量的練習就發展出非凡技能\u003c/li\u003e\n\u003cli\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eMy Top 3 Quotes 我最喜歡的 3 句 Quotes\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e人之所以停止學習、不再進步，不是因為到達天生能力的極限，而是因為某些原因不再練習，或者從未開始練習。\u003c/li\u003e\n\u003cli\u003e技能越高超，心智表徵越成熟，越了解這領域，代表自己更懂欠缺甚麼，也因此更能發揮刻意練習的效果，磨練技巧可以改善心智表徵，心智表徵又有助於技能進步\u003c/li\u003e\n\u003cli\u003e當你不再相信自己能達成目標時千萬別放棄，先和自己約定好，等到重回先前水準或突破高原期後再說，到時大概就會繼續下去了。\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e","title":"刻意練習：原創者全面解析, 比天賦更關鍵的學習法"},{"content":"📚讀後心得 讀完心流這本書後，心流對我的生活有很大的改觀，心流，就是我們在做某件事情時，全神貫注進入渾然忘我的狀態，讓我想起有時候在想一段程式，如何做優化，並且一步一步漸漸達成，接著看一下時間，突然就快要下班了，原來我也體驗過心流，那種感覺真的是很美好，整個人很享受當下那種慢慢擊破目標，達成目的的過程，裡面也有講到一段話我覺得很棒，成功，就像幸福一樣，不是追求而來的；它是一個人全心全意投入一件事，而忘卻自我的副產物。所以本書就是在教如何找到自己的心流所在，讓我們能夠變得更快樂，更幸福。\n心流的三個特徵，第一：全神貫注的忘我境界，拿我剛剛想程式碼的例子，從一開始的設計邏輯到實踐，整個過程我是全神貫注的狀態，第二：重建自我內在的秩序，我必須給自己信心，相信自己能夠實現出我所想的方法，第三：目標與即時的回饋，我透過一小段一小段慢慢實踐我所想的方法，並能夠立即知道結果，只要達成這三個，就有機會體驗心流，知道如何控制內在體驗的人們將有能力決定自己的人生品質。當我們進入心流體驗的時間越多，就越能提升自己本身的幸福感、加深對目標的堅持、擁有更積極的心態，讓我們面對未來種種挑戰也不會輕易受到外在的控制。自行作主的信念能使一個人能全心投入目標，行動完全受內在控制\n最後我整理了進入心流的五個步驟\n設定明確並且具有挑戰性的目標 具備一定程度的技能 拆解成階段性任務 屏除外界干擾專心投入 忘卻自我樂在當下 ","permalink":"https://sz9751210.github.io/posts/flow/","summary":"\u003ch2 id=\"讀後心得\"\u003e📚讀後心得\u003c/h2\u003e\n\u003cp\u003e讀完心流這本書後，心流對我的生活有很大的改觀，心流，就是我們在做某件事情時，全神貫注進入渾然忘我的狀態，讓我想起有時候在想一段程式，如何做優化，並且一步一步漸漸達成，接著看一下時間，突然就快要下班了，原來我也體驗過心流，那種感覺真的是很美好，整個人很享受當下那種慢慢擊破目標，達成目的的過程，裡面也有講到一段話我覺得很棒，成功，就像幸福一樣，不是追求而來的；它是一個人全心全意投入一件事，而忘卻自我的副產物。所以本書就是在教如何找到自己的心流所在，讓我們能夠變得更快樂，更幸福。\u003c/p\u003e","title":"心流：高手都在研究的最優體驗心理學"}]